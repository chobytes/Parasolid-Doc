<HTML>
<HEAD>
<TITLE>CRFASU</TITLE>
<LINK rel="stylesheet" href="../ps_doc.css">
</HEAD>
<BODY bgcolor="#ffffff" link="#0F3A68" vlink="#878787" alink="#FF7600" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0" background="../images/background.gif">
<A NAME="topofdoc">

<TABLE cellpadding=0 cellspacing=0 border=0 width=100%>
  <TR>
    <TD>&nbsp;<IMG src="../graphics/psbar_l.gif" border=0></TD>
    <TD align=RIGHT valign=CENTER>
        <FONT face="helvetica,arial" SIZE=5 class=NS28pt>
        <B>CRFASU</B></FONT></TD>
    <TD>&nbsp;&nbsp;</TD>
  </TR>
</TABLE>

<HR>
<TABLE><TR><TD VALIGN=TOP>Equivalent PK functions:</TD><TD>
<A HREF=../headers/pk_face_attach_surf_fitting.html>PK_FACE_attach_surf_fitting</A><BR>
</TD></TR></TABLE><HR>

<A NAME="endofcontents">
<PRE>
CRFASU ( face, sutype, surfac, state, ifail )
=============================================

  Create surface to fit and attach to face

Receives:
  KI_tag_face              *face           --- face to be fixed

Returns:
  KI_cod_tysu              *sutype         --- type of surface fixed to face
  KI_tag_surface           *surfac         --- new surface fixed to face
  KI_cod_rtlo              *state          --- state of the body
                                           ---   RTLOOK => Valid
                                           ---   RTLONG => Negated
                                           ---   RTLOSX => Self-Intersecting
  KI_cod_error             *ifail          --- failure code

Specific errors:
  KI_cant_find_su           Unable to find a surface
  KI_unsuitable_entity      Face does not belong to a sheet or solid body
  KI_general_body           general body

Description:
  If possible, a surface is created, consistent with the edge geometry of the
  face, which replaces the existing surface geometry (typically rubber).

  If a simple surface (plane, cylinder, torus, cone or sphere) will fit,
  it will be used; if no simple surface will fit, the modeller may be able to
  fit another surface (such as a blend or B-surface) but this is not
  guaranteed. It may be that more than one surface will fit the edges. In this
  case it is not defined which surface will be used.

  In general this procedure may give rise to self-intersecting object
  boundaries which could cause unpredictable errors later.

  If local checking is on, (see SEINTP and OUINTP) consistency checks will be
  made on newly created topological and geometrical entities, and the state
  of the body returned. A state of RTLOOK indicates the body is valid. A state
  of RTLONG indicates that the result body was originally "inside out" but has
  been negated, and is now "positive" (has positive volume) and valid. A state
  of RTLOSX indicates the body is self-intersecting and further modelling
  operations on it may fail. It is the responsibility of the calling routine to
  make any necessary reparation.

  If the session parameter for local checking is switched off, the state
  returned will be RTLOOK regardless.

  A self-intersecting body can be returned even if the ifail is zero.

  This function should only be called for faces in sheet or solid bodies. It is
  not supported for general bodies.

</PRE>
</BODY>
</HTML>
