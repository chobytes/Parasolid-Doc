<HTML>
<HEAD>
<LINK REL=STYLESHEET HREF=../ps_doc.css CHARSET=ISO-8859-1 TYPE=text/css>
<SCRIPT LANGUAGE="JavaScript">
<!--

top.note("chapters/fd_chap.002.html#50409781_pgfId-298082", " is stored. Parts can be saved in a <B>number</B> of ways: for example, as one or more", "Functional Description -  Introduction To Parasolid");
top.note("chapters/fd_chap.003.html#50409782_pgfId-298393", " C convention for a double precision floating point <B>number</B> ", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.003.html#50409782_pgfId-299798", " the platform in question. To find out the <B>number</B> of tags remaining in a session at any", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.004.html#50409783_pgfId-301321", " Functional Description is divided into a <B>number</B> of different volumes, each of which provides information", "Functional Description - Overview Of This Manual");
top.note("chapters/fd_chap.004.html#50409783_pgfId-301575", " Functional Description consists of a <B>number</B> of appendices that provide specific detailed information relating", "Functional Description - Overview Of This Manual");
top.note("chapters/fd_chap.008.html#50409788_pgfId-327053", " There are a <B>number</B> of session-level parameters that you can set up", "Functional Description - Further Implementation Decisions");
top.note("chapters/fd_chap.009.html#50409789_pgfId-467868", " Parasolid functionality. Parasolid Workshop.Net is shipped with a <B>number</B> of example plugins such as: ", "Functional Description - Parasolid Source Code Collateral");
top.note("chapters/fd_chap.010.html#50409790_pgfId-556522", " int * const n_faces, // <B>number</B> of faces (>= 0) ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-345294", " Parasolid includes a <B>number</B> of PK_DEBUG functions that you can use to", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-337764", " Replacement functions can usually be identified by a <B>number</B> at the end of the function name. For", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.011.html#50409791_pgfId-303628", " also provided. Typically, you should consider using a <B>number</B> of the tools and sources described here; it", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.011.html#50409791_pgfId-303632", " Tracking information can be returned in a <B>number</B> of ways, depending on the API, including: ", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.011.html#50409791_pgfId-303635", " A <B>number</B> of API functions return additional information through the", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.011.html#50409791_pgfId-303690", " With the exception of a very small <B>number</B> of APIs, the order of the returned entities", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.011.html#50409791_pgfId-303699", " or identify suitable help points, Parasolid provides a <B>number</B> of enquiry functions that let you determine a", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.011.html#50409791_pgfId-303714", " feature modelling application, can be implemented using a <B>number</B> of different approaches. The Parasolid tools described in", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.011.html#50409791_pgfId-303716", " There are a <B>number</B> of academic papers on the topic of persistent", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.011.html#50409791_pgfId-315803", " PK_BODY_sweep returns a <B>number</B> of laterals - new edges or faces created", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.012.html#50409792_pgfId-294769", " is writing to the report, together with a <B>number</B> of report records, each of type PK_REPORT_record_t .", "Functional Description - Using Reports");
top.note("chapters/fd_chap.012.html#50409792_pgfId-294803", " may create a single report, consisting of a <B>number</B> of different report records. In each report record,", "Functional Description - Using Reports");
top.note("chapters/fd_chap.012.html#50409792_pgfId-294854", " thus freeing the memory used. It sets the <B>number</B> of records in the report to zero and", "Functional Description - Using Reports");
top.note("chapters/fd_chap.012.html#50409792_pgfId-294862", " PK memory. The report is empty if the <B>number</B> of records is zero. PK_REPORT_ask is similar to", "Functional Description - Using Reports");
top.note("chapters/fd_chap.013.html#50409793_pgfId-295140", " Since names of identifiers cannot start with a <B>number</B> in C#, the leading digit is replaced by", "Functional Description - Calling Parasolid From .NET Code");
top.note("chapters/fd_chap.015.html#50409796_pgfId-294855", " body has one infinite void region, containing any <B>number</B> of shells, each of which contains only a", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-294862", " body has one infinite void region containing any <B>number</B> of shells, each of which contains a single", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-294871", " components has one infinite void region containing any <B>number</B> of shells, each of which contains a single", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_marker-295168", " (around the periphery of the face) and any <B>number</B> of ", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-295265", " Like non-periodic faces, cylindrical topology can contain any <B>number</B> of inner loops. ", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-295266", " end, contain just one outer loop, and any <B>number</B> of inner loops. Inner loops are also winding", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-295431", " An edge may have zero or any <B>number</B> of fins: ", "Functional Description - Model Structure");
top.note("chapters/fd_chap.016.html#50409797_pgfId-294776", " components has one infinite void region containing any <B>number</B> of shells, each of which contains a single", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_hUW1o287josi", " must involve exactly two laminar edges and any <B>number</B> of normal edges. ", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-296234", " A general body may have zero or any <B>number</B> of faces. A face is on the boundary", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-296236", " part of the boundary of zero or any <B>number</B> of faces; if it is not part of", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-296238", " <B>number</B> of edges, and of zero or any <B>number</B>", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-296845", "Figure 15-18 shows a <B>number</B> of examples. ", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297095", "Figure 15-19 for a <B>number</B> of examples. ", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297568", " The <B>number</B> of parts received from the transmitted data. ", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297606", " the receiving application must then specify the appropriate <B>number</B> for that compound body in ", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297625", " Parasolid provides a <B>number</B> of functions specifically designed to return information about", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297650", " compound bodies. For example, when enquiring about the <B>number</B> of faces in a body ( PK_BODY_ask_faces ),", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297658", " <B>Number</B> of faces returned ", "Functional Description - Body Types");
top.note("chapters/fd_chap.017.html#50409798_pgfId-295073", " has Parasolid session precision) is attached to a <B>number</B> of other edges at vertices V1 and V2.", "Functional Description - Session And Local Precision");
top.note("chapters/fd_chap.017.html#50409798_pgfId-295169", " In such cases, the edge is split a <B>number</B> of times, once for every surface singularity or", "Functional Description - Session And Local Precision");
top.note("chapters/fd_chap.018.html#50409799_pgfId-610406", " the <B>number</B> of segments in the curve ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-610818", " the <B>number</B> of segments in the surface ", "Functional Description - Geometry");
top.note("chapters/fd_chap.019.html#50409800_pgfId-298512", " You can control the splining operation in a <B>number</B> of ways to further define the shape of", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-298529", " field is the <B>number</B> of positions that you want to treat differently,", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-298769", " If you supply clamp information, a <B>number</B> of constraints apply. See the documentation for PK_BCURVE_create_spline_2_o_t", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300750", " In addition, the surfaces may require a larger <B>number</B> of control points. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300803", " performance and memory requirement are dependent on the <B>number</B> of constraints you specify and the tolerances to", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300804", " Limit the <B>number</B> of constraints to a few hundred. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-302240", " relevant curves. However, this can greatly increase the <B>number</B> of patches on the surface. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-302894", " smaller than the default may create an excessive <B>number</B> of vertices on the resulting curve. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-507376", " to a given tolerance. The function receives a <B>number</B> of edges, a tolerance and options, and returns", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-314482", " <B>number</B> of segments on a curve or the <B>number</B> of rows or columns of a surface. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-314489", " The <B>number</B> of times a knot may be removed ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-314702", " as required in order to produce the minimum <B>number</B> of edges/faces possible. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-316531", " There are a <B>number</B> of restrictions on the shape of B-curves and", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.021.html#50409802_pgfId-336099", " Estimated <B>number</B> of all lballs returned by all calls to", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-336103", " Estimated <B>number</B> of all lrods returned by all calls to", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-441381", " With this function, you can specify the minimum <B>number</B> of lrods in any of the returned lattices", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-378099", " choose to create a blended lattice using a <B>number</B> of options in PK_LATTICE_create_by_graph . Blending a lattice", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-412974", " Whether limits are set on the <B>number</B> of repetitions in the i_axis direction of the", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-435109", " Whether limits are set on the <B>number</B> of repetitions in the j_axis direction of the", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-435136", " Whether limits are set on the <B>number</B> of repetitions in the k_axis direction of the", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-414041", " the <B>number</B> of repetitions in that direction, ", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-515718", " The <B>number</B> of pattern repetitions in a complete period around", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-544653", " The <B>number</B> of attribute definitions, and the list of attribute", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-562894", " The <B>number</B> of attribute definitions, and the list of attribute", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-336193", " Returns the <B>number</B> of lballs in the given lattice ", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-336197", " Returns the <B>number</B> of lrods in the given lattice ", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.023.html#50409804_pgfId-294763", " An assembly may contain any <B>number</B> of instances of the same part. ", "Functional Description - Assemblies And Instances");
top.note("chapters/fd_chap.028.html#50409808_pgfId-309688", " the third direction, is used to reduce the <B>number</B> of extreme points until only one remains, which", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310044", " The two faces are not coincident because the <B>number</B> of holes in the two faces is different.", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310081", " appropriate, and return a structure that contains the <B>number</B> of self-intersections found, together with details about each", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310103", " respectively, and return a structure that contains the <B>number</B> of degeneracies found, together with details about each", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.029.html#50409809_pgfId-294714", " The <B>number</B> of ", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.029.html#50409809_pgfId-294718", " are not percentages but an indicator of the <B>number</B> of iterations in the calculation. ", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.029.html#50409809_pgfId-294727", " A <B>number</B> of arguments are returned by the function providing", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.029.html#50409809_pgfId-294827", " You can find a <B>number</B> of mass properties of an entity using the", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.032.html#50409812_pgfId-294782", " <B>number</B> of faults found. See Section 31.2.1, The <B>number</B> of faults to be returned , for more", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-295064", " 31.2.1 The <B>number</B> of faults to be returned ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-295066", " to a large <B>number</B>, e.g. 1000. ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-295069", " itself (such as PK_EDGE_state_bad_vertex_c) provided that the total <B>number</B> does not exceed ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-295255", " Entities may fail the checker for a <B>number</B> of reasons; not all of these mean that", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-295467", " in the face are wrong, or that the <B>number</B> and types of loops in the face are", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-378616", " Body has wrong <B>number</B> of regions ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-378619", " The returned body has the wrong <B>number</B> of regions. ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-296902", " of nearby faces. The checking can return a <B>number</B> of results. ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-296908", " bodys entities. However, if Parasolid is performing a <B>number</B> of local operations, you may prefer to check", "Functional Description - Checking");
top.note("chapters/fd_chap.034.html#50409815_pgfId-294785", " The <B>number</B> of oriented edges at a vertex is as", "Functional Description - Euler Operations");
top.note("chapters/fd_chap.035.html#50409816_pgfId-324614", " option can be used to control the <B>number</B> of topologies that are deleted. This is illustrated", "Functional Description - Controlling Redundant Topology");
top.note("chapters/fd_chap.035.html#50409816_pgfId-366740", ", the higher the <B>number</B> of vertices which are considered redundant. ", "Functional Description - Controlling Redundant Topology");
top.note("chapters/fd_chap.035.html#50409816_pgfId-324707", " the redundant topologies. If PK_LOGICAL_false, then only the <B>number</B> of redundant topologies is returned. ", "Functional Description - Controlling Redundant Topology");
top.note("chapters/fd_chap.036.html#50409817_pgfId-331033", " The <B>number</B> of new edges that were created. ", "Functional Description - Splitting Topology");
top.note("chapters/fd_chap.036.html#50409817_pgfId-331046", " The <B>number</B> of new faces that were created. ", "Functional Description - Splitting Topology");
top.note("chapters/fd_chap.038.html#50409820_pgfId-525635", " Both outline curves and spun outlines share a <B>number</B> of properties, as follows: ", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-308823", " The <B>number</B> of bodies to create outlines for. ", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-513789", " The <B>number</B> of curves that make up the outlines. ", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-308894", " You can set a <B>number</B> of options when creating outline curves, perspective outlines,", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-793172", " The <B>number</B> of faces to be excluded from the outline.", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-553101", " PK_BODY_make_persp_outline has a <B>number</B> of options that enable you to clip the", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.039.html#50409821_pgfId-294751", " of the extrusion can be specified in a <B>number</B> of ways; in particular by intersection with other", "Functional Description - Creating Extruded Bodies");
top.note("chapters/fd_chap.039.html#50409821_pgfId-295974", "Figure 38-12 shows a <B>number</B> of additional examples. In each one, the start", "Functional Description - Creating Extruded Bodies");
top.note("chapters/fd_chap.039.html#50409821_pgfId-296419", " may intersect with a bounding body a different <B>number</B> of times. This can lead to different result", "Functional Description - Creating Extruded Bodies");
top.note("chapters/fd_chap.040.html#50409822_pgfId-294825", " , you can control the sweep in a <B>number</B> of ways. The following table summarises these with", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-295124", " is solid. There is a limit to the <B>number</B> of sheet profiles that you can specify in", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-296074", " Parasolid provides you with a <B>number</B> of options for controlling when and how cross-section", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-296099", " The <B>number</B> of cross-sections to produce when ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-296100", " this value only as a guide to the <B>number</B> of cross-sections that are produced in total. See", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-296105", ", Parasolid can sometimes produce a different <B>number</B> of cross-sections than you expect. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-296109", " is PK_sweep_group_xsect_no_c , then Parasolid returns the <B>number</B> of cross-sections specified in ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-296304", " Figure 39-12 Specifying a total <B>number</B> of cross-section profiles ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-296312", " that contain non-smooth vertices, however, Parasolid creates the <B>number</B> of cross-sections specified for each edge that contains", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-296499", " Figure 39-13 Specifying a total <B>number</B> of cross-section profiles per edge ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-297736", " where C2 continuity would result in an excessive <B>number</B> of B-spline vertices. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-297755", " The swept body will contain the minimum <B>number</B> of faces. This is the default. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-298071", " the profiles are open and contain the same <B>number</B> of vertices. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-298078", " the profiles are closed and contain the same <B>number</B> of vertices. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-298085", " so that that each profile has the same <B>number</B> of vertices, and treat as per the appropriate", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-298135", " Each loop contains the same <B>number</B> of vertices across all the profiles. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-298257", " surfaces in the result (rather than the minimal <B>number</B> of surfaces), you may need to set the", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-298792", " The <B>number</B> of profiles that have clamps applied. (Default 0.)", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-299055", " The behaviour of guide wires depends on the <B>number</B> of guide wires supplied and the value of", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-301910", " <B>Number</B> of turns ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-301912", " The <B>number</B> of turns the helix makes. This is related", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-306270", " The <B>number</B> of turns that the helix makes, expressed as", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302015", " does not taper. If this is a negative <B>number</B>, then the helix tapers inwards; if positive, the", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302016", " the spiral pitch must be consistent with the <B>number</B> of turns requested, so as to ensure that", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302115", " the resulting helix may extend beyond the required <B>number</B> of turns at the corresponding ends, in order", "Functional Description - Sweeping");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295085", " The minimum <B>number</B> of profiles required for periodic and non-periodic lofts,", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-526299", " A <B>number</B> of restrictions apply to the supplied profiles, depending", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295602", " to specify derivative conditions for. This is the <B>number</B> of elements in both the ", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295663", " is the <B>number</B> of profiles, as specified in the call to", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-296140", " same <B>number</B> of edges, and hence the same <B>number</B> of vertices, the vertices are mapped one-to-one across", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-296435", " can also use guide wires to reduce the <B>number</B> of profiles required when creating periodic lofts: if", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-296422", " used to create a lofted body, creating a <B>number</B> of construction profiles in the process. ", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-296616", " An integer specifying the <B>number</B> of guide curves being used. ", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-296742", " to specify derivative conditions for. This is the <B>number</B> of elements in both the ", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-296817", " The lofted body will contain the minimum <B>number</B> of faces. This is the default. ", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-296836", " with guide wires ) does not change the <B>number</B> of faces in the resulting body, no matter", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-297106", " surfaces in the result (rather than the minimal <B>number</B> of surfaces), you may need to set the", "Functional Description - Lofting");
top.note("chapters/fd_chap.044.html#50409826_pgfId-295280", " of the emboss operation, and there are a <B>number</B> of ways that you can control the final", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.044.html#50409826_pgfId-295331", " the sidewall, and Parasolid provides you with a <B>number</B> of different methods and controls for you to", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.044.html#50409826_pgfId-295673", " The <B>number</B> of edges in the profile for which multiple", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.044.html#50409826_pgfId-297600", " emboss operations to be successful, Parasolid places a <B>number</B> of constraints on both the topology supplied to", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.044.html#50409826_pgfId-297630", " You should observe a <B>number</B> of constraints regarding the orientation of the various", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.046.html#50409829_pgfId-294962", " in the resulting offset body. Parasolid provides a <B>number</B> of options that let you control how those", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-354301", " to make a wire body, together with the <B>number</B> of those curves. If any supplied curves come", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295095", " The <B>number</B> of edges in the body. ", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295202", " You can set a <B>number</B> of options using the associated PK_CURVE_make_wire_body_o_t options structure,", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295244", " edges. The supplied edges can come from a <B>number</B> of different parts, but they must not intersect", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-358801", " to create a wire body, together with the <B>number</B> of edges. Edges can be passed to PK_EDGE_make_wire_body", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295284", " You can set a <B>number</B> of options using the associated PK_EDGE_make_wire_body_o_t options structure,", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.048.html#50409831_pgfId-654047", " fuse separate bodies together to form a minimum <B>number</B> of sheet, solid or general bodies. See Section", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-295217", " sewing operation is likely to include a large <B>number</B> of reported non-manifold problems. The sewn bodies additionally", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-295243", " same <B>number</B> of faces on each body; ", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-295244", " same <B>number</B> of edges on each body; ", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-295245", " same <B>number</B> of vertices on each body, with corresponding entries", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-295992", " the gap width bound of it. The average <B>number</B> of split points rises roughly as the square", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-404890", " The <B>number</B> of iterations of the sewing operation to perform.", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-373289", " predicted. If you are attempting to sew a <B>number</B> of sheets together in these conditions, you can", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-296425", " whose connected laminar edge groups have the greatest <B>number</B> of coincidences. ", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-296472", " is set to PK_BODY_sewing_assy_extend_c, the <B>number</B> of shared boundary edges is also examined. In", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-649598", " fuse separate bodies together to form a minimum <B>number</B> of sheet, solid or general bodies. See Section", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-297212", " The <B>number</B> of bodies for which to find a knitting", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-595516", " The <B>number</B> of bodies that could not be connected together.", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-297250", " The <B>number</B> of pairs of matching edges. The ", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-297262", " The <B>number</B> of owning bodies of edges in either ", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-370350", " The <B>number</B> of ", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-404507", " PK_BODY_knit joins a <B>number</B> of bodies together using 1:1 matching where one", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.049.html#50409832_pgfId-358858", " The <B>number</B> of construction methods that can be used. If", "Functional Description - Mid-Surface Generation");
top.note("chapters/fd_chap.050.html#50409833_pgfId-719871", " The <B>number</B> of edges to extend across. ", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.052.html#50409836_pgfId-544708", " The <B>number</B> of tool curves ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-544720", " The <B>number</B> of target entities ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-513589", " You can set a <B>number</B> of options when either projecting curves, imprinting curves", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-296320", " of type PK_continuity_t . This datatype contains a <B>number</B> of additional values that are not listed here,", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.053.html#50409837_pgfId-393184", " these functions are different, but have a large <B>number</B> of identical options.The following table lists the options", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394226", " The <B>number</B> of selector topologies supplied. ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394234", " The <B>number</B> of ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-1226845", " field should contain the <B>number</B> of matched regions supplied. (Default: 0) ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-396119", " be used with boolean operations to achieve a <B>number</B> of different results. See Section 52.4.14.3, Achieving different", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-396389", " is possible to perform fencing operations using a <B>number</B> of different combinations of material-side option values and", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.055.html#50409839_pgfId-295230", " A <B>number</B> of options in PK_BODY_boolean_2 are unsupported when performing", "Functional Description - General Booleans");
top.note("chapters/fd_chap.056.html#50409840_marker-294753", " performing a <B>number</B> of boolean operations involving a <B>number</B> of (often) identical tool bodies, e.g. when drilling", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-298424", " the <B>number</B> of faces in the tool body which are", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-298427", " total <B>number</B> of times instanced copies of the original face", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-837543", " to the same value as the <B>number</B> of transforms specified to PK_FACE_pattern_2 . ", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-301023", " option should be set to the <B>number</B> of transforms passed to PK_FACE_pattern_2 and each element", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-301032", " The <B>number</B> of boundary loops contained in the feature. (Default", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-301968", " should be set to the <B>number</B> of transforms and the destination faces should be", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-823010", " The <B>number</B> of pattern instances created. ", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-830429", " The <B>number</B> of topologies that caused a failure during the", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-816659", " pattern instances will be the same as the <B>number</B> of transforms specified to PK_FACE_pattern_2 . ", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-832437", " The <B>number</B> of resulting faces in the pattern instance. ", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-832449", " The <B>number</B> of topologies associated with the failure of the", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.057.html#50409620_pgfId-294761", " are different, but overlap with respect to a <B>number</B> of options. The options are as follows: ", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-453286", " For slicing operations, the <B>number</B> of offsets to be applied to the supplied", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-484196", " The <B>number</B> of entities used to clip the lattice. ", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-485825", " The <B>number</B> of lattices created ", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-500562", " The <B>number</B> of ", "Functional Description - Sectioning");
top.note("chapters/fd_chap.061.html#50409846_pgfId-299940", " occasions if for example, you have a large <B>number</B> of pierce faces. In the majority of cases,", "Functional Description - Hollowing");
top.note("chapters/fd_chap.064.html#50409850_pgfId-329445", " Note: A vast <B>number</B> of Parasolid operations have the potential to alter", "Functional Description -  Overview of Editing Models");
top.note("chapters/fd_chap.064.html#50409850_pgfId-341641", " offsetting functionality that forms the basis of a <B>number</B> of other areas of functionality, such as hollowing", "Functional Description -  Overview of Editing Models");
top.note("chapters/fd_chap.064.html#50409850_pgfId-349108", " the model. For example, if you have a <B>number</B> of imprinted edges on a body, you can", "Functional Description -  Overview of Editing Models");
top.note("chapters/fd_chap.064.html#50409850_pgfId-319802", " this has resulted in the creation of a <B>number</B> of small faces. PK_FACE_cover lets you control the", "Functional Description -  Overview of Editing Models");
top.note("chapters/fd_chap.064.html#50409850_pgfId-315913", " already discussed in this chapter, there are a <B>number</B> of other options and functional areas that are", "Functional Description -  Overview of Editing Models");
top.note("chapters/fd_chap.065.html#50409851_pgfId-301490", " them as a single composite, reducing the total <B>number</B> of loops remaining in the healed body. The", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.065.html#50409851_pgfId-321813", " The <B>number</B> of face sets to delete, together with an", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.065.html#50409851_pgfId-1003642", " The <B>number</B> of resulting bodies, together with the bodies themselves.", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.065.html#50409851_pgfId-1003647", " The <B>number</B> of face sets that could not be deleted,", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.065.html#50409851_pgfId-321838", " PK_FACE_delete_facesets takes a <B>number</B> of options, available in PK_FACE_delete_facesets_o_t . The options", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.065.html#50409851_pgfId-322277", " in particular, you might want to delete a <B>number</B> of blends in order to add a new", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.066.html#50409852_pgfId-294874", " The <B>number</B> of edges bounding the facesets, together with the", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-294914", " select which facesets are returned, together with the <B>number</B> of elements in the array. The precise facesets", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-295211", " detail you want to identify, together with the <B>number</B> of types of detail. ", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296029", " a body. This function lets you specify a <B>number</B> of constraints to control the characteristics of the", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-420753", " The <B>number</B> of faces from which to search for blends,", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-368327", " The <B>number</B> of components in the hole detail, together with", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.067.html#50409853_pgfId-297211", " range of topology changes. However, there are a <B>number</B> it cannot handle. The following attempted operations, illustrated", "Functional Description - Replacing The Surfaces Of Faces");
top.note("chapters/fd_chap.068.html#50409854_pgfId-1394549", " The <B>number</B> of faces used in the taper operation and", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.068.html#50409854_pgfId-1395283", " Parasolid allows you to create a <B>number</B> of different types of tapers using the ", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419122", " was set to PK_LOGICAL_false, together with the <B>number</B> of those faces. See Section 68.4.2, Suppressing mitering", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419155", " <B>Number</B> of reference entities that do not use the specified", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419187", " lie on the parting body, together with the <B>number</B> of those edges. See Section 68.6, Improving performance", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419195", " An array of non-reference edges (together with the <B>number</B> of those edges) that can be replaced by", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419240", " An array of faces (together with the <B>number</B> of faces) from whose upper bounds reference edges", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419263", " An array of faces (together with the <B>number</B> of faces) from whose lower bounds reference edges", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.070.html#50409856_pgfId-312931", " option contains a <B>number</B> of fields that you use to map tool", "Functional Description - Patching");
top.note("chapters/fd_chap.070.html#50409856_pgfId-312947", " The <B>number</B> of tool faces to be mapped to target", "Functional Description - Patching");
top.note("chapters/fd_chap.070.html#50409856_pgfId-312959", " The <B>number</B> of ", "Functional Description - Patching");
top.note("chapters/fd_chap.071.html#50409857_pgfId-294955", " A <B>number</B> of arguments are returned by the function to", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-294984", " Control of the <B>number</B> of faces in the patch, in cases where", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-295076", " fill a hole in a body using a <B>number</B> of different basic methods, all of which are", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-295328", " the <B>number</B> of faces in a patch generated by Parasolid", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-295365", " option to control the <B>number</B> of faces in any patches generated by PK_BODY_fill_hole", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-295374", " the recommended value, because Parasolid creates a suitable <B>number</B> of faces to ensure that the performance and", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-295385", " Attempt to minimise the <B>number</B> of faces in the patch. Using this value", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-296109", " operation is performed. This argument can affect a <B>number</B> of different aspects of the functionality, so you", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-296121", " The <B>number</B> of faces produced. ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-296127", " produce a more complex surface with a higher <B>number</B> of vertices. This will have an affect on", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-296200", " indicates the <B>number</B> of such entities. See PK_fill_hole_fault_t for more information.", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.073.html#50409859_pgfId-316668", " a body and uses them to make a <B>number</B> of new bodies. It receives and returns the", "Functional Description - Creating New Bodies From Existing Entities");
top.note("chapters/fd_chap.073.html#50409859_pgfId-316677", " The <B>number</B> of ", "Functional Description - Creating New Bodies From Existing Entities");
top.note("chapters/fd_chap.073.html#50409859_pgfId-316699", " The <B>number</B> of ", "Functional Description - Creating New Bodies From Existing Entities");
top.note("chapters/fd_chap.073.html#50409859_pgfId-316707", " The <B>number</B> of ", "Functional Description - Creating New Bodies From Existing Entities");
top.note("chapters/fd_chap.074.html#50409860_pgfId-300733", " You may sometimes need to perform a <B>number</B> of different local operations to different faces in", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-300737", " The second approach can have a <B>number</B> of benefits over the first: ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-302261", " The <B>number</B> of faces to change. ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-302279", " The <B>number</B> of different operations to perform. ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-302324", " array. This array should contain the same <B>number</B> of elements as the ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-302653", " <B>Number</B> of reference entities for the taper. ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-677594", " must be either one, or the <B>number</B> of faces mapped to the operation. If ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-302740", " pair of bend faces). You can associate any <B>number</B> of side faces with a bend face, though", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-303248", " by applying a twist and non-linear scale. A <B>number</B> of blends on the inside of the box", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-303387", " PK_FACE_change supports a <B>number</B> of options that let you control how the", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-933272", " PK_FACE_change supports a <B>number</B> of options that let you control how the", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-304033", " <B>Number</B> of ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-853001", " The <B>number</B> of boundary loops contained in the feature. (Default", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306412", " You can set a <B>number</B> of options for PK_FACE_change using the PK_FACE_change_o_t option", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306888", " The <B>number</B> of vertices to preserve. The ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306999", " Sometimes a series of modeling operations yields a <B>number</B> of possible different solutions. You can force Parasolid", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-307012", " The <B>number</B> of topological entities that you want to help", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-307313", " In addition, you can specify a <B>number</B> of other values for the ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.076.html#50409863_pgfId-306532", " are general while others are related to the <B>number</B> of adjacent edges that are blended. ", "Functional Description - Edge Blending Overview");
top.note("chapters/fd_chap.077.html#50409864_pgfId-603672", " end of the blend chain (regardless of the <B>number</B> of edges in the chain). Thus, ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-602610", " You can supply any <B>number</B> of fins from edges in the blend chain", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-1217438", " This section describes a <B>number</B> of options for chamfer and constant blends that", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296096", " The <B>number</B> of vertices in the ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296272", " The <B>number</B> of edges where setback blends are to be", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296306", " The <B>number</B> of vertices at which the patch configuration is", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296922", " The <B>number</B> of vertices to apply vertex blending to. The", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-297172", " The <B>number</B> of vertices to blend (default 0). ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298209", " The <B>number</B> of limits you are setting. Each of the", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298234", "Figure 76-33 illustrates how you can create a <B>number</B> of limits on a simple edge blend. Two", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298438", " The <B>number</B> of limits you are setting. Each of the", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299029", " caps, they can, of course, consist of any <B>number</B> of faces, and those faces need not necessarily", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299949", " is the <B>number</B> of blend faces created). Each array contains the", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.079.html#50409866_pgfId-296176", " properties of a face-face blend, there are a <B>number</B> of usability factors that determine the final appearance", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-352326", " the blend to existing surrounding geometry, but a <B>number</B> of different options are possible. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-296924", " order to support this, face-face blends define a <B>number</B> of properties that are not required by edge", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-711344", " The <B>number</B> of faces in the left wall, and an", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-711349", " The <B>number</B> of faces in the right wall, and an", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-1403266", " The <B>number</B> of sheet bodies created, and an array of", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-1403271", " The <B>number</B> of blend faces created, and an array of", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-306093", " If you do this, then a <B>number</B> of restrictions apply to face-face blending, as follows:", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-306178", " A <B>number</B> that controls the softness of a curvature-continuous blend.", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-307169", " You can supply any <B>number</B> of ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-821901", " improve performance, but can also sometimes limit the <B>number</B> of solutions possible for the blend data specified", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311472", " a <B>number</B> of ways, and specifying a maximum <B>number</B> of ribs to produce in each group. Ribs", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311500", " - Do not group the ribs. The total <B>number</B> of ribs produced is no more than ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311506", " The maximum <B>number</B> of ribs to produce in each group. Ribs", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311532", " The <B>number</B> of ribs that were created. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-294745", "Figure 79-1 shows a part containing a <B>number</B> of ribs, each of which has a three-face", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-295196", " The <B>number</B> of faces in the left wall, and an", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-295201", " The <B>number</B> of faces in the right wall, and an", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-295206", " The <B>number</B> of faces in the centre wall, and an", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.084.html#50409872_pgfId-388108", " Parasolid provides a <B>number</B> of functions that let you manage Convergent Modeling", "Functional Description - Overview Of Convergent Modeling");
top.note("chapters/fd_chap.085.html#50409873_pgfId-299662", " and manipulation of facet bodies, Parasolid defines a <B>number</B> of major entity classes in addition to those", "Functional Description - Facet Model Structure");
top.note("chapters/fd_chap.085.html#50409873_pgfId-435306", " Returns the <B>number</B> of mfacets in a mesh. ", "Functional Description - Facet Model Structure");
top.note("chapters/fd_chap.085.html#50409873_pgfId-435042", " Returns the <B>number</B> of mvertices in a mesh. ", "Functional Description - Facet Model Structure");
top.note("chapters/fd_chap.086.html#50409874_pgfId-321354", " Parasolid has a <B>number</B> of functions that allow you to create or", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-423434", " The maximum <B>number</B> of input mtopols used in ", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-427498", " The <B>number</B> of elements in the ", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.087.html#50409875_pgfId-344053", " Estimate of the total <B>number</B> of vertices returned by all calls to ", "Functional Description - Creating PSM Data From Foreign Facet Data");
top.note("chapters/fd_chap.087.html#50409875_pgfId-344057", " Estimate of the total <B>number</B> of facets returned by all calls to ", "Functional Description - Creating PSM Data From Foreign Facet Data");
top.note("chapters/fd_chap.087.html#50409875_pgfId-344490", " If a mesh has a large <B>number</B> of facets, ", "Functional Description - Creating PSM Data From Foreign Facet Data");
top.note("chapters/fd_chap.088.html#50409876_pgfId-339926", " PK_MESH_find_defects returns the <B>number</B> of defects found, together with a PK_MESH_defect_details_t structure", "Functional Description - Checking and Repairing Mesh Data");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343300", " mfins. Laminar boundaries that contain more than this <B>number</B> of mfins are not returned. See Section 88.3.1,", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343005", " fills holes in a mesh, based on the <B>number</B> of connected mfins in any of the meshs", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343213", " filled. Laminar boundaries that contain more than this <B>number</B> of mfins are not filled. See Section 88.3.1,", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343013", " of holes to fill by specifying a maximum <B>number</B> of mfins which any hole must contain. ", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343017", " within that mesh). You can specify a maximum <B>number</B> of mfins using either PK_MESH_find_laminar_mfins or PK_MESH_fill_holes ,", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343363", " Specify the maximum <B>number</B> of mfins using the ", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343369", " Specify the maximum <B>number</B> of mfins using the ", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.090.html#50409878_pgfId-353669", " Parasolid provides a <B>number</B> of functions for evaluating mesh parameters.These are as", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.090.html#50409878_pgfId-341515", " Parasolid provides a <B>number</B> of functions for evaluating normals on a mesh:", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.090.html#50409878_pgfId-381753", " list of those mvertices. To return just the <B>number</B> of sharp mvertices, set the ", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.090.html#50409878_pgfId-446298", " When this is set to PK_LOGICAL_false only the <B>number</B> of sharp mfins is returned. The default value", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.090.html#50409878_pgfId-426154", " data for mfacetsets that contain at least this <B>number</B> of mfacets is returned. ", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.090.html#50409878_pgfId-424127", " return an array of mvertices along with the <B>number</B> of those mvertices. The ", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.096.html#50409886_pgfId-294756", " string and Unicode string fields) can hold any <B>number</B> of items of data of the appropriate type,", "Functional Description - Attribute Definitions");
top.note("chapters/fd_chap.096.html#50409886_pgfId-294786", " fields whose contents must be accessed via the <B>number</B> of the field, as defined in the attribute", "Functional Description - Attribute Definitions");
top.note("chapters/fd_chap.096.html#50409886_pgfId-294843", " Return the <B>number</B> of user-defined attribute definitions in the session, optionally", "Functional Description - Attribute Definitions");
top.note("chapters/fd_chap.096.html#50409886_pgfId-295043", " should not rely on the precise sequence or <B>number</B> of events during a modeling operation remaining the", "Functional Description - Attribute Definitions");
top.note("chapters/fd_chap.097.html#50409887_pgfId-294747", " and enquired, and each field can hold any <B>number</B> of items of data of the appropriate type", "Functional Description - Attributes");
top.note("chapters/fd_chap.097.html#50409887_pgfId-294789", " A <B>number</B> of functions are available to write an array", "Functional Description - Attributes");
top.note("chapters/fd_chap.098.html#50409888_pgfId-370340", " example, when receiving a transmit file with a <B>number</B> of bodies in it, and then distributing them", "Functional Description - Partitions");
top.note("chapters/fd_chap.099.html#50409889_pgfId-294859", " PK_PMARK_goto_2 returns the <B>number</B> of affected entities as well as, by default,", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-295133", " Returns the <B>number</B> of bytes which would be written to the", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-295376", " Alternatively, PK_PARTITION_ask_pmark_size returns the <B>number</B> of bytes which would be written to the", "Functional Description - Rollback");
top.note("chapters/fd_chap.100.html#50409890_pgfId-397333", " you control this behaviour, and to control the <B>number</B> of groups in a part. ", "Functional Description - Groups");
top.note("chapters/fd_chap.100.html#50409890_pgfId-294738", " Similarly, a particular entity can be in any <B>number</B> of groups that are able to contain that", "Functional Description - Groups");
top.note("chapters/fd_chap.100.html#50409890_pgfId-392361", " the group with that label falls below the <B>number</B> specified by the corresponding entry in ", "Functional Description - Groups");
top.note("chapters/fd_chap.100.html#50409890_pgfId-392400", " An array of integers that specifies the minimum <B>number</B> of entities with a particular entity label (defined", "Functional Description - Groups");
top.note("chapters/fd_chap.100.html#50409890_pgfId-392196", " good way of ensuring, for instance, that the <B>number</B> of empty groups on a part does not", "Functional Description - Groups");
top.note("chapters/fd_chap.100.html#50409890_pgfId-394341", " The following table shows a <B>number</B> of examples to illustrate how you can use", "Functional Description - Groups");
top.note("chapters/fd_chap.100.html#50409890_pgfId-294845", " If an entity is split into a <B>number</B> of entities, the new entities are added to", "Functional Description - Groups");
top.note("chapters/fd_chap.101.html#50409891_pgfId-294989", " the event <B>number</B> ", "Functional Description - Bulletin Board");
top.note("chapters/fd_chap.102.html#50409892_pgfId-294867", " required indexing information, you need to do a <B>number</B> of things: ", "Functional Description - Archives");
top.note("chapters/fd_chap.102.html#50409892_pgfId-294874", " larger than a non-indexed part file, and a <B>number</B> of received nodes will be deleted immediately after", "Functional Description - Archives");
top.note("chapters/fd_chap.102.html#50409892_pgfId-295046", " The <B>number</B> of identifiers, together with a list of the", "Functional Description - Archives");
top.note("chapters/fd_chap.102.html#50409892_pgfId-295281", " option. The version <B>number</B> returned represents the format used for the transmit", "Functional Description - Archives");
top.note("chapters/fd_chap.102.html#50409892_pgfId-295288", " is non-zero, the version <B>number</B> returned represents the actual version of Parasolid used", "Functional Description - Archives");
top.note("chapters/fd_chap.102.html#50409892_pgfId-295292", " You can specify a <B>number</B> of options when receiving partitions, including the following:", "Functional Description - Archives");
top.note("chapters/fd_chap.102.html#50409892_pgfId-295326", " Use PK_PARTITION_ask_pmarks_2 to examine the <B>number</B> of pmarks in the new partition: if deltas", "Functional Description - Archives");
top.note("chapters/fd_chap.103.html#50409893_pgfId-326864", " The maximum <B>number</B> of faults that can be returned is set", "Functional Description - Debug Functionality");
top.note("chapters/fd_chap.103.html#50409893_pgfId-335234", " the SMP worker threads generated by Parasolid. The <B>number</B> of SMP worker threads calling the supplied function", "Functional Description - Debug Functionality");
top.note("chapters/fd_chap.103.html#50409893_pgfId-346304", " tags or you wish to monitor an unknown <B>number</B> of objects, you can pass arrays of PK_CLASS_t", "Functional Description - Debug Functionality");
top.note("chapters/fd_chap.106.html#50409897_pgfId-295207", " This occurrence <B>number</B> is passed onto GO and output as the", "Functional Description - Rendering Functions");
top.note("chapters/fd_chap.107.html#50409898_pgfId-953456", " parametric hatching with the <B>number</B> of u and v hatch lines supplied by", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-956091", " <B>number</B> of hatch lines in the u direction hatch", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-956119", " <B>number</B> of hatch lines in the v direction hatch", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-304455", " a large body that only change a small <B>number</B> of entities, or entities in a discrete part", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-304495", " The <B>number</B> of viewports you are specifying. This should be", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-304503", " render an equivalent <B>number</B> of lines. As the <B>number</B> of viewports increases, the complexity of any rendering", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.109.html#50409900_pgfId-294767", " viewing matrix to be specified. Parasolid has a <B>number</B> of requirements on such matrices, as explained in", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-294782", " A <B>number</B> of the facet mesh options can take a", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-294814", " three sides, as described in Section 108.2.6, Maximum <B>number</B> of sides on facets . ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-313209", " option contains the <B>number</B> of view directions, and should correspond with the", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-313269", " If you are calling PK_TOPOL_facet_2 , specify any <B>number</B> of view directions for culling using the ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-313270", " option contains the <B>number</B> of view directions, and should correspond with the", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-313302", " 108.2.6 Maximum <B>number</B> of sides on facets ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-313304", " field constrains the maximum <B>number</B> of sides on facets. The default value is", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-313450", " Figure 108-5 Maximum <B>number</B> of sides on facets ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-333112", " There are a <B>number</B> of ways that you can manage facet output", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-333313", " initial division of a face into a small <B>number</B> of facets. Each facet is then tested to", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-342165", " this can speed up faceting, and reduce the <B>number</B> of facets created. It is useful if you", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-342859", " large performance cost and result in a large <B>number</B> of facets even for those parts of the", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-342860", " to use the inflect option to increase the <B>number</B> of facets around points of inflection, while leaving", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-342869", " Do not increase the <B>number</B> of facets around points of inflection. This is", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-342873", " point of inflection so as to increase the <B>number</B> of facets. ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-342997", " Figure 108-13 Increasing the <B>number</B> of facets around points of inflection ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-1365917", " 108.2.20 Using viewports to limit the <B>number</B> of facets returned ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.110.html#50409901_pgfId-294928", " Specifies the maximum <B>number</B> of facets that should be combined into a", "Functional Description - Faceting Output Via GO ");
top.note("chapters/fd_chap.111.html#50409902_pgfId-295163", " The <B>number</B> of facets in the facet mesh. ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-295164", " The <B>number</B> of facet strips in the facet mesh. ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-295165", " The <B>number</B> of fins in the facet mesh. ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-295166", " The <B>number</B> of data tables requested. ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-296382", " for a facet strip that contains an odd <B>number</B> of facets. ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-408520", " facet vertices together in a zig-zag pattern: odd <B>number</B> of facets ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-408524", " for a facet strip that contains an even <B>number</B> of facets. The last entry in this table", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-296810", " facet vertices together in a zig-zag pattern: even <B>number</B> of facets ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-297765", " Specifies the maximum <B>number</B> of facets that should be combined into a", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-298012", " containing two faces, each of which contains a <B>number</B> of facet strips. ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.113.html#50409904_pgfId-326791", " edge or vertex. See Section 112.2, Controlling the <B>number</B> and type of entities selected , for more", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.113.html#50409904_pgfId-325006", " 112.2 Controlling the <B>number</B> and type of entities selected ", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.113.html#50409904_pgfId-325007", " options to control the maximum <B>number</B> of those entity types that you want PK_BODY_pick_topols", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.113.html#50409904_pgfId-300640", " By default, Parasolid warns you if the potential <B>number</B> of picked entities exceeds these specified maximum values.", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.113.html#50409904_pgfId-300657", " searching for further intersections with faces once the <B>number</B> of selected faces is equal to ", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.113.html#50409904_pgfId-420059", " The <B>number</B> of topologies to pick from. ", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.113.html#50409904_pgfId-301184", " If you are making a large <B>number</B> of calls to PK_BODY_pick_topols , you may be", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.115.html#50409907_pgfId-294806", " goes into Parasolid, unless the limit on the <B>number</B> of simultaneous threads inside Parasolid has been exceeded,", "Functional Description - Calling Parasolid From Multiple Threads");
top.note("chapters/fd_chap.115.html#50409907_pgfId-308648", " exclusively or concurrently. In addition, for a small <B>number</B> of functions, you can use PK_THREAD_set_function_run to change", "Functional Description - Calling Parasolid From Multiple Threads");
top.note("chapters/fd_chap.115.html#50409907_pgfId-295038", " slot is an application thread in which a <B>number</B> of functions, either concurrent or exclusive, run. In", "Functional Description - Calling Parasolid From Multiple Threads");
top.note("chapters/fd_chap.116.html#50409908_pgfId-294760", " they are present on a host machine. A <B>number</B> of functional areas within Parasolid have been adapted", "Functional Description - Symmetric Multi-Processing In Parasolid");
top.note("chapters/fd_chap.116.html#50409908_pgfId-294872", " information on how you can choose the optimum <B>number</B> of threads for your platform and application. ", "Functional Description - Symmetric Multi-Processing In Parasolid");
top.note("chapters/fd_chap.116.html#50409908_pgfId-330498", " 115.2.2 Determining the maximum <B>number</B> of SMP threads used in a session ", "Functional Description - Symmetric Multi-Processing In Parasolid");
top.note("chapters/fd_chap.116.html#50409908_pgfId-330582", " can use in a current session. Knowing the <B>number</B> of threads that Parasolid can use in a", "Functional Description - Symmetric Multi-Processing In Parasolid");
top.note("chapters/fd_chap.116.html#50409908_pgfId-332021", " <B>number</B> of threads returned depends on the maximum <B>number</B> of SMP threads that Parasolid can work with", "Functional Description - Symmetric Multi-Processing In Parasolid");
top.note("chapters/fd_chap.116.html#50409908_pgfId-332563", " Note: If SMP is disabled then the maximum <B>number</B> of threads is 1. ", "Functional Description - Symmetric Multi-Processing In Parasolid");
top.note("chapters/fd_chap.116.html#50409908_pgfId-295051", " SMP, the scaling of performance with an increased <B>number</B> of processors is not expected to be linear.", "Functional Description - Symmetric Multi-Processing In Parasolid");
top.note("chapters/fd_chap.117.html#50409909_pgfId-294784", " Return the <B>number</B> of tags that are currently available for use.", "Functional Description - Session Support");
top.note("chapters/fd_chap.117.html#50409909_pgfId-294933", " A user field consists of a <B>number</B> of bytes of memory, allocated to every entity", "Functional Description - Session Support");
top.note("chapters/fd_chap.117.html#50409909_pgfId-294943", " attributes; however within these constraints, any combination and <B>number</B> of attributes can be attached to an entity.", "Functional Description - Session Support");
top.note("chapters/fd_chap.118.html#50409910_pgfId-389132", " The consolidated system provides a <B>number</B> of benefits over the original system: ", "Functional Description - Version Controls");
top.note("chapters/fd_chap.118.html#50409910_pgfId-382140", "MM is the major version <B>number</B> ", "Functional Description - Version Controls");
top.note("chapters/fd_chap.118.html#50409910_pgfId-382150", "mm is the minor version <B>number</B> ", "Functional Description - Version Controls");
top.note("chapters/fd_chap.118.html#50409910_pgfId-382169", "pp is a patch <B>number</B> assigned by Parasolid, with 00 representing the First", "Functional Description - Version Controls");
top.note("chapters/fd_chap.118.html#50409910_pgfId-378061", " that are likely to affect only a small <B>number</B> of customers. These are described in Section 117.3.1", "Functional Description - Version Controls");
top.note("chapters/fd_chap.118.html#50409910_pgfId-378095", " Session level switches that only affect a small <B>number</B> of customers are shown below, organised according to", "Functional Description - Version Controls");
top.note("chapters/fd_chap.118.html#50409910_pgfId-379065", "XXX represents a Parasolid version <B>number</B>) is available for every version of Parasolid. ", "Functional Description - Version Controls");
top.note("chapters/fd_chap.118.html#50409910_pgfId-379095", "XXX represents a Parasolid version <B>number</B>, and ", "Functional Description - Version Controls");
top.note("chapters/fd_chap.118.html#50409910_pgfId-379105", " for creating new models in the Parasolid version <B>number</B> for which they are named, and for subsequent", "Functional Description - Version Controls");
top.note("chapters/fd_chap.124.html#50409918_pgfId-386950", " to invalid real values or NAN (not a <B>number</B>). Furthermore, system attributes with string fields, should not", "Functional Description - System Attribute Definitions");
top.note("chapters/fd_chap.124.html#50409918_pgfId-466344", " <B>number</B> of u hatch lines ", "Functional Description - System Attribute Definitions");
top.note("chapters/fd_chap.124.html#50409918_pgfId-466350", " <B>number</B> of v hatch lines ", "Functional Description - System Attribute Definitions");
top.note("chapters/fd_chap.124.html#50409918_pgfId-339007", " Layer <B>number</B> ", "Functional Description - System Attribute Definitions");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287036", " n is the <B>number</B> of vertices ( ", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-324676", " B.2.2.1 The <B>number</B> of knots and vertices ", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-324677", " it can be seen that we require the <B>number</B> of knots n_knots = n_vertices + degree +", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-324666", ",where nknots equals the <B>number</B> of knots, it can be seen then that", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-315601", ", where nknots equals the <B>number</B> of knots, then the difference between these values", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287171", " of control vertices is the product of the <B>number</B> that would be required for a curve using", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287414", " cols = <B>number</B> of columns of vertices ( ", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287418", " rows = <B>number</B> of rows of vertices ( ", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285292", " int, /* <B>number</B> of faces in hole detail */ ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285918", " int field_no, /* field <B>number</B> (>= 0) */ ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285919", " int n_doubles, /* <B>number</B> of doubles (>= 0) */ ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-334575", " each of which will only accept a limited <B>number</B> of users, and will terminate itself when all", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-348032", " struct PK_SESSION_register_fru_o_s { int o_t_version; /* version <B>number</B> */ ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275544", " The <B>number</B> of double precision numbers that are used to", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275839", " A curve or surface made up of a <B>number</B> of polynomial or rational pieces, with levels of", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-204661", " maximum <B>number</B> of faults 363 ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-206486", " maximum <B>number</B> of sides on 1517 ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-207864", " <B>number</B> of faults, checking 363 ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-207866", " <B>number</B> of sides on facets 1517 ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-208141", " <B>number</B> of faults, checking maximum 363 ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-208143", " <B>number</B> of sides on facets, maximum 1517 ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-209626", " sides on facets, maximum <B>number</B> of 1517 ", "Functional Description - ZGlossary");
top.note("chapters/ov_chap.02.html#50442241_pgfId-282888", " A <B>number</B> of functional areas within Parasolid have been adapted", "Overview of Parasolid - Introduction");
top.note("chapters/ov_chap.02.html#50442241_pgfId-275710", " Siemens Industry Software also offers a <B>number</B> of translator toolkits for translating between alternative solid", "Overview of Parasolid - Introduction");
top.note("chapters/ov_chap.03.html#50442274_pgfId-335435", " code into the application. Workshop.Net ships with a <B>number</B> of example plugins: ", "Overview of Parasolid - About Parasolid");
top.note("chapters/ov_chap.04.html#50442254_pgfId-274455", " Parasolid supports a <B>number</B> of other entities so that you can manipulate", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_pgfId-274491", " more complex models in Parasolid by combining any <B>number</B> of bodies into larger ", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_pgfId-286244", " reuse of modelling data, assemblies can contain any <B>number</B> of instances of the same part. You can", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_pgfId-286914", " Assembly information in Parasolid is subject to a <B>number</B> of basic restrictions: ", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_pgfId-282403", " body has one infinite void region, containing any <B>number</B> of shells, each of which contains only a", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_pgfId-282915", " body has one infinite void region containing any <B>number</B> of shells, each of which contains a single", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_marker-314337", " components has one infinite void region containing any <B>number</B> of shells, each of which contains a single", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.05.html#50442271_pgfId-318713", " Section 4.2.3, &#8220;Boolean tools&#8221; , describes a <B>number</B> of tools that let you add your own", "Overview of Parasolid - Booleans and Related Functionality");
top.note("chapters/ov_chap.05.html#50442271_pgfId-334458", " that you can use to create a huge <B>number</B> of effects. Most of these options can be", "Overview of Parasolid - Booleans and Related Functionality");
top.note("chapters/ov_chap.05.html#50442271_pgfId-417769", " Parasolid provides a <B>number</B> of boolean tools so that you can create", "Overview of Parasolid - Booleans and Related Functionality");
top.note("chapters/ov_chap.05.html#50442271_pgfId-401676", " can section any <B>number</B> of bodies using any <B>number</B> of tools and both surfaces and sheet bodies", "Overview of Parasolid - Booleans and Related Functionality");
top.note("chapters/ov_chap.06.html#50442273_pgfId-299499", " Parasolid can repair these wounds automatically, using a <B>number</B> of strategies that you can control to get", "Overview of Parasolid - Local Operations");
top.note("chapters/ov_chap.07.html#50442276_pgfId-314979", " Parasolid supports a <B>number</B> of other miscellaneous operations with sheets. These include:", "Overview of Parasolid - Working with Sheets and Wires");
top.note("chapters/ov_chap.08.html#50442268_pgfId-329640", " Parasolid can join a <B>number</B> of B-curves to form a single B-curve. ", "Overview of Parasolid - B-Spline Curves and Surfaces");
top.note("chapters/ov_chap.10.html#50442242_pgfId-279110", " extrusion , lofting involves the use of any <B>number</B> of profiles. ", "Overview of Parasolid - Building Bodies from Profiles");
top.note("chapters/ov_chap.11.html#50442244_pgfId-297024", " adjacent to the blended edge. Parasolid has a <B>number</B> of strategies that enable such blends to be", "Overview of Parasolid - Blending");
top.note("chapters/ov_chap.11.html#50442244_marker-336786", "blend overflows . Parasolid can create a <B>number</B> of different types of overflow, depending on the", "Overview of Parasolid - Blending");
top.note("chapters/ov_chap.11.html#50442244_pgfId-507593", "wire-face blend. There are a <B>number</B> of restrictions on the use of this functionality.", "Overview of Parasolid - Blending");
top.note("chapters/ov_chap.11.html#50442244_pgfId-289257", "Figure 10-16 shows a part containing a <B>number</B> of ribs, each of which has a three-face", "Overview of Parasolid - Blending");
top.note("chapters/ov_chap.15.html#50442255_pgfId-274632", " Parasolid provides a <B>number</B> of rendering and faceting functions: the one you", "Overview of Parasolid - Displaying Data");
top.note("chapters/ov_chap.15.html#50442255_pgfId-288344", " options to provide control over the style and <B>number</B> of facets created when generating facet data. These", "Overview of Parasolid - Displaying Data");
top.note("chapters/ov_chap.16.html#50442289_pgfId-281451", " in your application. Parasolid comes pre-defined with a <B>number</B> of attribute types, known as ", "Overview of Parasolid - Application Support");
top.note("chapters/ov_chap.16.html#50442289_pgfId-279658", " it to the user. The figure illustrates a <B>number</B> of stages in the creation of a part,", "Overview of Parasolid - Application Support");
top.note("chapters/ov_chap.16.html#50442289_pgfId-284406", " a given entity can be added to any <B>number</B> of valid groups, as determined by the group", "Overview of Parasolid - Application Support");
top.note("chapters/ov_chap.16.html#50442289_pgfId-284410", " criteria to enable you to intelligently manage the <B>number</B> of groups defined on a part, for example", "Overview of Parasolid - Application Support");
top.note("chapters/ov_chap.16.html#50442289_pgfId-276378", " Parasolid offers a <B>number</B> of different ways that you can track activity", "Overview of Parasolid - Application Support");
top.note("chapters/ov_chap.17.html#50442275_pgfId-274102", " to do this, you need to provide a <B>number</B> of modules, referred to generically as ", "Overview of Parasolid - Writing Parasolid Applications");
top.note("chapters/ov_chap.17.html#50442275_pgfId-279634", " There are a <B>number</B> of session-level options you can control that alter", "Overview of Parasolid - Writing Parasolid Applications");
top.note("chapters/ov_chap.18.html#50442277_pgfId-295450", " A <B>number</B> of functional areas within Parasolid have been adapted", "Overview of Parasolid - Multi-Processing Support");
top.note("chapters/ov_chap.18.html#50442277_pgfId-277399", " SMP, the scaling of performance with an increased <B>number</B> of processors is not expected to be linear.", "Overview of Parasolid - Multi-Processing Support");
top.note("chapters/p2_chap.02.html#sec_a_1_1", " token Code <B>Number</B> ", "PK Reference - PK Token Codes (Numeric)");
top.note("chapters/p2_chap.03.html#sec_b_1_1", " token Code <B>Number</B> Description ", "PK Reference - PK token Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.04.html#sec_c_app", " Error Code <B>Number</B> ", "PK Reference - PK token Codes (Alphabetic)");
top.note("chapters/p2_chap.05.html#sec_d_1_app", " Error Code <B>Number</B> Description ", "PK Reference - PK token Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.06.html#sec_e_1_1", " Error Code <B>Number</B> ", "PK Reference - PK Error Codes (Numeric)");
top.note("chapters/p2_chap.06.html#sec_e_1_2", " Error Code <B>Number</B> ", "PK Reference - PK Error Codes (Numeric)");
top.note("chapters/p2_chap.06.html#sec_e_1_3", " Error Code <B>Number</B> ", "PK Reference - PK Error Codes (Numeric)");
top.note("chapters/p2_chap.06.html#sec_e_1_4", " Error Code <B>Number</B> ", "PK Reference - PK Error Codes (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_1", " Error Code <B>Number</B> Function or Structure Description ", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_2", " Error Code <B>Number</B> Function or Structure Description ", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_3", " Error Code <B>Number</B> Function or Structure Description ", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_4", " Error Code <B>Number</B> Function or Structure Description ", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.08.html#sec_g_1_1", " Error Code <B>Number</B> ", "PK Reference - PK Error Codes (Alphabetic)");
top.note("chapters/p2_chap.08.html#sec_g_1_2", " Error Code <B>Number</B> ", "PK Reference - PK Error Codes (Alphabetic)");
top.note("chapters/p2_chap.08.html#sec_g_1_3", " Error Code <B>Number</B> ", "PK Reference - PK Error Codes (Alphabetic)");
top.note("chapters/p2_chap.08.html#sec_g_1_4", " Error Code <B>Number</B> ", "PK Reference - PK Error Codes (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_1", " Error Code <B>Number</B> Function or Structure Description ", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_2", " Error Code <B>Number</B> Function or Structure Description ", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_3", " Error Code <B>Number</B> Function or Structure Description ", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_4", " Error Code <B>Number</B> Function or Structure Description ", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.10.html#sec_i_1_1", " Function or Structure <B>Number</B> Error Code Description ", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_2", " Function or Structure <B>Number</B> Error Code Description ", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_3", " Function or Structure <B>Number</B> Error Code Description ", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_4", " Function or Structure <B>Number</B> Error Code Description ", "PK Reference - PK Error Codes (Functional)");
top.note("headers/pk_appitem_ask.html#declaration", " int n_appitems, --- <B>number</B> of appitems", "PK Reference - PK_APPITEM_ask");
top.note("headers/pk_appitem_create.html#declaration", " int n_pointers, --- <B>number</B> of application pointers", "PK Reference - PK_APPITEM_create");
top.note("headers/pk_appitem_delete.html#declaration", " int n_appitems, --- <B>number</B> of appitems", "PK Reference - PK_APPITEM_delete");
top.note("headers/pk_appitem_reset_pointers.html#declaration", " int n_appitems, --- <B>number</B> of appitems", "PK Reference - PK_APPITEM_reset_pointers");
top.note("headers/pk_assembly_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_ASSEMBLY_array_t");
top.note("headers/pk_assembly_ask_instances.html#declaration", " int *const n_instances, --- <B>number</B> of instances in assembly (>=0)", "PK Reference - PK_ASSEMBLY_ask_instances");
top.note("headers/pk_assembly_ask_instances.html#documentation", "will only compute the <B>number</B> of instances.", "PK Reference - PK_ASSEMBLY_ask_instances");
top.note("headers/pk_assembly_ask_parts.html#declaration", " int *const n_parts, --- <B>number</B> of parts in assembly (>=0)", "PK Reference - PK_ASSEMBLY_ask_parts");
top.note("headers/pk_assembly_ask_parts.html#documentation", "only compute the <B>number</B> of parts.", "PK Reference - PK_ASSEMBLY_ask_parts");
top.note("headers/pk_assembly_ask_parts_transfs.html#declaration", " int *const n_parts, --- <B>number</B> of parts in assembly (>=0)", "PK Reference - PK_ASSEMBLY_ask_parts_transfs");
top.note("headers/pk_assembly_check_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_ASSEMBLY_check_o_t");
top.note("headers/pk_assembly_check_o_t.html#documentation", " caller may set an upper limit on the <B>number</B> of faults found, in", "PK Reference - PK_ASSEMBLY_check_o_t");
top.note("headers/pk_assembly_check_r_t.html#declaration", " --- version <B>number</B> of return structure", "PK Reference - PK_ASSEMBLY_check_r_t");
top.note("headers/pk_assembly_check_r_t.html#documentation", " n_faults The <B>number</B> of faults found.", "PK Reference - PK_ASSEMBLY_check_r_t");
top.note("headers/pk_attdef_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_ATTDEF_array_t");
top.note("headers/pk_attdef_copy_callback_f_t.html#declaration", "int n_attribs, --- <B>number</B> of attribs on old_entity ", "PK Reference - PK_ATTDEF_copy_callback_f_t");
top.note("headers/pk_attdef_delete_callback_f_t.html#declaration", "int n_attribs, --- <B>number</B> of attribs on entity ", "PK Reference - PK_ATTDEF_delete_callback_f_t");
top.note("headers/pk_attdef_is_group_closing_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_ATTDEF_is_group_closing_o_t");
top.note("headers/pk_attdef_merge_callback_f_t.html#declaration", "int n_live_attribs, --- <B>number</B> of attribs on live_entity ", "PK Reference - PK_ATTDEF_merge_callback_f_t");
top.note("headers/pk_attdef_receive_callback_f_t.html#declaration", "int n_attribs, --- <B>number</B> of attribs on entity ", "PK Reference - PK_ATTDEF_receive_callback_f_t");
top.note("headers/pk_attdef_register_cb_o_t.html#declaration", " --- version <B>number</B> of option structure", "PK Reference - PK_ATTDEF_register_cb_o_t");
top.note("headers/pk_attdef_set_group_closing_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_ATTDEF_set_group_closing_o_t");
top.note("headers/pk_attdef_sf_2_t.html#declaration", " int n_owner_types; --- <B>number</B> of legal owners (>0)", "PK Reference - PK_ATTDEF_sf_2_t");
top.note("headers/pk_attdef_sf_t.html#declaration", " int n_owner_types; --- <B>number</B> of legal owners (>0)", "PK Reference - PK_ATTDEF_sf_t");
top.note("headers/pk_attdef_split_callback_f_t.html#declaration", "int n_attribs, --- <B>number</B> of attribs on old_entity ", "PK Reference - PK_ATTDEF_split_callback_f_t");
top.note("headers/pk_attdef_transmit_callback_f_t.html#declaration", "int n_attribs, --- <B>number</B> of attribs on `entity", "PK Reference - PK_ATTDEF_transmit_callback_f_t");
top.note("headers/pk_attrib_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_ATTRIB_array_t");
top.note("headers/pk_attrib_ask_axes.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_axes");
top.note("headers/pk_attrib_ask_axes.html#errors", " this <B>number</B>", "PK Reference - PK_ATTRIB_ask_axes");
top.note("headers/pk_attrib_ask_axes.html#documentation", "will only return the <B>number</B> of axes in the field.", "PK Reference - PK_ATTRIB_ask_axes");
top.note("headers/pk_attrib_ask_doubles.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_doubles");
top.note("headers/pk_attrib_ask_doubles.html#errors", " this <B>number</B>", "PK Reference - PK_ATTRIB_ask_doubles");
top.note("headers/pk_attrib_ask_doubles.html#documentation", "will only return the <B>number</B> of doubles in the field.", "PK Reference - PK_ATTRIB_ask_doubles");
top.note("headers/pk_attrib_ask_ints.html#declaration", "int field_no, --- field <B>number</B> (>= 0 )", "PK Reference - PK_ATTRIB_ask_ints");
top.note("headers/pk_attrib_ask_ints.html#errors", " this <B>number</B>", "PK Reference - PK_ATTRIB_ask_ints");
top.note("headers/pk_attrib_ask_ints.html#documentation", "will only return the <B>number</B> of integers in the field.", "PK Reference - PK_ATTRIB_ask_ints");
top.note("headers/pk_attrib_ask_named_axes.html#declaration", " int *const n_axes, --- <B>number</B> of axes (>=0)", "PK Reference - PK_ATTRIB_ask_named_axes");
top.note("headers/pk_attrib_ask_named_axes.html#documentation", "will only return the <B>number</B> of axes in the field.", "PK Reference - PK_ATTRIB_ask_named_axes");
top.note("headers/pk_attrib_ask_named_doubles.html#declaration", " int *const n_doubles, --- <B>number</B> of doubles (>=0)", "PK Reference - PK_ATTRIB_ask_named_doubles");
top.note("headers/pk_attrib_ask_named_doubles.html#documentation", "will only return the <B>number</B> of doubles in the field.", "PK Reference - PK_ATTRIB_ask_named_doubles");
top.note("headers/pk_attrib_ask_named_ints.html#declaration", " int *const n_ints, --- <B>number</B> of ints (>= 0)", "PK Reference - PK_ATTRIB_ask_named_ints");
top.note("headers/pk_attrib_ask_named_ints.html#documentation", "will only return the <B>number</B> of integers in the field.", "PK Reference - PK_ATTRIB_ask_named_ints");
top.note("headers/pk_attrib_ask_named_pointers.html#declaration", " int *const n_pointers, --- <B>number</B> of pointers (>=0)", "PK Reference - PK_ATTRIB_ask_named_pointers");
top.note("headers/pk_attrib_ask_named_pointers.html#documentation", "will only return the <B>number</B> of pointers in the field.", "PK Reference - PK_ATTRIB_ask_named_pointers");
top.note("headers/pk_attrib_ask_named_string.html#documentation", "If field <B>number</B> field_no is a character string field containing no", "PK Reference - PK_ATTRIB_ask_named_string");
top.note("headers/pk_attrib_ask_named_ustring.html#documentation", "If field <B>number</B> field_name is a Unicode string field containing no", "PK Reference - PK_ATTRIB_ask_named_ustring");
top.note("headers/pk_attrib_ask_named_vectors.html#declaration", " int *const n_vectors, --- <B>number</B> of vectors (>= 0)", "PK Reference - PK_ATTRIB_ask_named_vectors");
top.note("headers/pk_attrib_ask_named_vectors.html#documentation", "will only return the <B>number</B> of vectors in the field.", "PK Reference - PK_ATTRIB_ask_named_vectors");
top.note("headers/pk_attrib_ask_no_roll.html#declaration", " int n_attribs, --- <B>number</B> of attributes", "PK Reference - PK_ATTRIB_ask_no_roll");
top.note("headers/pk_attrib_ask_no_roll_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_ATTRIB_ask_no_roll_o_t");
top.note("headers/pk_attrib_ask_nth_axis.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_nth_axis");
top.note("headers/pk_attrib_ask_nth_axis.html#errors", " this <B>number</B>", "PK Reference - PK_ATTRIB_ask_nth_axis");
top.note("headers/pk_attrib_ask_nth_double.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_nth_double");
top.note("headers/pk_attrib_ask_nth_double.html#errors", " this <B>number</B>", "PK Reference - PK_ATTRIB_ask_nth_double");
top.note("headers/pk_attrib_ask_nth_int.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_nth_int");
top.note("headers/pk_attrib_ask_nth_int.html#errors", " this <B>number</B>", "PK Reference - PK_ATTRIB_ask_nth_int");
top.note("headers/pk_attrib_ask_nth_pointer.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_nth_pointer");
top.note("headers/pk_attrib_ask_nth_pointer.html#errors", " this <B>number</B>", "PK Reference - PK_ATTRIB_ask_nth_pointer");
top.note("headers/pk_attrib_ask_nth_vector.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_nth_vector");
top.note("headers/pk_attrib_ask_nth_vector.html#errors", " this <B>number</B>", "PK Reference - PK_ATTRIB_ask_nth_vector");
top.note("headers/pk_attrib_ask_pointers.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_pointers");
top.note("headers/pk_attrib_ask_pointers.html#errors", " this <B>number</B>", "PK Reference - PK_ATTRIB_ask_pointers");
top.note("headers/pk_attrib_ask_pointers.html#documentation", "will only return the <B>number</B> of pointers in the field.", "PK Reference - PK_ATTRIB_ask_pointers");
top.note("headers/pk_attrib_ask_string.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_string");
top.note("headers/pk_attrib_ask_string.html#description", " function returns the character string stored in field <B>number</B> field_no ", "PK Reference - PK_ATTRIB_ask_string");
top.note("headers/pk_attrib_ask_string.html#errors", " this <B>number</B>", "PK Reference - PK_ATTRIB_ask_string");
top.note("headers/pk_attrib_ask_string.html#documentation", "If field <B>number</B> field_no is a character string field containing no", "PK Reference - PK_ATTRIB_ask_string");
top.note("headers/pk_attrib_ask_ustring.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_ustring");
top.note("headers/pk_attrib_ask_ustring.html#description", " function returns the Unicode string stored in field <B>number</B> field_no ", "PK Reference - PK_ATTRIB_ask_ustring");
top.note("headers/pk_attrib_ask_ustring.html#errors", " this <B>number</B>", "PK Reference - PK_ATTRIB_ask_ustring");
top.note("headers/pk_attrib_ask_ustring.html#documentation", "If field <B>number</B> field_no is a Unicode string field containing no", "PK Reference - PK_ATTRIB_ask_ustring");
top.note("headers/pk_attrib_ask_vectors.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_vectors");
top.note("headers/pk_attrib_ask_vectors.html#errors", " this <B>number</B>", "PK Reference - PK_ATTRIB_ask_vectors");
top.note("headers/pk_attrib_ask_vectors.html#documentation", "will only return the <B>number</B> of vectors in the field.", "PK Reference - PK_ATTRIB_ask_vectors");
top.note("headers/pk_attrib_cb_f_t.html#documentation", " the field length and value arrays is the <B>number</B> of fields given in", "PK Reference - PK_ATTRIB_cb_f_t");
top.note("headers/pk_attrib_reset_cb_f_t.html#documentation", " it will now have these revised values. The <B>number</B> and type of", "PK Reference - PK_ATTRIB_reset_cb_f_t");
top.note("headers/pk_attrib_reset_cb_r_t.html#documentation", " n_values specifies the <B>number</B> of entries in values. This", "PK Reference - PK_ATTRIB_reset_cb_r_t");
top.note("headers/pk_attrib_set_axes.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_set_axes");
top.note("headers/pk_attrib_set_axes.html#description", " This function copies axes into field <B>number</B> field_no of the given", "PK Reference - PK_ATTRIB_set_axes");
top.note("headers/pk_attrib_set_axes.html#errors", " with this <B>number</B>", "PK Reference - PK_ATTRIB_set_axes");
top.note("headers/pk_attrib_set_doubles.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_set_doubles");
top.note("headers/pk_attrib_set_doubles.html#description", " This function copies doubles into field <B>number</B> field_no of the given", "PK Reference - PK_ATTRIB_set_doubles");
top.note("headers/pk_attrib_set_doubles.html#errors", " with this <B>number</B>", "PK Reference - PK_ATTRIB_set_doubles");
top.note("headers/pk_attrib_set_ints.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_set_ints");
top.note("headers/pk_attrib_set_ints.html#description", " This function copies ints into field <B>number</B> field_no of the given", "PK Reference - PK_ATTRIB_set_ints");
top.note("headers/pk_attrib_set_ints.html#errors", " with this <B>number</B>", "PK Reference - PK_ATTRIB_set_ints");
top.note("headers/pk_attrib_set_named_axes.html#declaration", "int n_axes, --- <B>number</B> of axes (>= 0)", "PK Reference - PK_ATTRIB_set_named_axes");
top.note("headers/pk_attrib_set_named_doubles.html#declaration", "int n_doubles, --- <B>number</B> of doubles (>= 0)", "PK Reference - PK_ATTRIB_set_named_doubles");
top.note("headers/pk_attrib_set_named_ints.html#declaration", "int n_ints, --- <B>number</B> of ints (>= 0)", "PK Reference - PK_ATTRIB_set_named_ints");
top.note("headers/pk_attrib_set_named_pointers.html#declaration", "int n_pointers, --- <B>number</B> of pointers (>= 0)", "PK Reference - PK_ATTRIB_set_named_pointers");
top.note("headers/pk_attrib_set_named_vectors.html#declaration", "int n_vectors, --- <B>number</B> of vectors (>=0)", "PK Reference - PK_ATTRIB_set_named_vectors");
top.note("headers/pk_attrib_set_no_roll.html#declaration", " int n_attribs, --- <B>number</B> of attributes", "PK Reference - PK_ATTRIB_set_no_roll");
top.note("headers/pk_attrib_set_no_roll_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_ATTRIB_set_no_roll_o_t");
top.note("headers/pk_attrib_set_pointers.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_set_pointers");
top.note("headers/pk_attrib_set_pointers.html#description", " This function copies pointers into field <B>number</B> field_no of the given", "PK Reference - PK_ATTRIB_set_pointers");
top.note("headers/pk_attrib_set_pointers.html#errors", " with this <B>number</B>", "PK Reference - PK_ATTRIB_set_pointers");
top.note("headers/pk_attrib_set_string.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_set_string");
top.note("headers/pk_attrib_set_string.html#description", " This function copies string into field <B>number</B> field_no of the given", "PK Reference - PK_ATTRIB_set_string");
top.note("headers/pk_attrib_set_string.html#errors", " with this <B>number</B>", "PK Reference - PK_ATTRIB_set_string");
top.note("headers/pk_attrib_set_ustring.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_set_ustring");
top.note("headers/pk_attrib_set_ustring.html#description", " This function copies Unicode string into field <B>number</B> field_no of the", "PK Reference - PK_ATTRIB_set_ustring");
top.note("headers/pk_attrib_set_ustring.html#errors", " with this <B>number</B>", "PK Reference - PK_ATTRIB_set_ustring");
top.note("headers/pk_attrib_set_vectors.html#declaration", "int field_no, --- field <B>number</B> (>= 0)", "PK Reference - PK_ATTRIB_set_vectors");
top.note("headers/pk_attrib_set_vectors.html#description", " This function copies vectors into field <B>number</B> field_no of the given", "PK Reference - PK_ATTRIB_set_vectors");
top.note("headers/pk_attrib_set_vectors.html#errors", " with this <B>number</B>", "PK Reference - PK_ATTRIB_set_vectors");
top.note("headers/pk_bb_output_events.html#declaration", " int *const n_entities, --- <B>number</B> of entities (>= 0)", "PK Reference - PK_BB_output_events");
top.note("headers/pk_bcurve_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_BCURVE_array_t");
top.note("headers/pk_bcurve_ask_knots.html#declaration", " int *const n_knots, --- <B>number</B> of knots", "PK Reference - PK_BCURVE_ask_knots");
top.note("headers/pk_bcurve_combine.html#declaration", " int n_bcurves, --- <B>number</B> of bcurves ( >=2 )", "PK Reference - PK_BCURVE_combine");
top.note("headers/pk_bcurve_create.html#errors", " PK_ERROR_insufficient_points invalid <B>number</B> of verticies", "PK Reference - PK_BCURVE_create");
top.note("headers/pk_bcurve_create_by_fitting_o_t.html#declaration", "int o_t_version; --- option structure version <B>number</B>", "PK Reference - PK_BCURVE_create_by_fitting_o_t");
top.note("headers/pk_bcurve_create_by_fitting_o_t.html#documentation", " n_curves the <B>number</B> of bcurves to be produced.", "PK Reference - PK_BCURVE_create_by_fitting_o_t");
top.note("headers/pk_bcurve_create_fitted_o_t.html#declaration", " --- <B>number</B>", "PK Reference - PK_BCURVE_create_fitted_o_t");
top.note("headers/pk_bcurve_create_fitted_o_t.html#documentation", " n_interpolation_parms the <B>number</B> of interpolation_parms supplied.", "PK Reference - PK_BCURVE_create_fitted_o_t");
top.note("headers/pk_bcurve_create_spline.html#declaration", " int n_positions, --- <B>number</B> of positions", "PK Reference - PK_BCURVE_create_spline");
top.note("headers/pk_bcurve_create_spline.html#documentation", " n_fault_values the <B>number</B> of fault_values returned.", "PK Reference - PK_BCURVE_create_spline");
top.note("headers/pk_bcurve_create_spline_2.html#declaration", " int n_positions, --- <B>number</B> of positions", "PK Reference - PK_BCURVE_create_spline_2");
top.note("headers/pk_bcurve_create_spline_2_o_t.html#declaration", " int n_parameters; --- <B>number</B> of parameters (0)", "PK Reference - PK_BCURVE_create_spline_2_o_t");
top.note("headers/pk_bcurve_create_spline_2_o_t.html#documentation", " n_parameters <B>Number</B> of parameters supplied. It must be no greater than", "PK Reference - PK_BCURVE_create_spline_2_o_t");
top.note("headers/pk_bcurve_create_spline_o_t.html#declaration", " int n_parameters; --- <B>number</B> of parameters (0)", "PK Reference - PK_BCURVE_create_spline_o_t");
top.note("headers/pk_bcurve_create_spline_o_t.html#documentation", " n_parameters <B>Number</B> of parameters supplied. It must be no greater", "PK Reference - PK_BCURVE_create_spline_o_t");
top.note("headers/pk_bcurve_find_g1_discontinuity.html#declaration", " int *const n_discs, --- <B>number</B> of discontinuities", "PK Reference - PK_BCURVE_find_g1_discontinuity");
top.note("headers/pk_bcurve_fit_chain_t.html#declaration", " int n_curves_in_chain; --- <B>number</B> of curves in this chain (0)", "PK Reference - PK_BCURVE_fit_chain_t");
top.note("headers/pk_bcurve_fit_chain_t.html#documentation", " n_curves_in_chain The <B>number</B> of curves in the chain.", "PK Reference - PK_BCURVE_fit_chain_t");
top.note("headers/pk_bcurve_fit_t.html#documentation", " PK_BCURVE_fit_bad_n_curves_c invalid <B>number</B> of curves supplied", "PK Reference - PK_BCURVE_fit_t");
top.note("headers/pk_bcurve_join.html#declaration", " int n_bcurves, --- <B>number</B> of bcurves ( >=2 )", "PK Reference - PK_BCURVE_join");
top.note("headers/pk_bcurve_join_o_t.html#declaration", " int n_knots; --- <B>number</B> of knot values (0)", "PK Reference - PK_BCURVE_join_o_t");
top.note("headers/pk_bcurve_make_bsurf_lofted.html#declaration", " int n_bcurves, --- <B>number</B> of bcurves", "PK Reference - PK_BCURVE_make_bsurf_lofted");
top.note("headers/pk_bcurve_make_bsurf_lofted.html#documentation", "The bcurves must have the same <B>number</B> of segments unless either the", "PK Reference - PK_BCURVE_make_bsurf_lofted");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure(1)", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#errors", " PK_ERROR_wrong_number_derivs wrong <B>number</B> of derivatives", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#documentation", " n_v_derivs <B>number</B> of doubles in v_derivs ", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_make_matched.html#declaration", " int n_bcurves, --- <B>number</B> of bcurves ( >=2 )", "PK Reference - PK_BCURVE_make_matched");
top.note("headers/pk_bcurve_piecewise_sf_t.html#declaration", " int n_segments; --- The <B>number</B> of curve segments", "PK Reference - PK_BCURVE_piecewise_sf_t");
top.note("headers/pk_bcurve_piecewise_sf_t.html#documentation", " n_segments The <B>number</B> of segments in the curve. This must be", "PK Reference - PK_BCURVE_piecewise_sf_t");
top.note("headers/pk_bcurve_remove_knots.html#declaration", " int *const n_knots_removed, --- <B>number</B> of knots removed", "PK Reference - PK_BCURVE_remove_knots");
top.note("headers/pk_bcurve_remove_knots.html#documentation", "The <B>number</B> of distinct knots removed, if any, is returned", "PK Reference - PK_BCURVE_remove_knots");
top.note("headers/pk_bcurve_remove_knots_o_t.html#declaration", " int n_knot_indices; --- <B>number</B> of knot indices (0)", "PK Reference - PK_BCURVE_remove_knots_o_t");
top.note("headers/pk_bcurve_remove_knots_o_t.html#documentation", " n_knot_indices The <B>number</B> of knot indices provided. If this is", "PK Reference - PK_BCURVE_remove_knots_o_t");
top.note("headers/pk_bcurve_sf_t.html#declaration", " int n_vertices; --- The <B>number</B> of vertices.", "PK Reference - PK_BCURVE_sf_t");
top.note("headers/pk_bcurve_sf_t.html#documentation", " <B>number</B> of important differences, designed to make its use", "PK Reference - PK_BCURVE_sf_t");
top.note("headers/pk_bcurve_spline_r_t.html#declaration", " int n_bcurves; --- <B>number</B> of returned B-curves", "PK Reference - PK_BCURVE_spline_r_t");
top.note("headers/pk_bcurve_spline_r_t.html#documentation", " n_bcurves The <B>number</B> of resultant B-curves.", "PK Reference - PK_BCURVE_spline_r_t");
top.note("headers/pk_bcurve_splinewise_sf_t.html#declaration", " int n_positions; --- The <B>number</B> of positions", "PK Reference - PK_BCURVE_splinewise_sf_t");
top.note("headers/pk_bcurve_splinewise_sf_t.html#errors", " PK_ERROR_wrong_number_knots wrong <B>number</B> of knots (MILD)", "PK Reference - PK_BCURVE_splinewise_sf_t");
top.note("headers/pk_bcurve_splinewise_sf_t.html#documentation", " n_positions <B>Number</B> of positions.", "PK Reference - PK_BCURVE_splinewise_sf_t");
top.note("headers/pk_blend_cap_data_t.html#declaration", " int n_caps; --- <B>number</B> of caps (0)", "PK Reference - PK_blend_cap_data_t");
top.note("headers/pk_blend_cap_data_t.html#documentation", " n_caps The <B>number</B> of capping entities.", "PK Reference - PK_blend_cap_data_t");
top.note("headers/pk_blend_constraint_t.html#declaration", " int n_caps; --- <B>number</B> of caps (0)", "PK Reference - PK_blend_constraint_t");
top.note("headers/pk_blend_constraint_t.html#documentation", " and tangent_edges must not be set, and the <B>number</B> of edge", "PK Reference - PK_blend_constraint_t");
top.note("headers/pk_blend_delete_cap_data_t.html#declaration", " int n_blends; --- <B>number</B>", "PK Reference - PK_blend_delete_cap_data_t");
top.note("headers/pk_blend_delete_unders_data_t.html#declaration", " int n_blends; --- <B>number</B> of blend faces ( 0 )", "PK Reference - PK_blend_delete_unders_data_t");
top.note("headers/pk_blend_delete_unders_data_t.html#errors", " PK_ERROR_bad_combination The <B>number</B> of unders supplied for each blend", "PK Reference - PK_blend_delete_unders_data_t");
top.note("headers/pk_blend_edge_shape_t.html#declaration", " int n_ranges; --- <B>number</B> of ranges (0)", "PK Reference - PK_blend_edge_shape_t");
top.note("headers/pk_blend_edge_shape_t.html#documentation", " n_ranges <B>number</B> of positions along the edge at which ranges", "PK Reference - PK_blend_edge_shape_t");
top.note("headers/pk_blend_group_rib_t.html#documentation", "This datatype selects how max_n_ribs limits the <B>number</B> of ribs to be", "PK Reference - PK_blend_group_rib_t");
top.note("headers/pk_blend_limit_data_t.html#declaration", " int n_limits; --- <B>number</B> of limits (0)", "PK Reference - PK_blend_limit_data_t");
top.note("headers/pk_blend_rib_control_t.html#declaration", " int n_interval_parms; --- <B>number</B> of parameters (0)", "PK Reference - PK_blend_rib_control_t");
top.note("headers/pk_blend_rib_control_t.html#documentation", " Grouping controls how the limit on the <B>number</B> of ribs", "PK Reference - PK_blend_rib_control_t");
top.note("headers/pk_blend_rib_r_t.html#declaration", " int n_ribs; --- <B>number</B> of ribs", "PK Reference - PK_blend_rib_r_t");
top.note("headers/pk_blend_rib_r_t.html#documentation", " n_ribs the <B>number</B> of curves and points in the ribs array", "PK Reference - PK_blend_rib_r_t");
top.note("headers/pk_blend_setback_data_t.html#declaration", " int n_edges; --- <B>number</B> of edges (0)", "PK Reference - PK_blend_setback_data_t");
top.note("headers/pk_blend_setback_shape_data_t.html#declaration", " int n_vertices; --- <B>number</B> of vertices at which", "PK Reference - PK_blend_setback_shape_data_t");
top.note("headers/pk_blend_vx_blend_data_t.html#declaration", " int n_vertices; --- <B>number</B> of vertices (0)", "PK Reference - PK_blend_vx_blend_data_t");
top.note("headers/pk_blend_vx_order_data_t.html#declaration", " int n_vertices; --- <B>number</B> of vertices (0)", "PK Reference - PK_blend_vx_order_data_t");
top.note("headers/pk_blend_y_blend_data_t.html#declaration", " int n_vertices; --- <B>number</B> of vertices (0)", "PK Reference - PK_blend_y_blend_data_t");
top.note("headers/pk_blendsf_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_BLENDSF_array_t");
top.note("headers/pk_body_add_to_compound.html#declaration", " int n_bodies, --- <B>number</B> of bodies", "PK Reference - PK_BODY_add_to_compound");
top.note("headers/pk_body_add_to_compound_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_add_to_compound_o_t");
top.note("headers/pk_body_apply_knit_pattern.html#documentation", " This function joins a <B>number</B> of faces or bodies together by fusing coincident", "PK Reference - PK_BODY_apply_knit_pattern");
top.note("headers/pk_body_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_BODY_array_t");
top.note("headers/pk_body_ask_children.html#declaration", " int *const n_children, --- <B>number</B> of children (>= 0)", "PK Reference - PK_BODY_ask_children");
top.note("headers/pk_body_ask_children_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_ask_children_o_t");
top.note("headers/pk_body_ask_components.html#declaration", " int *const n_components, --- <B>number</B> of components (>= 1)", "PK Reference - PK_BODY_ask_components");
top.note("headers/pk_body_ask_components.html#documentation", "will only compute the <B>number</B> of components in the body.", "PK Reference - PK_BODY_ask_components");
top.note("headers/pk_body_ask_edges.html#declaration", " int *const n_edges, --- <B>number</B> of edges (>= 0)", "PK Reference - PK_BODY_ask_edges");
top.note("headers/pk_body_ask_edges.html#documentation", "will only compute the <B>number</B> of edges in the body.", "PK Reference - PK_BODY_ask_edges");
top.note("headers/pk_body_ask_faces.html#declaration", " int *const n_faces, --- <B>number</B> of faces (>= 0)", "PK Reference - PK_BODY_ask_faces");
top.note("headers/pk_body_ask_faces.html#documentation", "will only compute the <B>number</B> of faces in the body.", "PK Reference - PK_BODY_ask_faces");
top.note("headers/pk_body_ask_fins.html#declaration", " int *const n_fins, --- <B>number</B> of fins (>= 0)", "PK Reference - PK_BODY_ask_fins");
top.note("headers/pk_body_ask_fins.html#documentation", "only compute the <B>number</B> of fins in the body.", "PK Reference - PK_BODY_ask_fins");
top.note("headers/pk_body_ask_frames.html#declaration", " int *const n_frames, --- <B>number</B> of frames (>= 0)", "PK Reference - PK_BODY_ask_frames");
top.note("headers/pk_body_ask_frames.html#documentation", "only compute the <B>number</B> of frames in the body.", "PK Reference - PK_BODY_ask_frames");
top.note("headers/pk_body_ask_loops.html#declaration", " int *const n_loops, --- <B>number</B> of loops (>= 0)", "PK Reference - PK_BODY_ask_loops");
top.note("headers/pk_body_ask_loops.html#documentation", "will only compute the <B>number</B> of loops in the body.", "PK Reference - PK_BODY_ask_loops");
top.note("headers/pk_body_ask_parent_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_ask_parent_o_t");
top.note("headers/pk_body_ask_regions.html#declaration", " int *const n_regions, --- <B>number</B> of regions (>= 1)", "PK Reference - PK_BODY_ask_regions");
top.note("headers/pk_body_ask_regions.html#documentation", "will only compute the <B>number</B> of regions in the body.", "PK Reference - PK_BODY_ask_regions");
top.note("headers/pk_body_ask_shells.html#declaration", " int *const n_shells, --- <B>number</B> of shells (>= 0)", "PK Reference - PK_BODY_ask_shells");
top.note("headers/pk_body_ask_shells.html#documentation", "will only compute the <B>number</B> of shells in the body.", "PK Reference - PK_BODY_ask_shells");
top.note("headers/pk_body_ask_topology.html#declaration", " int *const n_topols, --- <B>number</B> of topological", "PK Reference - PK_BODY_ask_topology");
top.note("headers/pk_body_ask_topology_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_ask_topology_o_t");
top.note("headers/pk_body_ask_vertices.html#declaration", " int *const n_vertices, --- <B>number</B> of vertices (>= 0)", "PK Reference - PK_BODY_ask_vertices");
top.note("headers/pk_body_ask_vertices.html#documentation", "will only compute the <B>number</B> of vertices in the body.", "PK Reference - PK_BODY_ask_vertices");
top.note("headers/pk_body_boolean.html#declaration", "int n_tools, --- <B>number</B> of tool bodies", "PK Reference - PK_BODY_boolean");
top.note("headers/pk_body_boolean.html#documentation", "<B>number</B> of bodies, each of which is a manifold", "PK Reference - PK_BODY_boolean");
top.note("headers/pk_body_boolean_2.html#declaration", "int n_tools, --- <B>number</B> of tool bodies", "PK Reference - PK_BODY_boolean_2");
top.note("headers/pk_body_boolean_2.html#documentation", "<B>number</B> of bodies, each of which is a manifold", "PK Reference - PK_BODY_boolean_2");
top.note("headers/pk_body_boolean_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_boolean_o_t");
top.note("headers/pk_body_check.html#declaration", " int *const n_faults, --- <B>number</B> of faults", "PK Reference - PK_BODY_check");
top.note("headers/pk_body_check_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_BODY_check_o_t");
top.note("headers/pk_body_check_o_t.html#documentation", " caller may set an upper limit on the <B>number</B> of faults found, in", "PK Reference - PK_BODY_check_o_t");
top.note("headers/pk_body_copy_topology_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_copy_topology_o_t");
top.note("headers/pk_body_create_minimum_topology.html#declaration", " int n_topols, --- <B>number</B> of topols", "PK Reference - PK_BODY_create_minimum_topology");
top.note("headers/pk_body_create_sheet_planar.html#declaration", " int n_vectors, --- <B>number</B> of position", "PK Reference - PK_BODY_create_sheet_planar");
top.note("headers/pk_body_create_sheet_planar_o_t.html#declaration", " int o_t_version; --- version <B>number</B> (1)", "PK Reference - PK_BODY_create_sheet_planar_o_t");
top.note("headers/pk_body_create_sheet_planar_o_t.html#documentation", "vector belongs. Thus the <B>number</B> of elements in each array must be equal.", "PK Reference - PK_BODY_create_sheet_planar_o_t");
top.note("headers/pk_body_create_sheet_polygon.html#declaration", "int n_sides, --- <B>number</B> of sides of polygon (>2)", "PK Reference - PK_BODY_create_sheet_polygon");
top.note("headers/pk_body_create_sheet_topology.html#declaration", " int n_topols, --- <B>number</B> of topols", "PK Reference - PK_BODY_create_sheet_topology");
top.note("headers/pk_body_create_solid_prism.html#declaration", "int n_sides, --- <B>number</B> of sides (>2)", "PK Reference - PK_BODY_create_solid_prism");
top.note("headers/pk_body_create_solid_topology.html#declaration", " int n_topols, --- <B>number</B> of topols", "PK Reference - PK_BODY_create_solid_topology");
top.note("headers/pk_body_create_solid_topology.html#documentation", " - A loop must have either a <B>number</B> of edges (with senses) as children,", "PK Reference - PK_BODY_create_solid_topology");
top.note("headers/pk_body_create_topology.html#declaration", " int n_topols, --- <B>number</B> of topols", "PK Reference - PK_BODY_create_topology");
top.note("headers/pk_body_create_topology.html#documentation", " - A loop must have either a <B>number</B> of edges (with senses) as children, or", "PK Reference - PK_BODY_create_topology");
top.note("headers/pk_body_create_topology_2.html#declaration", " int n_topols, --- <B>number</B> of topols", "PK Reference - PK_BODY_create_topology_2");
top.note("headers/pk_body_create_topology_2.html#documentation", " - A loop must have either a <B>number</B> of edges (with senses) as children, or", "PK Reference - PK_BODY_create_topology_2");
top.note("headers/pk_body_create_topology_2_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_create_topology_2_o_t");
top.note("headers/pk_body_create_topology_2_o_t.html#documentation", " consists of any <B>number</B> of isolated vertices, then the", "PK Reference - PK_BODY_create_topology_2_o_t");
top.note("headers/pk_body_create_topology_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_create_topology_o_t");
top.note("headers/pk_body_create_topology_o_t.html#documentation", " consists of any <B>number</B> of isolated vertices, then the", "PK Reference - PK_BODY_create_topology_o_t");
top.note("headers/pk_body_create_wire_topology.html#declaration", " int n_topols, --- <B>number</B> of topols", "PK Reference - PK_BODY_create_wire_topology");
top.note("headers/pk_body_disjoin.html#declaration", " int *const n_bodies, --- <B>number</B> of disjoint bodies (>= 1)", "PK Reference - PK_BODY_disjoin");
top.note("headers/pk_body_embed_in_surf.html#declaration", " int *const n_edges, --- <B>number</B> of edges converted to SPCURVEs", "PK Reference - PK_BODY_embed_in_surf");
top.note("headers/pk_body_embed_in_surf.html#documentation", "The <B>number</B> of edges whose curves have been converted to", "PK Reference - PK_BODY_embed_in_surf");
top.note("headers/pk_body_emboss_o_t.html#declaration", " int o_t_version;--- version <B>number</B> of options", "PK Reference - PK_BODY_emboss_o_t");
top.note("headers/pk_body_enlarge_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_BODY_enlarge_o_t");
top.note("headers/pk_body_enlarge_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return", "PK Reference - PK_BODY_enlarge_r_t");
top.note("headers/pk_body_enlarge_r_t.html#documentation", " n_bodies The <B>number</B> of enlarged bodies.", "PK Reference - PK_BODY_enlarge_r_t");
top.note("headers/pk_body_extend.html#declaration", "int n_boundary_edges, --- <B>number</B> of boundary edges", "PK Reference - PK_BODY_extend");
top.note("headers/pk_body_extend.html#documentation", " n_boundary_edges <B>number</B> of boundary edges. This must be positive.", "PK Reference - PK_BODY_extend");
top.note("headers/pk_body_extend_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_extend_o_t");
top.note("headers/pk_body_extrude_o_t.html#declaration", " int o_t_version; --- options structure version <B>number</B>", "PK Reference - PK_BODY_extrude_o_t");
top.note("headers/pk_body_fill_hole.html#declaration", "int n_edges, --- <B>number</B> of edges", "PK Reference - PK_BODY_fill_hole");
top.note("headers/pk_body_fill_hole.html#documentation", "returned in fault_topols . The <B>number</B> of fault_topols returned will", "PK Reference - PK_BODY_fill_hole");
top.note("headers/pk_body_fill_hole_o_t.html#declaration", " --- version <B>number</B>", "PK Reference - PK_BODY_fill_hole_o_t");
top.note("headers/pk_body_fill_hole_o_t.html#documentation", " n_clamps The <B>number</B> of supporting bodies for which clamping should", "PK Reference - PK_BODY_fill_hole_o_t");
top.note("headers/pk_body_find_extreme.html#description", "are used successively to reduce the <B>number</B> of extreme points to one.", "PK Reference - PK_BODY_find_extreme");
top.note("headers/pk_body_find_extreme_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option struct", "PK Reference - PK_BODY_find_extreme_o_t");
top.note("headers/pk_body_find_facesets_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option struct", "PK Reference - PK_BODY_find_facesets_o_t");
top.note("headers/pk_body_find_facesets_o_t.html#documentation", " n_selecting_topol Indicates the <B>number</B> of elements in selecting_topol .", "PK Reference - PK_BODY_find_facesets_o_t");
top.note("headers/pk_body_find_facesets_r_t.html#declaration", " int n_selected_facesets; --- <B>number</B> of returned facesets", "PK Reference - PK_BODY_find_facesets_r_t");
top.note("headers/pk_body_find_facesets_r_t.html#documentation", " n_selected_facesets The <B>number</B> of returned facesets in the body,", "PK Reference - PK_BODY_find_facesets_r_t");
top.note("headers/pk_body_find_laminar_edges.html#declaration", " int *const n_components, --- <B>number</B> of components (>= 0)", "PK Reference - PK_BODY_find_laminar_edges");
top.note("headers/pk_body_find_laminar_edges.html#documentation", "but the <B>number</B> of components may be zero.", "PK Reference - PK_BODY_find_laminar_edges");
top.note("headers/pk_body_fix_blends.html#declaration", " int *const n_blends, --- <B>number</B> of blend faces", "PK Reference - PK_BODY_fix_blends");
top.note("headers/pk_body_fix_blends.html#documentation", "PK_BODY_fix_blends returns the <B>number</B> of created blend faces,", "PK Reference - PK_BODY_fix_blends");
top.note("headers/pk_body_fix_blends_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_BODY_fix_blends_o_t");
top.note("headers/pk_body_hollow.html#declaration", " int *const n_faces, --- <B>number</B> of faces", "PK Reference - PK_BODY_hollow");
top.note("headers/pk_body_hollow_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_BODY_hollow_o_t");
top.note("headers/pk_body_hollow_o_t.html#documentation", " n_local_faces <B>Number</B> of faces for local hollowing.", "PK Reference - PK_BODY_hollow_o_t");
top.note("headers/pk_body_identify_details.html#declaration", "int n_details, --- <B>number</B> of detail types", "PK Reference - PK_BODY_identify_details");
top.note("headers/pk_body_identify_details_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of opt struct", "PK Reference - PK_BODY_identify_details_o_t");
top.note("headers/pk_body_identify_facesets.html#declaration", "int n_edges, --- <B>number</B> of common", "PK Reference - PK_BODY_identify_facesets");
top.note("headers/pk_body_identify_facesets_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option struct", "PK Reference - PK_BODY_identify_facesets_o_t");
top.note("headers/pk_body_imprint_curve.html#declaration", " int *const n_new_edges, --- <B>number</B> of new edges", "PK Reference - PK_BODY_imprint_curve");
top.note("headers/pk_body_imprint_curve.html#documentation", "to NULL then only the <B>number</B> of new edges and/or faces will be returned.", "PK Reference - PK_BODY_imprint_curve");
top.note("headers/pk_body_imprint_curves_normal.html#declaration", "int n_curves, --- <B>number</B> of curves", "PK Reference - PK_BODY_imprint_curves_normal");
top.note("headers/pk_body_imprint_curves_vector.html#declaration", "int n_curves, --- <B>number</B> of curves", "PK Reference - PK_BODY_imprint_curves_vector");
top.note("headers/pk_body_imprint_cus_normal.html#declaration", "int n_curves, --- <B>number</B> of curves", "PK Reference - PK_BODY_imprint_cus_normal");
top.note("headers/pk_body_imprint_cus_normal_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_imprint_cus_normal_o_t");
top.note("headers/pk_body_imprint_cus_shadow.html#declaration", " const int n_bodies, --- <B>number</B> of bodies", "PK Reference - PK_BODY_imprint_cus_shadow");
top.note("headers/pk_body_imprint_cus_shadow_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_imprint_cus_shadow_o_t");
top.note("headers/pk_body_imprint_cus_vec.html#declaration", "int n_curves, --- <B>number</B> of curves", "PK Reference - PK_BODY_imprint_cus_vec");
top.note("headers/pk_body_imprint_cus_vec_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_imprint_cus_vec_o_t");
top.note("headers/pk_body_imprint_cus_vector.html#declaration", "int n_curves, --- <B>number</B> of curves", "PK Reference - PK_BODY_imprint_cus_vector");
top.note("headers/pk_body_imprint_cus_vector_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_BODY_imprint_cus_vector_o_t");
top.note("headers/pk_body_imprint_faces.html#declaration", "int n_faces, --- <B>number</B> of faces", "PK Reference - PK_BODY_imprint_faces");
top.note("headers/pk_body_imprint_faces_2.html#declaration", "int n_faces, --- <B>number</B> of tool faces", "PK Reference - PK_BODY_imprint_faces_2");
top.note("headers/pk_body_imprint_faces_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_BODY_imprint_faces_o_t");
top.note("headers/pk_body_imprint_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_BODY_imprint_o_t");
top.note("headers/pk_body_imprint_plane.html#declaration", " int *const n_edges, --- <B>number</B> of edges imprinted", "PK Reference - PK_BODY_imprint_plane");
top.note("headers/pk_body_imprint_plane_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_BODY_imprint_plane_o_t");
top.note("headers/pk_body_intersect_bodies.html#declaration", "int n_tools, --- <B>Number</B> of tool bodies", "PK Reference - PK_BODY_intersect_bodies");
top.note("headers/pk_body_is_cellular_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_BODY_is_cellular_o_t");
top.note("headers/pk_body_is_cellular_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of returns structure", "PK Reference - PK_BODY_is_cellular_r_t");
top.note("headers/pk_body_knit.html#declaration", "int n_topols, --- <B>number</B> of topols", "PK Reference - PK_BODY_knit");
top.note("headers/pk_body_knit.html#documentation", "This function joins a <B>number</B> of bodies together by fusing coincident topology.", "PK Reference - PK_BODY_knit");
top.note("headers/pk_body_knit_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_knit_o_t");
top.note("headers/pk_body_loft_face_clamp_t.html#declaration", " int n_faces; --- <B>number</B> of clamping faces and clamped", "PK Reference - PK_BODY_loft_face_clamp_t");
top.note("headers/pk_body_loft_face_clamp_t.html#documentation", " n_faces The <B>number</B> of faces held in the structure. This must", "PK Reference - PK_BODY_loft_face_clamp_t");
top.note("headers/pk_body_loft_vector_clamp_t.html#declaration", " int n_tangents; --- <B>number</B> of derivative vectors (0)", "PK Reference - PK_BODY_loft_vector_clamp_t");
top.note("headers/pk_body_loft_vector_clamp_t.html#documentation", " n_tangents The <B>number</B> of derivatives held in the structure. This must", "PK Reference - PK_BODY_loft_vector_clamp_t");
top.note("headers/pk_body_make_compound.html#declaration", " int n_bodies, --- <B>number</B> of bodies", "PK Reference - PK_BODY_make_compound");
top.note("headers/pk_body_make_compound_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_make_compound_o_t");
top.note("headers/pk_body_make_curves_outline.html#declaration", " const int n_bodies, --- <B>number</B> of bodies", "PK Reference - PK_BODY_make_curves_outline");
top.note("headers/pk_body_make_curves_outline_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_make_curves_outline_o_t");
top.note("headers/pk_body_make_lofted_body.html#declaration", " int n_profiles, --- <B>number</B> of profiles", "PK Reference - PK_BODY_make_lofted_body");
top.note("headers/pk_body_make_lofted_body.html#errors", " PK_ERROR_bad_value Incorrect <B>number</B> of profiles provided", "PK Reference - PK_BODY_make_lofted_body");
top.note("headers/pk_body_make_lofted_body.html#documentation", " <B>Number</B> of Profiles", "PK Reference - PK_BODY_make_lofted_body");
top.note("headers/pk_body_make_lofted_body_o_t.html#declaration", " --- version <B>number</B>", "PK Reference - PK_BODY_make_lofted_body_o_t");
top.note("headers/pk_body_make_lofted_body_o_t.html#documentation", " n_guide_wires The <B>number</B> of guide curves for the loft. (0)", "PK Reference - PK_BODY_make_lofted_body_o_t");
top.note("headers/pk_body_make_manifold_bodies.html#declaration", " int *const n_components, --- <B>number</B> of manifold bodies", "PK Reference - PK_BODY_make_manifold_bodies");
top.note("headers/pk_body_make_manifold_bodies.html#documentation", "upon whether the <B>number</B> of vertices was one or greater than one.", "PK Reference - PK_BODY_make_manifold_bodies");
top.note("headers/pk_body_make_patterned.html#documentation", "core body . The bounds determines the <B>number</B> of repetitions of the", "PK Reference - PK_BODY_make_patterned");
top.note("headers/pk_body_make_patterned_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_BODY_make_patterned_o_t");
top.note("headers/pk_body_make_patterned_o_t.html#errors", " specify a <B>number</B> of repetitions greater", "PK Reference - PK_BODY_make_patterned_o_t");
top.note("headers/pk_body_make_patterned_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of returns structure", "PK Reference - PK_BODY_make_patterned_r_t");
top.note("headers/pk_body_make_persp_outline.html#declaration", " const int n_bodies, --- <B>number</B> of bodies", "PK Reference - PK_BODY_make_persp_outline");
top.note("headers/pk_body_make_persp_outline_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_make_persp_outline_o_t");
top.note("headers/pk_body_make_persp_outline_r_t.html#documentation", " n_outlines The <B>number</B> of outlines.", "PK Reference - PK_BODY_make_persp_outline_r_t");
top.note("headers/pk_body_make_section.html#declaration", " int n_targets, --- <B>number</B> of target bodies", "PK Reference - PK_BODY_make_section");
top.note("headers/pk_body_make_section_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_make_section_o_t");
top.note("headers/pk_body_make_section_o_t.html#documentation", " n_offsets This specifies the <B>number</B> of entries in offsets .", "PK Reference - PK_BODY_make_section_o_t");
top.note("headers/pk_body_make_section_r_t.html#declaration", " int n_bodies; --- <B>number</B> of bodies", "PK Reference - PK_BODY_make_section_r_t");
top.note("headers/pk_body_make_section_r_t.html#documentation", " n_bodies The <B>number</B> of bodies in the bodies array.", "PK Reference - PK_BODY_make_section_r_t");
top.note("headers/pk_body_make_section_with_surfs.html#declaration", " int n_targets, --- <B>number</B> of target bodies", "PK Reference - PK_BODY_make_section_with_surfs");
top.note("headers/pk_body_make_spun_outline.html#declaration", " const int n_bodies, --- <B>number</B> of bodies", "PK Reference - PK_BODY_make_spun_outline");
top.note("headers/pk_body_make_spun_outline_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_make_spun_outline_o_t");
top.note("headers/pk_body_make_swept_body.html#documentation", " minimum <B>number</B> of faces possible. Profile edges which meet smoothly", "PK Reference - PK_BODY_make_swept_body");
top.note("headers/pk_body_make_swept_body_2.html#declaration", " int n_profiles, --- <B>number</B> of profiles", "PK Reference - PK_BODY_make_swept_body_2");
top.note("headers/pk_body_make_swept_body_2.html#documentation", " <B>Number</B> of Profiles", "PK Reference - PK_BODY_make_swept_body_2");
top.note("headers/pk_body_make_swept_body_2_o_t.html#declaration", " --- <B>number</B> of path vertices that may", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_2_o_t.html#errors", " path was incompatible with the <B>number</B> of", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_2_o_t.html#documentation", " n_ignorable_vertices The <B>number</B> of vertices that may be ignored, for the", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#declaration", " --- <B>number</B> of vertices that may be", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#documentation", " n_ignorable_vertices The <B>number</B> of vertices that may be ignored, for the", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_make_swept_tool_o_t.html#declaration", " int n_cap_faces; --- <B>number</B> of elements in", "PK Reference - PK_BODY_make_swept_tool_o_t");
top.note("headers/pk_body_make_swept_tool_o_t.html#documentation", " n_cap_faces The <B>number</B> of cap faces of the tool. (0)", "PK Reference - PK_BODY_make_swept_tool_o_t");
top.note("headers/pk_body_offset_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_BODY_offset_o_t");
top.note("headers/pk_body_offset_planar_wire.html#declaration", " int *const n_new_wires, --- <B>number</B> of new wires", "PK Reference - PK_BODY_offset_planar_wire");
top.note("headers/pk_body_offset_planar_wire_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_offset_planar_wire_o_t");
top.note("headers/pk_body_pick_topols.html#declaration", " const int n_bodies, --- <B>number</B> of bodies", "PK Reference - PK_BODY_pick_topols");
top.note("headers/pk_body_pick_topols_o_t.html#declaration", "--- option structure version <B>number</B>", "PK Reference - PK_BODY_pick_topols_o_t");
top.note("headers/pk_body_pick_topols_o_t.html#documentation", " - the maximum <B>number</B> of each type of entity which can be", "PK Reference - PK_BODY_pick_topols_o_t");
top.note("headers/pk_body_pick_topols_r_t.html#documentation", "The occurence field is a <B>number</B> in the range [0..n_bodies-1]. It identifies", "PK Reference - PK_BODY_pick_topols_r_t");
top.note("headers/pk_body_problem_group_t.html#documentation", " n_edges: The <B>number</B> of edges associated with the problem", "PK Reference - PK_BODY_problem_group_t");
top.note("headers/pk_body_remove_from_parents.html#declaration", " int n_children, --- <B>number</B> of children", "PK Reference - PK_BODY_remove_from_parents");
top.note("headers/pk_body_remove_from_parents_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_remove_from_parents_o_t");
top.note("headers/pk_body_repair_shells_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_repair_shells_o_t");
top.note("headers/pk_body_section_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_section_o_t");
top.note("headers/pk_body_set_type_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_BODY_set_type_o_t");
top.note("headers/pk_body_sew_bodies.html#declaration", " int n_bodies, --- <B>number</B> of bodies to sew", "PK Reference - PK_BODY_sew_bodies");
top.note("headers/pk_body_sew_bodies_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_BODY_sew_bodies_o_t");
top.note("headers/pk_body_sew_bodies_o_t.html#errors", " PK_ERROR_bad_iteration_count The requested <B>number</B> of iterations was", "PK Reference - PK_BODY_sew_bodies_o_t");
top.note("headers/pk_body_sew_bodies_o_t.html#documentation", " number_of_iterations: This specifies the <B>number</B> of gap width bound", "PK Reference - PK_BODY_sew_bodies_o_t");
top.note("headers/pk_body_share_geom.html#declaration", " int *const n_geoms --- <B>number</B> of geometries removed", "PK Reference - PK_BODY_share_geom");
top.note("headers/pk_body_simplify_geom.html#declaration", " int *const n_geoms, --- <B>number</B> of geoms returned", "PK Reference - PK_BODY_simplify_geom");
top.note("headers/pk_body_simplify_geom.html#documentation", "geometries deleted. The <B>number</B> of new geometric entities is returned in", "PK Reference - PK_BODY_simplify_geom");
top.note("headers/pk_body_spin.html#declaration", " int *const n_laterals, --- <B>number</B> of laterals", "PK Reference - PK_BODY_spin");
top.note("headers/pk_body_subtract_bodies.html#declaration", "int n_tools, --- <B>Number</B> of tool bodies", "PK Reference - PK_BODY_subtract_bodies");
top.note("headers/pk_body_sweep.html#declaration", " int *const n_laterals, --- <B>number</B> of laterals", "PK Reference - PK_BODY_sweep");
top.note("headers/pk_body_sweep_law_discrete_t.html#documentation", " n_vertices The <B>number</B> of vertices with specified law values", "PK Reference - PK_BODY_sweep_law_discrete_t");
top.note("headers/pk_body_sweep_status_2_r_t.html#documentation", " n_fault_entities The <B>number</B> of topological or geometric entities in", "PK Reference - PK_BODY_sweep_status_2_r_t");
top.note("headers/pk_body_sweep_tool_status_r_t.html#documentation", " n_faults The <B>number</B> of entries in the arrays faults ,", "PK Reference - PK_BODY_sweep_tool_status_r_t");
top.note("headers/pk_body_taper.html#declaration", "int n_refs_above, --- <B>number</B> of reference", "PK Reference - PK_BODY_taper");
top.note("headers/pk_body_taper.html#documentation", " PK_LOGICAL_true, then both sides must have the same <B>number</B> of", "PK Reference - PK_BODY_taper");
top.note("headers/pk_body_taper_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_BODY_taper_o_t");
top.note("headers/pk_body_taper_o_t.html#documentation", " n_methods <B>Number</B> of elements in methods and method_refs ", "PK Reference - PK_BODY_taper_o_t");
top.note("headers/pk_body_thicken.html#declaration", " int *const n_topols, --- <B>number</B> of topols", "PK Reference - PK_BODY_thicken");
top.note("headers/pk_body_thicken_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_BODY_thicken_o_t");
top.note("headers/pk_body_topology_t.html#documentation", " PK_BODY_topology_minimal_c Produce the minimum <B>number</B> of faces (default).", "PK Reference - PK_BODY_topology_t");
top.note("headers/pk_body_transform.html#declaration", " int *const n_replaces, --- <B>number</B> of geoms replaced", "PK Reference - PK_BODY_transform");
top.note("headers/pk_body_transform.html#documentation", " it is set to NULL then only the <B>number</B> of new", "PK Reference - PK_BODY_transform");
top.note("headers/pk_body_transform_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_BODY_transform_o_t");
top.note("headers/pk_body_trim.html#declaration", "int n_edges, --- <B>number</B> of edges", "PK Reference - PK_BODY_trim");
top.note("headers/pk_body_trim_gap_analysis.html#declaration", "int n_edges, --- <B>number</B> of edges", "PK Reference - PK_BODY_trim_gap_analysis");
top.note("headers/pk_body_trim_neutral_sheets.html#declaration", "int n_pairs, --- the <B>number</B> of pairs", "PK Reference - PK_BODY_trim_neutral_sheets");
top.note("headers/pk_body_trim_neutral_sheets_2.html#declaration", "int n_pairs, --- <B>number</B> of pairs", "PK Reference - PK_BODY_trim_neutral_sheets_2");
top.note("headers/pk_body_unite_bodies.html#declaration", "int n_tools, --- <B>Number</B> of tool bodies", "PK Reference - PK_BODY_unite_bodies");
top.note("headers/pk_body_vertex_match_t.html#documentation", " n_matches The <B>number</B> of matches held in the structure. This must", "PK Reference - PK_BODY_vertex_match_t");
top.note("headers/pk_body_vertex_matches_t.html#documentation", " n_mappings The <B>number</B> of mappings held in the structure. When", "PK Reference - PK_BODY_vertex_matches_t");
top.note("headers/pk_boolean_config_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_boolean_config_o_t");
top.note("headers/pk_boolean_match_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_boolean_match_o_t");
top.note("headers/pk_boolean_match_o_t.html#documentation", " n_match_regions The <B>number</B> of matched region structures supplied.", "PK Reference - PK_boolean_match_o_t");
top.note("headers/pk_boolean_match_region_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_boolean_match_region_o_t");
top.note("headers/pk_boolean_match_region_o_t.html#documentation", " two edges) which forms the intersection between a <B>number</B> of", "PK Reference - PK_boolean_match_region_o_t");
top.note("headers/pk_boolean_r_t.html#documentation", " n_reports The <B>number</B> of boolean reports in the reports array.", "PK Reference - PK_boolean_r_t");
top.note("headers/pk_boolean_region_select_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_boolean_region_select_o_t");
top.note("headers/pk_boolean_region_select_o_t.html#documentation", " n_region_selectors The <B>number</B> of topological entities supplied.", "PK Reference - PK_boolean_region_select_o_t");
top.note("headers/pk_boolean_select_topolset_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_boolean_select_topolset_o_t");
top.note("headers/pk_boolean_select_topolset_o_t.html#documentation", " n_selectors The <B>number</B> of selector topologies supplied.", "PK Reference - PK_boolean_select_topolset_o_t");
top.note("headers/pk_bsurf_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_BSURF_array_t");
top.note("headers/pk_bsurf_ask_knots.html#declaration", " int *const n_knots, --- <B>number</B> of knots", "PK Reference - PK_BSURF_ask_knots");
top.note("headers/pk_bsurf_create_constrained_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_BSURF_create_constrained_o_t");
top.note("headers/pk_bsurf_create_constrained_o_t.html#documentation", " n_positions The <B>number</B> of position constraints. (0)", "PK Reference - PK_BSURF_create_constrained_o_t");
top.note("headers/pk_bsurf_create_fitted_o_t.html#declaration", "int o_t_version; --- option structure version <B>number</B>", "PK Reference - PK_BSURF_create_fitted_o_t");
top.note("headers/pk_bsurf_create_fitted_o_t.html#documentation", " n_u_interpolation_parms the <B>number</B> of u_interpolation_parms supplied.", "PK Reference - PK_BSURF_create_fitted_o_t");
top.note("headers/pk_bsurf_find_g1_discontinuity.html#declaration", " int *const n_u_discs, --- <B>number</B> of U discontinuities", "PK Reference - PK_BSURF_find_g1_discontinuity");
top.note("headers/pk_bsurf_piecewise_sf_t.html#declaration", " int n_u_segments; --- The <B>number</B> of segments in u.", "PK Reference - PK_BSURF_piecewise_sf_t");
top.note("headers/pk_bsurf_piecewise_sf_t.html#documentation", " n_u_segments The <B>number</B> of segments in the surface in the u", "PK Reference - PK_BSURF_piecewise_sf_t");
top.note("headers/pk_bsurf_remove_knots.html#declaration", " int *const n_knots_removed, --- <B>number</B> of knots removed", "PK Reference - PK_BSURF_remove_knots");
top.note("headers/pk_bsurf_remove_knots.html#documentation", "The <B>number</B> of distinct knots removed, if any, is returned", "PK Reference - PK_BSURF_remove_knots");
top.note("headers/pk_bsurf_remove_knots_o_t.html#declaration", " int n_knot_indices; --- <B>number</B> of knot indices (0)", "PK Reference - PK_BSURF_remove_knots_o_t");
top.note("headers/pk_bsurf_remove_knots_o_t.html#documentation", " n_knot_indices The <B>number</B> of knot indices provided. If this is", "PK Reference - PK_BSURF_remove_knots_o_t");
top.note("headers/pk_bsurf_sf_t.html#declaration", " int n_u_vertices; --- The <B>number</B> of vertices in u.", "PK Reference - PK_BSURF_sf_t");
top.note("headers/pk_bsurf_sf_t.html#documentation", " <B>number</B> of important differences, designed to make its use", "PK Reference - PK_BSURF_sf_t");
top.note("headers/pk_bsurf_splinewise_sf_t.html#declaration", " int n_u_positions; --- The <B>number</B> of positions in u", "PK Reference - PK_BSURF_splinewise_sf_t");
top.note("headers/pk_bsurf_splinewise_sf_t.html#errors", " PK_ERROR_wrong_number_knots wrong <B>number</B> of knots (MILD)", "PK Reference - PK_BSURF_splinewise_sf_t");
top.note("headers/pk_bsurf_splinewise_sf_t.html#documentation", " n_u_positions <B>Number</B> of positions in the u direction.", "PK Reference - PK_BSURF_splinewise_sf_t");
top.note("headers/pk_change_edge_geom_data_t.html#declaration", " int n_edge_arrays; --- <B>number</B> of arrays of edges", "PK Reference - PK_change_edge_geom_data_t");
top.note("headers/pk_change_edge_geom_data_t.html#documentation", " n_edge_arrays <B>Number</B> of arrays of edges supplied. Length of", "PK Reference - PK_change_edge_geom_data_t");
top.note("headers/pk_check_fault_t.html#documentation", "| | | |where m is the <B>number</B> of |", "PK Reference - PK_check_fault_t");
top.note("headers/pk_check_state_t.html#documentation", " PK_BCURVE_state_knot_vx_count_c <B>number</B> of vertices < degree + 1", "PK Reference - PK_check_state_t");
top.note("headers/pk_circle_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_CIRCLE_array_t");
top.note("headers/pk_class_array_t.html#documentation", " length : the <B>number</B> of tokens in array ", "PK Reference - PK_CLASS_array_t");
top.note("headers/pk_clip_lattice_r_t.html#declaration", " int n_error_ltopols; --- <B>number</B> of error ltopols", "PK Reference - PK_clip_lattice_r_t");
top.note("headers/pk_comparison_t.html#documentation", "a <B>number</B> (d) whether the constraint is true or false.", "PK Reference - PK_comparison_t");
top.note("headers/pk_cone_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_CONE_array_t");
top.note("headers/pk_constrained_opt_t.html#documentation", " use a larger <B>number</B> of control points", "PK Reference - PK_constrained_opt_t");
top.note("headers/pk_curve_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_CURVE_array_t");
top.note("headers/pk_curve_ask_edges.html#declaration", " int *const n_edges, --- <B>number</B> of edges (>= 0)", "PK Reference - PK_CURVE_ask_edges");
top.note("headers/pk_curve_ask_edges.html#documentation", "will only compute the <B>number</B> of edges.", "PK Reference - PK_CURVE_ask_edges");
top.note("headers/pk_curve_ask_edges_nmnl.html#declaration", " int *const n_edges, --- <B>number</B> of edges (>= 0)", "PK Reference - PK_CURVE_ask_edges_nmnl");
top.note("headers/pk_curve_ask_edges_nmnl.html#documentation", "will only compute the <B>number</B> of edges.", "PK Reference - PK_CURVE_ask_edges_nmnl");
top.note("headers/pk_curve_degens_t.html#declaration", " int n_degen; --- <B>number</B> of degeneracies", "PK Reference - PK_CURVE_degens_t");
top.note("headers/pk_curve_degens_t.html#documentation", " n_degen The <B>number</B> of degeneracies on the curve.", "PK Reference - PK_CURVE_degens_t");
top.note("headers/pk_curve_embed_in_surf_o_t.html#documentation", " o_t_version Version <B>number</B> of option structure.", "PK Reference - PK_CURVE_embed_in_surf_o_t");
top.note("headers/pk_curve_eval.html#declaration", "int n_derivs, --- <B>number</B> of derivatives", "PK Reference - PK_CURVE_eval");
top.note("headers/pk_curve_eval.html#documentation", "The maximum <B>number</B> of derivatives that can be computed depends on", "PK Reference - PK_CURVE_eval");
top.note("headers/pk_curve_eval_handed.html#declaration", "int n_derivs, --- <B>number</B> of derivatives", "PK Reference - PK_CURVE_eval_handed");
top.note("headers/pk_curve_eval_with_tan_handed.html#declaration", "int n_derivs, --- <B>number</B> of derivatives", "PK Reference - PK_CURVE_eval_with_tan_handed");
top.note("headers/pk_curve_eval_with_tangent.html#declaration", "int n_derivs, --- <B>number</B> of derivatives", "PK Reference - PK_CURVE_eval_with_tangent");
top.note("headers/pk_curve_find_degens_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_CURVE_find_degens_o_t");
top.note("headers/pk_curve_find_discontinuity.html#declaration", " int *const n_params, --- <B>number</B> of discontinuities", "PK Reference - PK_CURVE_find_discontinuity");
top.note("headers/pk_curve_find_min_radius.html#declaration", " int *const n_radii, --- <B>number</B> of radii returned", "PK Reference - PK_CURVE_find_min_radius");
top.note("headers/pk_curve_find_self_int_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_CURVE_find_self_int_o_t");
top.note("headers/pk_curve_find_surfs_common.html#declaration", " int *const n_surfs, --- <B>number</B> of common surfaces", "PK Reference - PK_CURVE_find_surfs_common");
top.note("headers/pk_curve_find_vectors_o_t.html#declaration", " int n_measurements; --- <B>number</B> of measurements", "PK Reference - PK_CURVE_find_vectors_o_t");
top.note("headers/pk_curve_find_vectors_o_t.html#documentation", "The <B>number</B> of values supplied in measurements .", "PK Reference - PK_CURVE_find_vectors_o_t");
top.note("headers/pk_curve_fix_degens_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_CURVE_fix_degens_o_t");
top.note("headers/pk_curve_fix_degens_r_t.html#documentation", " n_curves The the <B>number</B> of resultant curves.", "PK Reference - PK_CURVE_fix_degens_r_t");
top.note("headers/pk_curve_fix_self_int_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_CURVE_fix_self_int_o_t");
top.note("headers/pk_curve_fix_self_int_r_t.html#documentation", " n_curves The <B>number</B> of resultant curves.", "PK Reference - PK_CURVE_fix_self_int_r_t");
top.note("headers/pk_curve_general_eval_f_t.html#declaration", "int n_deriv, --- <B>number</B> of derivatives requested", "PK Reference - PK_CURVE_general_eval_f_t");
top.note("headers/pk_curve_intersect_curve.html#declaration", " int *const n_vectors, --- <B>number</B> of intersections", "PK Reference - PK_CURVE_intersect_curve");
top.note("headers/pk_curve_intersect_curve_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_CURVE_intersect_curve_o_t");
top.note("headers/pk_curve_is_isoparam_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_CURVE_is_isoparam_o_t");
top.note("headers/pk_curve_make_approx.html#documentation", "Smaller values may cause excessive <B>number</B> of vertices on the resulting", "PK Reference - PK_CURVE_make_approx");
top.note("headers/pk_curve_make_approx_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_CURVE_make_approx_o_t");
top.note("headers/pk_curve_make_approx_o_t.html#documentation", " o_t_version Version <B>number</B> of option structure.", "PK Reference - PK_CURVE_make_approx_o_t");
top.note("headers/pk_curve_make_bcurve_array.html#declaration", " int n_curves, --- <B>number</B> of curves", "PK Reference - PK_CURVE_make_bcurve_array");
top.note("headers/pk_curve_make_helical_surf.html#documentation", "<B>number</B> of turns in both directions. The surface will", "PK Reference - PK_CURVE_make_helical_surf");
top.note("headers/pk_curve_make_spcurves.html#documentation", " <B>Number</B> of SP-curves produced", "PK Reference - PK_CURVE_make_spcurves");
top.note("headers/pk_curve_make_spcurves_2.html#declaration", " int *const n_spcurves, --- <B>number</B> of SP-curves produced", "PK Reference - PK_CURVE_make_spcurves_2");
top.note("headers/pk_curve_make_spcurves_2.html#documentation", " <B>Number</B> of SP-curves produced.", "PK Reference - PK_CURVE_make_spcurves_2");
top.note("headers/pk_curve_make_spcurves_o_t.html#documentation", " o_t_version Version <B>number</B> of option structure.", "PK Reference - PK_CURVE_make_spcurves_o_t");
top.note("headers/pk_curve_make_wire_body_2.html#declaration", " int n_curves, --- <B>number</B> of curves (ie,", "PK Reference - PK_CURVE_make_wire_body_2");
top.note("headers/pk_curve_make_wire_body_2.html#documentation", "The <B>number</B> of edges in the wire body is returned.", "PK Reference - PK_CURVE_make_wire_body_2");
top.note("headers/pk_curve_make_wire_body_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_CURVE_make_wire_body_o_t");
top.note("headers/pk_curve_make_wire_body_o_t.html#documentation", " o_t_version Version <B>number</B> of option structure.", "PK Reference - PK_CURVE_make_wire_body_o_t");
top.note("headers/pk_curve_output_vectors.html#declaration", " int *const n_vectors, --- <B>number</B> of position vectors", "PK Reference - PK_CURVE_output_vectors");
top.note("headers/pk_curve_project.html#declaration", " int n_curves, --- <B>number</B> of tool curves", "PK Reference - PK_CURVE_project");
top.note("headers/pk_curve_project_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_CURVE_project_o_t");
top.note("headers/pk_curve_project_r_t.html#documentation", " n_geoms The <B>number</B> of projected geometries (curves and points).", "PK Reference - PK_CURVE_project_r_t");
top.note("headers/pk_curve_self_int_t.html#documentation", " n_positions Indicates the <B>number</B> of positions returned. Currently this", "PK Reference - PK_CURVE_self_int_t");
top.note("headers/pk_curve_self_ints_t.html#declaration", " int n_self_int; --- <B>number</B> of self-intersections", "PK Reference - PK_CURVE_self_ints_t");
top.note("headers/pk_curve_self_ints_t.html#documentation", " n_self_int The <B>number</B> of self-intersections on the curve.", "PK Reference - PK_CURVE_self_ints_t");
top.note("headers/pk_cyl_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_CYL_array_t");
top.note("headers/pk_debug_behaviours_start_o_t.html#declaration", " int o_t_version; --- options structure version <B>number</B>", "PK Reference - PK_DEBUG_behaviours_start_o_t");
top.note("headers/pk_debug_body_compare_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_DEBUG_BODY_compare_o_t");
top.note("headers/pk_debug_body_compare_o_t.html#documentation", " the <B>number</B> of vertices/edges or faces in the body.", "PK Reference - PK_DEBUG_BODY_compare_o_t");
top.note("headers/pk_debug_body_compare_r_t.html#documentation", " n_global_diffs <B>Number</B> of global difference structures returned", "PK Reference - PK_DEBUG_BODY_compare_r_t");
top.note("headers/pk_debug_check_fault_t.html#documentation", "<B>number</B> of associated items stored in item_array . The", "PK Reference - PK_DEBUG_check_fault_t");
top.note("headers/pk_debug_global_diffs_r_t.html#documentation", " n_masters <B>Number</B> of entities of the type defined in diff ", "PK Reference - PK_DEBUG_global_diffs_r_t");
top.note("headers/pk_debug_report_start_o_t.html#declaration", " int o_t_version; --- options structure version <B>number</B>", "PK Reference - PK_DEBUG_report_start_o_t");
top.note("headers/pk_debug_session_check.html#declaration", " int *const n_faults, --- <B>number</B> of faults", "PK Reference - PK_DEBUG_SESSION_check");
top.note("headers/pk_debug_session_check_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_DEBUG_SESSION_check_o_t");
top.note("headers/pk_debug_session_check_o_t.html#documentation", " caller may set an upper limit on the <B>number</B>", "PK Reference - PK_DEBUG_SESSION_check_o_t");
top.note("headers/pk_debug_session_watch_fns.html#declaration", " int n_fns, --- <B>number</B> of functions", "PK Reference - PK_DEBUG_SESSION_watch_fns");
top.note("headers/pk_debug_session_watch_fns.html#documentation", "entry and an exit callback function. If the <B>number</B> of functions to", "PK Reference - PK_DEBUG_SESSION_watch_fns");
top.note("headers/pk_debug_shuffle_start_o_t.html#declaration", " int o_t_version; --- options structure version <B>number</B>", "PK Reference - PK_DEBUG_shuffle_start_o_t");
top.note("headers/pk_debug_transmit.html#documentation", "If only geometry is to be saved, any <B>number</B> or type can be specified", "PK Reference - PK_DEBUG_transmit");
top.note("headers/pk_debug_try_error_handler_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_DEBUG_try_error_handler_o_t");
top.note("headers/pk_debug_try_smp_t.html#documentation", " Parasolid. The <B>number</B> of these threads depends", "PK Reference - PK_DEBUG_try_smp_t");
top.note("headers/pk_detail_def_hole_t.html#declaration", " int n_components; --- <B>number</B> of hole components", "PK Reference - PK_detail_def_hole_t");
top.note("headers/pk_detail_def_hole_t.html#documentation", " n_components <B>number</B> of hole components in the hole.", "PK Reference - PK_detail_def_hole_t");
top.note("headers/pk_detail_hole_cb_f_t.html#declaration", " int n_faces, --- <B>number</B> of faces in hole detail", "PK Reference - PK_detail_hole_cb_f_t");
top.note("headers/pk_double_array_t.html#documentation", " length the <B>number</B> of doubles in array ", "PK Reference - PK_double_array_t");
top.note("headers/pk_edge_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_EDGE_array_t");
top.note("headers/pk_edge_ask_convexity_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_EDGE_ask_convexity_o_t");
top.note("headers/pk_edge_ask_faces.html#declaration", " int *const n_faces, --- <B>number</B> of faces (>= 0)", "PK Reference - PK_EDGE_ask_faces");
top.note("headers/pk_edge_ask_faces.html#documentation", "will only compute the <B>number</B> of faces which contain the edge.", "PK Reference - PK_EDGE_ask_faces");
top.note("headers/pk_edge_ask_fins.html#declaration", " int *const n_fins, --- <B>number</B> of fins (>= 0)", "PK Reference - PK_EDGE_ask_fins");
top.note("headers/pk_edge_ask_fins.html#documentation", "will only compute the <B>number</B> of fins around the edge.", "PK Reference - PK_EDGE_ask_fins");
top.note("headers/pk_edge_ask_shells.html#declaration", " int *const n_shells, --- <B>number</B> of shells (>= 1)", "PK Reference - PK_EDGE_ask_shells");
top.note("headers/pk_edge_ask_shells.html#documentation", "will only compute the <B>number</B> of shells containing the edge.", "PK Reference - PK_EDGE_ask_shells");
top.note("headers/pk_edge_ask_type_t.html#declaration", " PK_EDGE_fins_type_t fins_type; --- <B>number</B> of fins on edge", "PK Reference - PK_EDGE_ask_type_t");
top.note("headers/pk_edge_attach_curve_nmnl_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_EDGE_attach_curve_nmnl_o_t");
top.note("headers/pk_edge_attach_curves.html#declaration", " int n_edges, --- <B>number</B> of edges", "PK Reference - PK_EDGE_attach_curves");
top.note("headers/pk_edge_attach_curves_2.html#declaration", " int n_edges, --- <B>number</B> of edges", "PK Reference - PK_EDGE_attach_curves_2");
top.note("headers/pk_edge_attach_curves_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_EDGE_attach_curves_o_t");
top.note("headers/pk_edge_attach_curves_o_t.html#documentation", " n_intervals The <B>number</B> of curve intervals being supplied through the", "PK Reference - PK_EDGE_attach_curves_o_t");
top.note("headers/pk_edge_check.html#declaration", " int *const n_faults, --- <B>number</B> of faults", "PK Reference - PK_EDGE_check");
top.note("headers/pk_edge_check.html#documentation", " maximum <B>number</B> of faults to be returned and whether to", "PK Reference - PK_EDGE_check");
top.note("headers/pk_edge_check_blends.html#declaration", " int n_edges, --- <B>number</B> of edges", "PK Reference - PK_EDGE_check_blends");
top.note("headers/pk_edge_check_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_EDGE_check_o_t");
top.note("headers/pk_edge_delete.html#declaration", " int n_edges, --- <B>number</B> of edges", "PK Reference - PK_EDGE_delete");
top.note("headers/pk_edge_delete_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_EDGE_delete_o_t");
top.note("headers/pk_edge_delete_wireframe.html#declaration", " int n_edges, --- <B>number</B> of edges", "PK Reference - PK_EDGE_delete_wireframe");
top.note("headers/pk_edge_find_blend_topol.html#declaration", " int *const n_edges, --- <B>number</B> of affected edges", "PK Reference - PK_EDGE_find_blend_topol");
top.note("headers/pk_edge_find_deviation.html#declaration", " int *const n_distances, --- <B>number</B> of distances returned", "PK Reference - PK_EDGE_find_deviation");
top.note("headers/pk_edge_find_deviation.html#documentation", "chosen. For each extended region a <B>number</B> of locations on the more complicated", "PK Reference - PK_EDGE_find_deviation");
top.note("headers/pk_edge_find_deviation_o_t.html#declaration", " int o_t_version; --- Version <B>number</B> of option", "PK Reference - PK_EDGE_find_deviation_o_t");
top.note("headers/pk_edge_find_deviation_o_t.html#documentation", " Controls the maximum <B>number</B> of samples returned by", "PK Reference - PK_EDGE_find_deviation_o_t");
top.note("headers/pk_edge_find_deviation_r_t.html#declaration", " int n_regions; --- <B>number</B> of regions", "PK Reference - PK_EDGE_find_deviation_r_t");
top.note("headers/pk_edge_find_deviation_r_t.html#documentation", " n_regions The <B>number</B> of overlap regions.", "PK Reference - PK_EDGE_find_deviation_r_t");
top.note("headers/pk_edge_find_deviation_t.html#declaration", " int n_distances; --- <B>number</B> of distances returned", "PK Reference - PK_EDGE_find_deviation_t");
top.note("headers/pk_edge_find_deviation_t.html#documentation", " n_distances The <B>number</B> of samples returned for this region.", "PK Reference - PK_EDGE_find_deviation_t");
top.note("headers/pk_edge_find_extreme.html#description", "are used successively to reduce the <B>number</B> of extreme points to one.", "PK Reference - PK_EDGE_find_extreme");
top.note("headers/pk_edge_find_g1_edges.html#declaration", " int *const n_edges, --- <B>number</B> of edges (>= 1)", "PK Reference - PK_EDGE_find_g1_edges");
top.note("headers/pk_edge_make_curve.html#declaration", "int n_edges, --- <B>number</B> of edges", "PK Reference - PK_EDGE_make_curve");
top.note("headers/pk_edge_make_faces_from_wire.html#declaration", " int n_edges, --- <B>number</B> of edges", "PK Reference - PK_EDGE_make_faces_from_wire");
top.note("headers/pk_edge_make_wire_body.html#declaration", " int n_edges, --- <B>number</B> of edges", "PK Reference - PK_EDGE_make_wire_body");
top.note("headers/pk_edge_make_wire_body_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_EDGE_make_wire_body_o_t");
top.note("headers/pk_edge_make_wire_body_o_t.html#documentation", " o_t_version Version <B>number</B> of option structure.", "PK Reference - PK_EDGE_make_wire_body_o_t");
top.note("headers/pk_edge_offset_on_body.html#declaration", " int n_edges, --- <B>number</B> of edges", "PK Reference - PK_EDGE_offset_on_body");
top.note("headers/pk_edge_offset_on_body_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_EDGE_offset_on_body_o_t");
top.note("headers/pk_edge_offset_on_body_r_t.html#declaration", " int n_fault_entities; --- <B>number</B> of entities", "PK Reference - PK_EDGE_offset_on_body_r_t");
top.note("headers/pk_edge_offset_on_body_r_t.html#documentation", " n_fault_entities The <B>number</B> of fault entities returned.", "PK Reference - PK_EDGE_offset_on_body_r_t");
top.note("headers/pk_edge_optimise_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_EDGE_optimise_o_t");
top.note("headers/pk_edge_remove_to_bodies_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_EDGE_remove_to_bodies_o_t");
top.note("headers/pk_edge_repair.html#declaration", " int n_edges, --- <B>number</B> of edges (may be zero)", "PK Reference - PK_EDGE_repair");
top.note("headers/pk_edge_repair_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_EDGE_repair_o_t");
top.note("headers/pk_edge_reset_precision_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_EDGE_reset_precision_o_t");
top.note("headers/pk_edge_reverse_2.html#declaration", " int n_edges, --- <B>number</B> of edges", "PK Reference - PK_EDGE_reverse_2");
top.note("headers/pk_edge_reverse_2_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_EDGE_reverse_2_o_t");
top.note("headers/pk_edge_set_blend_chain_o_t.html#declaration", " int n_positions; --- <B>number</B> of given positions (0)", "PK Reference - PK_EDGE_set_blend_chain_o_t");
top.note("headers/pk_edge_set_blend_chain_o_t.html#documentation", " The <B>number</B> of positions at which to specify numerical blend", "PK Reference - PK_EDGE_set_blend_chain_o_t");
top.note("headers/pk_edge_set_blend_chamfer.html#declaration", " int *const n_blend_edges, --- <B>number</B> of edges with", "PK Reference - PK_EDGE_set_blend_chamfer");
top.note("headers/pk_edge_set_blend_chamfer_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_EDGE_set_blend_chamfer_o_t");
top.note("headers/pk_edge_set_blend_constant.html#declaration", " int *const n_blend_edges, --- <B>number</B> of edges with", "PK Reference - PK_EDGE_set_blend_constant");
top.note("headers/pk_edge_set_blend_constant_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_EDGE_set_blend_constant_o_t");
top.note("headers/pk_edge_set_blend_variable.html#declaration", " int *const n_blend_edges, --- <B>number</B> of edges with", "PK Reference - PK_EDGE_set_blend_variable");
top.note("headers/pk_edge_set_blend_variable_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_EDGE_set_blend_variable_o_t");
top.note("headers/pk_edge_set_precision.html#declaration", " int *const n_new_edges, --- <B>number</B> of new edges", "PK Reference - PK_EDGE_set_precision");
top.note("headers/pk_edge_set_precision.html#documentation", " be split a <B>number</B> of times, once for every surface singularity or", "PK Reference - PK_EDGE_set_precision");
top.note("headers/pk_edge_set_precision_2.html#declaration", " int *const n_new_edges, --- <B>number</B> of new edges", "PK Reference - PK_EDGE_set_precision_2");
top.note("headers/pk_edge_set_precision_2.html#documentation", " be split a <B>number</B> of times, once for every surface singularity or", "PK Reference - PK_EDGE_set_precision_2");
top.note("headers/pk_ellipse_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_ELLIPSE_array_t");
top.note("headers/pk_emboss_sidewall_data_t.html#declaration", " --- <B>number</B> of edges of profile", "PK Reference - PK_emboss_sidewall_data_t");
top.note("headers/pk_emboss_sidewall_data_t.html#documentation", " n_multi_taper_edges <B>number</B> of edges of profile body which will use", "PK Reference - PK_emboss_sidewall_data_t");
top.note("headers/pk_entity_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_ENTITY_array_t");
top.note("headers/pk_entity_ask_attribs.html#declaration", " int *const n_attribs, --- <B>number</B> of attributes (>=0)", "PK Reference - PK_ENTITY_ask_attribs");
top.note("headers/pk_entity_ask_attribs.html#documentation", "will only return the <B>number</B> of such attributes attached to the entity.", "PK Reference - PK_ENTITY_ask_attribs");
top.note("headers/pk_entity_ask_description_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_ENTITY_ask_description_o_t");
top.note("headers/pk_entity_ask_owning_groups.html#declaration", " int *const n_groups, --- <B>number</B> of groups (>=0)", "PK Reference - PK_ENTITY_ask_owning_groups");
top.note("headers/pk_entity_ask_owning_groups.html#documentation", "will only compute the <B>number</B> of groups of which the entity is a", "PK Reference - PK_ENTITY_ask_owning_groups");
top.note("headers/pk_entity_ask_owning_groups_2.html#declaration", " int *const n_groups, --- <B>number</B> of groups (>=0)", "PK Reference - PK_ENTITY_ask_owning_groups_2");
top.note("headers/pk_entity_ask_owning_groups_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_ENTITY_ask_owning_groups_o_t");
top.note("headers/pk_entity_ask_owning_groups_o_t.html#documentation", " want_groups n_groups , the <B>number</B> of groups satisfying the", "PK Reference - PK_ENTITY_ask_owning_groups_o_t");
top.note("headers/pk_entity_ask_user_field.html#documentation", "The <B>number</B> of integers returned is that set by the", "PK Reference - PK_ENTITY_ask_user_field");
top.note("headers/pk_entity_check_attribs.html#declaration", " int *const n_faults, --- <B>number</B> of bad attributes", "PK Reference - PK_ENTITY_check_attribs");
top.note("headers/pk_entity_check_attribs.html#documentation", "set to the <B>number</B> of attribute faults found.", "PK Reference - PK_ENTITY_check_attribs");
top.note("headers/pk_entity_check_attribs_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_ENTITY_check_attribs_o_t");
top.note("headers/pk_entity_check_attribs_o_t.html#documentation", " return array, or only the <B>number</B> of such faults.", "PK Reference - PK_ENTITY_check_attribs_o_t");
top.note("headers/pk_entity_copy_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_ENTITY_copy_o_t");
top.note("headers/pk_entity_delete.html#declaration", " int n_entities, --- <B>number</B> of entities to be deleted", "PK Reference - PK_ENTITY_delete");
top.note("headers/pk_entity_delete_attribs.html#declaration", " int *const n_deleted --- <B>number</B> of attributes deleted (>=0)", "PK Reference - PK_ENTITY_delete_attribs");
top.note("headers/pk_entity_delete_attribs.html#documentation", "The function returns the <B>number</B> of such attributes deleted.", "PK Reference - PK_ENTITY_delete_attribs");
top.note("headers/pk_entity_find_reparam_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_ENTITY_find_reparam_o_t");
top.note("headers/pk_entity_find_reparam_r_t.html#documentation", "n_records The <B>number</B> of records describing a preferred", "PK Reference - PK_ENTITY_find_reparam_r_t");
top.note("headers/pk_entity_range_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_ENTITY_range_o_t");
top.note("headers/pk_entity_range_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_ENTITY_range_r_t");
top.note("headers/pk_entity_range_vector.html#declaration", " int n_entities, --- <B>number</B> of entities", "PK Reference - PK_ENTITY_range_vector");
top.note("headers/pk_entity_range_vector.html#documentation", " (1) The <B>number</B> of positions is one:", "PK Reference - PK_ENTITY_range_vector");
top.note("headers/pk_entity_range_vector_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option struct", "PK Reference - PK_ENTITY_range_vector_o_t");
top.note("headers/pk_entity_range_vector_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_ENTITY_range_vector_r_t");
top.note("headers/pk_error_sf_t.html#declaration", " int argument_number; --- <B>number</B> of invalid argument or 0", "PK Reference - PK_ERROR_sf_t");
top.note("headers/pk_expr_sf_t.html#declaration", " int n_sub_exprs; --- <B>number</B> of sub-expressions (0)", "PK Reference - PK_EXPR_sf_t");
top.note("headers/pk_expr_sf_t.html#documentation", " n_sub_exprs The <B>number</B> of sub-expressions.", "PK Reference - PK_EXPR_sf_t");
top.note("headers/pk_extend_side_data_t.html#declaration", " int n_vertices; --- <B>number</B> of vertices", "PK Reference - PK_extend_side_data_t");
top.note("headers/pk_face_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_FACE_array_t");
top.note("headers/pk_face_ask_edges.html#declaration", " int *const n_edges, --- <B>number</B> of edges (>= 0)", "PK Reference - PK_FACE_ask_edges");
top.note("headers/pk_face_ask_edges.html#documentation", "will only compute the <B>number</B> of edges in the face.", "PK Reference - PK_FACE_ask_edges");
top.note("headers/pk_face_ask_faces_adjacent.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_ask_faces_adjacent");
top.note("headers/pk_face_ask_faces_adjacent_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of", "PK Reference - PK_FACE_ask_faces_adjacent_o_t");
top.note("headers/pk_face_ask_loops.html#declaration", " int *const n_loops, --- <B>number</B> of loops (>= 0)", "PK Reference - PK_FACE_ask_loops");
top.note("headers/pk_face_ask_loops.html#documentation", "will only compute the <B>number</B> of loops bounding the face.", "PK Reference - PK_FACE_ask_loops");
top.note("headers/pk_face_ask_type_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_FACE_ask_type_o_t");
top.note("headers/pk_face_ask_type_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of returns", "PK Reference - PK_FACE_ask_type_r_t");
top.note("headers/pk_face_ask_vertices.html#declaration", " int *const n_vertices, --- <B>number</B> of vertices (>= 0)", "PK Reference - PK_FACE_ask_vertices");
top.note("headers/pk_face_ask_vertices.html#documentation", "will only compute the <B>number</B> of vertices in the face.", "PK Reference - PK_FACE_ask_vertices");
top.note("headers/pk_face_attach_surfs.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_attach_surfs");
top.note("headers/pk_face_boolean.html#declaration", " int n_targets, --- <B>number</B> of target faces", "PK Reference - PK_FACE_boolean");
top.note("headers/pk_face_boolean_2.html#declaration", " int n_targets, --- <B>number</B> of target faces", "PK Reference - PK_FACE_boolean_2");
top.note("headers/pk_face_boolean_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_FACE_boolean_o_t");
top.note("headers/pk_face_change.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_change");
top.note("headers/pk_face_change_bend_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_change_bend_o_t");
top.note("headers/pk_face_change_blend_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_FACE_change_blend_o_t");
top.note("headers/pk_face_change_blend_o_t.html#errors", " PK_ERROR_wrong_number_entities (MILD) Wrong <B>number</B> of n_unders ", "PK Reference - PK_FACE_change_blend_o_t");
top.note("headers/pk_face_change_blend_o_t.html#documentation", " n_unders The <B>number</B> of underlying faces of the blend that are", "PK Reference - PK_FACE_change_blend_o_t");
top.note("headers/pk_face_change_data_taper_t.html#declaration", " int n_refs; --- <B>number</B> of reference entities", "PK Reference - PK_FACE_change_data_taper_t");
top.note("headers/pk_face_change_data_taper_t.html#documentation", " n_refs must be either one, or the <B>number</B> of faces", "PK Reference - PK_FACE_change_data_taper_t");
top.note("headers/pk_face_change_deform_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_change_deform_o_t");
top.note("headers/pk_face_change_deform_o_t.html#documentation", " n_matched_edges The <B>number</B> of matched edges.", "PK Reference - PK_FACE_change_deform_o_t");
top.note("headers/pk_face_change_o_t.html#declaration", " --- version <B>number</B> of option", "PK Reference - PK_FACE_change_o_t");
top.note("headers/pk_face_change_patch_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_change_patch_o_t");
top.note("headers/pk_face_change_radiate_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_change_radiate_o_t");
top.note("headers/pk_face_change_replace_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_change_replace_o_t");
top.note("headers/pk_face_change_taper_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_FACE_change_taper_o_t");
top.note("headers/pk_face_change_taper_o_t.html#documentation", " n_parting_edges <B>Number</B> of parting edges.", "PK Reference - PK_FACE_change_taper_o_t");
top.note("headers/pk_face_change_transform_o_t.html#declaration", " int n_loops; --- <B>number</B> of boundary loops of the", "PK Reference - PK_FACE_change_transform_o_t");
top.note("headers/pk_face_change_transform_o_t.html#documentation", " n_loops The <B>number</B> of boundary loops of the faces being", "PK Reference - PK_FACE_change_transform_o_t");
top.note("headers/pk_face_check.html#declaration", " int *const n_faults, --- <B>number</B> of faults", "PK Reference - PK_FACE_check");
top.note("headers/pk_face_check.html#documentation", " maximum <B>number</B> of faults to be returned and whether to", "PK Reference - PK_FACE_check");
top.note("headers/pk_face_check_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_check_o_t");
top.note("headers/pk_face_check_pair.html#declaration", " int *const n_faults, --- <B>number</B> of faults", "PK Reference - PK_FACE_check_pair");
top.note("headers/pk_face_check_pair.html#documentation", " maximum <B>number</B> of faults to be returned and whether to", "PK Reference - PK_FACE_check_pair");
top.note("headers/pk_face_check_pair_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_check_pair_o_t");
top.note("headers/pk_face_classify_details.html#declaration", " int n_facesets, --- <B>number</B> of facesets", "PK Reference - PK_FACE_classify_details");
top.note("headers/pk_face_classify_details_o_t.html#declaration", " --- <B>number</B>", "PK Reference - PK_FACE_classify_details_o_t");
top.note("headers/pk_face_classify_details_r_t.html#declaration", " int n_detail_defs; --- <B>number</B> of detail definitions", "PK Reference - PK_FACE_classify_details_r_t");
top.note("headers/pk_face_classify_details_r_t.html#documentation", " n_detail_defs <B>number</B> of detail definitions", "PK Reference - PK_FACE_classify_details_r_t");
top.note("headers/pk_face_close_gaps.html#declaration", " int *const n_vertices, --- <B>number</B> of vertices where gaps", "PK Reference - PK_FACE_close_gaps");
top.note("headers/pk_face_contains_vectors_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_FACE_contains_vectors_o_t");
top.note("headers/pk_face_contains_vectors_o_t.html#documentation", "the same position, and the <B>number</B> of elements in each array must be the", "PK Reference - PK_FACE_contains_vectors_o_t");
top.note("headers/pk_face_cover.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_cover");
top.note("headers/pk_face_cover_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_FACE_cover_o_t");
top.note("headers/pk_face_delete.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_delete");
top.note("headers/pk_face_delete_2.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_delete_2");
top.note("headers/pk_face_delete_blends.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_delete_blends");
top.note("headers/pk_face_delete_blends_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_delete_blends_o_t");
top.note("headers/pk_face_delete_facesets.html#declaration", " int n_facesets, --- <B>number</B> of facesets", "PK Reference - PK_FACE_delete_facesets");
top.note("headers/pk_face_delete_facesets_o_t.html#declaration", " int o_t_version; --- options structure version <B>number</B>", "PK Reference - PK_FACE_delete_facesets_o_t");
top.note("headers/pk_face_delete_facesets_o_t.html#documentation", " n_details <B>number</B> of details in the following array. Setting this", "PK Reference - PK_FACE_delete_facesets_o_t");
top.note("headers/pk_face_delete_from_gen_body.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_delete_from_gen_body");
top.note("headers/pk_face_delete_from_sheet.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_delete_from_sheet");
top.note("headers/pk_face_delete_from_sheet_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_delete_from_sheet_o_t");
top.note("headers/pk_face_delete_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_delete_o_t");
top.note("headers/pk_face_details_hole_o_t.html#declaration", " int o_t_version; --- options structure version <B>number</B>", "PK Reference - PK_FACE_details_hole_o_t");
top.note("headers/pk_face_emboss.html#declaration", " int n_faces, --- <B>number</B> of target faces > 0", "PK Reference - PK_FACE_emboss");
top.note("headers/pk_face_emboss_o_t.html#declaration", " int o_t_version;--- version <B>number</B> of options", "PK Reference - PK_FACE_emboss_o_t");
top.note("headers/pk_face_euler_unslit.html#errors", " PK_ERROR_invalid_face wrong <B>number</B> of loops or edges on face ", "PK Reference - PK_FACE_euler_unslit");
top.note("headers/pk_face_find_blend_unders_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_FACE_find_blend_unders_o_t");
top.note("headers/pk_face_find_blend_unders_r_t.html#declaration", " int n_unders; --- <B>number</B> of underlying", "PK Reference - PK_FACE_find_blend_unders_r_t");
top.note("headers/pk_face_find_blend_unders_r_t.html#documentation", " n_unders The <B>number</B> of underlying facesets found.", "PK Reference - PK_FACE_find_blend_unders_r_t");
top.note("headers/pk_face_find_edges_common.html#declaration", " int *const n_edges, --- <B>number</B> of common edges", "PK Reference - PK_FACE_find_edges_common");
top.note("headers/pk_face_find_extreme.html#description", "are used successively to reduce the <B>number</B> of extreme points to one.", "PK Reference - PK_FACE_find_extreme");
top.note("headers/pk_face_find_interior_vec_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_find_interior_vec_o_t");
top.note("headers/pk_face_find_outer_loop_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_FACE_find_outer_loop_o_t");
top.note("headers/pk_face_fix_mesh_defects.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_fix_mesh_defects");
top.note("headers/pk_face_fix_mesh_defects_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_fix_mesh_defects_o_t");
top.note("headers/pk_face_fix_mesh_defects_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return", "PK Reference - PK_FACE_fix_mesh_defects_r_t");
top.note("headers/pk_face_grow_cb_f_t.html#declaration", " int n_faces1, --- <B>number</B> of faces1", "PK Reference - PK_FACE_grow_cb_f_t");
top.note("headers/pk_face_hollow.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_hollow");
top.note("headers/pk_face_hollow_2.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_hollow_2");
top.note("headers/pk_face_hollow_3.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_hollow_3");
top.note("headers/pk_face_hollow_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_hollow_o_t");
top.note("headers/pk_face_identify_blends.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_identify_blends");
top.note("headers/pk_face_identify_blends_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_FACE_identify_blends_o_t");
top.note("headers/pk_face_identify_blends_r_t.html#declaration", " int n_blend_facesets; --- <B>number</B> of blend facesets", "PK Reference - PK_FACE_identify_blends_r_t");
top.note("headers/pk_face_identify_blends_r_t.html#documentation", " n_blend_facesets The <B>number</B> of blend facesets found.", "PK Reference - PK_FACE_identify_blends_r_t");
top.note("headers/pk_face_imprint_curve.html#declaration", " int *const n_new_edges, --- <B>number</B> of new edges", "PK Reference - PK_FACE_imprint_curve");
top.note("headers/pk_face_imprint_curve.html#documentation", "in new_edges , and the <B>number</B> of them in n_new_edges . The new edges", "PK Reference - PK_FACE_imprint_curve");
top.note("headers/pk_face_imprint_curves_2.html#declaration", "int n_curves, --- <B>number</B> of curves", "PK Reference - PK_FACE_imprint_curves_2");
top.note("headers/pk_face_imprint_curves_2.html#errors", " PK_ERROR_not_in_same_partition (MILD) face and a <B>number</B> of curves ", "PK Reference - PK_FACE_imprint_curves_2");
top.note("headers/pk_face_imprint_curves_isocline.html#declaration", " int n_rec_faces, --- <B>number</B> of received faces (>0)", "PK Reference - PK_FACE_imprint_curves_isocline");
top.note("headers/pk_face_imprint_curves_isocline.html#documentation", "will only output the <B>number</B> of resulting faces. The output array is_steep is", "PK Reference - PK_FACE_imprint_curves_isocline");
top.note("headers/pk_face_imprint_curves_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_FACE_imprint_curves_o_t");
top.note("headers/pk_face_imprint_cus_isoclin.html#declaration", " int n_rec_faces,--- <B>number</B> of received faces", "PK Reference - PK_FACE_imprint_cus_isoclin");
top.note("headers/pk_face_imprint_cus_isoclin_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_imprint_cus_isoclin_o_t");
top.note("headers/pk_face_imprint_cus_normal.html#declaration", " int n_targets, --- <B>number</B> of faces", "PK Reference - PK_FACE_imprint_cus_normal");
top.note("headers/pk_face_imprint_cus_normal_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_FACE_imprint_cus_normal_o_t");
top.note("headers/pk_face_imprint_cus_vec.html#declaration", " int n_targets, --- <B>number</B> of faces", "PK Reference - PK_FACE_imprint_cus_vec");
top.note("headers/pk_face_imprint_cus_vec_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_FACE_imprint_cus_vec_o_t");
top.note("headers/pk_face_imprint_cus_vector.html#declaration", " int n_targets, --- <B>number</B> of faces", "PK Reference - PK_FACE_imprint_cus_vector");
top.note("headers/pk_face_imprint_cus_vector_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_imprint_cus_vector_o_t");
top.note("headers/pk_face_imprint_faces.html#declaration", " int n_targets, --- <B>number</B> of target faces", "PK Reference - PK_FACE_imprint_faces");
top.note("headers/pk_face_imprint_faces_2.html#declaration", " int n_targets, --- <B>number</B> of target faces", "PK Reference - PK_FACE_imprint_faces_2");
top.note("headers/pk_face_imprint_faces_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_imprint_faces_o_t");
top.note("headers/pk_face_imprint_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_imprint_o_t");
top.note("headers/pk_face_inst_tools_r_t.html#documentation", " n_instances The <B>number</B> of instanced tools which appear in the resultant", "PK Reference - PK_FACE_inst_tools_r_t");
top.note("headers/pk_face_install_surfs_isocline.html#declaration", " int n_faces, --- <B>number</B> of target faces (>0)", "PK Reference - PK_FACE_install_surfs_isocline");
top.note("headers/pk_face_instance_bodies.html#declaration", " int n_target_faces, --- <B>number</B> of target faces", "PK Reference - PK_FACE_instance_bodies");
top.note("headers/pk_face_instance_bodies_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_FACE_instance_bodies_o_t");
top.note("headers/pk_face_instance_tools.html#declaration", " int n_target_faces, --- <B>number</B> of target faces (>0)", "PK Reference - PK_FACE_instance_tools");
top.note("headers/pk_face_intersect_curve.html#declaration", " int *const n_vectors, --- <B>number</B> of intersections", "PK Reference - PK_FACE_intersect_curve");
top.note("headers/pk_face_intersect_face.html#declaration", " int *const n_vectors, --- <B>number</B> of point intersections", "PK Reference - PK_FACE_intersect_face");
top.note("headers/pk_face_intersect_face.html#documentation", " make point contact. n_vectors indicates the <B>number</B> of intersection points.", "PK Reference - PK_FACE_intersect_face");
top.note("headers/pk_face_intersect_face_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_FACE_intersect_face_o_t");
top.note("headers/pk_face_intersect_surf.html#declaration", " int *const n_vectors, --- <B>number</B> of point intersections", "PK Reference - PK_FACE_intersect_surf");
top.note("headers/pk_face_intersect_surf.html#documentation", " and face make point contact. n_vectors indicates the <B>number</B> of intersection", "PK Reference - PK_FACE_intersect_surf");
top.note("headers/pk_face_intersect_surf_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_FACE_intersect_surf_o_t");
top.note("headers/pk_face_make_3_face_blend.html#declaration", " int n_left_wall_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_make_3_face_blend");
top.note("headers/pk_face_make_3_face_blend_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_FACE_make_3_face_blend_o_t");
top.note("headers/pk_face_make_3_face_blend_o_t.html#documentation", " n_limits The <B>number</B> of limiting entities.", "PK Reference - PK_FACE_make_3_face_blend_o_t");
top.note("headers/pk_face_make_3_face_blend_r_t.html#declaration", " int n_sheets; --- <B>number</B> of sheets", "PK Reference - PK_FACE_make_3_face_blend_r_t");
top.note("headers/pk_face_make_3_face_blend_r_t.html#documentation", " n_sheets the <B>number</B> of blend sheet bodies returned", "PK Reference - PK_FACE_make_3_face_blend_r_t");
top.note("headers/pk_face_make_blend.html#declaration", " int n_left_wall_faces, --- <B>number</B> of faces in", "PK Reference - PK_FACE_make_blend");
top.note("headers/pk_face_make_blend.html#documentation", " n_ribs the <B>number</B> of curves and points in the ribs array", "PK Reference - PK_FACE_make_blend");
top.note("headers/pk_face_make_blend_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_FACE_make_blend_o_t");
top.note("headers/pk_face_make_blend_o_t.html#documentation", " and tangent_edges must not be set, and the <B>number</B> of edge", "PK Reference - PK_FACE_make_blend_o_t");
top.note("headers/pk_face_make_neutral_sheet_2.html#declaration", " int n_left_faces, --- <B>number</B> of left faces", "PK Reference - PK_FACE_make_neutral_sheet_2");
top.note("headers/pk_face_make_neutral_sheet_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_make_neutral_sheet_o_t");
top.note("headers/pk_face_make_neutral_sheet_o_t.html#documentation", " n_methods <B>Number</B> of construction methods to use. Currently this", "PK Reference - PK_FACE_make_neutral_sheet_o_t");
top.note("headers/pk_face_make_sect_with_sfs.html#declaration", " int n_targets, --- <B>Number</B> of target faces", "PK Reference - PK_FACE_make_sect_with_sfs");
top.note("headers/pk_face_make_sect_with_sfs_o_t.html#declaration", " int o_t_version; --- Version <B>number</B>", "PK Reference - PK_FACE_make_sect_with_sfs_o_t");
top.note("headers/pk_face_make_sect_with_sfs_r_t.html#declaration", " int n_bodies; --- <B>number</B> of bodies", "PK Reference - PK_FACE_make_sect_with_sfs_r_t");
top.note("headers/pk_face_make_sect_with_sfs_r_t.html#documentation", " n_bodies The <B>number</B> of bodies in the bodies array.", "PK Reference - PK_FACE_make_sect_with_sfs_r_t");
top.note("headers/pk_face_make_sheet_bodies.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_make_sheet_bodies");
top.note("headers/pk_face_make_sheet_bodies_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_make_sheet_bodies_o_t");
top.note("headers/pk_face_make_sheet_body.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_make_sheet_body");
top.note("headers/pk_face_make_solid_bodies.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_make_solid_bodies");
top.note("headers/pk_face_neutral_causes_array_t.html#declaration", " int n_causes; --- <B>Number</B> of face causes in array", "PK Reference - PK_FACE_neutral_causes_array_t");
top.note("headers/pk_face_neutral_causes_array_t.html#documentation", " n_causes and this is the <B>number</B> of faces in the corresponding", "PK Reference - PK_FACE_neutral_causes_array_t");
top.note("headers/pk_face_neutral_causes_t.html#declaration", " int n_faces_back; --- <B>Number</B> of faces compressed onto", "PK Reference - PK_FACE_neutral_causes_t");
top.note("headers/pk_face_neutral_causes_t.html#documentation", "are cases, however, in which the <B>number</B> of faces which project to the", "PK Reference - PK_FACE_neutral_causes_t");
top.note("headers/pk_face_offset.html#declaration", " int n_faces, --- <B>number</B> of faces > 0", "PK Reference - PK_FACE_offset");
top.note("headers/pk_face_offset_2.html#declaration", " int n_faces, --- <B>number</B> of faces > 0", "PK Reference - PK_FACE_offset_2");
top.note("headers/pk_face_offset_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_offset_o_t");
top.note("headers/pk_face_overflow_data_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_FACE_overflow_data_o_t");
top.note("headers/pk_face_pattern.html#declaration", " int n_pattern_faces, --- <B>number</B> of pattern faces (>0)", "PK Reference - PK_FACE_pattern");
top.note("headers/pk_face_pattern.html#documentation", "The set of pattern faces may have any <B>number</B> of boundaries (circuits of", "PK Reference - PK_FACE_pattern");
top.note("headers/pk_face_pattern_2.html#declaration", " int n_pattern_faces, --- <B>number</B> of pattern faces (>0)", "PK Reference - PK_FACE_pattern_2");
top.note("headers/pk_face_pattern_2.html#documentation", "The set of pattern faces may have any <B>number</B> of boundaries (circuits of", "PK Reference - PK_FACE_pattern_2");
top.note("headers/pk_face_pattern_2_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of the options", "PK Reference - PK_FACE_pattern_2_o_t");
top.note("headers/pk_face_pattern_2_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return", "PK Reference - PK_FACE_pattern_2_r_t");
top.note("headers/pk_face_pattern_2_r_t.html#documentation", " PK_pattern_result_partial_c , the <B>number</B> of elements in this", "PK Reference - PK_FACE_pattern_2_r_t");
top.note("headers/pk_face_pattern_data_r_t.html#documentation", " completely failed, the <B>number</B> of elements in this", "PK Reference - PK_FACE_pattern_data_r_t");
top.note("headers/pk_face_pattern_instance_r_t.html#declaration", " int n_result_faces; --- <B>number</B> of result faces", "PK Reference - PK_FACE_pattern_instance_r_t");
top.note("headers/pk_face_pattern_instance_r_t.html#documentation", " n_error_topols The <B>number</B> of topological entities in the error_topols ", "PK Reference - PK_FACE_pattern_instance_r_t");
top.note("headers/pk_face_pattern_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_FACE_pattern_o_t");
top.note("headers/pk_face_pattern_r_t.html#documentation", " <B>number</B> of elements in this array will be the", "PK Reference - PK_FACE_pattern_r_t");
top.note("headers/pk_face_remove_to_solid_bodies.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_remove_to_solid_bodies");
top.note("headers/pk_face_repair_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_repair_o_t");
top.note("headers/pk_face_reparameterise_surf.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_reparameterise_surf");
top.note("headers/pk_face_reparameterise_surf_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_FACE_reparameterise_surf_o_t");
top.note("headers/pk_face_replace_surfs.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_replace_surfs");
top.note("headers/pk_face_replace_surfs_2.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_replace_surfs_2");
top.note("headers/pk_face_replace_surfs_2.html#documentation", "The <B>number</B> of surfaces and sense flags passed to the", "PK Reference - PK_FACE_replace_surfs_2");
top.note("headers/pk_face_replace_surfs_3.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_replace_surfs_3");
top.note("headers/pk_face_replace_surfs_3.html#documentation", "The <B>number</B> of surfaces and sense flags passed to the", "PK Reference - PK_FACE_replace_surfs_3");
top.note("headers/pk_face_replace_surfs_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_FACE_replace_surfs_o_t");
top.note("headers/pk_face_replace_surfs_r_t.html#documentation", " n_error_entities The <B>number</B> of topological or geometric entities in", "PK Reference - PK_FACE_replace_surfs_r_t");
top.note("headers/pk_face_replace_with_sheet.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_replace_with_sheet");
top.note("headers/pk_face_replace_with_sheet_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_FACE_replace_with_sheet_o_t");
top.note("headers/pk_face_reverse.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_reverse");
top.note("headers/pk_face_reverse_o_t.html#declaration", " int o_t_version; ---version <B>number</B> of options structure", "PK Reference - PK_FACE_reverse_o_t");
top.note("headers/pk_face_section_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_FACE_section_o_t");
top.note("headers/pk_face_section_with_sheet.html#declaration", " int n_targets, --- <B>Number</B> of target faces", "PK Reference - PK_FACE_section_with_sheet");
top.note("headers/pk_face_section_with_sheet_2.html#declaration", " int n_targets, --- <B>number</B> of target faces", "PK Reference - PK_FACE_section_with_sheet_2");
top.note("headers/pk_face_set_approx.html#declaration", " int n_faces, --- <B>number</B> of faces to process (>0)", "PK Reference - PK_FACE_set_approx");
top.note("headers/pk_face_set_pair_t.html#declaration", " int n_faces1; --- <B>Number</B> of faces in first set", "PK Reference - PK_FACE_set_pair_t");
top.note("headers/pk_face_simplify_geom.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_simplify_geom");
top.note("headers/pk_face_simplify_geom.html#documentation", "geometries, and the old geometries deleted. The <B>number</B> of new geometric", "PK Reference - PK_FACE_simplify_geom");
top.note("headers/pk_face_simplify_geom_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_simplify_geom_o_t");
top.note("headers/pk_face_simplify_geom_o_t.html#documentation", " o_t_version version <B>number</B> of option structure.", "PK Reference - PK_FACE_simplify_geom_o_t");
top.note("headers/pk_face_spin.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_spin");
top.note("headers/pk_face_split_at_param.html#declaration", " int *const n_new_edges, --- <B>number</B> of new edges", "PK Reference - PK_FACE_split_at_param");
top.note("headers/pk_face_split_at_param.html#documentation", "in new_edges , and the <B>number</B> of them in n_new_edges . The new edges", "PK Reference - PK_FACE_split_at_param");
top.note("headers/pk_face_split_at_param_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_split_at_param_o_t");
top.note("headers/pk_face_split_at_param_o_t.html#documentation", " o_t_version version <B>number</B> of option structure.", "PK Reference - PK_FACE_split_at_param_o_t");
top.note("headers/pk_face_sweep.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_sweep");
top.note("headers/pk_face_taper.html#declaration", " int n_faces, --- <B>number</B> of target faces (>0)", "PK Reference - PK_FACE_taper");
top.note("headers/pk_face_taper_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_FACE_taper_o_t");
top.note("headers/pk_face_taper_o_t.html#documentation", " n_faces <B>Number</B> of faces in the taper_faces array.", "PK Reference - PK_FACE_taper_o_t");
top.note("headers/pk_face_tracking_r_t.html#documentation", " n_times_instanced Total <B>number</B> of times instanced copies of this face appear", "PK Reference - PK_FACE_tracking_r_t");
top.note("headers/pk_face_transform.html#declaration", " int n_faces, --- <B>number</B> of faces", "PK Reference - PK_FACE_transform");
top.note("headers/pk_face_transform.html#documentation", " it is set to NULL then only the <B>number</B> of", "PK Reference - PK_FACE_transform");
top.note("headers/pk_face_transform_2.html#declaration", " int n_faces, --- <B>number</B> of faces > 0", "PK Reference - PK_FACE_transform_2");
top.note("headers/pk_face_transform_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FACE_transform_o_t");
top.note("headers/pk_face_trim_cb_f_t.html#declaration", " int n_faces1, --- <B>number</B> of faces1", "PK Reference - PK_FACE_trim_cb_f_t");
top.note("headers/pk_face_unset_approx.html#declaration", " int n_faces, --- <B>number</B> of faces to process (>0)", "PK Reference - PK_FACE_unset_approx");
top.note("headers/pk_facet_local_tolerances_t.html#documentation", " a curved edge entity is approximated by a <B>number</B> of straight line", "PK Reference - PK_facet_local_tolerances_t");
top.note("headers/pk_fcurve_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_FCURVE_array_t");
top.note("headers/pk_fcurve_sf_t.html#declaration", " int n_ints; --- <B>number</B> of integer values (>=0)", "PK Reference - PK_FCURVE_sf_t");
top.note("headers/pk_ffoprb_f_t.html#documentation", " be reduced, for example, to give a whole <B>number</B> of", "PK Reference - PK_FFOPRB_f_t");
top.note("headers/pk_ffread_f_t.html#documentation", " int *nmax --- maximum <B>number</B> of chars returned", "PK Reference - PK_FFREAD_f_t");
top.note("headers/pk_ffwrit_f_t.html#documentation", " the <B>number</B> of characters or bytes written. In the case", "PK Reference - PK_FFWRIT_f_t");
top.note("headers/pk_fgevsu_f_t.html#documentation", "derivatives request). The arguments nu, nv specify the <B>number</B> of u and v", "PK Reference - PK_FGEVSU_f_t");
top.note("headers/pk_fill_hole_point_data_t.html#documentation", " n_points Indicates the <B>number</B> of points supplied.", "PK Reference - PK_fill_hole_point_data_t");
top.note("headers/pk_fill_hole_topol_t.html#documentation", " <B>number</B> of faces in the resultant patch", "PK Reference - PK_fill_hole_topol_t");
top.note("headers/pk_fin_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_FIN_array_t");
top.note("headers/pk_fin_attach_curves.html#declaration", " int n_fins, --- <B>number</B> of fins", "PK Reference - PK_FIN_attach_curves");
top.note("headers/pk_fin_euler_glue.html#declaration", " int n_fins, --- <B>number</B> of fins", "PK Reference - PK_FIN_euler_glue");
top.note("headers/pk_fin_euler_glue.html#errors", " PK_ERROR_wrong_number_edges the total <B>number</B> of edges referenced by", "PK Reference - PK_FIN_euler_glue");
top.note("headers/pk_fin_euler_glue.html#documentation", "same <B>number</B> of vertices (zero, one or two).", "PK Reference - PK_FIN_euler_glue");
top.note("headers/pk_fin_find_mtopols.html#documentation", "the <B>number</B> of mvertices via the options structure, and similarly", "PK Reference - PK_FIN_find_mtopols");
top.note("headers/pk_fin_find_mtopols_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_FIN_find_mtopols_o_t");
top.note("headers/pk_fin_find_mtopols_o_t.html#documentation", " want_mvertices n_mvertices , the <B>number</B> of mvertices, is always", "PK Reference - PK_FIN_find_mtopols_o_t");
top.note("headers/pk_find_reparam_record_r_t.html#declaration", " int n_topols; --- <B>Number</B> of topologies whose", "PK Reference - PK_find_reparam_record_r_t");
top.note("headers/pk_find_reparam_record_r_t.html#documentation", " n_topols The <B>number</B> of topologies whose shape depends on at", "PK Reference - PK_find_reparam_record_r_t");
top.note("headers/pk_frame_ask_geometry_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_FRAME_ask_geometry_o_t");
top.note("headers/pk_frame_ask_geometry_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_FRAME_ask_geometry_r_t");
top.note("headers/pk_frame_ask_owner_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_FRAME_ask_owner_o_t");
top.note("headers/pk_frame_ask_owner_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_FRAME_ask_owner_r_t");
top.note("headers/pk_frame_reverse_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_FRAME_reverse_o_t");
top.note("headers/pk_frame_reverse_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_FRAME_reverse_r_t");
top.note("headers/pk_fsurf_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_FSURF_array_t");
top.note("headers/pk_fsurf_sf_t.html#declaration", " int n_ints; --- <B>number</B> of integer values (>=0)", "PK Reference - PK_FSURF_sf_t");
top.note("headers/pk_function_find.html#declaration", " int n_function_names, --- <B>number</B> of names", "PK Reference - PK_FUNCTION_find");
top.note("headers/pk_function_find_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_FUNCTION_find_o_t");
top.note("headers/pk_fxf_error_t.html#declaration", " int n_topols; --- <B>number</B> of topols", "PK Reference - PK_fxf_error_t");
top.note("headers/pk_fxf_error_t.html#documentation", " n_topols the <B>number</B> of topological entities associated with the fault", "PK Reference - PK_fxf_error_t");
top.note("headers/pk_geom_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_GEOM_array_t");
top.note("headers/pk_geom_ask_dependents.html#declaration", " int *const n_dependents, --- <B>number</B> of dependents (>= 0)", "PK Reference - PK_GEOM_ask_dependents");
top.note("headers/pk_geom_ask_dependents.html#documentation", "function will only compute the <B>number</B> of dependents of the given entity.", "PK Reference - PK_GEOM_ask_dependents");
top.note("headers/pk_geom_ask_geom_category_o_t.html#declaration", "int o_t_version; --- version <B>number</B>", "PK Reference - PK_GEOM_ask_geom_category_o_t");
top.note("headers/pk_geom_ask_geom_owners.html#declaration", " int *const n_owners, --- <B>number</B> of geometric owners (>= 0)", "PK Reference - PK_GEOM_ask_geom_owners");
top.note("headers/pk_geom_ask_geom_owners.html#documentation", "function will only compute the <B>number</B> of geometric owners of the given entity.", "PK Reference - PK_GEOM_ask_geom_owners");
top.note("headers/pk_geom_check.html#declaration", " int *const n_faults, --- <B>number</B> of faults", "PK Reference - PK_GEOM_check");
top.note("headers/pk_geom_check_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_GEOM_check_o_t");
top.note("headers/pk_geom_check_o_t.html#documentation", " maximum <B>number</B> of faults to be returned and whether to", "PK Reference - PK_GEOM_check_o_t");
top.note("headers/pk_geom_copy.html#documentation", "that if a geometry was specified a multiple <B>number</B> of times as input only one", "PK Reference - PK_GEOM_copy");
top.note("headers/pk_geom_copy_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_GEOM_copy_o_t");
top.note("headers/pk_geom_copy_r_t.html#documentation", " array has length equal to n_geoms ( the <B>number</B> of input", "PK Reference - PK_GEOM_copy_r_t");
top.note("headers/pk_geom_enlarge.html#declaration", " int n_geoms, --- <B>number</B> of geometry entities", "PK Reference - PK_GEOM_enlarge");
top.note("headers/pk_geom_enlarge_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_GEOM_enlarge_o_t");
top.note("headers/pk_geom_enlarge_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return", "PK Reference - PK_GEOM_enlarge_r_t");
top.note("headers/pk_geom_enlarge_r_t.html#documentation", " n_results The <B>number</B> of results. This will be equal to n_geoms", "PK Reference - PK_GEOM_enlarge_r_t");
top.note("headers/pk_geom_range_array_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_GEOM_range_array_o_t");
top.note("headers/pk_geom_range_array_vector_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_GEOM_range_array_vector_o_t");
top.note("headers/pk_geom_range_local_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_GEOM_range_local_o_t");
top.note("headers/pk_geom_range_local_vector_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_GEOM_range_local_vector_o_t");
top.note("headers/pk_geom_range_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option struct.", "PK Reference - PK_GEOM_range_o_t");
top.note("headers/pk_geom_range_vector_many.html#declaration", "int n_vectors, --- <B>number</B> of positions", "PK Reference - PK_GEOM_range_vector_many");
top.note("headers/pk_geom_range_vector_many_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_GEOM_range_vector_many_o_t");
top.note("headers/pk_geom_range_vector_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_GEOM_range_vector_o_t");
top.note("headers/pk_geom_render.html#declaration", " int n_geoms, --- <B>number</B> of entities to be rendered", "PK Reference - PK_GEOM_render");
top.note("headers/pk_geom_render_line.html#declaration", " const int n_geoms, --- <B>number</B> of entities to be rendered", "PK Reference - PK_GEOM_render_line");
top.note("headers/pk_geom_render_o_t.html#declaration", " int param_u_<B>number</B>; --- <B>Number</B> of u direction hatch", "PK Reference - PK_GEOM_render_o_t");
top.note("headers/pk_geom_render_o_t.html#documentation", "This is the <B>number</B> of entities with which a scale factor will", "PK Reference - PK_GEOM_render_o_t");
top.note("headers/pk_geom_transform_2.html#declaration", " int n_geoms, --- <B>number</B> of geometry entities", "PK Reference - PK_GEOM_transform_2");
top.note("headers/pk_goopsg_f_t.html#documentation", " lntp[0] - Occurrence <B>number</B> of the entity from which the segment", "PK Reference - PK_GOOPSG_f_t");
top.note("headers/pk_gopixl_f_t.html#documentation", " npixels is the <B>number</B> of pixels to output in a row (ie.", "PK Reference - PK_GOPIXL_f_t");
top.note("headers/pk_gosgmt_f_t.html#documentation", " The <B>number</B> of edge tags given equals the <B>number</B> of", "PK Reference - PK_GOSGMT_f_t");
top.note("headers/pk_group_add_entities.html#declaration", "int n_entities, --- <B>number</B> of entities (>=0)", "PK Reference - PK_GROUP_add_entities");
top.note("headers/pk_group_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_GROUP_array_t");
top.note("headers/pk_group_ask_closure.html#declaration", "int *const n_attribs, --- <B>number</B> of attribs (>=0)", "PK Reference - PK_GROUP_ask_closure");
top.note("headers/pk_group_ask_closure_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_GROUP_ask_closure_o_t");
top.note("headers/pk_group_ask_controls_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_GROUP_ask_controls_o_t");
top.note("headers/pk_group_ask_controls_r_t.html#declaration", " int n_int_arrays; --- <B>number</B> of int arrays", "PK Reference - PK_GROUP_ask_controls_r_t");
top.note("headers/pk_group_ask_entities.html#declaration", " int *const n_entities, --- <B>number</B> of entities (>=0)", "PK Reference - PK_GROUP_ask_entities");
top.note("headers/pk_group_ask_entities.html#documentation", "will only return the <B>number</B> of entities in the group.", "PK Reference - PK_GROUP_ask_entities");
top.note("headers/pk_group_create_from_entities.html#declaration", "int n_entities, --- <B>number</B> of entities (>=0)", "PK Reference - PK_GROUP_create_from_entities");
top.note("headers/pk_group_create_from_entities_2.html#declaration", "int n_entities, --- <B>number</B> of entities (>=0)", "PK Reference - PK_GROUP_create_from_entities_2");
top.note("headers/pk_group_create_from_ents_o_t.html#declaration", " --- version <B>number</B>", "PK Reference - PK_GROUP_create_from_ents_o_t");
top.note("headers/pk_group_create_from_ents_o_t.html#documentation", " specify a minimum <B>number</B> of entities with that label", "PK Reference - PK_GROUP_create_from_ents_o_t");
top.note("headers/pk_group_find_entities.html#declaration", " int *const n_entities, --- <B>number</B> of entities (>=0)", "PK Reference - PK_GROUP_find_entities");
top.note("headers/pk_group_find_entities_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_GROUP_find_entities_o_t");
top.note("headers/pk_group_merge_entities.html#declaration", "int n_entities, --- <B>number</B> of entities (>=0)", "PK Reference - PK_GROUP_merge_entities");
top.note("headers/pk_group_remove_entities.html#declaration", "int n_entities, --- <B>number</B> of entities", "PK Reference - PK_GROUP_remove_entities");
top.note("headers/pk_icurve_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_ICURVE_array_t");
top.note("headers/pk_identify_details_r_t.html#declaration", " int n_facesets; --- <B>number</B> of facesets", "PK Reference - PK_identify_details_r_t");
top.note("headers/pk_identify_details_r_t.html#documentation", " n_facesets The <B>number</B> of facesets found", "PK Reference - PK_identify_details_r_t");
top.note("headers/pk_identify_facesets_r_t.html#declaration", " int n_survive_target_faces; --- <B>number</B> of surviving", "PK Reference - PK_identify_facesets_r_t");
top.note("headers/pk_identify_facesets_r_t.html#documentation", " n_survive_target_faces The <B>number</B> of surviving facesets on the", "PK Reference - PK_identify_facesets_r_t");
top.note("headers/pk_identify_general_r_t.html#declaration", " int n_general; --- <B>number</B> of general characteristics", "PK Reference - PK_identify_general_r_t");
top.note("headers/pk_identify_general_r_t.html#documentation", " n_general The <B>number</B> of general characteristics found", "PK Reference - PK_identify_general_r_t");
top.note("headers/pk_instance_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_INSTANCE_array_t");
top.note("headers/pk_int_array_t.html#documentation", " length : the <B>number</B> of ints in array ", "PK Reference - PK_int_array_t");
top.note("headers/pk_item_array_t.html#documentation", " length : the <B>number</B> of items in array ", "PK Reference - PK_ITEM_array_t");
top.note("headers/pk_lattice_ask_connectivity_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LATTICE_ask_connectivity_o_t");
top.note("headers/pk_lattice_ask_connectivity_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of", "PK Reference - PK_LATTICE_ask_connectivity_r_t");
top.note("headers/pk_lattice_ask_connectivity_r_t.html#documentation", " n_components The <B>number</B> of connected components in the graph of the", "PK Reference - PK_LATTICE_ask_connectivity_r_t");
top.note("headers/pk_lattice_ask_n_lballs.html#description", " This function returns the <B>number</B> of lballs in the given lattice .", "PK Reference - PK_LATTICE_ask_n_lballs");
top.note("headers/pk_lattice_ask_n_lballs_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LATTICE_ask_n_lballs_o_t");
top.note("headers/pk_lattice_ask_n_lballs_o_t.html#description", " Holds optional controls for querying the <B>number</B> of lballs in a lattice.", "PK Reference - PK_LATTICE_ask_n_lballs_o_t");
top.note("headers/pk_lattice_ask_n_lballs_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LATTICE_ask_n_lballs_r_t");
top.note("headers/pk_lattice_ask_n_lballs_r_t.html#description", " A structure packaging the <B>number</B> of lballs in the lattice.", "PK Reference - PK_LATTICE_ask_n_lballs_r_t");
top.note("headers/pk_lattice_ask_n_lballs_r_t.html#documentation", " n_lballs The <B>number</B> of lballs in the lattice.", "PK Reference - PK_LATTICE_ask_n_lballs_r_t");
top.note("headers/pk_lattice_ask_n_lrods.html#description", " This function returns the <B>number</B> of lrods in the given lattice .", "PK Reference - PK_LATTICE_ask_n_lrods");
top.note("headers/pk_lattice_ask_n_lrods_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LATTICE_ask_n_lrods_o_t");
top.note("headers/pk_lattice_ask_n_lrods_o_t.html#description", " Holds optional controls for querying the <B>number</B> of lrods in a lattice.", "PK Reference - PK_LATTICE_ask_n_lrods_o_t");
top.note("headers/pk_lattice_ask_n_lrods_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LATTICE_ask_n_lrods_r_t");
top.note("headers/pk_lattice_ask_n_lrods_r_t.html#description", " A structure packaging the <B>number</B> of lrods in the lattice.", "PK Reference - PK_LATTICE_ask_n_lrods_r_t");
top.note("headers/pk_lattice_ask_n_lrods_r_t.html#documentation", " n_lrods The <B>number</B> of lrods in the lattice.", "PK Reference - PK_LATTICE_ask_n_lrods_r_t");
top.note("headers/pk_lattice_ask_regions_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LATTICE_ask_regions_o_t");
top.note("headers/pk_lattice_ask_regions_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LATTICE_ask_regions_r_t");
top.note("headers/pk_lattice_ask_regions_r_t.html#documentation", " n_regions The <B>number</B> of regions in which lattice is embedded.", "PK Reference - PK_LATTICE_ask_regions_r_t");
top.note("headers/pk_lattice_clip_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_LATTICE_clip_o_t");
top.note("headers/pk_lattice_clip_o_t.html#documentation", " n_clip_entities The <B>number</B> of entities supplied in clip_entities ", "PK Reference - PK_LATTICE_clip_o_t");
top.note("headers/pk_lattice_clip_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LATTICE_clip_r_t");
top.note("headers/pk_lattice_clip_r_t.html#documentation", " n_lattices The <B>number</B> of clipped lattices.", "PK Reference - PK_LATTICE_clip_r_t");
top.note("headers/pk_lattice_combine.html#declaration", " int n_lattices, --- <B>number</B> of lattices", "PK Reference - PK_LATTICE_combine");
top.note("headers/pk_lattice_combine_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LATTICE_combine_o_t");
top.note("headers/pk_lattice_combine_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of returns", "PK Reference - PK_LATTICE_combine_r_t");
top.note("headers/pk_lattice_create_by_graph_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_LATTICE_create_by_graph_o_t");
top.note("headers/pk_lattice_create_by_graph_o_t.html#documentation", " <B>number</B> of lballs that will be returned", "PK Reference - PK_LATTICE_create_by_graph_o_t");
top.note("headers/pk_lattice_create_by_graph_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LATTICE_create_by_graph_r_t");
top.note("headers/pk_lattice_create_by_graph_r_t.html#documentation", " n_lattices The <B>number</B> of created lattices.", "PK Reference - PK_LATTICE_create_by_graph_r_t");
top.note("headers/pk_lattice_disjoin_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_LATTICE_disjoin_o_t");
top.note("headers/pk_lattice_disjoin_o_t.html#documentation", " min_n_lrods The minimum <B>number</B> of lrods in any returned", "PK Reference - PK_LATTICE_disjoin_o_t");
top.note("headers/pk_lattice_disjoin_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of returns structure", "PK Reference - PK_LATTICE_disjoin_r_t");
top.note("headers/pk_lattice_disjoin_r_t.html#documentation", " n_lattices The <B>number</B> of returned lattices.", "PK Reference - PK_LATTICE_disjoin_r_t");
top.note("headers/pk_lattice_find_box_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_LATTICE_find_box_o_t");
top.note("headers/pk_lattice_find_box_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LATTICE_find_box_r_t");
top.note("headers/pk_lattice_find_nabox_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_LATTICE_find_nabox_o_t");
top.note("headers/pk_lattice_find_nabox_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LATTICE_find_nabox_r_t");
top.note("headers/pk_lattice_graph_cone_o_t.html#declaration", " int o_t_version; --- Version <B>number</B> of options", "PK Reference - PK_LATTICE_graph_cone_o_t");
top.note("headers/pk_lattice_graph_cone_o_t.html#documentation", " n_lball_positions The <B>number</B> of lballs in the array lball_positions .", "PK Reference - PK_LATTICE_graph_cone_o_t");
top.note("headers/pk_lattice_graph_cyl_o_t.html#declaration", " int o_t_version; --- Version <B>number</B> of options", "PK Reference - PK_LATTICE_graph_cyl_o_t");
top.note("headers/pk_lattice_graph_cyl_o_t.html#documentation", " n_lball_positions The <B>number</B> of lballs in the array lball_positions .", "PK Reference - PK_LATTICE_graph_cyl_o_t");
top.note("headers/pk_lattice_make_bodies_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LATTICE_make_bodies_r_t");
top.note("headers/pk_lattice_make_bodies_r_t.html#documentation", " n_bodies The <B>number</B> of the bodies returned.", "PK Reference - PK_LATTICE_make_bodies_r_t");
top.note("headers/pk_lattice_make_patterned_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_LATTICE_make_patterned_o_t");
top.note("headers/pk_lattice_make_patterned_o_t.html#errors", " specify a <B>number</B> of repetitions greater", "PK Reference - PK_LATTICE_make_patterned_o_t");
top.note("headers/pk_lattice_make_patterned_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of returns structure", "PK Reference - PK_LATTICE_make_patterned_r_t");
top.note("headers/pk_law_sf_t.html#declaration", " int n_vertices; --- The <B>number</B> of vertices. (0)", "PK Reference - PK_LAW_sf_t");
top.note("headers/pk_law_sf_t.html#documentation", " This field gives the <B>number</B> of doubles per vertex in the array", "PK Reference - PK_LAW_sf_t");
top.note("headers/pk_lball_ask_blend_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LBALL_ask_blend_o_t");
top.note("headers/pk_lball_ask_blend_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LBALL_ask_blend_r_t");
top.note("headers/pk_lball_ask_lballs_adj_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LBALL_ask_lballs_adj_o_t");
top.note("headers/pk_lball_ask_lballs_adj_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LBALL_ask_lballs_adj_r_t");
top.note("headers/pk_lball_ask_lballs_adj_r_t.html#documentation", " n_lballs_adj The <B>number</B> of adjacent lballs to the lball .", "PK Reference - PK_LBALL_ask_lballs_adj_r_t");
top.note("headers/pk_lball_ask_lrods_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LBALL_ask_lrods_o_t");
top.note("headers/pk_lball_ask_lrods_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LBALL_ask_lrods_r_t");
top.note("headers/pk_lball_ask_lrods_r_t.html#documentation", " n_lrods The <B>number</B> of lrods.", "PK Reference - PK_LBALL_ask_lrods_r_t");
top.note("headers/pk_lball_ask_position_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LBALL_ask_position_o_t");
top.note("headers/pk_lball_ask_position_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LBALL_ask_position_r_t");
top.note("headers/pk_lball_ask_radius_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LBALL_ask_radius_o_t");
top.note("headers/pk_lball_ask_radius_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LBALL_ask_radius_r_t");
top.note("headers/pk_line_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_LINE_array_t");
top.note("headers/pk_loop_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_LOOP_array_t");
top.note("headers/pk_loop_ask_edges.html#declaration", " int *const n_edges, --- <B>number</B> of edges (>= 0)", "PK Reference - PK_LOOP_ask_edges");
top.note("headers/pk_loop_ask_edges.html#documentation", "only compute the <B>number</B> of edges in the loop.", "PK Reference - PK_LOOP_ask_edges");
top.note("headers/pk_loop_ask_fins.html#declaration", " int *const n_fins, --- <B>number</B> of fins (>= 0)", "PK Reference - PK_LOOP_ask_fins");
top.note("headers/pk_loop_ask_fins.html#documentation", "only compute the <B>number</B> of fins in the loop.", "PK Reference - PK_LOOP_ask_fins");
top.note("headers/pk_loop_ask_type.html#documentation", "peripheral loop (PK_LOOP_type_outer_c) and any <B>number</B> of holes", "PK Reference - PK_LOOP_ask_type");
top.note("headers/pk_loop_ask_vertices.html#declaration", " int *const n_vertices, --- <B>number</B> of vertices (>= 0)", "PK Reference - PK_LOOP_ask_vertices");
top.note("headers/pk_loop_ask_vertices.html#documentation", "will only compute the <B>number</B> of vertices in the loop (counting repeats).", "PK Reference - PK_LOOP_ask_vertices");
top.note("headers/pk_loop_close_gaps.html#declaration", " int *const n_vertices, --- <B>number</B> of vertices where gaps", "PK Reference - PK_LOOP_close_gaps");
top.note("headers/pk_loop_delete_from_sheet_body.html#declaration", " int n_loops, --- <B>number</B> of loops to be deleted", "PK Reference - PK_LOOP_delete_from_sheet_body");
top.note("headers/pk_lrod_ask_geometry_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LROD_ask_geometry_o_t");
top.note("headers/pk_lrod_ask_geometry_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LROD_ask_geometry_r_t");
top.note("headers/pk_lrod_ask_geometry_r_t.html#documentation", " n_radii The <B>number</B> of radii of the lrod.", "PK Reference - PK_LROD_ask_geometry_r_t");
top.note("headers/pk_lrod_ask_lballs_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LROD_ask_lballs_o_t");
top.note("headers/pk_lrod_ask_lballs_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LROD_ask_lballs_r_t");
top.note("headers/pk_lrod_shape_cone_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_LROD_shape_cone_o_t");
top.note("headers/pk_lrod_shape_cyl_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_LROD_shape_cyl_o_t");
top.note("headers/pk_ltopol_ask_box.html#declaration", " int n_ltopols, --- <B>number</B> of ltopols", "PK Reference - PK_LTOPOL_ask_box");
top.note("headers/pk_ltopol_ask_box_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LTOPOL_ask_box_o_t");
top.note("headers/pk_ltopol_ask_box_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LTOPOL_ask_box_r_t");
top.note("headers/pk_ltopol_ask_class_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LTOPOL_ask_class_o_t");
top.note("headers/pk_ltopol_ask_class_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LTOPOL_ask_class_r_t");
top.note("headers/pk_ltopol_is_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_LTOPOL_is_o_t");
top.note("headers/pk_ltopol_is_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_LTOPOL_is_r_t");
top.note("headers/pk_mark_ask_pmarks.html#declaration", " int *const n_pmarks, --- <B>number</B> of pmarks of mark", "PK Reference - PK_MARK_ask_pmarks");
top.note("headers/pk_mark_goto_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MARK_goto_o_t");
top.note("headers/pk_mark_goto_r_t.html#declaration", " int n_partitions; --- <B>number</B> of partitions", "PK Reference - PK_MARK_goto_r_t");
top.note("headers/pk_memory_alloc.html#declaration", " size_t nbytes, --- <B>number</B> of bytes required", "PK Reference - PK_MEMORY_alloc");
top.note("headers/pk_mesh_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_MESH_array_t");
top.note("headers/pk_mesh_ask_n_mfacets.html#declaration", " int *const n_mfacets --- <B>number</B> of mfacets", "PK Reference - PK_MESH_ask_n_mfacets");
top.note("headers/pk_mesh_ask_n_mfacets.html#description", " This function returns the <B>number</B> of mfacets in the given mesh .", "PK Reference - PK_MESH_ask_n_mfacets");
top.note("headers/pk_mesh_ask_n_mvertices.html#declaration", " int *const n_mvertices --- <B>number</B> of mvertices", "PK Reference - PK_MESH_ask_n_mvertices");
top.note("headers/pk_mesh_ask_n_mvertices.html#description", " This function returns the <B>number</B> of mvertices in the given mesh .", "PK Reference - PK_MESH_ask_n_mvertices");
top.note("headers/pk_mesh_ask_normal_type_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MESH_ask_normal_type_o_t");
top.note("headers/pk_mesh_create_from_facets_o_t.html#declaration", " int o_t_version; --- Version <B>number</B> of", "PK Reference - PK_MESH_create_from_facets_o_t");
top.note("headers/pk_mesh_create_from_facets_o_t.html#documentation", " <B>number</B> of vertices that will be returned", "PK Reference - PK_MESH_create_from_facets_o_t");
top.note("headers/pk_mesh_defect_array_t.html#documentation", " n_defects <B>Number</B> of defects on the resultant mesh", "PK Reference - PK_MESH_defect_array_t");
top.note("headers/pk_mesh_defect_details_t.html#declaration", " int n_entities; --- <B>number</B> of defect entities", "PK Reference - PK_MESH_defect_details_t");
top.note("headers/pk_mesh_discard_normals_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MESH_discard_normals_o_t");
top.note("headers/pk_mesh_eval_with_mtopol_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MESH_eval_with_mtopol_o_t");
top.note("headers/pk_mesh_facet_fan_t.html#declaration", " int n_vertex_positions; --- <B>Number</B> of vertices in", "PK Reference - PK_MESH_facet_fan_t");
top.note("headers/pk_mesh_facet_fan_t.html#documentation", " n_vertex_positions The <B>number</B> of vertices in the array vertex_positions ", "PK Reference - PK_MESH_facet_fan_t");
top.note("headers/pk_mesh_facet_index_t.html#declaration", " int n_vertex_positions; --- <B>Number</B> of vertices in", "PK Reference - PK_MESH_facet_index_t");
top.note("headers/pk_mesh_facet_index_t.html#documentation", " n_vertex_positions The <B>number</B> of vertices in the array", "PK Reference - PK_MESH_facet_index_t");
top.note("headers/pk_mesh_facet_strip_t.html#declaration", " int n_vertex_positions; --- <B>Number</B> of vertices in", "PK Reference - PK_MESH_facet_strip_t");
top.note("headers/pk_mesh_facet_strip_t.html#documentation", " n_vertex_positions The <B>number</B> of vertices in the array", "PK Reference - PK_MESH_facet_strip_t");
top.note("headers/pk_mesh_facet_vector_t.html#declaration", " int n_vertex_positions; --- <B>Number</B> of vertices in", "PK Reference - PK_MESH_facet_vector_t");
top.note("headers/pk_mesh_facet_vector_t.html#documentation", " n_vertex_positions The <B>number</B> of vertices in the array vertex_positions .", "PK Reference - PK_MESH_facet_vector_t");
top.note("headers/pk_mesh_fill_holes_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of", "PK Reference - PK_MESH_fill_holes_o_t");
top.note("headers/pk_mesh_fill_holes_o_t.html#documentation", " max_n_mfins Defines an upper bound on the <B>number</B> of laminar mfins", "PK Reference - PK_MESH_fill_holes_o_t");
top.note("headers/pk_mesh_find_defects.html#declaration", " int *const n_defects, --- <B>number</B> of defects", "PK Reference - PK_MESH_find_defects");
top.note("headers/pk_mesh_find_defects_o_t.html#declaration", " --- version <B>number</B> of option", "PK Reference - PK_MESH_find_defects_o_t");
top.note("headers/pk_mesh_find_defects_o_t.html#documentation", " The maximum <B>number</B> of defects to be returned.", "PK Reference - PK_MESH_find_defects_o_t");
top.note("headers/pk_mesh_find_laminar_mfins.html#documentation", "at least one mfin, but the <B>number</B> of components may be zero. Components will", "PK Reference - PK_MESH_find_laminar_mfins");
top.note("headers/pk_mesh_find_laminar_mfins_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of", "PK Reference - PK_MESH_find_laminar_mfins_o_t");
top.note("headers/pk_mesh_find_laminar_mfins_o_t.html#documentation", " n_help_positions The <B>number</B> of help positions. If supplied,", "PK Reference - PK_MESH_find_laminar_mfins_o_t");
top.note("headers/pk_mesh_find_laminar_mfins_r_t.html#declaration", " int n_components; --- <B>number</B> of components", "PK Reference - PK_MESH_find_laminar_mfins_r_t");
top.note("headers/pk_mesh_find_laminar_mfins_r_t.html#documentation", " n_components The <B>number</B> of components returned.", "PK Reference - PK_MESH_find_laminar_mfins_r_t");
top.note("headers/pk_mesh_find_sharp_mfins.html#declaration", " int *const n_sharp_mfins, --- <B>number</B> of sharp mfins", "PK Reference - PK_MESH_find_sharp_mfins");
top.note("headers/pk_mesh_find_sharp_mfins_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MESH_find_sharp_mfins_o_t");
top.note("headers/pk_mesh_find_sharp_mfins_o_t.html#documentation", " want_sharp_mfins If set to PK_LOGICAL_false, then only the <B>number</B> of sharp", "PK Reference - PK_MESH_find_sharp_mfins_o_t");
top.note("headers/pk_mesh_find_sharp_mvxs.html#declaration", " int *const n_sharp_mvxs, --- <B>number</B> of sharp mvertices", "PK Reference - PK_MESH_find_sharp_mvxs");
top.note("headers/pk_mesh_find_sharp_mvxs_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MESH_find_sharp_mvxs_o_t");
top.note("headers/pk_mesh_find_sharp_mvxs_o_t.html#documentation", " want_sharp_mvxs If set to PK_LOGICAL_false, then only the <B>number</B>", "PK Reference - PK_MESH_find_sharp_mvxs_o_t");
top.note("headers/pk_mesh_fix_defects.html#declaration", "int *const n_resultant_meshes, --- <B>number</B> of resultant", "PK Reference - PK_MESH_fix_defects");
top.note("headers/pk_mesh_fix_defects_o_t.html#declaration", " --- version <B>number</B> of option", "PK Reference - PK_MESH_fix_defects_o_t");
top.note("headers/pk_mesh_has_unique_normals_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MESH_has_unique_normals_o_t");
top.note("headers/pk_mesh_imprint_vectors.html#declaration", "int n_vectors, --- <B>number</B> of vectors", "PK Reference - PK_MESH_imprint_vectors");
top.note("headers/pk_mesh_imprint_vectors_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of", "PK Reference - PK_MESH_imprint_vectors_o_t");
top.note("headers/pk_mesh_imprint_vectors_o_t.html#documentation", " n_max_cb_mtopols This determines the maximum <B>number</B> of mtopols that", "PK Reference - PK_MESH_imprint_vectors_o_t");
top.note("headers/pk_mesh_imprint_vectors_r_t.html#declaration", "int n_error_indices; --- <B>number</B> of vectors not on the", "PK Reference - PK_MESH_imprint_vectors_r_t");
top.note("headers/pk_mesh_is_loaded_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_MESH_is_loaded_o_t");
top.note("headers/pk_mesh_is_loaded_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_MESH_is_loaded_r_t");
top.note("headers/pk_mesh_make_bodies.html#declaration", " int *const n_bodies, --- <B>number</B> of result bodies", "PK Reference - PK_MESH_make_bodies");
top.note("headers/pk_mesh_make_bodies_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of", "PK Reference - PK_MESH_make_bodies_o_t");
top.note("headers/pk_mesh_make_surf_trimmed_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of", "PK Reference - PK_MESH_make_surf_trimmed_o_t");
top.note("headers/pk_mesh_store_normals_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of", "PK Reference - PK_MESH_store_normals_o_t");
top.note("headers/pk_mfacet_array_t.html#documentation", " length the <B>number</B> of elements in array ", "PK Reference - PK_MFACET_array_t");
top.note("headers/pk_mfacet_ask_mvx_normals_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MFACET_ask_mvx_normals_o_t");
top.note("headers/pk_mfacet_find_perimeters.html#declaration", " int n_mfacets, --- the <B>number</B> of mfacets", "PK Reference - PK_MFACET_find_perimeters");
top.note("headers/pk_mfacet_find_perimeters_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MFACET_find_perimeters_o_t");
top.note("headers/pk_mfacet_find_perimeters_o_t.html#documentation", " fewer than this <B>number</B> of facets will be ignored.", "PK Reference - PK_MFACET_find_perimeters_o_t");
top.note("headers/pk_mfacet_find_perimeters_r_t.html#declaration", " int num_perimeters; --- <B>number</B> of perimeters", "PK Reference - PK_MFACET_find_perimeters_r_t");
top.note("headers/pk_mfacet_find_perimeters_r_t.html#documentation", " num_perimeters The <B>number</B> of perimeters returned.", "PK Reference - PK_MFACET_find_perimeters_r_t");
top.note("headers/pk_mfacet_parameterise_vec_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MFACET_parameterise_vec_o_t");
top.note("headers/pk_mfin_array_t.html#documentation", " length the <B>number</B> of elements in array ", "PK Reference - PK_MFIN_array_t");
top.note("headers/pk_mfin_ask_mvx_curvature_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MFIN_ask_mvx_curvature_o_t");
top.note("headers/pk_mfin_ask_mvx_normal_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MFIN_ask_mvx_normal_o_t");
top.note("headers/pk_mfin_is_sharp_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MFIN_is_sharp_o_t");
top.note("headers/pk_mloop_details_r_t.html#declaration", " int n_plines; --- <B>number</B> of plines for this mloop", "PK Reference - PK_mloop_details_r_t");
top.note("headers/pk_mloop_details_r_t.html#documentation", " n_plines The <B>number</B> of plines returned for this mloop. This will", "PK Reference - PK_mloop_details_r_t");
top.note("headers/pk_mtopol_make_meshes.html#declaration", " int n_mtopols, --- the <B>number</B> of mtopols", "PK Reference - PK_MTOPOL_make_meshes");
top.note("headers/pk_mtopol_make_meshes_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MTOPOL_make_meshes_o_t");
top.note("headers/pk_mtopol_make_meshes_o_t.html#documentation", " n_max_cb_mtopols This determines the maximum <B>number</B> of mtopols that", "PK Reference - PK_MTOPOL_make_meshes_o_t");
top.note("headers/pk_mvertex_ask_mfacets.html#declaration", " int *const n_mfacets, --- the <B>number</B> of mfacets ", "PK Reference - PK_MVERTEX_ask_mfacets");
top.note("headers/pk_mvertex_ask_mfacets.html#documentation", "will only compute the <B>number</B> of mfacets which have this mvertex as one", "PK Reference - PK_MVERTEX_ask_mfacets");
top.note("headers/pk_mvertex_ask_mvertices_ring.html#declaration", " int *const n_mvertices_ring, --- the <B>number</B> of mvertices", "PK Reference - PK_MVERTEX_ask_mvertices_ring");
top.note("headers/pk_mvertex_ask_mvertices_ring.html#documentation", "the function will only compute the <B>number</B> of mvertices in the ring.", "PK Reference - PK_MVERTEX_ask_mvertices_ring");
top.note("headers/pk_mvertex_ask_normals.html#declaration", " int *const n_normals, --- <B>number</B> of normals", "PK Reference - PK_MVERTEX_ask_normals");
top.note("headers/pk_mvertex_ask_normals_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MVERTEX_ask_normals_o_t");
top.note("headers/pk_mvertex_ask_normals_o_t.html#documentation", " only the <B>number</B> of normals will be returned.", "PK Reference - PK_MVERTEX_ask_normals_o_t");
top.note("headers/pk_mvertex_set_positions.html#declaration", " int n_mvertices, --- the <B>number</B> of mvertices", "PK Reference - PK_MVERTEX_set_positions");
top.note("headers/pk_mvertex_set_positions_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_MVERTEX_set_positions_o_t");
top.note("headers/pk_offset_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_OFFSET_array_t");
top.note("headers/pk_outline_curve_t.html#documentation", " n_curves The <B>number</B> of curves in the outline.", "PK Reference - PK_outline_curve_t");
top.note("headers/pk_part_add_geoms.html#declaration", "int n_geoms, --- <B>number</B> of geoms", "PK Reference - PK_PART_add_geoms");
top.note("headers/pk_part_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_PART_array_t");
top.note("headers/pk_part_ask_all_attdefs.html#declaration", " int *const n_attdefs, --- <B>number</B> of attdefs (>= 0)", "PK Reference - PK_PART_ask_all_attdefs");
top.note("headers/pk_part_ask_all_attdefs.html#documentation", "will only compute the <B>number</B> of different attribute definitions used within", "PK Reference - PK_PART_ask_all_attdefs");
top.note("headers/pk_part_ask_all_attribs.html#declaration", " int *const n_attribs, --- <B>number</B> of attributes (>= 0)", "PK Reference - PK_PART_ask_all_attribs");
top.note("headers/pk_part_ask_all_attribs.html#documentation", "will only compute the <B>number</B> of such attributes within the part.", "PK Reference - PK_PART_ask_all_attribs");
top.note("headers/pk_part_ask_attribs_cb.html#declaration", " int *const n_attribs, --- <B>number</B> of attributes (>= 0)", "PK Reference - PK_PART_ask_attribs_cb");
top.note("headers/pk_part_ask_attribs_cb_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_PART_ask_attribs_cb_o_t");
top.note("headers/pk_part_ask_con_lattices.html#declaration", " int *const n_con_lattices, --- <B>number</B> of construction lattices (>=0)", "PK Reference - PK_PART_ask_con_lattices");
top.note("headers/pk_part_ask_con_lattices.html#documentation", "will only compute the <B>number</B> of construction lattices in the part.", "PK Reference - PK_PART_ask_con_lattices");
top.note("headers/pk_part_ask_construction_curves.html#declaration", " int *const n_con_curves, --- <B>number</B> of construction curves (>=0)", "PK Reference - PK_PART_ask_construction_curves");
top.note("headers/pk_part_ask_construction_curves.html#documentation", "will only compute the <B>number</B> of construction curves in the part.", "PK Reference - PK_PART_ask_construction_curves");
top.note("headers/pk_part_ask_construction_points.html#declaration", " int *const n_con_points, --- <B>number</B> of construction points (>=0)", "PK Reference - PK_PART_ask_construction_points");
top.note("headers/pk_part_ask_construction_points.html#documentation", "will only compute the <B>number</B> of construction points in the part.", "PK Reference - PK_PART_ask_construction_points");
top.note("headers/pk_part_ask_construction_surfs.html#declaration", " int *const n_con_surfs, --- <B>number</B> of construction surfaces (>=0)", "PK Reference - PK_PART_ask_construction_surfs");
top.note("headers/pk_part_ask_construction_surfs.html#documentation", "will only compute the <B>number</B> of construction surfaces in the part.", "PK Reference - PK_PART_ask_construction_surfs");
top.note("headers/pk_part_ask_geoms.html#declaration", " int *const n_geoms, --- <B>number</B> of geoms (>=0)", "PK Reference - PK_PART_ask_geoms");
top.note("headers/pk_part_ask_geoms.html#documentation", "will only compute the <B>number</B> of geometric entities in the part.", "PK Reference - PK_PART_ask_geoms");
top.note("headers/pk_part_ask_groups.html#declaration", " int *const n_groups, --- <B>number</B> of groups (>=0)", "PK Reference - PK_PART_ask_groups");
top.note("headers/pk_part_ask_groups.html#documentation", "will only compute the <B>number</B> of groups in the part.", "PK Reference - PK_PART_ask_groups");
top.note("headers/pk_part_ask_groups_2.html#declaration", " int *const n_groups, --- <B>number</B> of groups (>=0)", "PK Reference - PK_PART_ask_groups_2");
top.note("headers/pk_part_ask_groups_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_PART_ask_groups_o_t");
top.note("headers/pk_part_ask_groups_o_t.html#documentation", " want_groups n_groups , the <B>number</B> of groups satisfying the", "PK Reference - PK_PART_ask_groups_o_t");
top.note("headers/pk_part_ask_ref_instances.html#declaration", " int *const n_instances, --- <B>number</B> of instances (>=0)", "PK Reference - PK_PART_ask_ref_instances");
top.note("headers/pk_part_ask_ref_instances.html#documentation", "will only compute the <B>number</B> of instances referencing the part.", "PK Reference - PK_PART_ask_ref_instances");
top.note("headers/pk_part_delete_attribs.html#declaration", "int n_attdefs, --- <B>number</B> of attribute", "PK Reference - PK_PART_delete_attribs");
top.note("headers/pk_part_delete_attribs.html#documentation", "The function returns the <B>number</B> of such attributes deleted.", "PK Reference - PK_PART_delete_attribs");
top.note("headers/pk_part_delete_attribs_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_PART_delete_attribs_o_t");
top.note("headers/pk_part_receive.html#declaration", " int *const n_parts, --- <B>number</B> of parts received", "PK Reference - PK_PART_receive");
top.note("headers/pk_part_receive_b.html#declaration", " int *const n_parts, --- <B>number</B> of parts received", "PK Reference - PK_PART_receive_b");
top.note("headers/pk_part_receive_meshes.html#declaration", " int n_parts, --- <B>number</B> of parts", "PK Reference - PK_PART_receive_meshes");
top.note("headers/pk_part_receive_meshes_o_t.html#declaration", " int o_t_version; --- Version <B>number</B> of option structure", "PK Reference - PK_PART_receive_meshes_o_t");
top.note("headers/pk_part_receive_o_t.html#declaration", " --- version <B>number</B>", "PK Reference - PK_PART_receive_o_t");
top.note("headers/pk_part_receive_o_t.html#documentation", " the <B>number</B> of parts received from the transmit", "PK Reference - PK_PART_receive_o_t");
top.note("headers/pk_part_receive_u.html#declaration", " int *const n_parts, --- <B>number</B> of parts received", "PK Reference - PK_PART_receive_u");
top.note("headers/pk_part_rectify_identifiers.html#declaration", " int *const n_entities, --- <B>number</B> of entities with changed idents", "PK Reference - PK_PART_rectify_identifiers");
top.note("headers/pk_part_remove_geoms.html#declaration", "int n_geoms, --- <B>number</B> of geoms to be removed", "PK Reference - PK_PART_remove_geoms");
top.note("headers/pk_part_transmit.html#declaration", " int n_parts, --- <B>number</B> of parts", "PK Reference - PK_PART_transmit");
top.note("headers/pk_part_transmit_b.html#declaration", " int n_parts, --- <B>number</B> of parts", "PK Reference - PK_PART_transmit_b");
top.note("headers/pk_part_transmit_o_t.html#declaration", " --- version <B>number</B>", "PK Reference - PK_PART_transmit_o_t");
top.note("headers/pk_part_transmit_u.html#declaration", " int n_parts, --- <B>number</B> of parts", "PK Reference - PK_PART_transmit_u");
top.note("headers/pk_partition_advance_pmark_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_PARTITION_advance_pmark_o_t");
top.note("headers/pk_partition_ask_appitems.html#declaration", " int *const n_appitems, --- <B>number</B> of appitems (>= 0)", "PK Reference - PK_PARTITION_ask_appitems");
top.note("headers/pk_partition_ask_appitems.html#documentation", "will only compute the <B>number</B> of appitems in the partition.", "PK Reference - PK_PARTITION_ask_appitems");
top.note("headers/pk_partition_ask_assemblies.html#declaration", " int *const n_assemblies, --- <B>number</B> of assemblies (>= 0)", "PK Reference - PK_PARTITION_ask_assemblies");
top.note("headers/pk_partition_ask_assemblies.html#documentation", "will only compute the <B>number</B> of assemblies in the partition.", "PK Reference - PK_PARTITION_ask_assemblies");
top.note("headers/pk_partition_ask_bodies.html#declaration", " int *const n_bodies, --- <B>number</B> of bodies (>= 0)", "PK Reference - PK_PARTITION_ask_bodies");
top.note("headers/pk_partition_ask_bodies.html#documentation", "will only compute the <B>number</B> of bodies in the partition.", "PK Reference - PK_PARTITION_ask_bodies");
top.note("headers/pk_partition_ask_cloning.html#declaration", " int *const n_clone_records, --- <B>number</B> of clone", "PK Reference - PK_PARTITION_ask_cloning");
top.note("headers/pk_partition_ask_cloning_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_PARTITION_ask_cloning_o_t");
top.note("headers/pk_partition_ask_facet_geom.html#declaration", "int *const n_parts, --- <B>number</B> of parts", "PK Reference - PK_PARTITION_ask_facet_geom");
top.note("headers/pk_partition_ask_facet_geom_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of", "PK Reference - PK_PARTITION_ask_facet_geom_o_t");
top.note("headers/pk_partition_ask_facet_geom_o_t.html#documentation", " the <B>number</B> of such parts present.", "PK Reference - PK_PARTITION_ask_facet_geom_o_t");
top.note("headers/pk_partition_ask_geoms.html#declaration", " int *const n_geoms, --- <B>number</B> of geoms (>= 0)", "PK Reference - PK_PARTITION_ask_geoms");
top.note("headers/pk_partition_ask_geoms.html#documentation", "will only compute the <B>number</B> of geometric entities in the partition.", "PK Reference - PK_PARTITION_ask_geoms");
top.note("headers/pk_partition_ask_ki_lists.html#declaration", " int *const n_lists, --- <B>number</B> of lists (>= 0)", "PK Reference - PK_PARTITION_ask_ki_lists");
top.note("headers/pk_partition_ask_ki_lists.html#documentation", "will only compute the <B>number</B> of lists in the partition.", "PK Reference - PK_PARTITION_ask_ki_lists");
top.note("headers/pk_partition_ask_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_PARTITION_ask_o_t");
top.note("headers/pk_partition_ask_pmark_size.html#description", " This function returns the <B>number</B> of bytes of roll file which would be", "PK Reference - PK_PARTITION_ask_pmark_size");
top.note("headers/pk_partition_ask_pmarks.html#declaration", " int *const n_pmarks, --- <B>number</B> of pmarks (>= 1)", "PK Reference - PK_PARTITION_ask_pmarks");
top.note("headers/pk_partition_ask_pmarks.html#documentation", "will only compute the <B>number</B> of pmarks in the partition.", "PK Reference - PK_PARTITION_ask_pmarks");
top.note("headers/pk_partition_ask_pmarks_2_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_PARTITION_ask_pmarks_2_o_t");
top.note("headers/pk_partition_ask_pmarks_2_o_t.html#documentation", " <B>number</B> of pmarks requested.", "PK Reference - PK_PARTITION_ask_pmarks_2_o_t");
top.note("headers/pk_partition_ask_pmarks_2_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of returns structure", "PK Reference - PK_PARTITION_ask_pmarks_2_r_t");
top.note("headers/pk_partition_ask_pmarks_2_r_t.html#documentation", " n_pmarks the <B>number</B> of pmarks.", "PK Reference - PK_PARTITION_ask_pmarks_2_r_t");
top.note("headers/pk_partition_ask_r_t.html#declaration", " int r_t_version; --- version <B>number</B>", "PK Reference - PK_PARTITION_ask_r_t");
top.note("headers/pk_partition_ask_transfs.html#declaration", " int *const n_transfs, --- <B>number</B> of transforms (>= 0)", "PK Reference - PK_PARTITION_ask_transfs");
top.note("headers/pk_partition_ask_transfs.html#documentation", "will only compute the <B>number</B> of transforms in the partition.", "PK Reference - PK_PARTITION_ask_transfs");
top.note("headers/pk_partition_clone_pmark.html#declaration", "int *const n_new, --- <B>number</B> of entities", "PK Reference - PK_PARTITION_clone_pmark");
top.note("headers/pk_partition_copy_o_t.html#declaration", " --- version <B>number</B>", "PK Reference - PK_PARTITION_copy_o_t");
top.note("headers/pk_partition_create_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of structure", "PK Reference - PK_PARTITION_create_o_t");
top.note("headers/pk_partition_create_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of returns structure", "PK Reference - PK_PARTITION_create_r_t");
top.note("headers/pk_partition_delete_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_PARTITION_delete_o_t");
top.note("headers/pk_partition_entities_t.html#declaration", " int n_new; --- <B>number</B> of entities created", "PK Reference - PK_PARTITION_entities_t");
top.note("headers/pk_partition_goto_guard_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_PARTITION_goto_guard_o_t");
top.note("headers/pk_partition_goto_guard_r_t.html#declaration", " int r_t_version; --- version <B>number</B>", "PK Reference - PK_PARTITION_goto_guard_r_t");
top.note("headers/pk_partition_has_lattices_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_PARTITION_has_lattices_o_t");
top.note("headers/pk_partition_has_lattices_o_t.html#documentation", " will be returned, as well as the <B>number</B> of parts present.", "PK Reference - PK_PARTITION_has_lattices_o_t");
top.note("headers/pk_partition_has_lattices_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of returns structure", "PK Reference - PK_PARTITION_has_lattices_r_t");
top.note("headers/pk_partition_has_lattices_r_t.html#documentation", " n_parts The <B>number</B> of parts with lattice geometry in the partition", "PK Reference - PK_PARTITION_has_lattices_r_t");
top.note("headers/pk_partition_is_clone.html#declaration", "int *const n_entities, --- <B>number</B> of different", "PK Reference - PK_PARTITION_is_clone");
top.note("headers/pk_partition_is_clone_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_PARTITION_is_clone_o_t");
top.note("headers/pk_partition_merge.html#declaration", " int n_partitions, --- <B>number</B> of partitions", "PK Reference - PK_PARTITION_merge");
top.note("headers/pk_partition_merge_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_PARTITION_merge_o_t");
top.note("headers/pk_partition_receive_deltas_o_t.html#declaration", " --- version <B>number</B>", "PK Reference - PK_PARTITION_receive_deltas_o_t");
top.note("headers/pk_partition_receive_meshes.html#declaration", " int *const n_owners, --- <B>number</B> of owners", "PK Reference - PK_PARTITION_receive_meshes");
top.note("headers/pk_partition_receive_meshes_o_t.html#declaration", " int o_t_version; --- Version <B>number</B> of option structure", "PK Reference - PK_PARTITION_receive_meshes_o_t");
top.note("headers/pk_partition_receive_o_t.html#declaration", " --- version <B>number</B>", "PK Reference - PK_PARTITION_receive_o_t");
top.note("headers/pk_partition_receive_o_t.html#documentation", " the <B>number</B> of bodies received from the partition", "PK Reference - PK_PARTITION_receive_o_t");
top.note("headers/pk_partition_reset_attribs.html#declaration", "int n_attdefs, --- <B>number</B> of attdefs", "PK Reference - PK_PARTITION_reset_attribs");
top.note("headers/pk_partition_reset_attribs_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_PARTITION_reset_attribs_o_t");
top.note("headers/pk_partition_set_guard_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_PARTITION_set_guard_o_t");
top.note("headers/pk_partition_set_guard_r_t.html#declaration", " int r_t_version; --- version <B>number</B>", "PK Reference - PK_PARTITION_set_guard_r_t");
top.note("headers/pk_partition_start_cloning_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_PARTITION_start_cloning_o_t");
top.note("headers/pk_partition_stop_cloning_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_PARTITION_stop_cloning_o_t");
top.note("headers/pk_partition_transmit_delta_o_t.html#declaration", " --- version <B>number</B>", "PK Reference - PK_PARTITION_transmit_delta_o_t");
top.note("headers/pk_partition_transmit_o_t.html#declaration", " --- version <B>number</B>", "PK Reference - PK_PARTITION_transmit_o_t");
top.note("headers/pk_pattern_axial_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of structure", "PK Reference - PK_pattern_axial_o_t");
top.note("headers/pk_pattern_axial_o_t.html#documentation", " reps_per_period <B>Number</B> of repetitions that would form a full period", "PK Reference - PK_pattern_axial_o_t");
top.note("headers/pk_pattern_bound_t.html#documentation", " provided <B>number</B> of repetitions in the direction", "PK Reference - PK_pattern_bound_t");
top.note("headers/pk_pattern_callback_t.html#declaration", " int max_cb_positions; --- maximum <B>number</B> of positions", "PK Reference - PK_pattern_callback_t");
top.note("headers/pk_pattern_callback_t.html#documentation", " max_cb_positions Maximum <B>number</B> of positions passed per call to pattern_cb ", "PK Reference - PK_pattern_callback_t");
top.note("headers/pk_pattern_cb_f_t.html#declaration", " --- <B>number</B> of positions", "PK Reference - PK_pattern_cb_f_t");
top.note("headers/pk_pattern_cb_f_t.html#documentation", " n_receive_positions is equal to the <B>number</B> of elements in", "PK Reference - PK_pattern_cb_f_t");
top.note("headers/pk_pattern_cb_o_t.html#declaration", " int o_t_version; --- Version <B>number</B> of options", "PK Reference - PK_pattern_cb_o_t");
top.note("headers/pk_pattern_face_map_t.html#declaration", " int n_loops; --- <B>number</B> of boundary loops which", "PK Reference - PK_pattern_face_map_t");
top.note("headers/pk_pattern_face_map_t.html#documentation", " n_loops <B>number</B> of boundary loops which support the pattern", "PK Reference - PK_pattern_face_map_t");
top.note("headers/pk_pattern_rectilinear_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of structure", "PK Reference - PK_pattern_rectilinear_o_t");
top.note("headers/pk_pattern_trim_data_t.html#declaration", " int n_curves; --- <B>number</B> of trimming curves", "PK Reference - PK_pattern_trim_data_t");
top.note("headers/pk_plane_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_PLANE_array_t");
top.note("headers/pk_pline_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_PLINE_array_t");
top.note("headers/pk_pline_sf_t.html#documentation", " n_positions The <B>number</B> of elements in the positions array.", "PK Reference - PK_PLINE_sf_t");
top.note("headers/pk_pmark_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_PMARK_array_t");
top.note("headers/pk_pmark_ask_entities.html#declaration", " int *const n_new, --- <B>number</B> of entities created", "PK Reference - PK_PMARK_ask_entities");
top.note("headers/pk_pmark_ask_entities_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_PMARK_ask_entities_o_t");
top.note("headers/pk_pmark_ask_following.html#declaration", " int *const n_following, --- <B>number</B> of following pmarks", "PK Reference - PK_PMARK_ask_following");
top.note("headers/pk_pmark_ask_following.html#documentation", "will only compute the <B>number</B> of following pmarks of the pmark.", "PK Reference - PK_PMARK_ask_following");
top.note("headers/pk_pmark_ask_marks.html#declaration", " int *const n_marks, --- <B>number</B> of marks of pmark", "PK Reference - PK_PMARK_ask_marks");
top.note("headers/pk_pmark_ask_marks.html#documentation", "will only compute the <B>number</B> of marks using the given pmark .", "PK Reference - PK_PMARK_ask_marks");
top.note("headers/pk_pmark_delete.html#declaration", " int n_pmarks, --- <B>number</B> of pmarks", "PK Reference - PK_PMARK_delete");
top.note("headers/pk_pmark_delete.html#documentation", "There are a <B>number</B> of restrictions on pmarks which can be deleted.", "PK Reference - PK_PMARK_delete");
top.note("headers/pk_pmark_goto.html#declaration", " int *const n_new, --- <B>number</B> of entities created", "PK Reference - PK_PMARK_goto");
top.note("headers/pk_pmark_goto_2.html#declaration", " int *const n_new, --- <B>number</B> of entities created", "PK Reference - PK_PMARK_goto_2");
top.note("headers/pk_pmark_goto_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_PMARK_goto_o_t");
top.note("headers/pk_point_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_POINT_array_t");
top.note("headers/pk_point_make_helical_curve.html#documentation", "<B>number</B> of turns in both directions. The curve will", "PK Reference - PK_POINT_make_helical_curve");
top.note("headers/pk_region_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_REGION_array_t");
top.note("headers/pk_region_ask_lattices_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_REGION_ask_lattices_o_t");
top.note("headers/pk_region_ask_lattices_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_REGION_ask_lattices_r_t");
top.note("headers/pk_region_ask_lattices_r_t.html#documentation", " n_lattices The <B>number</B> of lattices embedded in region .", "PK Reference - PK_REGION_ask_lattices_r_t");
top.note("headers/pk_region_ask_regions_adjacent.html#declaration", " int *n_regions_adjacent, --- <B>number</B> of adjacent regions", "PK Reference - PK_REGION_ask_regions_adjacent");
top.note("headers/pk_region_ask_shells.html#declaration", " int *const n_shells, --- <B>number</B> of shells (>= 0)", "PK Reference - PK_REGION_ask_shells");
top.note("headers/pk_region_ask_shells.html#documentation", "will only compute the <B>number</B> of shells bounding the region.", "PK Reference - PK_REGION_ask_shells");
top.note("headers/pk_region_ask_type_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_REGION_ask_type_o_t");
top.note("headers/pk_region_ask_type_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of returns", "PK Reference - PK_REGION_ask_type_r_t");
top.note("headers/pk_region_embed_lattices.html#declaration", "int n_lattices, --- <B>number</B> of lattices", "PK Reference - PK_REGION_embed_lattices");
top.note("headers/pk_region_embed_lattices_o_t.html#declaration", " int o_t_version; --- Version <B>number</B> of options", "PK Reference - PK_REGION_embed_lattices_o_t");
top.note("headers/pk_region_embed_lattices_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_REGION_embed_lattices_r_t");
top.note("headers/pk_region_imprint_curve.html#declaration", " int *const n_new_edges, --- <B>number</B> of new edges", "PK Reference - PK_REGION_imprint_curve");
top.note("headers/pk_region_imprint_curve.html#documentation", "to NULL then only the <B>number</B> of new edges and/or faces will be returned.", "PK Reference - PK_REGION_imprint_curve");
top.note("headers/pk_region_remove_lattice_o_t.html#declaration", " --- Version <B>number</B> of options", "PK Reference - PK_REGION_remove_lattice_o_t");
top.note("headers/pk_region_remove_lattice_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_REGION_remove_lattice_r_t");
top.note("headers/pk_render_param_t.html#documentation", " : parametric hatch with the <B>number</B> of", "PK Reference - PK_render_param_t");
top.note("headers/pk_replace_edge_data_t.html#declaration", " int n_edges; --- <B>number</B> of edges (0)", "PK Reference - PK_replace_edge_data_t");
top.note("headers/pk_replace_edge_data_t.html#documentation", " n_edges <B>Number</B> of edges. Length of the edges , curves and", "PK Reference - PK_replace_edge_data_t");
top.note("headers/pk_replace_help_points_t.html#declaration", " int n_topologies; --- <B>number</B> of topologies (0)", "PK Reference - PK_replace_help_points_t");
top.note("headers/pk_replace_help_points_t.html#documentation", " n_topologies <B>Number</B> of topologies to help modify. Length of the", "PK Reference - PK_replace_help_points_t");
top.note("headers/pk_replace_patch_data_t.html#declaration", " int n_matches; --- <B>number</B> of matched faces (0)", "PK Reference - PK_replace_patch_data_t");
top.note("headers/pk_replace_patch_data_t.html#documentation", " n_matches <B>Number</B> of matched faces, i.e. the length of tool_patches ", "PK Reference - PK_replace_patch_data_t");
top.note("headers/pk_replace_variation_data_t.html#declaration", " int n_variation_faces; --- <B>number</B> of faces (0)", "PK Reference - PK_replace_variation_data_t");
top.note("headers/pk_replace_variation_data_t.html#documentation", " n_variation_faces <B>Number</B> of faces.", "PK Reference - PK_replace_variation_data_t");
top.note("headers/pk_replace_vertex_data_t.html#declaration", " int n_vertices; --- <B>number</B> of vertices (0)", "PK Reference - PK_replace_vertex_data_t");
top.note("headers/pk_replace_vertex_data_t.html#documentation", " n_vertices <B>Number</B> of vertices to modify. Length of the", "PK Reference - PK_replace_vertex_data_t");
top.note("headers/pk_report_3_t.html#documentation", " of n+1 old_item_arrays , where n is the <B>number</B> of underlying", "PK Reference - PK_REPORT_3_t");
top.note("headers/pk_report_4_t.html#documentation", " 4 int_arrays each of length equal to the <B>number</B> of meshes for", "PK Reference - PK_REPORT_4_t");
top.note("headers/pk_report_add_records.html#declaration", "int n_report_records, --- <B>number</B> of report records", "PK Reference - PK_REPORT_add_records");
top.note("headers/pk_report_r_t.html#declaration", " int n_report_records; --- <B>number</B> of report records", "PK Reference - PK_REPORT_r_t");
top.note("headers/pk_report_r_t.html#documentation", " n_report_records the <B>number</B> of report records in the report", "PK Reference - PK_REPORT_r_t");
top.note("headers/pk_report_record_1_t.html#declaration", " int n_old_items; --- <B>number</B> of original items", "PK Reference - PK_REPORT_record_1_t");
top.note("headers/pk_report_record_1_t.html#documentation", " n_old_items the <B>number</B> of reported items which existed before the", "PK Reference - PK_REPORT_record_1_t");
top.note("headers/pk_report_record_2_t.html#declaration", " int n_old_item_arrays; --- <B>number</B> of original item arrays", "PK Reference - PK_REPORT_record_2_t");
top.note("headers/pk_report_record_2_t.html#documentation", " n_old_item_arrays the <B>number</B> of structs stored in old_item_arrays and", "PK Reference - PK_REPORT_record_2_t");
top.note("headers/pk_report_record_3_t.html#declaration", " int n_int_arrays; --- <B>number</B> of int arrays", "PK Reference - PK_REPORT_record_3_t");
top.note("headers/pk_report_record_3_t.html#documentation", " n_int_arrays the <B>number</B> of integer arrays", "PK Reference - PK_REPORT_record_3_t");
top.note("headers/pk_report_record_4_t.html#declaration", " int n_int_arrays; --- <B>number</B> of int arrays", "PK Reference - PK_REPORT_record_4_t");
top.note("headers/pk_report_record_4_t.html#documentation", " n_int_arrays the <B>number</B> of integer arrays", "PK Reference - PK_REPORT_record_4_t");
top.note("headers/pk_section_2_r_t.html#declaration", " int n_front_bodies; --- <B>number</B> of front bodies", "PK Reference - PK_section_2_r_t");
top.note("headers/pk_section_2_r_t.html#documentation", " n_front_bodies The <B>number</B> of bodies in the front_bodies array.", "PK Reference - PK_section_2_r_t");
top.note("headers/pk_session_ask_attdefs.html#declaration", " int *const n_attdefs, --- <B>number</B> of attribute", "PK Reference - PK_SESSION_ask_attdefs");
top.note("headers/pk_session_ask_attdefs_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_SESSION_ask_attdefs_o_t");
top.note("headers/pk_session_ask_behaviour_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_SESSION_ask_behaviour_o_t");
top.note("headers/pk_session_ask_err_reports_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_SESSION_ask_err_reports_o_t");
top.note("headers/pk_session_ask_fru_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_SESSION_ask_fru_o_t");
top.note("headers/pk_session_ask_max_threads.html#description", " This function returns the maximum <B>number</B> of threads which Parasolid can", "PK Reference - PK_SESSION_ask_max_threads");
top.note("headers/pk_session_ask_max_threads.html#documentation", "This <B>number</B> depends on the values returned by PK_SESSION_ask_smp ", "PK Reference - PK_SESSION_ask_max_threads");
top.note("headers/pk_session_ask_max_threads_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_SESSION_ask_max_threads_o_t");
top.note("headers/pk_session_ask_partitions.html#declaration", " int *const n_partitions, --- <B>number</B> of partitions (>= 0)", "PK Reference - PK_SESSION_ask_partitions");
top.note("headers/pk_session_ask_partitions.html#documentation", "will only compute the <B>number</B> of partitions in the session.", "PK Reference - PK_SESSION_ask_partitions");
top.note("headers/pk_session_ask_parts.html#declaration", " int *const n_parts, --- <B>number</B> of parts (>= 0)", "PK Reference - PK_SESSION_ask_parts");
top.note("headers/pk_session_ask_parts.html#documentation", "will only compute the <B>number</B> of parts in the session.", "PK Reference - PK_SESSION_ask_parts");
top.note("headers/pk_session_ask_tags_remaining.html#declaration", " int *const tags_remaining --- <B>number</B> of available unused tags", "PK Reference - PK_SESSION_ask_tags_remaining");
top.note("headers/pk_session_ask_tags_remaining.html#description", " This function returns the current <B>number</B> of tags which are available for", "PK Reference - PK_SESSION_ask_tags_remaining");
top.note("headers/pk_session_behaviour_t.html#documentation", " major version <B>number</B>, mm is the minor version <B>number</B>", "PK Reference - PK_SESSION_behaviour_t");
top.note("headers/pk_session_indexio_t.html#documentation", " given buffer and returning the actual <B>number</B> of bytes read", "PK Reference - PK_SESSION_indexio_t");
top.note("headers/pk_session_kernel_version_t.html#declaration", " int build_number; --- Value of current build <B>number</B> of the kernel.", "PK Reference - PK_SESSION_kernel_version_t");
top.note("headers/pk_session_receive_o_t.html#declaration", " --- version <B>number</B>", "PK Reference - PK_SESSION_receive_o_t");
top.note("headers/pk_session_register_fru_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_SESSION_register_fru_o_t");
top.note("headers/pk_session_schema_version_t.html#documentation", " <B>number</B>, the third digit is the minor version <B>number</B>", "PK Reference - PK_SESSION_schema_version_t");
top.note("headers/pk_session_set_behaviour_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_SESSION_set_behaviour_o_t");
top.note("headers/pk_session_set_err_reports_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_SESSION_set_err_reports_o_t");
top.note("headers/pk_session_smp_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_SESSION_smp_o_t");
top.note("headers/pk_session_smp_o_t.html#documentation", " determines the <B>number</B> of threads to be", "PK Reference - PK_SESSION_smp_o_t");
top.note("headers/pk_session_smp_r_t.html#documentation", " determines the <B>number</B> of threads that will", "PK Reference - PK_SESSION_smp_r_t");
top.note("headers/pk_session_start_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of this option structure", "PK Reference - PK_SESSION_start_o_t");
top.note("headers/pk_session_transmit_o_t.html#declaration", " --- version <B>number</B>", "PK Reference - PK_SESSION_transmit_o_t");
top.note("headers/pk_session_watch_tags.html#declaration", " int n_tags, --- <B>number</B> of tags", "PK Reference - PK_SESSION_watch_tags");
top.note("headers/pk_shell_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_SHELL_array_t");
top.note("headers/pk_shell_ask_oriented_faces.html#declaration", " int *const n_faces, --- <B>number</B> of faces (>= 0)", "PK Reference - PK_SHELL_ask_oriented_faces");
top.note("headers/pk_shell_ask_oriented_faces.html#documentation", "the function will only compute the <B>number</B> of faces in the shell (with repeats).", "PK Reference - PK_SHELL_ask_oriented_faces");
top.note("headers/pk_shell_ask_wireframe_edges.html#declaration", " int *const n_edges, --- <B>number</B> of wireframe edges (>= 0)", "PK Reference - PK_SHELL_ask_wireframe_edges");
top.note("headers/pk_shell_ask_wireframe_edges.html#documentation", "will only return the <B>number</B> of wireframe edges in the shell.", "PK Reference - PK_SHELL_ask_wireframe_edges");
top.note("headers/pk_spcurve_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_SPCURVE_array_t");
top.note("headers/pk_sphere_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_SPHERE_array_t");
top.note("headers/pk_spun_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_SPUN_array_t");
top.note("headers/pk_surf_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_SURF_array_t");
top.note("headers/pk_surf_ask_faces.html#declaration", " int *const n_faces, --- <B>number</B> of faces (>= 0)", "PK Reference - PK_SURF_ask_faces");
top.note("headers/pk_surf_ask_faces.html#documentation", "will only compute the <B>number</B> of faces lying on a surface.", "PK Reference - PK_SURF_ask_faces");
top.note("headers/pk_surf_create_blend_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_SURF_create_blend_o_t");
top.note("headers/pk_surf_degens_t.html#declaration", " int n_degen; --- <B>number</B> of degeneracies", "PK Reference - PK_SURF_degens_t");
top.note("headers/pk_surf_degens_t.html#documentation", " n_degen The <B>number</B> of degeneracies on the surface.", "PK Reference - PK_SURF_degens_t");
top.note("headers/pk_surf_eval.html#declaration", "int n_u_derivs, --- <B>number</B> of u derivatives [NF]", "PK Reference - PK_SURF_eval");
top.note("headers/pk_surf_eval.html#documentation", "There is a limit on the <B>number</B> of derivatives which may be requested.", "PK Reference - PK_SURF_eval");
top.note("headers/pk_surf_eval_grid.html#declaration", "int n_u, --- <B>number</B> of u parameters", "PK Reference - PK_SURF_eval_grid");
top.note("headers/pk_surf_eval_handed.html#declaration", "int n_u_derivs, --- <B>number</B> of u derivatives [NF]", "PK Reference - PK_SURF_eval_handed");
top.note("headers/pk_surf_eval_with_normal.html#declaration", "int n_u_derivs, --- <B>number</B> of u derivatives [NF]", "PK Reference - PK_SURF_eval_with_normal");
top.note("headers/pk_surf_eval_with_normal_handed.html#declaration", "int n_u_derivs, --- <B>number</B> of u derivatives", "PK Reference - PK_SURF_eval_with_normal_handed");
top.note("headers/pk_surf_find_curves_common.html#declaration", " int *const n_curves, --- <B>number</B> of common curves", "PK Reference - PK_SURF_find_curves_common");
top.note("headers/pk_surf_find_degens_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_SURF_find_degens_o_t");
top.note("headers/pk_surf_find_discontinuity.html#declaration", " int *const n_params, --- <B>number</B> of discontinuities", "PK Reference - PK_SURF_find_discontinuity");
top.note("headers/pk_surf_find_min_radii.html#declaration", " int *const n_radii, --- <B>number</B> of radii returned", "PK Reference - PK_SURF_find_min_radii");
top.note("headers/pk_surf_find_self_int_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_SURF_find_self_int_o_t");
top.note("headers/pk_surf_find_vectors_o_t.html#declaration", " int n_measurements; --- <B>number</B> of measurements", "PK Reference - PK_SURF_find_vectors_o_t");
top.note("headers/pk_surf_find_vectors_o_t.html#documentation", "The <B>number</B> of values supplied in measurements .", "PK Reference - PK_SURF_find_vectors_o_t");
top.note("headers/pk_surf_fix_degens_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_SURF_fix_degens_o_t");
top.note("headers/pk_surf_fix_degens_o_t.html#documentation", " n_normals <B>Number</B> of normals supplied. (0)", "PK Reference - PK_SURF_fix_degens_o_t");
top.note("headers/pk_surf_fix_self_int_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_SURF_fix_self_int_o_t");
top.note("headers/pk_surf_fix_self_int_r_t.html#documentation", " n_surfs The <B>number</B> of resultant surfaces.", "PK Reference - PK_SURF_fix_self_int_r_t");
top.note("headers/pk_surf_general_eval_f_t.html#declaration", "int n_u_derivs, --- <B>number</B> of u derivatives", "PK Reference - PK_SURF_general_eval_f_t");
top.note("headers/pk_surf_general_eval_f_t.html#documentation", "The maximum <B>number</B> of derivatives that can be returned by this", "PK Reference - PK_SURF_general_eval_f_t");
top.note("headers/pk_surf_general_user_t.html#declaration", " int n_u_discontinuities; --- <B>number</B> of params in", "PK Reference - PK_SURF_general_user_t");
top.note("headers/pk_surf_general_user_t.html#documentation", " n_u_discontinuities The <B>number</B> of u parameters at which the surface has", "PK Reference - PK_SURF_general_user_t");
top.note("headers/pk_surf_intersect_curve.html#declaration", " int *const n_vectors, --- <B>number</B> of intersections", "PK Reference - PK_SURF_intersect_curve");
top.note("headers/pk_surf_intersect_curve_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_SURF_intersect_curve_o_t");
top.note("headers/pk_surf_intersect_surf.html#declaration", " int *const n_vectors, --- <B>number</B> of point intersections", "PK Reference - PK_SURF_intersect_surf");
top.note("headers/pk_surf_intersect_surf.html#documentation", " make point contact. n_vectors indicates the <B>number</B> of intersection points.", "PK Reference - PK_SURF_intersect_surf");
top.note("headers/pk_surf_intersect_surf_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_SURF_intersect_surf_o_t");
top.note("headers/pk_surf_make_bsurf_array.html#declaration", " int n_surfs, --- <B>number</B> of surfaces", "PK Reference - PK_SURF_make_bsurf_array");
top.note("headers/pk_surf_make_curve_isoparam_o_t.html#declaration", "int o_t_version; --- version <B>number</B>", "PK Reference - PK_SURF_make_curve_isoparam_o_t");
top.note("headers/pk_surf_make_curves_isocline.html#declaration", " int *const n_curves, --- <B>number</B> of isocline curves (>= 0)", "PK Reference - PK_SURF_make_curves_isocline");
top.note("headers/pk_surf_make_curves_isocline.html#documentation", "The <B>number</B> of isocline curves created is returned as n_curves", "PK Reference - PK_SURF_make_curves_isocline");
top.note("headers/pk_surf_make_cus_isocline.html#declaration", " int *const n_curves, --- <B>number</B> of isocline curves (>= 0)", "PK Reference - PK_SURF_make_cus_isocline");
top.note("headers/pk_surf_make_cus_isocline.html#documentation", "The <B>number</B> of isocline curves created is returned as n_curves", "PK Reference - PK_SURF_make_cus_isocline");
top.note("headers/pk_surf_make_cus_isocline_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_SURF_make_cus_isocline_o_t");
top.note("headers/pk_surf_self_int_t.html#documentation", " n_positions Indicates the <B>number</B> of positions returned. Currently this", "PK Reference - PK_SURF_self_int_t");
top.note("headers/pk_surf_self_ints_t.html#declaration", " int n_self_int; --- <B>number</B> of self-intersections", "PK Reference - PK_SURF_self_ints_t");
top.note("headers/pk_surf_self_ints_t.html#documentation", " n_self_int The <B>number</B> of self-intersections on the surface.", "PK Reference - PK_SURF_self_ints_t");
top.note("headers/pk_surf_trim_data_t.html#declaration", " int n_spcurves; --- <B>number</B> of trimming curves", "PK Reference - PK_SURF_trim_data_t");
top.note("headers/pk_sweep_face_clamp_t.html#declaration", " int n_edges; --- <B>number</B> of clamping faces and", "PK Reference - PK_sweep_face_clamp_t");
top.note("headers/pk_sweep_guide_clamp_dirn_t.html#declaration", " int n_directions; --- the <B>number</B> of clamp directions (0)", "PK Reference - PK_sweep_guide_clamp_dirn_t");
top.note("headers/pk_sweep_guide_clamp_dirn_t.html#documentation", " n_directions The <B>number</B> of clamp directions. This must equal the value", "PK Reference - PK_sweep_guide_clamp_dirn_t");
top.note("headers/pk_sweep_guide_control_t.html#documentation", " to the <B>number</B> of profiles. For each profile, a guide vertex", "PK Reference - PK_sweep_guide_control_t");
top.note("headers/pk_swept_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_SWEPT_array_t");
top.note("headers/pk_thread_ask_err_reports_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_THREAD_ask_err_reports_o_t");
top.note("headers/pk_thread_ask_function_run.html#declaration", " int n_functions, --- <B>number</B> of functions", "PK Reference - PK_THREAD_ask_function_run");
top.note("headers/pk_thread_ask_function_run_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_THREAD_ask_function_run_o_t");
top.note("headers/pk_thread_ask_local_level_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_THREAD_ask_local_level_o_t");
top.note("headers/pk_thread_ask_partitions_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_THREAD_ask_partitions_o_t");
top.note("headers/pk_thread_chain_start.html#documentation", "that at most that <B>number</B> of Parasolid functions will be in each link.", "PK Reference - PK_THREAD_chain_start");
top.note("headers/pk_thread_chain_start_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_THREAD_chain_start_o_t");
top.note("headers/pk_thread_chain_start_o_t.html#documentation", " length Maximum <B>number</B> of Parasolid functions in each chain link. The", "PK Reference - PK_THREAD_chain_start_o_t");
top.note("headers/pk_thread_chain_stop_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_THREAD_chain_stop_o_t");
top.note("headers/pk_thread_is_in_chain.html#description", "with its link length and the maximum <B>number</B> of remaining functions in the", "PK Reference - PK_THREAD_is_in_chain");
top.note("headers/pk_thread_lock_partitions_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_THREAD_lock_partitions_o_t");
top.note("headers/pk_thread_lock_partitions_r_t.html#documentation", " n_locked_partitions The <B>number</B> of partitions in the", "PK Reference - PK_THREAD_lock_partitions_r_t");
top.note("headers/pk_thread_set_err_reports_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_THREAD_set_err_reports_o_t");
top.note("headers/pk_thread_set_function_run.html#declaration", " int n_functions, --- <B>number</B> of functions", "PK Reference - PK_THREAD_set_function_run");
top.note("headers/pk_thread_set_function_run_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_THREAD_set_function_run_o_t");
top.note("headers/pk_thread_set_id_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_THREAD_set_id_o_t");
top.note("headers/pk_thread_set_id_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of returns structure", "PK Reference - PK_THREAD_set_id_r_t");
top.note("headers/pk_thread_t.html#documentation", " PK_thread_per_processor_c <B>Number</B> of threads set on a per processor basis", "PK Reference - PK_thread_t");
top.note("headers/pk_thread_unlock_partitions_o_t.html#declaration", " int o_t_version; --- version <B>number</B>", "PK Reference - PK_THREAD_unlock_partitions_o_t");
top.note("headers/pk_topol_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_TOPOL_array_t");
top.note("headers/pk_topol_ask_entities_by_attdef.html#declaration", " int *const n_entities, --- <B>number</B> of entities ( >= 0 )", "PK Reference - PK_TOPOL_ask_entities_by_attdef");
top.note("headers/pk_topol_ask_entities_by_attdef.html#documentation", "will only compute the <B>number</B> of entities.", "PK Reference - PK_TOPOL_ask_entities_by_attdef");
top.note("headers/pk_topol_categorise_geom_o_t.html#declaration", "int o_t_version; --- version <B>number</B>", "PK Reference - PK_TOPOL_categorise_geom_o_t");
top.note("headers/pk_topol_clash.html#declaration", " const int n_targets, --- <B>Number</B> of target topologies", "PK Reference - PK_TOPOL_clash");
top.note("headers/pk_topol_clash.html#documentation", "If clashes are found, then n_clash is the <B>number</B> of clashes found", "PK Reference - PK_TOPOL_clash");
top.note("headers/pk_topol_clash_o_t.html#declaration", " int n_op_ex; --- <B>Number</B> of body pairs that may be ignored", "PK Reference - PK_TOPOL_clash_o_t");
top.note("headers/pk_topol_clash_o_t.html#documentation", " n_op_ex <B>Number</B> of topology exclusion body pairs.", "PK Reference - PK_TOPOL_clash_o_t");
top.note("headers/pk_topol_delete_redundant_2.html#declaration", " int n_topols, --- <B>number</B> of topols", "PK Reference - PK_TOPOL_delete_redundant_2");
top.note("headers/pk_topol_delete_redundant_2_o_t.html#declaration", "int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_TOPOL_delete_redundant_2_o_t");
top.note("headers/pk_topol_delete_redundant_2_o_t.html#documentation", " typically increase the <B>number</B> of vertices which are", "PK Reference - PK_TOPOL_delete_redundant_2_o_t");
top.note("headers/pk_topol_eval_mass_props.html#declaration", " int n_topols, --- <B>number</B> of topols ( >0 )", "PK Reference - PK_TOPOL_eval_mass_props");
top.note("headers/pk_topol_eval_mass_props.html#documentation", " 0 <B>Number</B> of vertices", "PK Reference - PK_TOPOL_eval_mass_props");
top.note("headers/pk_topol_eval_mass_props_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_TOPOL_eval_mass_props_o_t");
top.note("headers/pk_topol_eval_mass_props_o_t.html#documentation", " n_transfs Specifies the <B>number</B> of transformations supplied to be", "PK Reference - PK_TOPOL_eval_mass_props_o_t");
top.note("headers/pk_topol_facet.html#declaration", " const int n_topols, --- <B>number</B> of entities", "PK Reference - PK_TOPOL_facet");
top.note("headers/pk_topol_facet.html#documentation", " generation options include parameters such as the maximum <B>number</B>", "PK Reference - PK_TOPOL_facet");
top.note("headers/pk_topol_facet_2.html#declaration", " const int n_topols, --- <B>number</B> of entities", "PK Reference - PK_TOPOL_facet_2");
top.note("headers/pk_topol_facet_2.html#documentation", " generation options include parameters such as the maximum <B>number</B>", "PK Reference - PK_TOPOL_facet_2");
top.note("headers/pk_topol_facet_2_r_t.html#description", " The PK_TOPOL_facet_2_r_t structure returns the total <B>number</B> of facets, strips", "PK Reference - PK_TOPOL_facet_2_r_t");
top.note("headers/pk_topol_facet_2_r_t.html#documentation", "The returned structure always returns the <B>number</B> of facets, strips and fins in", "PK Reference - PK_TOPOL_facet_2_r_t");
top.note("headers/pk_topol_facet_choice_2_o_t.html#documentation", "can be used to limit the <B>number</B> of facets per strip.", "PK Reference - PK_TOPOL_facet_choice_2_o_t");
top.note("headers/pk_topol_facet_choice_o_t.html#documentation", "current version <B>number</B> of the PK_TOPOL_facet_choice_o_t structure and", "PK Reference - PK_TOPOL_facet_choice_o_t");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#declaration", " int max_facet_sides; --- max <B>number</B> of sides on a facet (3)", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#errors", " PK_ERROR_nitems_lt_0 negative <B>number</B> of items in loop array.", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#documentation", " Parasolid has a <B>number</B> of requirements on the view transformations used", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#declaration", " int max_facet_sides; --- max <B>number</B> of sides on a facet (3)", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#errors", " PK_ERROR_nitems_lt_0 negative <B>number</B> of items in loop array.", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#documentation", " A <B>number</B> of the mesh options require a viewing matrix", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_facet_r_t.html#description", " The PK_TOPOL_facet_r_t structure returns the total <B>number</B> of facets, fins and", "PK Reference - PK_TOPOL_facet_r_t");
top.note("headers/pk_topol_facet_r_t.html#documentation", "The returned structure always calculates and returns the <B>number</B> of facets,", "PK Reference - PK_TOPOL_facet_r_t");
top.note("headers/pk_topol_fctab_fin_data_t.html#documentation", " than n data indices, where n is the <B>number</B> of faces", "PK Reference - PK_TOPOL_fctab_fin_data_t");
top.note("headers/pk_topol_fctab_strip_zigzag_t.html#documentation", "The first facet strip contains an even <B>number</B> of facets, its strip_zigzag is", "PK Reference - PK_TOPOL_fctab_strip_zigzag_t");
top.note("headers/pk_topol_fctab_vertex_point_t.html#documentation", "The vertex normal index is provided because the <B>number</B> of vertex normals", "PK Reference - PK_TOPOL_fctab_vertex_point_t");
top.note("headers/pk_topol_find_box_2.html#declaration", " int n_topols, --- <B>number</B> of topologies", "PK Reference - PK_TOPOL_find_box_2");
top.note("headers/pk_topol_find_box_2_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_TOPOL_find_box_2_o_t");
top.note("headers/pk_topol_find_box_2_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return structure", "PK Reference - PK_TOPOL_find_box_2_r_t");
top.note("headers/pk_topol_find_box_2_r_t.html#documentation", " equal to the <B>number</B> of topologies supplied. Otherwise", "PK Reference - PK_TOPOL_find_box_2_r_t");
top.note("headers/pk_topol_find_frames_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_TOPOL_find_frames_o_t");
top.note("headers/pk_topol_find_frames_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of returns structure", "PK Reference - PK_TOPOL_find_frames_r_t");
top.note("headers/pk_topol_find_frames_r_t.html#documentation", " n_frames The <B>number</B> of frames associated with topol ", "PK Reference - PK_TOPOL_find_frames_r_t");
top.note("headers/pk_topol_find_nabox.html#declaration", " int n_topols, --- <B>number</B> of entities", "PK Reference - PK_TOPOL_find_nabox");
top.note("headers/pk_topol_find_nabox_o_t.html#declaration", " int o_t_version; --- options structure version <B>number</B>", "PK Reference - PK_TOPOL_find_nabox_o_t");
top.note("headers/pk_topol_identify_redundant.html#declaration", " int n_topols, --- <B>number</B> of topols", "PK Reference - PK_TOPOL_identify_redundant");
top.note("headers/pk_topol_identify_redundant_o_t.html#declaration", "int o_t_version; --- version <B>number</B> of options", "PK Reference - PK_TOPOL_identify_redundant_o_t");
top.note("headers/pk_topol_identify_redundant_o_t.html#documentation", " If the value is PK_LOGICAL_false, only the <B>number</B> of", "PK Reference - PK_TOPOL_identify_redundant_o_t");
top.note("headers/pk_topol_imprint_frames.html#declaration", " int n_topols, --- <B>number</B> of topologies", "PK Reference - PK_TOPOL_imprint_frames");
top.note("headers/pk_topol_imprint_frames_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of options structure", "PK Reference - PK_TOPOL_imprint_frames_o_t");
top.note("headers/pk_topol_imprint_frames_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of returns structure", "PK Reference - PK_TOPOL_imprint_frames_r_t");
top.note("headers/pk_topol_imprint_frames_r_t.html#documentation", " one or more records are created. The <B>number</B> and type of records", "PK Reference - PK_TOPOL_imprint_frames_r_t");
top.note("headers/pk_topol_local_r_t.html#documentation", " is indicated by the status field, then the <B>number</B> of", "PK Reference - PK_TOPOL_local_r_t");
top.note("headers/pk_topol_make_facet_topol.html#declaration", " int n_topols, --- <B>Number</B> of entities", "PK Reference - PK_TOPOL_make_facet_topol");
top.note("headers/pk_topol_make_general_body.html#declaration", " int n_topols, --- <B>number</B> of topologies (> 0)", "PK Reference - PK_TOPOL_make_general_body");
top.note("headers/pk_topol_make_new_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_TOPOL_make_new_o_t");
top.note("headers/pk_topol_range_array_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_TOPOL_range_array_o_t");
top.note("headers/pk_topol_range_array_vector_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of", "PK Reference - PK_TOPOL_range_array_vector_o_t");
top.note("headers/pk_topol_range_geom_array_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_TOPOL_range_geom_array_o_t");
top.note("headers/pk_topol_range_geom_array_o_t.html#documentation", " the <B>number</B> of the geometrical entities provided.", "PK Reference - PK_TOPOL_range_geom_array_o_t");
top.note("headers/pk_topol_range_geom_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_TOPOL_range_geom_o_t");
top.note("headers/pk_topol_range_local_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_TOPOL_range_local_o_t");
top.note("headers/pk_topol_range_local_vector_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_TOPOL_range_local_vector_o_t");
top.note("headers/pk_topol_range_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_TOPOL_range_o_t");
top.note("headers/pk_topol_range_vector_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option", "PK Reference - PK_TOPOL_range_vector_o_t");
top.note("headers/pk_topol_render_facet.html#declaration", " const int n_topols, --- <B>number</B> of entities", "PK Reference - PK_TOPOL_render_facet");
top.note("headers/pk_topol_render_facet.html#documentation", " generation options include parameters such as the maximum <B>number</B>", "PK Reference - PK_TOPOL_render_facet");
top.note("headers/pk_topol_render_facet_go_o_t.html#documentation", " to limit the <B>number</B> of facets per strip.", "PK Reference - PK_TOPOL_render_facet_go_o_t");
top.note("headers/pk_topol_render_line.html#declaration", " const int n_topols, --- <B>number</B> of entities", "PK Reference - PK_TOPOL_render_line");
top.note("headers/pk_topol_render_line_o_t.html#declaration", " --- <B>number</B> of u direction hatch lines.", "PK Reference - PK_TOPOL_render_line_o_t");
top.note("headers/pk_topol_render_line_o_t.html#documentation", " suppressed_indices to indicate the <B>number</B> of bodies and the body indices", "PK Reference - PK_TOPOL_render_line_o_t");
top.note("headers/pk_topol_render_volume.html#declaration", " int n_topols, --- <B>number</B> of topols", "PK Reference - PK_TOPOL_render_volume");
top.note("headers/pk_topol_render_volume_o_t.html#declaration", " int o_t_version; --- Version <B>number</B> of options", "PK Reference - PK_TOPOL_render_volume_o_t");
top.note("headers/pk_topol_render_volume_r_t.html#declaration", " int r_t_version; --- Version <B>number</B> of returns", "PK Reference - PK_TOPOL_render_volume_r_t");
top.note("headers/pk_torus_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_TORUS_array_t");
top.note("headers/pk_transf_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_TRANSF_array_t");
top.note("headers/pk_transf_check.html#declaration", " int *const n_faults, --- <B>number</B> of faults", "PK Reference - PK_TRANSF_check");
top.note("headers/pk_transf_check.html#documentation", " maximum <B>number</B> of faults to be returned and whether to", "PK Reference - PK_TRANSF_check");
top.note("headers/pk_transf_check_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_TRANSF_check_o_t");
top.note("headers/pk_transf_classify_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_TRANSF_classify_o_t");
top.note("headers/pk_transf_enlarge_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_TRANSF_enlarge_o_t");
top.note("headers/pk_transf_enlarge_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return", "PK Reference - PK_TRANSF_enlarge_r_t");
top.note("headers/pk_transf_transform_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_TRANSF_transform_o_t");
top.note("headers/pk_transf_transform_r_t.html#declaration", " int r_t_version; --- version <B>number</B> of return", "PK Reference - PK_TRANSF_transform_r_t");
top.note("headers/pk_trcurve_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_TRCURVE_array_t");
top.note("headers/pk_vector_array_t.html#documentation", " length the <B>number</B> of elements in array ", "PK Reference - PK_VECTOR_array_t");
top.note("headers/pk_vector_make_lsq_plane.html#declaration", " int n_positions, --- <B>number</B> of positions", "PK Reference - PK_VECTOR_make_lsq_plane");
top.note("headers/pk_vertex_array_t.html#documentation", " length : the <B>number</B> of entities in array ", "PK Reference - PK_VERTEX_array_t");
top.note("headers/pk_vertex_ask_faces.html#declaration", " int *const n_faces, --- <B>number</B> of faces (>= 0)", "PK Reference - PK_VERTEX_ask_faces");
top.note("headers/pk_vertex_ask_faces.html#documentation", "only compute the <B>number</B> of faces at the vertex.", "PK Reference - PK_VERTEX_ask_faces");
top.note("headers/pk_vertex_ask_isolated_loops.html#declaration", " int *const n_loops, --- <B>number</B> of isolated loops (>= 0)", "PK Reference - PK_VERTEX_ask_isolated_loops");
top.note("headers/pk_vertex_ask_isolated_loops.html#documentation", "will only compute the <B>number</B> of isolated loops at the vertex.", "PK Reference - PK_VERTEX_ask_isolated_loops");
top.note("headers/pk_vertex_ask_oriented_edges.html#declaration", " int *const n_edges, --- <B>number</B> of edges (>= 0)", "PK Reference - PK_VERTEX_ask_oriented_edges");
top.note("headers/pk_vertex_ask_oriented_edges.html#documentation", "function will only compute the <B>number</B> of edges at the vertex (with repeats).", "PK Reference - PK_VERTEX_ask_oriented_edges");
top.note("headers/pk_vertex_ask_shells.html#declaration", " int *const n_shells, --- <B>number</B> of shells (>= 1)", "PK Reference - PK_VERTEX_ask_shells");
top.note("headers/pk_vertex_ask_shells.html#documentation", "only compute the <B>number</B> of shells at the vertex.", "PK Reference - PK_VERTEX_ask_shells");
top.note("headers/pk_vertex_attach_points.html#declaration", " int n_vertices, --- <B>number</B> of vertices", "PK Reference - PK_VERTEX_attach_points");
top.note("headers/pk_vertex_delete_acorn.html#declaration", " int n_vertices, --- <B>number</B> of vertices", "PK Reference - PK_VERTEX_delete_acorn");
top.note("headers/pk_vertex_euler_merge_edges.html#errors", " PK_ERROR_bad_vertex incorrect <B>number</B> of edges or isolated loops", "PK Reference - PK_VERTEX_euler_merge_edges");
top.note("headers/pk_vertex_optimise_o_t.html#declaration", " int o_t_version; --- version <B>number</B> of option structure", "PK Reference - PK_VERTEX_optimise_o_t");
top.note("chapters/di_chap.02.html#50511934_pgfId-284004", " int *<B>number</B>, /* test <B>number</B> */ ", "Downward Interfaces - Introduction to the Frustrum");
top.note("chapters/di_chap.02.html#50511934_pgfId-281493", " <B>number</B> ", "Downward Interfaces - Introduction to the Frustrum");
top.note("chapters/di_chap.02.html#50511934_pgfId-281495", " test <B>number</B> ", "Downward Interfaces - Introduction to the Frustrum");
top.note("chapters/di_chap.02.html#50511934_pgfId-281676", " <B>number</B>, purpose, result ", "Downward Interfaces - Introduction to the Frustrum");
top.note("chapters/di_chap.02.html#50511934_pgfId-274162", " Note the test <B>number</B> which has failed as N. ", "Downward Interfaces - Introduction to the Frustrum");
top.note("chapters/di_chap.02.html#50511934_pgfId-274165", " in TESTFR are associated with the given test <B>number</B>; it should be incremented (this is to allow", "Downward Interfaces - Introduction to the Frustrum");
top.note("chapters/di_chap.02.html#50511934_pgfId-274166", " defined for TESTFR. If running with the test <B>number</B> as zero, this message shows up at the", "Downward Interfaces - Introduction to the Frustrum");
top.note("chapters/di_chap.02.html#50511934_pgfId-274168", " association between a particular check and a test <B>number</B> will not necessarily be maintained between releases of", "Downward Interfaces - Introduction to the Frustrum");
top.note("chapters/di_chap.03.html#50511935_pgfId-273844", " Whilst such facilities could be implemented in a <B>number</B> of ways, they are described here in terms", "Downward Interfaces - File Handling");
top.note("chapters/di_chap.03.html#50511935_pgfId-286088", " 2.1.5 <B>Number</B> of files open concurrently ", "Downward Interfaces - File Handling");
top.note("chapters/di_chap.04.html#50511936_pgfId-273947", " in lower case and a four digit year <B>number</B>). ", "Downward Interfaces - File Header Structure");
top.note("chapters/di_chap.05.html#50511937_pgfId-299936", " from Parasolid. The GO Interface consists of a <B>number</B> of functions that must meet the specifications in", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274067", " in the hierarchical segment. They may contain any <B>number</B> of other segments. ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274088", " occurrence <B>number</B> when they are rendered - this <B>number</B> is the index of the body (in the", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274090", " in a separate segment (or segments). The occurrence <B>number</B> is different in each case. ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274274", "occurrence <B>number</B> of the segment, and the rest of which", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274289", " which are given as well as the occurrence <B>number</B> for all single-level segment types, are as follows.", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-285370", " you are rendering a large body in a <B>number</B> steps using several viewports, this code can help", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274533", " ngeom = the <B>number</B> of 3D vectors ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274555", " ngeom = the <B>number</B> of facet vertices ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274575", " ngeom = 2 times the <B>number</B> of facet vertices ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274607", " ngeom = 2 times the <B>number</B> of facet vertices ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274631", " ngeom = 3 times the <B>number</B> of facet vertices ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274663", " ngeom = the <B>number</B> of Bezier vertices defining the curve ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274683", " ngeom = the <B>number</B> of points ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274715", " ngeom = 3 (<B>number</B> of b-spline vertices) + <B>number</B> of knots ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274743", " 9th element of the integer array and the <B>number</B> of knots is supplied in the 10th element", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274788", " 9th element of the integer array and the <B>number</B> of knots is supplied in the 10th element", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274793", " ngeom = 5 times the <B>number</B> of facet vertices ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274841", " ngeom = 8 times the <B>number</B> of facet vertices ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275000", " derived. The <B>number</B> of edge tags equals the <B>number</B> of vertices which define the facet. The null", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275002", " contains the <B>number</B> of loops in the facet ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275003", " contains the <B>number</B> of vertices in the first loop ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275004", " contains the <B>number</B> of vertices in the second loop ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275030", " represents the <B>number</B> of visibility code ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275037", " holds the <B>number</B> of these visibility transition points. ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275132", " The <B>number</B> of facets in each strip must be specified", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275194", " holds the <B>number</B> of visibility transition points. ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275200", " holds the <B>number</B> of visibility codes. ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.06.html#50511938_pgfId-273993", " incompatible combination, the application can enquire the version <B>number</B> of the installed Parasolid using PK_SESSION_ask_kernel_version . For", "Downward Interfaces - Registering the Frustrum");
top.note("chapters/di_chap.06.html#50511938_pgfId-274000", " The read functions must be handed the correct <B>number</B> of computation-ready data items, as written out by", "Downward Interfaces - Registering the Frustrum");
top.note("chapters/di_chap.09.html#50511941_pgfId-286022", " int n_bytes, /* <B>number</B> of bytes to write */ ", "Downward Interfaces - PK_DELTA Functions");
top.note("chapters/di_chap.09.html#50511941_pgfId-286035", " int n_bytes, /* <B>number</B> of bytes to read */ ", "Downward Interfaces - PK_DELTA Functions");
top.note("chapters/kd_chap.02.html#50475009_pgfId-273872", " to render items from the kernel in a <B>number</B> of ways. Picking from the screen is used", "KID Manual - Kernel Interface Driver (KID) - an Overview");
top.note("chapters/kd_chap.03.html#50475011_pgfId-273872", " A <B>number</B> of symbol-strings are predefined by the system, for", "KID Manual - LISP in KID");
top.note("chapters/kd_chap.03.html#50475011_pgfId-273916", " takes any <B>number</B> of arguments, evaluates them, and builds a new", "KID Manual - LISP in KID");
top.note("chapters/kd_chap.03.html#50475011_pgfId-273939", " s-expression can have any <B>number</B> of arguments (clauses), which consist of a series", "KID Manual - LISP in KID");
top.note("chapters/kd_chap.03.html#50475011_pgfId-273959", " we want to repeat an operation an indefinite <B>number</B> of times, each time with different inputs. This", "KID Manual - LISP in KID");
top.note("chapters/kd_chap.04.html#50475012_pgfId-274106", " local operation is performed, there are sometimes a <B>number</B> of possible solutions. When the option check is", "KID Manual - Object-Oriented KID");
top.note("chapters/kd_chap.04.html#50475012_pgfId-274115", " given maximum <B>number</B> of live marks. The maximum <B>number</B> of live rollmarks can be set using the", "KID Manual - Object-Oriented KID");
top.note("chapters/kd_chap.05.html#50475010_pgfId-273844", " small <B>number</B> of support functions and a large <B>number</B> of functions to call the KI/PK; 2 per", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.05.html#50475010_pgfId-280942", " int *const n_things --- <B>number</B> of things", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.05.html#50475010_pgfId-281460", " argument is supplied as nil, then only the <B>number</B> of ", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.05.html#50475010_pgfId-280957", " --- just returns the <B>number</B> of faces ", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.05.html#50475010_pgfId-273993", " The function allow_ifails takes any <B>number</B> of arguments. The first is a specification of", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.05.html#50475010_pgfId-274011", ". It raises and reports the <B>number</B> of the first LISP error which occurs within", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.07.html#50475033_pgfId-273842", " A <B>number</B> of functions exist for operations which are only", "KID Manual - Operations on Bodies, Curves, Surfaces, etc.");
top.note("chapters/kd_chap.07.html#50475033_pgfId-274283", " maximum <B>number</B> of entities on badtaglist ", "KID Manual - Operations on Bodies, Curves, Surfaces, etc.");
top.note("chapters/kd_chap.07.html#50475033_pgfId-274333", " maximum <B>number</B> of entities on badtaglist ", "KID Manual - Operations on Bodies, Curves, Surfaces, etc.");
top.note("chapters/kd_chap.08.html#50475021_pgfId-273894", " depending on which function created/removed them, and the <B>number</B> of child bodies created/removed. ", "KID Manual - Local Operation Functions");
top.note("chapters/kd_chap.10.html#50475015_pgfId-273860", " For the assembly, the <B>number</B> of components it consists of; how many of", "KID Manual - Enquiries");
top.note("chapters/kd_chap.10.html#50475015_pgfId-273862", " substructure, a statement to that effect and the <B>number</B> of sheet and solid bodies the assembly consists", "KID Manual - Enquiries");
top.note("chapters/kd_chap.12.html#50475019_pgfId-273851", " allows one view to be active, although any <B>number</B> can be defined. When KID is started by", "KID Manual - KID Graphics: Overview");
top.note("chapters/kd_chap.12.html#50475019_pgfId-273875", " devices, and to send output simultaneously to a <B>number</B> of devices. This and other device dependent KID", "KID Manual - KID Graphics: Overview");
top.note("chapters/kd_chap.13.html#50475017_pgfId-273940", " The zoom function takes a real <B>number</B> as its argument. It changes the current window", "KID Manual - Viewing Environment and Definition");
top.note("chapters/kd_chap.13.html#50475017_pgfId-273952", " the view. The pan functions take a real <B>number</B> as their argument. The effect is to move", "KID Manual - Viewing Environment and Definition");
top.note("chapters/kd_chap.13.html#50475017_pgfId-273955", " The rotate functions also take a real <B>number</B> as their argument. They rotate the viewing direction", "KID Manual - Viewing Environment and Definition");
top.note("chapters/kd_chap.13.html#50475017_pgfId-274015", " be used to create a sketch of a <B>number</B> of objects. ", "KID Manual - Viewing Environment and Definition");
top.note("chapters/kd_chap.14.html#50475018_pgfId-274241", " Maximum <B>number</B> of sides per facet ", "KID Manual - KID Rendering");
top.note("chapters/kd_chap.14.html#50475018_pgfId-274254", " option RROPTS is set with the given maximum <B>number</B> of facets in a strip ", "KID Manual - KID Rendering");
top.note("chapters/kd_chap.14.html#50475018_pgfId-274427", " The argument given is a list containing a <B>number</B> of lists, each defining a light source. If", "KID Manual - KID Rendering");
top.note("chapters/kd_chap.14.html#50475018_pgfId-274428", " A <B>number</B> of pre-defined light sources are available as follows:", "KID Manual - KID Rendering");
top.note("chapters/kd_chap.14.html#50475018_pgfId-274936", " replicated to ensure that there are an equal <B>number</B> of transforms as entities. At all times the", "KID Manual - KID Rendering");
top.note("chapters/kd_chap.20.html#50475025_pgfId-274699", " and local variables that the function uses. Any <B>number</B> of actions can be given for the function", "KID Manual - List of Parasolid LISP Functions");
top.note("chapters/kd_chap.20.html#50475025_pgfId-274741", " LET takes any <B>number</B> of arguments. The first is interpreted as a", "KID Manual - List of Parasolid LISP Functions");
top.note("chapters/kd_chap.20.html#50475025_pgfId-283962", " (PLUS <B>number</B> <B>number</B> ...) ", "KID Manual - List of Parasolid LISP Functions");
top.note("chapters/kd_chap.20.html#50475025_pgfId-274775", " of all its arguments. PLUS can have any <B>number</B> of arguments. If one of the arguments is", "KID Manual - List of Parasolid LISP Functions");
top.note("chapters/kd_chap.24.html#50475028_pgfId-36335", " <B>number</B> ", "KID Manual - Machine Dependency in KID");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274672", " Keylen is 14 (i.e. the <B>number</B> of characters in the evaluator key string), ", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-281887", " be available of which the final two (the <B>number</B> of cycles, n, and the width of the", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274714", " to the <B>number</B> of u derivatives requested, the <B>number</B> of v derivatives requested, and the triangular flag.", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-282521", " request is a single argument, nderiv, for the <B>number</B> of t derivatives requested as opposed to the", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.04.html#50462726_pgfId-273851", " <B>number</B> of integer values supplied ", "FG Manual - Modeling using Foreign Geometry");
top.note("chapters/fg_chap.04.html#50462726_pgfId-273853", " <B>number</B> of real values supplied ", "FG Manual - Modeling using Foreign Geometry");
top.note("chapters/fg_chap.04.html#50462726_pgfId-296147", " waves on the surface, the second is the <B>number</B> of wave cycles in the surface and the", "FG Manual - Modeling using Foreign Geometry");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274126", " <B>Number</B> of integers passed ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274146", " <B>Number</B> of reals passed ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274299", " <B>Number</B> of integers passed ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274319", " <B>Number</B> of reals passed ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274723", " derivatives request). The arguments nu, nv specify the <B>number</B> of u an v derivatives requested. ", "FG Manual - FG Module Interface Functions");
top.note("chapters/in_chap.04.html#50520097_pgfId-302826", " A <B>number</B> of software applications are included on the DVD:", "Installation Notes - Installing Parasolid");
top.note("chapters/in_chap.05.html#50520098_pgfId-273045", " This directory contains a <B>number</B> of schema files whose names have the form", "Installation Notes - Parasolid Release Area");
top.note("chapters/in_chap.06.html#50520099_pgfId-293430", " 5.6.1 Guidelines for setting the <B>number</B> of threads ", "Installation Notes - Using Parasolid");
top.note("chapters/in_chap.06.html#50520099_pgfId-299534", " time. Application threads are not included in this <B>number</B>. ", "Installation Notes - Using Parasolid");
top.note("chapters/in_chap.06.html#50520099_pgfId-297828", " Limited <B>number</B> of threads ", "Installation Notes - Using Parasolid");
top.note("chapters/in_chap.06.html#50520099_pgfId-293466", " There is a limit on the <B>number</B> of threads that Parasolid can use, noted in", "Installation Notes - Using Parasolid");
top.note("chapters/in_chap.06.html#50520099_pgfId-350060", " <B>number</B> of Parasolid SMP worker threads to the <B>number</B> of high-performance cores, but experimentation and benchmarking with", "Installation Notes - Using Parasolid");
top.note("chapters/in_chap.06.html#50520099_pgfId-293470", " most useful for applications that need a large <B>number</B> of threads but where the threads don&#8217;t have", "Installation Notes - Using Parasolid");
top.note("chapters/in_chap.06.html#50520099_pgfId-331296", " If this is greater than 1, use that <B>number</B> of threads, to a maximum of the Parasolid", "Installation Notes - Using Parasolid");
top.note("chapters/in_chap.06.html#50520099_pgfId-293490", " to get the <B>number</B> of processors. If this is greater than 1,", "Installation Notes - Using Parasolid");
top.note("chapters/in_chap.06.html#50520099_pgfId-355745", " to get the <B>number</B> of processors. If this is greater than 1,", "Installation Notes - Using Parasolid");
top.note("chapters/in_chap.06.html#50520099_pgfId-294488", " to get the <B>number</B> of available processors. If this is greater than", "Installation Notes - Using Parasolid");
top.note("chapters/in_chap.06.html#50520099_pgfId-350427", " cores in the machine. You can establish this <B>number</B> as follows: ", "Installation Notes - Using Parasolid");
top.note("chapters/in_chap.06.html#50520099_pgfId-356514", " macOS 12 and later, you can find the <B>number</B> of processors at performance level zero, the fastest", "Installation Notes - Using Parasolid");
top.note("chapters/in_chap.07.html#50520100_pgfId-537119", " perfection is unattainable. The differences are similar in <B>number</B> and scope to those caused by a change", "Installation Notes - Environment");
top.note("chapters/in_chap.08.html#50520101_pgfId-289135", " is not permitted, hence zero is an invalid <B>number</B> for division. ", "Installation Notes - Floating-Point Traps");
top.note("chapters/in_chap.08.html#50520101_pgfId-278364", " A.8.1 NaN (&#8220;Not A <B>Number</B>&#8221;) ", "Installation Notes - Floating-Point Traps");
top.note("chapters/in_chap.08.html#50520101_pgfId-278365", " essentially tells the processor: &#8220;This is not a <B>number</B> and cannot be used in mathematical calculations.&#8221; If", "Installation Notes - Floating-Point Traps");
top.note("chapters/in_chap.08.html#50520101_pgfId-278379", " simple programs where it is acceptable for Not A <B>Number</B> or Infinity to propagate through the data the program", "Installation Notes - Floating-Point Traps");
top.note("chapters/fr_chap.02.html#50462722_pgfId-278363", " issue; once you have been given a PR <B>number</B>, you can be assured that Parasolid development have", "Reporting Faults to Parasolid - Introduction");
top.note("chapters/fr_chap.02.html#50462722_pgfId-278377", " respond to you, quoting the Parasolid database reference <B>number</B> (e.g. IR1234567). You will also be contacted if", "Reporting Faults to Parasolid - Introduction");
top.note("chapters/fr_chap.03.html#50462723_pgfId-281082", " In a small <B>number</B> of cases, Debug XML cannot be used to", "Reporting Faults to Parasolid - Data To Include In Fault Reports");
top.note("chapters/fr_chap.04.html#50462721_pgfId-279486", " issue, you are immediately given a tracking reference <B>number</B> for it. ", "Reporting Faults to Parasolid - How To Report A Fault");
top.note("chapters/fr_chap.04.html#50462721_pgfId-281829", " A reference <B>number</B> for the IR. ", "Reporting Faults to Parasolid - How To Report A Fault");
top.note("chapters/fr_chap.04.html#50462721_pgfId-281831", " Please make a note of this <B>number</B> and refer to it in any further discussions", "Reporting Faults to Parasolid - How To Report A Fault");
top.note("chapters/fr_chap.04.html#50462721_pgfId-278695", " Enter a specific issue <B>number</B> in the Call <B>number</B> box ", "Reporting Faults to Parasolid - How To Report A Fault");
top.note("chapters/fr_chap.04.html#50462721_pgfId-284298", " Your reference <B>number</B> ", "Reporting Faults to Parasolid - How To Report A Fault");
top.note("chapters/fr_chap.04.html#50462721_pgfId-284432", " be aware that this is a standard UK <B>number</B>, and that our telephone lines are only manned", "Reporting Faults to Parasolid - How To Report A Fault");
top.note("chapters/fr_chap.06.html#50462725_pgfId-275468", " older than this, you need to update a <B>number</B> of frustrum functions to support this guise type.", "Reporting Faults to Parasolid - Updating The Frustrum");
top.display();
//-->
</SCRIPT>
</HEAD>
<BODY bgcolor=#FFFFFF link=#0F3A68 vlink=#878787 alink=#FF7600 leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
</BODY>
</HTML>
