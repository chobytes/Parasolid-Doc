<HTML>
<HEAD>
<LINK REL=STYLESHEET HREF=../ps_doc.css CHARSET=ISO-8859-1 TYPE=text/css>
<SCRIPT LANGUAGE="JavaScript">
<!--

top.note("chapters/fd_chap.010.html#50409790_pgfId-294778", " and type. If the option structure contains an <B>array</B> of substructures, these must also be initialised by", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-387353", " is an <B>array</B> whose length is not known at compile-time. The", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.011.html#50409791_pgfId-305139", " Using an <B>array</B> or set of arrays. ", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.011.html#50409791_pgfId-303708", " provide a means of associating a fixed-length byte <B>array</B> with each and every Parasolid entity. You can", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.011.html#50409791_pgfId-312583", " The interval of that line therefore comprises an <B>array</B> containing these two parameters. ", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.011.html#50409791_pgfId-317634", " each curve received, and returns these in the <B>array</B> of ", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.011.html#50409791_pgfId-317663", " <B>array</B> to compare ", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.015.html#50409796_pgfId-295765", " PK_GEOM_copy receives an <B>array</B> of geometric entities, together with an options structure", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-892912", " <B>array</B> which contains an <B>array</B> of the enlarged geometries and information on the", "Functional Description - Model Structure");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297522", " create a compound body. This function receives an <B>array</B> of bodies (which must all be in the", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-445730", " the received bodies are added as children. The <B>array</B> of bodies and the compound body specified must", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297573", " If the part was a compound body, an <B>array</B> of the identifiers that each received child body", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297580", " the received child bodies. Each item in this <B>array</B> corresponds to an item in ", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297582", " the part was not a compound body, an <B>array</B> containing the original part. ", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297600", " This should be a single element <B>array</B> ( ", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297604", " This should be an <B>array</B> of length ", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297731", " collection of shared geometry, this field contains an <B>array</B> that holds the tags of the original geometries", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297735", " shared geometry, there is a corresponding single element <B>array</B> in this field that contains the tag of", "Functional Description - Body Types");
top.note("chapters/fd_chap.018.html#50409799_pgfId-384203", " <B>array</B> from the construction geometry of a part ", "Functional Description - Geometry");
top.note("chapters/fd_chap.019.html#50409800_pgfId-1172905", " parametric interval for each curve in the supplied <B>array</B> of ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-1072019", " parametric interval for each surface in the supplied <B>array</B> of ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-1173416", " you to specify the destination for the resulting <B>array</B> of b-curves. If the destination is: ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-1112040", " you to specify the destination for the resulting <B>array</B> of b-surfaces. If the destination is: ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-298529", " is an <B>array</B> of length ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300486", " An <B>array</B> of parameter values that lie within the specified", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300490", " For curves, a single <B>array</B> of interpolation parameters is supplied. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300654", " by an <B>array</B> of curves and a matching <B>array</B> of parameter intervals - as shown in ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300717", " constraints for PK_BSURF_create_constrained . Each position in this <B>array</B> denotes a point in the cloud of constraining", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300723", " Supplying an <B>array</B> of ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300737", " is an <B>array</B> mapping normal information onto the supplied ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.021.html#50409802_pgfId-336131", " arrays define an <B>array</B> of lrods by specifying the absolute indices of", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-336145", " arrays define an <B>array</B> of lrods by specifying the absolute indices of", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-431740", " You can also take an <B>array</B> of lattices and combine them into a single,", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-576069", " frames using PK_TOPOL_imprint_frames . This function takes an <B>array</B> of regions or a single body and imprints", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-570511", " representation of the lattice geometry from an input <B>array</B> of bodies or regions. ", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.022.html#50409803_pgfId-296527", " by modifying copies of them. It receives an <B>array</B> of geometries, a transformation and a set of", "Functional Description - Transformations");
top.note("chapters/fd_chap.022.html#50409803_pgfId-373784", " <B>array</B> of PK_LOGICAL_t tokens, one for each transformed geometry.", "Functional Description - Transformations");
top.note("chapters/fd_chap.024.html#50409622_pgfId-463055", " scale factor for each one in the input <B>array</B>. ", "Functional Description - Distant and Multi-scale Modelling");
top.note("chapters/fd_chap.026.html#50409768_pgfId-385740", " sub-classes. The form of a vector is an <B>array</B> of three reals. ", "Functional Description - Expressions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-306635", " faces that are immediately adjacent to a given <B>array</B> of input faces ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-802939", " return an <B>array</B> of individual axis-aligned boxes for each topology received", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310449", " curve and a parameter interval to return an <B>array</B> of positions and corresponding parameters on the curve", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.029.html#50409809_pgfId-294710", " An <B>array</B> of topological entities. ", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.029.html#50409809_pgfId-366373", " An <B>array</B> of transformations used to transform topologies passed into", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.029.html#50409809_pgfId-466572", " <B>array</B> that indicates the scale relative to the smallest", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.029.html#50409809_pgfId-469547", " <B>array</B> can only contain bodies or assemblies. ", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.029.html#50409809_pgfId-294942", " the mass properties of a set of an <B>array</B> of unsewn sheets (which when sewn would form", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.029.html#50409809_pgfId-366739", " transformations and reflection transformations. This option takes an <B>array</B> (of size ", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296601", " or group of entities and a position or <B>array</B> of positions. ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296898", "<B>array</B> functions in subsequent sections. ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296923", " between an <B>array</B> of topological entities and an <B>array</B> of geometric", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296928", " or <B>array</B> of positions and an entity or <B>array</B> of entities. For convenience, these are referred to", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296946", " minimum distances between a geometrical entity and an <B>array</B> of positions, one distance for each geometry/position pairing.", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296960", " The global minimum distance between an <B>array</B> of geometrical entities and a position. ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296967", " The global minimum distance between an <B>array</B> of topological entities and a position. ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-373444", " between a transformed <B>array</B> of entities and an <B>array</B> of positions. See Section 29.2.1, Calculating the distance", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-397783", " are set to PK_ENTITY_null, the entities in the <B>array</B> are not transformed. ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-413908", " also allows you to calculate distances between an <B>array</B> of vectors and either a single topology or", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297048", "Available in: all standard and <B>array</B> functions that involve at least one geometrical entity.", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-410244", " <B>array</B> which indicates the scale relative to the smallest", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-374836", "<B>array</B> function PK_ENTITY_range you can only provide an estimate", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-414137", " For PK_GEOM_range_vector_many you provide an <B>array</B> of estimates, one for each position supplied to", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297125", " , and PK_TOPOL_range_geom_array . If you are using <B>array</B> functions to measure distances, and you have enough", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297143", " contains the corresponding parameter information. It is an <B>array</B> containing up to two parameters. ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-377967", " Note: For PK_GEOM_range_vector_many , an <B>array</B> of range results and ranges is returned, one", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-371660", " Double <B>array</B> that indicates the separation distance between entities. ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.031.html#50409811_pgfId-294923", " sheets, and wire bodies. This function receives an <B>array</B> of target topologies ( ", "Functional Description - Clash Detection Of Bodies");
top.note("chapters/fd_chap.031.html#50409811_pgfId-361407", " <B>array</B> contains the first bodies of each exclusion pair", "Functional Description - Clash Detection Of Bodies");
top.note("chapters/fd_chap.031.html#50409811_pgfId-294945", " to PK_LOGICAL_true, you can supply an <B>array</B> of transforms to apply to either targets or", "Functional Description - Clash Detection Of Bodies");
top.note("chapters/fd_chap.032.html#50409812_pgfId-295178", " amount of data is supplied for each data <B>array</B> in a system attribute. For example: ", "Functional Description - Checking");
top.note("chapters/fd_chap.035.html#50409816_pgfId-324591", " PK_TOPOL_delete_redundant_2 receives an <B>array</B> of ", "Functional Description - Controlling Redundant Topology");
top.note("chapters/fd_chap.035.html#50409816_pgfId-324682", " topologies, use PK_TOPOL_identify_redundant . This function receives an <B>array</B> of ", "Functional Description - Controlling Redundant Topology");
top.note("chapters/fd_chap.038.html#50409820_pgfId-308827", " An <B>array</B> of length ", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-308831", " An <B>array</B> of length ", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-308832", " If an element in this <B>array</B> is PK_ENTITY_null, then no transformation is applied to", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-308833", " If the entire <B>array</B> is PK_ENTITY_null, then no transformations are applied to", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-523961", " Structure containing status information and an <B>array</B> of the outlines generated. ", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-793168", " An <B>array</B> of faces to be excluded from the outline.", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.040.html#50409822_pgfId-296677", " <B>array</B>: no cross-sections are produced at ignorable vertices. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-722086", " An <B>array</B> of faces that you want to lock the", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-297913", " The option takes an <B>array</B> of vertices, each of which represents a vertex", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-297914", " however, that path vertex is included in the <B>array</B> of ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-298796", " An <B>array</B> of structures specifying for each profile the details", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-298800", " clamps applied, and is parallel to the profile_derivs <B>array</B>. (Default NULL.) ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-298802", " Each entry in the profile_derivs <B>array</B> is a structure containing the following fields: ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.041.html#50409823_pgfId-325607", " An <B>array</B> of faces on the tool body whose precise", "Functional Description - Sweeping Tool Bodies Along a Path");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295084", " Profiles are supplied to PK_BODY_make_lofted_body as an <B>array</B> of wire, sheet or minimal bodies. Sheets and", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-611718", " must be in sequential order in the profile <B>array</B> and clamps cannot be applied to the repeated", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-534256", " clamp varies according to each entry in the <B>array</B>, based on a default magnitude value that is", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295606", " An <B>array</B> of derivative conditions for the profiles indexed in", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295613", " An <B>array</B> of integers. Each integer refers to a profile", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295650", " you want to constrain. Each element in the <B>array</B> describes a curvature and clamp type to apply", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295659", " <B>array</B>. This is an <B>array</B> of integers that specifies which profile each derivative", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-296620", " An <B>array</B> of oriented connected manifold wire bodies ", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-296746", " An <B>array</B> of derivative conditions for the guide wires indexed", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-296753", " An <B>array</B> of integers. Each integer refers to a guide", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-297146", " <B>array</B>: edges with the same value originated from the", "Functional Description - Lofting");
top.note("chapters/fd_chap.043.html#50409825_pgfId-351222", " An <B>array</B> of length ", "Functional Description - Shadow Curves");
top.note("chapters/fd_chap.044.html#50409826_pgfId-295677", " An <B>array</B> of edges in the profile for which multiple", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.044.html#50409826_pgfId-295681", " An <B>array</B> of taper angles for each of the edges", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.044.html#50409826_pgfId-297005", " <B>array</B> of the ", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295063", " PK_CURVE_make_wire_body_2 creates a wire body from an <B>array</B> of curves. The wire body that is created", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-354301", " An <B>array</B> of curves used to make a wire body,", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-354305", " An <B>array</B> of intervals. Each interval describes the bound for", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295099", " An <B>array</B> of the edges in the wire body. Returning", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295106", " An <B>array</B> of length ", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295114", " <B>array</B> is undefined. ", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295119", " information about which curves in the received curves <B>array</B> were used to create each edge in the", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295191", " containing 4 edges has been created from an <B>array</B> of 2 curves, one of which contains 2", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295227", " <B>array</B> to the curves they correspond to in the", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295244", " PK_EDGE_make_wire_body creates a wire body from an <B>array</B> of edges. The supplied edges can come from", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-358801", " An <B>array</B> of edges used to create a wire body,", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.048.html#50409831_pgfId-346780", " in the result(s). The first sheet in the <B>array</B> is the target sheet. On completion of the", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-295249", " members of the classes are returned in the <B>array</B> of unsewn bodies. ", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-295257", " loops present on each result returned in the <B>array</B> ", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-295260", " that the appearance of a sheet in this <B>array</B> does not imply that it has remained unmodified", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-295371", " being handed in at the head of the <B>array</B>), the result of handing A, B and C", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-295372", " <B>array</B> holds structures, each of which is an <B>array</B> of edges with an accompanying token indicating the", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-404894", " An <B>array</B> of different gap-width bounds used when ", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-600442", " If this <B>array</B> is NULL (default) then Parasolid generates an increasing", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-370207", " Edges (manifold or non-manifold) or vertices from an <B>array</B> of topologies can be fused together to create", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-297216", " An <B>array</B> of bodies for which to find a knitting", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-595648", " An <B>array</B> of bodies that could not be connected together.", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-297254", " An <B>array</B> of edges that can be matched wholly with", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-297258", " An <B>array</B> of matching edges for the supplied ", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-297266", " An <B>array</B> containing the owning bodies of any edges in", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-297272", " knitting pattern. The edges specified in the matches <B>array</B> of the knitting pattern are deleted after knitting", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-370337", " together using PK_BODY_knit . This function takes an <B>array</B> of topologies which you want to fuse together", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-370354", " An <B>array</B> of input topology. This <B>array</B> can contain duplicates; however, it cannot contain elements", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-370358", " An <B>array</B> of topology that matches ", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-404507", " <B>array</B> is knitted to the topology in the ", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.049.html#50409832_pgfId-358794", " <B>array</B> once, even though there are two faces in", "Functional Description - Mid-Surface Generation");
top.note("chapters/fd_chap.049.html#50409832_pgfId-358862", " The <B>array</B> of construction methods that are used to construct", "Functional Description - Mid-Surface Generation");
top.note("chapters/fd_chap.050.html#50409833_pgfId-719928", " An <B>array</B> of laminar edges belonging to the body: the", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-296489", ": an <B>array</B> of vertices representing the terminal vertices of edge", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-296490", ": an <B>array</B> of tokens of type PK_extend_side_t specifying how to", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.052.html#50409836_pgfId-544712", " An <B>array</B> describing the tool curves. It cannot contain self-intersecting", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-544716", " An <B>array</B> describing the curve intervals ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-544724", " An <B>array</B> describing the target entities ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362493", " are not to be produced by the operation.This <B>array</B> cannot contain both PK_CLASS_bcurve and PK_CLASS_spcurve. ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362594", " can be hidden by faces in the input <B>array</B> ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.053.html#50409837_pgfId-393960", " list of tool bodies, e.g. when drilling an <B>array</B> of holes in a body, the performance of", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394071", " An <B>array</B> of faces, edges, or vertices, each of which", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394075", " An optional <B>array</B> of help points (vectors) which, when combined with", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394079", " An optional <B>array</B> that describes the type of each region specified", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394085", " An optional <B>array</B> that is used in conjunction with ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394133", " <B>array</B> to define a single boundary region, and ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394230", " An <B>array</B> that may contain a mixture of solid regions,", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394238", " An <B>array</B> of vectors, which when combined with an appropriate", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394634", " is an <B>array</B> of substructures ( PK_boolean_match_region_o_t ) containing information about", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.054.html#50409838_pgfId-303273", " Each function receives a target body and an <B>array</B> of tool bodies, as detailed below. ", "Functional Description - Manifold Booleans");
top.note("chapters/fd_chap.056.html#50409840_pgfId-294769", " faces from a single tool body, and an <B>array</B> of transforms (either translations or rotations). Each transform", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-294776", " arrays (either translations, rotations, or scales). Each transform <B>array</B> determines the positions of the instances of the", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-298425", " an <B>array</B> of data structures for each face in the", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-298435", " of faces that define a feature and an <B>array</B> of transforms. Each transform is to be applied", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-300874", " <B>array</B> should be set to NULL. ", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-300882", " <B>array</B> should be set to NULL. ", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-301023", " <B>array</B>; this helps Parasolid maintain optimal performance. The ", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-301042", " <B>array</B> to NULL and ", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-301046", " <B>array</B> consists of a single element containing the boundary", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-301188", " <B>array</B> consists of two elements, each containing two boundary", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-301968", " <B>array</B>; otherwise this should be set to NULL and", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-829736", " An <B>array</B> of structures containing status, tracking and diagnostic information", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.057.html#50409620_pgfId-453728", " For slicing operations, an <B>array</B> of classes of curves that cannot appear in", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-459418", " sections from a single tool plane and an <B>array</B> of offset distances. Parasolid will generate a section", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-458483", " sectioned using a tool plane and an offsets <B>array</B> containing four non-zero values. ", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-463366", " banned_classes options to non-default values, the tool surfaces <B>array</B> must contain a single plane, keep_as_facet must be", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-484200", " An <B>array</B> of clipping entities which must be either a", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-484204", " A parallel <B>array</B> of flags that indicate which side of the", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-485729", " An <B>array</B> of ", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-482090", " option to request that an <B>array</B> of affected lballs is returned for each result", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-485692", " PK_LATTICE_clip returns an <B>array</B> of structures containing information on the lattices that", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-500590", " A parallel <B>array</B> of tokens giving information on how the corresponding", "Functional Description - Sectioning");
top.note("chapters/fd_chap.061.html#50409846_pgfId-294811", " An <B>array</B> of faces that should be pierced. See Section", "Functional Description - Hollowing");
top.note("chapters/fd_chap.061.html#50409846_pgfId-294816", " An <B>array</B> of faces that should be offset by a", "Functional Description - Hollowing");
top.note("chapters/fd_chap.061.html#50409846_pgfId-294823", " An <B>array</B> of offset distances corresponding to the <B>array</B> of", "Functional Description - Hollowing");
top.note("chapters/fd_chap.061.html#50409846_pgfId-294884", " If hollowing a subset of faces, this <B>array</B> describes the faces that should be hollowed. See", "Functional Description - Hollowing");
top.note("chapters/fd_chap.061.html#50409846_pgfId-298959", " <B>array</B> is offset by the corresponding value in ", "Functional Description - Hollowing");
top.note("chapters/fd_chap.061.html#50409846_pgfId-299593", " option. This takes an <B>array</B> of faces, which should be connected together in", "Functional Description - Hollowing");
top.note("chapters/fd_chap.061.html#50409846_pgfId-299699", " <B>array</B>. This <B>array</B> must consist of collections of connected faces that,", "Functional Description - Hollowing");
top.note("chapters/fd_chap.062.html#50409847_pgfId-297778", " An <B>array</B> of faces that are removed from the thickened", "Functional Description - Thickening");
top.note("chapters/fd_chap.062.html#50409847_pgfId-297820", " An <B>array</B> of faces to be offset by a distance", "Functional Description - Thickening");
top.note("chapters/fd_chap.062.html#50409847_pgfId-297824", " An <B>array</B> of size ", "Functional Description - Thickening");
top.note("chapters/fd_chap.062.html#50409847_pgfId-297828", " An <B>array</B> of size ", "Functional Description - Thickening");
top.note("chapters/fd_chap.065.html#50409851_pgfId-301067", " PK_FACE_delete_2 receives an <B>array</B> of faces that you want to delete, together", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.065.html#50409851_pgfId-321813", " of face sets to delete, together with an <B>array</B> of those face sets. Each element in ", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.065.html#50409851_pgfId-1003647", " <B>array</B> indicating which face sets could not be deleted.", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.065.html#50409851_pgfId-321860", " an <B>array</B> of detail types corresponding to the <B>array</B> of", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.065.html#50409851_pgfId-321865", " to a single element <B>array</B> containing PK_detail_any_c . ", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.065.html#50409851_pgfId-322448", " An <B>array</B> of arrays of entities. The entities that you", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.066.html#50409852_pgfId-294874", " of edges bounding the facesets, together with the <B>array</B> of edges bounding the facesets. ", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-294914", " together with the number of elements in the <B>array</B>. The precise facesets that are returned depends on", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-295236", " PK_BODY_identify_details returns a PK_identify_details_r_t structure that includes an <B>array</B> of identified ", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-436944", " returned in the PK_FACE_identify_blends_r_t return structure as an <B>array</B> parallel to the ", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296360", " ) and, optionally, a tolerance, and returns the <B>array</B> of faces that underlie the blend. ", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296907", " An <B>array</B> of facesets that you want to classify in", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296911", " An <B>array</B> of detail types by which to classify the", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296930", " A structure containing an <B>array</B> of detail definitions that contain the following information:", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296956", " <B>array</B> of ", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.067.html#50409853_pgfId-297149", " An <B>array</B> of edges whose geometry you want to replace,", "Functional Description - Replacing The Surfaces Of Faces");
top.note("chapters/fd_chap.067.html#50409853_pgfId-297150", " An <B>array</B> of curves that forms the required geometry. ", "Functional Description - Replacing The Surfaces Of Faces");
top.note("chapters/fd_chap.067.html#50409853_pgfId-297151", " An <B>array</B> of tolerance values. ", "Functional Description - Replacing The Surfaces Of Faces");
top.note("chapters/fd_chap.067.html#50409853_pgfId-297162", " The <B>array</B> of ", "Functional Description - Replacing The Surfaces Of Faces");
top.note("chapters/fd_chap.067.html#50409853_pgfId-297193", " <B>array</B> for every edge that you consider to be", "Functional Description - Replacing The Surfaces Of Faces");
top.note("chapters/fd_chap.068.html#50409854_pgfId-1394602", " <B>array</B> and the ", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.068.html#50409854_pgfId-1395223", " An <B>array</B> of angles that you want to apply to", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.068.html#50409854_pgfId-1395716", " option is an <B>array</B> of faces for which you want to specify", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.068.html#50409854_pgfId-1395718", " its reference face are both included in this <B>array</B>, you must ensure that the same taper angle", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419122", " An <B>array</B> of reference edges on which taper faces should", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419160", " An <B>array</B> containing tapering methods to use on reference entities", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419174", " An <B>array</B> of reference entities for which the ", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419187", " An <B>array</B> of all the edges of the body to", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419195", " An <B>array</B> of non-reference edges (together with the number of", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419240", " An <B>array</B> of faces (together with the number of faces)", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419263", " An <B>array</B> of faces (together with the number of faces)", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-311817", " the performance of body tapering by supplying an <B>array</B> of parting edges that describe where the parting", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-311883", " Figure 68-15 Specifying an <B>array</B> of parting edges to improve performance ", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.070.html#50409856_pgfId-312951", " on the target body. Each face in this <B>array</B> replaces the corresponding face in the ", "Functional Description - Patching");
top.note("chapters/fd_chap.070.html#50409856_pgfId-312955", " <B>array</B>. Each face in this <B>array</B> is replaced by the corresponding face in the", "Functional Description - Patching");
top.note("chapters/fd_chap.070.html#50409856_pgfId-310964", " face using PK_FACE_cover . This function receives an <B>array</B> of faces and a set of options. The", "Functional Description - Patching");
top.note("chapters/fd_chap.071.html#50409857_pgfId-294935", " An <B>array</B> describing the edges of the hole to be", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-363103", " the shape of the patch using an <B>array</B> of point (position) data. ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-337095", " is an <B>array</B> of boundary edges that do not have to", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-337096", " is an <B>array</B> of boundary edges that do not have to", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-334920", " <B>array</B> passed to PK_BODY_fill_hole . ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-376193", " the shape of a patch using a supplied <B>array</B> of point data. The patch created will pass", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-376222", " shape of a patch is controlled using an <B>array</B> of point data. ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-295714", " An <B>array</B> of wire bodies. ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-295768", " Figure 70-15 Using an <B>array</B> of wire bodies to guide the shape of", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-295831", " <B>Array</B> of wire bodies ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-295979", " An <B>array</B> of one or more clamps to apply to", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-295983", " An <B>array</B> of length ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-296200", " <B>array</B>, and ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.072.html#50409858_pgfId-294772", " a face, an <B>array</B> of faces, or an <B>array</B> of face arrays", "Functional Description - Moving Faces");
top.note("chapters/fd_chap.072.html#50409858_pgfId-294773", " Either a transform, or an <B>array</B> of transforms ", "Functional Description - Moving Faces");
top.note("chapters/fd_chap.073.html#50409859_pgfId-294762", " PK_FACE_make_solid_bodies creates a solid from an <B>array</B> of faces by copying the selected faces to", "Functional Description - Creating New Bodies From Existing Entities");
top.note("chapters/fd_chap.073.html#50409859_pgfId-316681", " An <B>array</B> of input edges. These edges must belong to", "Functional Description - Creating New Bodies From Existing Entities");
top.note("chapters/fd_chap.073.html#50409859_pgfId-317841", " PK_EDGE_remove_to_bodies takes an <B>array</B> of ", "Functional Description - Creating New Bodies From Existing Entities");
top.note("chapters/fd_chap.074.html#50409860_pgfId-302274", " An <B>array</B> mapping operations onto faces. See Section 73.2, Specifying", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-302283", " The operations to perform. This is an <B>array</B> of PK_FACE_change_t types, and can be any combination", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-302324", " <B>array</B>. This <B>array</B> should contain the same number of elements as", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-302501", " <B>array</B> is specified using PK_FACE_change_t . This contains the", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-302659", " <B>Array</B> of reference entities for the taper. ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-677594", " is the latter, each face entry in the <B>array</B> is mapped to a single reference entity in", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-504301", " <B>array</B>: ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-303983", " the taper condition. Edges that appear in this <B>array</B> should ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-303987", " the taper condition. Edges that appear in this <B>array</B> should ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-304557", " <B>array</B> such that the boundary loops of the feature", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-304568", " <B>array</B> contains two boundary loops and the target_faces <B>array</B> two destination faces as shown. The corresponding new", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-305145", " An <B>array</B> of length ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-305270", " An <B>array</B> of length ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-305831", " <B>array</B> in cases where you are applying different operations", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-464402", "not in this <B>array</B> will have its geometry recalculated. See Section 73.5.1,", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-464423", "not in this <B>array</B> will have its geometry recalculated. See Section 73.5.2,", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306676", " when defining the curves attached to the associated <B>array</B> of edges. Each individual entity can either be", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-916831", " An <B>array</B> of PK_change_edge_method_t values that determines the method for", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-862246", " An <B>array</B> used to control the creation of step faces", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-592807", " An <B>array</B> defining the sweep direction if ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306684", " An <B>array</B> of PK_LOGICAL_t values that indicates whether the direction", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306690", " An <B>array</B> of signed distances that indicates the distance to", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306695", " An <B>array</B> of transforms to be used on the corresponding", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306700", " An <B>array</B> of tolerances associated with the corresponding edges in", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306710", " An <B>array</B> of PK_replace_use_t values that controls behaviour when the", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306892", " An <B>array</B> of vertices to preserve. Default: NULL ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306896", " An <B>array</B> of replacement positions attached to each vertex in", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-1067010", " An <B>array</B> of tolerances within which to work. A separate", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-307020", " An <B>array</B> of geometric help positions for the supplied ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-307401", " An <B>array</B> of faces that represents the first set of", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-307405", " An <B>array</B> of faces that represents the second set of", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-307409", " An <B>array</B> of faces that represents the faces on which", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.077.html#50409864_pgfId-603495", " <B>array</B> (and its corresponding ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-604783", " <B>array</B> that represent the positions at which you need", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-618517", " <B>array</B> is to indicate points in the chain where", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-585017", " blend chain are equal, and the rho values <B>array</B> is PK_ENTITY_null or all rho values are zero", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-717111", " are specified, and the rho values <B>array</B> is PK_ENTITY_null or all rho values are zero(see", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-585018", " blend chain are different, and the rho values <B>array</B> is PK_ENTITY_null or all rho values are zero", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-602021", " <B>array</B>, making it possible to create elliptical, hyperbolic, parabolic,", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-728936", " <B>array</B>, ensure the rho value is 0.5, ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-622435", " option contains an <B>array</B> of integers. Each entry in ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-295143", " An <B>array</B> of the same length as ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296100", " An <B>array</B> of vertices that Y-shaped blends should be created", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296276", " An <B>array</B> of length n_edges containing the edges (default NULL).", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296280", " An <B>array</B> of length n_edges specifying at which end of", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296284", " An <B>array</B> of length n_edges specifying the distance at which", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296310", " An <B>array</B> of length n_vertices containing the vertices at which", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296314", " An <B>array</B> of length n_vertices specifying the patch configurations for", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296339", " The tracking information returned by PK_BODY_fix_blends contains an <B>array</B> of blend faces in ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296926", " An <B>array</B> of length n_vertices that contains the vertices that", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-297176", " An <B>array</B> of length n_vertices containing the vertices (default NULL).", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-297180", " An <B>array</B> of length n_vertices that contains specific ordering information", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-297969", " <B>array</B> in the ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298199", " completely defined by taking an element from each <B>array</B>: the first elements define the first limit, the", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298213", " An <B>array</B> of points that determine where the blend should", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298220", " An <B>array</B> of directions that indicate which side of the", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298224", " An <B>array</B> of edges that identify, for each limit defined,", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298229", " An <B>array</B> of length ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298442", " An <B>array</B> of ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298446", " An <B>array</B> of ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298450", " An <B>array</B> of edges that identify, for each limit defined,", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298454", " An <B>array</B> of length ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298707", " An <B>array</B> of faces, planes, or sheet bodies that you", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298711", " An <B>array</B> of type PK_LOGICAL_t , one for each entry", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299033", " isoparameter plane. To use this option, specify an <B>array</B> of fins or faces in the ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299140", " the specified underlying topologies. This option takes an <B>array</B> of topological entities that should be the same", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299320", " An <B>array</B> of length 1 of ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299321", " An <B>array</B> of length 1 of ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299322", " An <B>array</B> of 3 doubles indicating the limit point on", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299323", " An <B>array</B> of 3 doubles indicating the limit direction. ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299324", " An enum <B>array</B> of length 2. The first element is of", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299332", " An <B>array</B> of length 1 of ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299333", " An <B>array</B> of length 1 of ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299334", " limit would be likely to succeed. The second <B>array</B> contains the underlying faces of the blend to", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299341", " except for any vertices supplied in the vertices <B>array</B> in the ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299949", " <B>array</B> returned by PK_BODY_fix_blends contains ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299993", " each blend face to be identified uniquely (each <B>array</B> in ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-1442349", " An <B>array</B> of length 1 that contains the natural chamfer", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-1442353", " An <B>array</B> of length 4 containing the parameter intervals of", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-1442361", " An <B>array</B> of length 1 and type PK_PARAM_direction_t that specifies", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.079.html#50409866_pgfId-711344", " of faces in the left wall, and an <B>array</B> of those faces. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-711349", " of faces in the right wall, and an <B>array</B> of those faces. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-1403266", " The number of sheet bodies created, and an <B>array</B> of those sheet bodies. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-1403271", " The number of blend faces created, and an <B>array</B> of those blend faces. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-299611", " specified line. All holdlines are represented by an <B>array</B> of one or more edges. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-304986", " An <B>array</B> of edges to use as tangent holdlines. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-304990", " An <B>array</B> of edges to use as conic holdlines. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-304994", " An <B>array</B> of edges to use as cliff edges. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-304998", " An <B>array</B> of edges to use as inverted tangent holdlines.", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-305002", " An <B>array</B> of edges to use as inverted conic holdlines.", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-308207", " isoparameter plane. To use this option, specify an <B>array</B> of fins or faces in the ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-308294", " <B>array</B>, and the cap face has arisen from using", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-308303", " <B>array</B> requires a corresponding logical value in the ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311514", " of each group. The first member of the <B>array</B> defines the start of the first interval, the", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311536", " The ribs that were created, stored as an <B>array</B> of geometry. These are usually curves, but may", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311540", " An <B>array</B> of parameters. Each member of the <B>array</B> represents the position of the corresponding rib on", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311544", " An <B>array</B> of indices that uniquely identifies each rib returned.", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-312692", " <B>array</B>, and the associated underlying entities (which may consist", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-295196", " of faces in the left wall, and an <B>array</B> of those faces. ", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-295201", " of faces in the right wall, and an <B>array</B> of those faces. ", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-295206", " of faces in the centre wall, and an <B>array</B> of those faces. ", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-296224", " <B>array</B>, and the cap face has arisen from using", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.082.html#50409869_pgfId-305561", " an <B>array</B> of topological entities associated with the fault ", "Functional Description - Interpreting Face-Face Blending Error Codes");
top.note("chapters/fd_chap.082.html#50409869_pgfId-305565", " an <B>array</B> of vectors associated with the fault ", "Functional Description - Interpreting Face-Face Blending Error Codes");
top.note("chapters/fd_chap.082.html#50409869_pgfId-305569", " an <B>array</B> of distance values associated with the fault ", "Functional Description - Interpreting Face-Face Blending Error Codes");
top.note("chapters/fd_chap.082.html#50409869_pgfId-305609", " is the invalid <B>array</B> of faces. ", "Functional Description - Interpreting Face-Face Blending Error Codes");
top.note("chapters/fd_chap.082.html#50409869_pgfId-305660", " is an <B>array</B> containing the tags of a pair of clashing", "Functional Description - Interpreting Face-Face Blending Error Codes");
top.note("chapters/fd_chap.082.html#50409869_pgfId-305665", " is an <B>array</B> containing the tags of a pair of clashing", "Functional Description - Interpreting Face-Face Blending Error Codes");
top.note("chapters/fd_chap.082.html#50409869_pgfId-305670", " is an <B>array</B> containing the tags of the blend faces with", "Functional Description - Interpreting Face-Face Blending Error Codes");
top.note("chapters/fd_chap.084.html#50409872_pgfId-604974", " Sewing an <B>array</B> of facet sheet bodies ", "Functional Description - Overview Of Convergent Modeling");
top.note("chapters/fd_chap.085.html#50409873_pgfId-437289", " Parasolid to load all PSM data for an <B>array</B> of parts specified or for a given partition", "Functional Description - Facet Model Structure");
top.note("chapters/fd_chap.085.html#50409873_pgfId-509671", " Imprint an <B>array</B> of vectors on to a mesh ", "Functional Description - Facet Model Structure");
top.note("chapters/fd_chap.086.html#50409874_pgfId-475431", " Whether to return an <B>array</B> of all topological entities that were modified by", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-431075", " An <B>array</B> of faces that the given mtopols are attached", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.087.html#50409875_pgfId-339499", " <B>array</B> contains a single list of the ", "Functional Description - Creating PSM Data From Foreign Facet Data");
top.note("chapters/fd_chap.088.html#50409876_pgfId-339928", " <B>array</B> of new, repaired meshes, together with an <B>array</B> of PK_MESH_defect_details_t structures (one for each mesh returned),", "Functional Description - Checking and Repairing Mesh Data");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343304", " An <B>array</B> of position data to help locate chains of", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343025", " option takes an <B>array</B> of position vectors, and for each position vector", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.090.html#50409878_pgfId-372574", " Attached to an mfacet in the received <B>array</B> ", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.090.html#50409878_pgfId-424127", " option controls whether to return an <B>array</B> of mvertices along with the number of those", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.097.html#50409887_pgfId-294789", " number of functions are available to write an <B>array</B> of data into an attribute field of a", "Functional Description - Attributes");
top.note("chapters/fd_chap.098.html#50409888_pgfId-294912", " PK_PARTITION_merge takes an <B>array</B> of partitions and an <B>array</B> of pmarks. ", "Functional Description - Partitions");
top.note("chapters/fd_chap.098.html#50409888_pgfId-294913", " The first partition in the partitions <B>array</B> survives the operation, and all the others are", "Functional Description - Partitions");
top.note("chapters/fd_chap.098.html#50409888_pgfId-294914", " The pmarks <B>array</B> contains all the pmarks for each of the", "Functional Description - Partitions");
top.note("chapters/fd_chap.098.html#50409888_pgfId-294915", " from each original partition must appear in this <B>array</B> in the order in which they occur in", "Functional Description - Partitions");
top.note("chapters/fd_chap.099.html#50409889_pgfId-294862", " <B>Array</B> name ", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-294925", " 98.2.4.1 Correct use of the mod_entities <B>array</B> ", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-294928", " <B>array</B> cannot be, and it is not recommended that", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-294930", " <B>array</B> may sometimes contain entities that do not seem", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-294949", " <B>array</B>, not the attributes themselves. ", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-294951", " <B>array</B> (and improve performance) in this way by setting", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-294964", " return <B>array</B> can include entities that do not appear to", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-295023", " the immediately following pmarks are also in the <B>array</B> of pmarks to be deleted (and can themselves", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-450184", " is a no-roll attribute. This function takes an <B>array</B> of attributes and checks each one for the", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-295349", " writes (appends) n_bytes bytes from the given <B>array</B> to the given delta ", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-295353", " n_bytes bytes from the given delta into the <B>array</B> ", "Functional Description - Rollback");
top.note("chapters/fd_chap.100.html#50409890_pgfId-392361", " automatically deleted. For each entity label in this <B>array</B>, if the number of entities in the group", "Functional Description - Groups");
top.note("chapters/fd_chap.100.html#50409890_pgfId-392400", " An <B>array</B> of integers that specifies the minimum number of", "Functional Description - Groups");
top.note("chapters/fd_chap.100.html#50409890_pgfId-380381", " Turn an <B>array</B> of entities into a group. ", "Functional Description - Groups");
top.note("chapters/fd_chap.101.html#50409891_pgfId-294983", " <B>Array</B> ", "Functional Description - Bulletin Board");
top.note("chapters/fd_chap.101.html#50409891_pgfId-341662", " of the entity involved. The use of this <B>array</B> is optional and depends on whether the user", "Functional Description - Bulletin Board");
top.note("chapters/fd_chap.103.html#50409893_pgfId-329870", " Starts shuffling of return <B>array</B> arguments from some Parasolid functions. ", "Functional Description - Debug Functionality");
top.note("chapters/fd_chap.103.html#50409893_pgfId-329874", " Stops shuffling of return <B>array</B> arguments from some Parasolid functions. ", "Functional Description - Debug Functionality");
top.note("chapters/fd_chap.103.html#50409893_pgfId-335741", " and the entry into and exit from an <B>array</B> of PK functions. You can supply a pair", "Functional Description - Debug Functionality");
top.note("chapters/fd_chap.103.html#50409893_pgfId-329936", " Registers an <B>array</B> of PK functions that are to be watched", "Functional Description - Debug Functionality");
top.note("chapters/fd_chap.106.html#50409897_pgfId-295200", " functions it must not contain duplicates, unless an <B>array</B> of transformation entities is also supplied, implying that", "Functional Description - Rendering Functions");
top.note("chapters/fd_chap.106.html#50409897_pgfId-295206", " Each entity in the <B>array</B> of geometric or topological entities is identified by", "Functional Description - Rendering Functions");
top.note("chapters/fd_chap.106.html#50409897_pgfId-295207", " 1. When faces or edges appear in the <B>array</B> of topological entities, a call to GOOPSG is", "Functional Description - Rendering Functions");
top.note("chapters/fd_chap.106.html#50409897_pgfId-309850", " The PK rendering functions can be passed an <B>array</B> of transformation entities, allowing selective transformation of individual", "Functional Description - Rendering Functions");
top.note("chapters/fd_chap.106.html#50409897_pgfId-295225", " An <B>array</B> entry of PK_ENTITY_null denotes that a particular entity", "Functional Description - Rendering Functions");
top.note("chapters/fd_chap.107.html#50409898_pgfId-1012719", " <B>array</B> that indicates the scale relative to the smallest", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-305586", " <B>array</B> (as passed to PK_TOPOL_render_line ), enabling you to", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-305605", " will be checked against all others in this <B>array</B>. ", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-305611", " Each body indexed in the first <B>array</B> will be checked against all bodies indexed in", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-305620", " of bodies indexed by corresponding entries in each <B>array</B> will be checked for clashes. ", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-303921", " <B>array</B> of an occurrence of the body to the", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-303939", " <B>array</B> contains an index to it, regardless of whether", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-303942", " <B>array</B> contains the index values of body occurrences that", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-304499", " An <B>array</B> of viewports. Each viewport is specified using the", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-1018689", " <B>array</B> that indicates the scale relative to the smallest", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.109.html#50409900_pgfId-964408", " any boundaries between neighbouring faces in the input <B>array</B>. ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-313209", " option. This takes an <B>array</B> of unit vectors, each unit vector defining a", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-313270", " is an <B>array</B> of PK_TRANSF_t objects, each object defining a different", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-313273", " <B>array</B> can currently only contain a single view direction.", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-333090", " to be attached to entities. This is an <B>array</B> of PK_facet_local_tolerances_t . Default: 0 (empty). ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-333094", " An <B>array</B> of unique topological entities (faces or bodies) to", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-333096", " If this is not empty, the parallel <B>array</B> ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-333101", " <B>array</B> for each of the entities in ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-1435626", " options. An <B>array</B> of bodies whose facets you want to enlarge", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.111.html#50409902_pgfId-295099", " table, and the value is stored in the <B>array</B>. ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-295104", " two or more fields. The index of the <B>array</B> itself has no specific meaning. ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-297822", " You can return an <B>array</B> of all the coordinates that are available for", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-297832", " You can return an <B>array</B> of all the normals that are available for", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-297844", " You can return an <B>array</B> of all the surface parameters that are available", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-297853", " You can return an <B>array</B> of all the first or second order derivatives", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-514172", " You can return an <B>array</B> of all the principal directions and curvatures of", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294746", " space is allocated as a 4 by 4 <B>array</B> in C using ", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.113.html#50409904_pgfId-326790", " (world) coordinate system as the bodies. If an <B>array</B> of transforms is provided in ", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.113.html#50409904_pgfId-300631", " An <B>array</B> of nearby entities ", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.113.html#50409904_pgfId-419672", " from a subset of topologies from the supplied <B>array</B>. Where you can supply this context, limiting the", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.113.html#50409904_pgfId-420066", " An <B>array</B> of topologies for Parasolid to pick from. ", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.113.html#50409904_pgfId-420355", " A parallel <B>array</B> to ", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.113.html#50409904_pgfId-425012", " <B>array</B> that indicates the scale relative to the smallest", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.125.html#50409919_pgfId-306776", " stores an <B>array</B> of distinct values and an <B>array</B> of integer multiplicities. This is reflected in the", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285609", " // Basic constructor, taking an <B>array</B> ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285634", " This has the same <B>array</B> of two doubles, called value, but it has", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285636", " The only example of a two-dimensional <B>array</B> in the PK interface is PK_TRANS_sf_t. The C#", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285911", " C.6.2 Functions with <B>array</B> arguments ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285912", " arrays. In order to support both, functions with <B>array</B> arguments are overloaded: two versions are provided, one", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285960", " still only provides two versions: one with all <B>array</B> arguments as C-style arrays, and one with all", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275464", " which a composite B-curve is represented by an <B>array</B> of B-spline vertices, and a knot vector. ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275758", " of curve pieces. It is represented by an <B>array</B> of points of the curve and values for", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275841", " meets specified constraints. It is represented by an <B>array</B> of position vectors and values representing its degree,", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275884", " Used for saving an <B>array</B> of information with each entity, for example, a", "Functional Description - ZGlossary");
top.note("chapters/ov_chap.05.html#50442271_pgfId-294256", " tools with a local boolean operation and an <B>array</B> of transforms so as to repeat the boolean", "Overview of Parasolid - Booleans and Related Functionality");
top.note("chapters/ov_chap.05.html#50442271_pgfId-312017", " of a set of faces according to an <B>array</B> of specified transforms. Although patterning may initially appear", "Overview of Parasolid - Booleans and Related Functionality");
top.note("chapters/ov_chap.05.html#50442271_pgfId-312039", " a separate target and tool, together with an <B>array</B> of transforms that describes how the patterns are", "Overview of Parasolid - Booleans and Related Functionality");
top.note("chapters/ov_chap.14.html#50442249_pgfId-275835", " Parasolid provides a vast <B>array</B> of functionality to let you enquire about the", "Overview of Parasolid - Enquiring Model Data and Identifying Details");
top.note("chapters/ov_chap.15.html#50442255_pgfId-293141", " Via an <B>array</B> table. This option does not use the GO.", "Overview of Parasolid - Displaying Data");
top.note("chapters/ov_chap.15.html#50442255_pgfId-288401", " your application using the GO, or using an <B>array</B> table. ", "Overview of Parasolid - Displaying Data");
top.note("chapters/ov_chap.20.html#50442278_pgfId-5437414", " <B>array</B> tables ", "Overview of Parasolid - Multi-Processing Support");
top.note("chapters/p2_chap.03.html#sec_b_1_1", " PK_BODY_fault_bad_body_c 15102 PK_CLASS_body appears in classes none <B>array</B> but not at the first position ", "PK Reference - PK token Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.05.html#sec_d_1_app", " The associated data in topols is the invalid <B>array</B> of faces. ", "PK Reference - PK token Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.07.html#sec_f_1_1", " PK_ERROR_wrong_entity 10 PK_TOPOL_make_facet_topol The topols <B>array</B> contains an item which is", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_2", " PK_ERROR_wrong_entity_in_array 357 PK_ATTDEF_create invalid token found in <B>array</B> of owners", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_3", " PK_ERROR_not_in_same_body 1032 PK_CURVE_project (MILD) The targets <B>array</B> contains", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_4", " PK_ERROR_bad_class 5041 PK_BODY_create_minimum_topology bad class in classes <B>array</B>", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.09.html#sec_h_1_1", " PK_ERROR_bad_class 5041 PK_BODY_create_minimum_topology bad class in classes <B>array</B>", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_2", " PK_ERROR_duplicate_array_item 511 PK_ATTDEF_create item duplicated in <B>array</B> of owners", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_3", " PK_BODY_find_knit_pattern a general body is present in the <B>array</B> of", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_4", " not in the given <B>array</B>", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.10.html#sec_i_1_1", " PK_ATTDEF_create 511 PK_ERROR_duplicate_array_item item duplicated in <B>array</B> of owners", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_2", " PK_CURVE_project 1032 PK_ERROR_not_in_same_body (MILD) The targets <B>array</B> contains", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_3", " 511 PK_ERROR_duplicate_array_item geom has duplicates but no transf <B>array</B>", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_4", " transfs <B>array</B> is not a rigid motion", "PK Reference - PK Error Codes (Functional)");
top.note("headers/pk_3_face_blend_t.html#documentation", " invalid <B>array</B> of faces.", "PK Reference - PK_3_face_blend_t");
top.note("headers/pk_assembly_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_ASSEMBLY_t ", "PK Reference - PK_ASSEMBLY_array_t");
top.note("headers/pk_assembly_array_t.html#documentation", " PK_ASSEMBLY_t *<B>array</B>; --- <B>array</B> of ASSEMBLYs", "PK Reference - PK_ASSEMBLY_array_t");
top.note("headers/pk_assembly_ask_instances.html#documentation", "The output <B>array</B> instances is optional. If it is set to", "PK Reference - PK_ASSEMBLY_ask_instances");
top.note("headers/pk_assembly_ask_parts.html#documentation", "The output <B>array</B> parts is optional. If it is set to", "PK Reference - PK_ASSEMBLY_ask_parts");
top.note("headers/pk_assembly_ask_parts_transfs.html#documentation", "The output <B>array</B> parts is optional. If it is set to", "PK Reference - PK_ASSEMBLY_ask_parts_transfs");
top.note("headers/pk_assembly_check.html#documentation", "Faults are returned in an <B>array</B> of PK_check_fault_t structures.", "PK Reference - PK_ASSEMBLY_check");
top.note("headers/pk_assembly_check_r_t.html#documentation", " faults An <B>array</B> containing the faults found.", "PK Reference - PK_ASSEMBLY_check_r_t");
top.note("headers/pk_attdef_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_ATTDEF_t ", "PK Reference - PK_ATTDEF_array_t");
top.note("headers/pk_attdef_array_t.html#documentation", " PK_ATTDEF_t *<B>array</B>; --- <B>array</B> of ATTribute DEFinitions", "PK Reference - PK_ATTDEF_array_t");
top.note("headers/pk_attdef_ask.html#description", "<B>array</B> fields of non zero length.", "PK Reference - PK_ATTDEF_ask");
top.note("headers/pk_attdef_ask_2.html#description", "<B>array</B> fields of non zero length.", "PK Reference - PK_ATTDEF_ask_2");
top.note("headers/pk_attdef_create.html#errors", " PK_ERROR_wrong_entity_in_array invalid token found in <B>array</B> of owners", "PK Reference - PK_ATTDEF_create");
top.note("headers/pk_attdef_create_2.html#errors", " PK_ERROR_wrong_entity_in_array invalid token found in <B>array</B> of owners", "PK Reference - PK_ATTDEF_create_2");
top.note("headers/pk_attdef_sf_2_t.html#documentation", " An <B>array</B> of length n_owner_types which dictates the entity", "PK Reference - PK_ATTDEF_sf_2_t");
top.note("headers/pk_attdef_sf_t.html#documentation", " owner_types An <B>array</B> of length n_owner_types which dictates the entity", "PK Reference - PK_ATTDEF_sf_t");
top.note("headers/pk_attrib_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_ATTRIB_t ", "PK Reference - PK_ATTRIB_array_t");
top.note("headers/pk_attrib_array_t.html#documentation", " PK_ATTRIB_t *<B>array</B>; --- <B>array</B> of ATTRIButes", "PK Reference - PK_ATTRIB_array_t");
top.note("headers/pk_attrib_ask_axes.html#description", " This function returns the <B>array</B> of axes from field field_no of the given", "PK Reference - PK_ATTRIB_ask_axes");
top.note("headers/pk_attrib_ask_axes.html#documentation", "The output <B>array</B> axes is optional. If it is set to", "PK Reference - PK_ATTRIB_ask_axes");
top.note("headers/pk_attrib_ask_doubles.html#description", " This function returns the <B>array</B> of doubles from field field_no ", "PK Reference - PK_ATTRIB_ask_doubles");
top.note("headers/pk_attrib_ask_doubles.html#documentation", "The output <B>array</B> doubles is optional. If it is set to", "PK Reference - PK_ATTRIB_ask_doubles");
top.note("headers/pk_attrib_ask_ints.html#description", " This function returns the <B>array</B> of integers from field field_no ", "PK Reference - PK_ATTRIB_ask_ints");
top.note("headers/pk_attrib_ask_ints.html#documentation", "The output <B>array</B> ints is optional. If it is set to", "PK Reference - PK_ATTRIB_ask_ints");
top.note("headers/pk_attrib_ask_named_axes.html#description", " This function returns the <B>array</B> of axes from field field_name of the given", "PK Reference - PK_ATTRIB_ask_named_axes");
top.note("headers/pk_attrib_ask_named_axes.html#documentation", "The output <B>array</B> axes is optional. If it is set to", "PK Reference - PK_ATTRIB_ask_named_axes");
top.note("headers/pk_attrib_ask_named_doubles.html#description", " This function returns the <B>array</B> of doubles from field field_name ", "PK Reference - PK_ATTRIB_ask_named_doubles");
top.note("headers/pk_attrib_ask_named_doubles.html#documentation", "The output <B>array</B> doubles is optional. If it is set to", "PK Reference - PK_ATTRIB_ask_named_doubles");
top.note("headers/pk_attrib_ask_named_ints.html#description", " This function returns the <B>array</B> of integers from field field_name ", "PK Reference - PK_ATTRIB_ask_named_ints");
top.note("headers/pk_attrib_ask_named_ints.html#documentation", "The output <B>array</B> ints is optional. If it is set to", "PK Reference - PK_ATTRIB_ask_named_ints");
top.note("headers/pk_attrib_ask_named_pointers.html#description", " This function returns the <B>array</B> of pointers from field field_name ", "PK Reference - PK_ATTRIB_ask_named_pointers");
top.note("headers/pk_attrib_ask_named_pointers.html#documentation", "The output <B>array</B> pointers is optional. If it is set to", "PK Reference - PK_ATTRIB_ask_named_pointers");
top.note("headers/pk_attrib_ask_named_vectors.html#description", " This function returns the <B>array</B> of vectors from field field_name ", "PK Reference - PK_ATTRIB_ask_named_vectors");
top.note("headers/pk_attrib_ask_named_vectors.html#documentation", "The output <B>array</B> vectors is optional. If it is set to", "PK Reference - PK_ATTRIB_ask_named_vectors");
top.note("headers/pk_attrib_ask_no_roll.html#description", " an <B>array</B> of attributes, and returns a corresponding <B>array</B>", "PK Reference - PK_ATTRIB_ask_no_roll");
top.note("headers/pk_attrib_ask_nth_axis.html#description", " function returns a single element of the axis <B>array</B> from field", "PK Reference - PK_ATTRIB_ask_nth_axis");
top.note("headers/pk_attrib_ask_nth_double.html#description", " function returns a single element of the double <B>array</B> from field", "PK Reference - PK_ATTRIB_ask_nth_double");
top.note("headers/pk_attrib_ask_nth_int.html#description", " function returns a single element of the integer <B>array</B> from field", "PK Reference - PK_ATTRIB_ask_nth_int");
top.note("headers/pk_attrib_ask_nth_pointer.html#description", " function returns a single element of the pointer <B>array</B> from field", "PK Reference - PK_ATTRIB_ask_nth_pointer");
top.note("headers/pk_attrib_ask_nth_vector.html#description", " function returns a single element of the vector <B>array</B> from field", "PK Reference - PK_ATTRIB_ask_nth_vector");
top.note("headers/pk_attrib_ask_pointers.html#description", " This function returns the <B>array</B> of pointers from field field_no ", "PK Reference - PK_ATTRIB_ask_pointers");
top.note("headers/pk_attrib_ask_pointers.html#documentation", "The output <B>array</B> pointers is optional. If it is set to", "PK Reference - PK_ATTRIB_ask_pointers");
top.note("headers/pk_attrib_ask_vectors.html#description", " This function returns the <B>array</B> of vectors from field field_no ", "PK Reference - PK_ATTRIB_ask_vectors");
top.note("headers/pk_attrib_ask_vectors.html#documentation", "The output <B>array</B> vectors is optional. If it is set to", "PK Reference - PK_ATTRIB_ask_vectors");
top.note("headers/pk_attrib_cb_f_t.html#documentation", "definition, the length of each <B>array</B> of attribute field values, the arrays of", "PK Reference - PK_ATTRIB_cb_f_t");
top.note("headers/pk_attrib_reset_cb_f_t.html#documentation", "then values is an <B>array</B> of n_values characters which does not", "PK Reference - PK_ATTRIB_reset_cb_f_t");
top.note("headers/pk_attrib_reset_cb_r_t.html#declaration", " int n_values; --- length of <B>array</B> of values", "PK Reference - PK_ATTRIB_reset_cb_r_t");
top.note("headers/pk_attrib_reset_cb_r_t.html#documentation", " values, indicating that the <B>array</B> values ", "PK Reference - PK_ATTRIB_reset_cb_r_t");
top.note("headers/pk_bb_output_events.html#documentation", " event_types <B>array</B> (see documentation for PK_BB_event_t ) and the classes", "PK Reference - PK_BB_output_events");
top.note("headers/pk_bcurve_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_BCURVE_t ", "PK Reference - PK_BCURVE_array_t");
top.note("headers/pk_bcurve_array_t.html#documentation", " PK_BCURVE_t *<B>array</B>; --- <B>array</B> of B geometry CURVEs", "PK Reference - PK_BCURVE_array_t");
top.note("headers/pk_bcurve_ask_knots.html#documentation", "multiplicity) be returned. In this case the integer <B>array</B> of multiplicities", "PK Reference - PK_BCURVE_ask_knots");
top.note("headers/pk_bcurve_create_by_fitting.html#declaration", " PK_BCURVE_t bcurves[],--- <B>array</B> of b-curves, some", "PK Reference - PK_BCURVE_create_by_fitting");
top.note("headers/pk_bcurve_create_by_fitting_o_t.html#declaration", " PK_BCURVE_fit_data_t *fit_data; --- <B>array</B> of fitting data (NULL)", "PK Reference - PK_BCURVE_create_by_fitting_o_t");
top.note("headers/pk_bcurve_create_by_fitting_o_t.html#documentation", " fit_data an <B>array</B> of length n_curves specifying for each", "PK Reference - PK_BCURVE_create_by_fitting_o_t");
top.note("headers/pk_bcurve_create_fitted_o_t.html#documentation", " interpolation_parms a strictly increasing <B>array</B> of length", "PK Reference - PK_BCURVE_create_fitted_o_t");
top.note("headers/pk_bcurve_create_spline_2_o_t.html#documentation", " parameters An <B>array</B> of length n_parameters . If this option is", "PK Reference - PK_BCURVE_create_spline_2_o_t");
top.note("headers/pk_bcurve_create_spline_o_t.html#documentation", " parameters An <B>array</B> of length n_parameters . If this option is", "PK Reference - PK_BCURVE_create_spline_o_t");
top.note("headers/pk_bcurve_fit_chain_t.html#documentation", " curves_in_chain An ordered <B>array</B> of n_curves_in_chain curves.", "PK Reference - PK_BCURVE_fit_chain_t");
top.note("headers/pk_bcurve_fit_eval_f_t.html#documentation", " PK_BCURVE_fit_eval_failure_c will be returned in the corresponding <B>array</B>", "PK Reference - PK_BCURVE_fit_eval_f_t");
top.note("headers/pk_bcurve_fit_fault_t.html#documentation", " status an <B>array</B> of length n_curves specifying the final", "PK Reference - PK_BCURVE_fit_fault_t");
top.note("headers/pk_bcurve_piecewise_sf_t.html#documentation", " in the <B>array</B> coeffs . Allowable values are 3 and 4.", "PK Reference - PK_BCURVE_piecewise_sf_t");
top.note("headers/pk_bcurve_remove_knots_o_t.html#documentation", " knot_indices An <B>array</B> of length n_knot_indices . All values", "PK Reference - PK_BCURVE_remove_knots_o_t");
top.note("headers/pk_bcurve_sf_t.html#documentation", " the number of doubles per vertex in the <B>array</B>", "PK Reference - PK_BCURVE_sf_t");
top.note("headers/pk_bcurve_spline_r_t.html#documentation", " bcurves An <B>array</B> of length n_bcurves , each element holding", "PK Reference - PK_BCURVE_spline_r_t");
top.note("headers/pk_bcurve_spline_t.html#documentation", " the derivs <B>array</B> are returned in", "PK Reference - PK_BCURVE_spline_t");
top.note("headers/pk_bcurve_splinewise_sf_t.html#documentation", " positions <B>Array</B> of positions.", "PK Reference - PK_BCURVE_splinewise_sf_t");
top.note("headers/pk_blend_constraint_t.html#documentation", " An <B>array</B> of edge tags is given.", "PK Reference - PK_blend_constraint_t");
top.note("headers/pk_blend_delete_cap_data_t.html#documentation", " blends An <B>array</B>, of length n_blends , of blend faces to", "PK Reference - PK_blend_delete_cap_data_t");
top.note("headers/pk_blend_delete_unders_data_t.html#errors", " PK_ERROR_wrong_entity An <B>array</B> in unders contains entities that", "PK Reference - PK_blend_delete_unders_data_t");
top.note("headers/pk_blend_delete_unders_data_t.html#documentation", " blends An <B>array</B>, of length n_blends , of blend faces for", "PK Reference - PK_blend_delete_unders_data_t");
top.note("headers/pk_blend_limit_data_t.html#documentation", " limit_points is an <B>array</B> of length n_limits of points that specify the", "PK Reference - PK_blend_limit_data_t");
top.note("headers/pk_blend_limit_patch_array_t.html#description", " This structure wraps the data structure with the <B>array</B> length to allow", "PK Reference - PK_blend_limit_patch_array_t");
top.note("headers/pk_blend_params_t.html#documentation", "This datatype determines the contents of an <B>array</B> of doubles, blend_params ,", "PK Reference - PK_blend_params_t");
top.note("headers/pk_blend_rib_r_t.html#documentation", " number of curves and points in the ribs <B>array</B> (may be 0)", "PK Reference - PK_blend_rib_r_t");
top.note("headers/pk_blend_setback_data_t.html#documentation", " edges is an <B>array</B> of length n_edges specifying on which edges", "PK Reference - PK_blend_setback_data_t");
top.note("headers/pk_blend_setback_shape_data_t.html#declaration", " const PK_VERTEX_t *vertices; --- <B>array</B> of vertices at which the", "PK Reference - PK_blend_setback_shape_data_t");
top.note("headers/pk_blend_setback_shape_data_t.html#documentation", " vertices This is an <B>array</B> of length n_vertices specifying on", "PK Reference - PK_blend_setback_shape_data_t");
top.note("headers/pk_blend_vx_blend_data_t.html#declaration", " const PK_VERTEX_t *vertices; --- <B>array</B> of vertices to blend (NULL)", "PK Reference - PK_blend_vx_blend_data_t");
top.note("headers/pk_blend_vx_blend_data_t.html#documentation", " vertices is an <B>array</B> of length n_vertices specifying on", "PK Reference - PK_blend_vx_blend_data_t");
top.note("headers/pk_blend_vx_order_data_t.html#documentation", " vertices an <B>array</B> of length n_vertices specifying which", "PK Reference - PK_blend_vx_order_data_t");
top.note("headers/pk_blend_y_blend_data_t.html#declaration", " const PK_VERTEX_t *vertices; --- <B>array</B> of vertices to blend (NULL)", "PK Reference - PK_blend_y_blend_data_t");
top.note("headers/pk_blend_y_blend_data_t.html#documentation", " vertices is an <B>array</B> of length n_vertices specifying on", "PK Reference - PK_blend_y_blend_data_t");
top.note("headers/pk_blendsf_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_BLENDSF_t ", "PK Reference - PK_BLENDSF_array_t");
top.note("headers/pk_blendsf_array_t.html#documentation", " PK_BLENDSF_t *<B>array</B>; --- <B>array</B> of BLEND SurFaces", "PK Reference - PK_BLENDSF_array_t");
top.note("headers/pk_body_add_to_compound.html#documentation", "The <B>array</B> bodies must not contain compound bodies, children of", "PK Reference - PK_BODY_add_to_compound");
top.note("headers/pk_body_add_to_compound_o_t.html#documentation", " there will be an <B>array</B> in old_item_arrays containing", "PK Reference - PK_BODY_add_to_compound_o_t");
top.note("headers/pk_body_apply_knit_pattern.html#documentation", " the edges <B>array</B> within the knitting pattern will survive the knit", "PK Reference - PK_BODY_apply_knit_pattern");
top.note("headers/pk_body_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_BODY_t ", "PK Reference - PK_BODY_array_t");
top.note("headers/pk_body_array_t.html#documentation", " PK_BODY_t *<B>array</B>; --- <B>array</B> of BODYs", "PK Reference - PK_BODY_array_t");
top.note("headers/pk_body_ask_components.html#documentation", "The output <B>array</B> components is optional. If it is set to", "PK Reference - PK_BODY_ask_components");
top.note("headers/pk_body_ask_edges.html#documentation", "The output <B>array</B> edges is optional. If it is set to", "PK Reference - PK_BODY_ask_edges");
top.note("headers/pk_body_ask_faces.html#documentation", "The output <B>array</B> faces is optional. If it is set to", "PK Reference - PK_BODY_ask_faces");
top.note("headers/pk_body_ask_fins.html#documentation", "The output <B>array</B> fins is optional. If it is set to", "PK Reference - PK_BODY_ask_fins");
top.note("headers/pk_body_ask_frames.html#documentation", "The output <B>array</B> frames is optional. If it is set to", "PK Reference - PK_BODY_ask_frames");
top.note("headers/pk_body_ask_loops.html#documentation", "The output <B>array</B> loops is optional. If it is set to", "PK Reference - PK_BODY_ask_loops");
top.note("headers/pk_body_ask_regions.html#documentation", "The output <B>array</B> regions is optional. If it is set to", "PK Reference - PK_BODY_ask_regions");
top.note("headers/pk_body_ask_shells.html#documentation", "The output <B>array</B> shells is optional. If it is set to", "PK Reference - PK_BODY_ask_shells");
top.note("headers/pk_body_ask_vertices.html#documentation", "The output <B>array</B> vertices is optional. If it is set to", "PK Reference - PK_BODY_ask_vertices");
top.note("headers/pk_body_boolean_2.html#documentation", "an <B>array</B> within a results structure.", "PK Reference - PK_BODY_boolean_2");
top.note("headers/pk_body_check.html#documentation", "Faults are returned in an <B>array</B> of PK_check_fault_t structures.", "PK Reference - PK_BODY_check");
top.note("headers/pk_body_create_minimum_topology.html#errors", " PK_ERROR_bad_class bad class in classes <B>array</B>", "PK Reference - PK_BODY_create_minimum_topology");
top.note("headers/pk_body_create_sheet_planar.html#documentation", " loops field of the options structure is an <B>array</B> of the same length", "PK Reference - PK_BODY_create_sheet_planar");
top.note("headers/pk_body_create_sheet_planar_o_t.html#documentation", " belongs. Thus the number of elements in each <B>array</B> must be equal.", "PK Reference - PK_BODY_create_sheet_planar_o_t");
top.note("headers/pk_body_create_sheet_topology.html#errors", " PK_ERROR_bad_class bad class in classes <B>array</B>", "PK Reference - PK_BODY_create_sheet_topology");
top.note("headers/pk_body_create_solid_topology.html#errors", " PK_ERROR_bad_class bad class in classes <B>array</B>", "PK Reference - PK_BODY_create_solid_topology");
top.note("headers/pk_body_create_solid_topology.html#documentation", "The <B>array</B> classes specifies the class of each topological entity.", "PK Reference - PK_BODY_create_solid_topology");
top.note("headers/pk_body_create_topology.html#errors", " PK_ERROR_bad_class (MILD) bad class in classes <B>array</B>", "PK Reference - PK_BODY_create_topology");
top.note("headers/pk_body_create_topology.html#documentation", "The <B>array</B> classes specifies the class of each topological entity.", "PK Reference - PK_BODY_create_topology");
top.note("headers/pk_body_create_topology_2.html#errors", " PK_ERROR_bad_class (MILD) bad class in classes <B>array</B>", "PK Reference - PK_BODY_create_topology_2");
top.note("headers/pk_body_create_topology_2.html#documentation", "The <B>array</B> classes specifies the class of each topological entity.", "PK Reference - PK_BODY_create_topology_2");
top.note("headers/pk_body_create_topology_2_r_t.html#documentation", " entities corresponding to the entries in the classes <B>array</B> are", "PK Reference - PK_BODY_create_topology_2_r_t");
top.note("headers/pk_body_create_wire_topology.html#errors", " PK_ERROR_bad_class bad class in classes <B>array</B>", "PK Reference - PK_BODY_create_wire_topology");
top.note("headers/pk_body_embed_in_surf.html#documentation", "returned. Otherwise edges returns the <B>array</B> of edges whose curves have", "PK Reference - PK_BODY_embed_in_surf");
top.note("headers/pk_body_emboss.html#documentation", " and an <B>array</B> of entities involved in this failure is", "PK Reference - PK_BODY_emboss");
top.note("headers/pk_body_enlarge_r_t.html#documentation", " an operation failure and an <B>array</B> of entities involved in this", "PK Reference - PK_BODY_enlarge_r_t");
top.note("headers/pk_body_extend.html#documentation", " boundary_edges an <B>array</B> of laminar edges belonging to body and", "PK Reference - PK_BODY_extend");
top.note("headers/pk_body_fault_t.html#documentation", "returned which is the index in the classes <B>array</B> of the faulty entity.", "PK Reference - PK_BODY_fault_t");
top.note("headers/pk_body_fill_hole.html#documentation", " boundary of the hole is specified by the <B>array</B> edges . If the", "PK Reference - PK_BODY_fill_hole");
top.note("headers/pk_body_fill_hole_o_t.html#declaration", " --- <B>array</B> of boundary edges that do", "PK Reference - PK_BODY_fill_hole_o_t");
top.note("headers/pk_body_fill_hole_o_t.html#documentation", " non_smooth_edges <B>Array</B> of boundary edges for which G1 smoothness to adjoining", "PK Reference - PK_BODY_fill_hole_o_t");
top.note("headers/pk_body_find_facesets_o_t.html#documentation", " the <B>array</B> must contain only one topology.", "PK Reference - PK_BODY_find_facesets_o_t");
top.note("headers/pk_body_find_facesets_r_t.html#documentation", " Each <B>array</B> element represents a complete faceset.", "PK Reference - PK_BODY_find_facesets_r_t");
top.note("headers/pk_body_find_knit_pattern.html#declaration", " int n_bodies, --- <B>array</B> of", "PK Reference - PK_BODY_find_knit_pattern");
top.note("headers/pk_body_find_knit_pattern.html#errors", " PK_ERROR_bad_type body in the <B>array</B> is of incorrect type", "PK Reference - PK_BODY_find_knit_pattern");
top.note("headers/pk_body_find_knit_pattern.html#documentation", " of edges, and an <B>array</B> of bodies. Corresponding elements in the arrays", "PK Reference - PK_BODY_find_knit_pattern");
top.note("headers/pk_body_find_laminar_edges.html#documentation", "The output <B>array</B> components is optional. If it is set to", "PK Reference - PK_BODY_find_laminar_edges");
top.note("headers/pk_body_fix_blends.html#documentation", " then unders will contain an <B>array</B> of n_blends arrays of", "PK Reference - PK_BODY_fix_blends");
top.note("headers/pk_body_fix_blends_o_t.html#documentation", " limit_topols An <B>array</B> of faces and/or fins which will be used", "PK Reference - PK_BODY_fix_blends_o_t");
top.note("headers/pk_body_hollow.html#documentation", " been split, so a single face in one <B>array</B> corresponds to two or", "PK Reference - PK_BODY_hollow");
top.note("headers/pk_body_hollow_2.html#documentation", "<B>array</B> in the supplied option structure. Pierced faces remain", "PK Reference - PK_BODY_hollow_2");
top.note("headers/pk_body_hollow_o_t.html#declaration", " --- faces in offset_faces <B>array</B> (NULL)", "PK Reference - PK_BODY_hollow_o_t");
top.note("headers/pk_body_hollow_o_t.html#documentation", " pierce_faces The <B>array</B> of faces which are not to be offset.", "PK Reference - PK_BODY_hollow_o_t");
top.note("headers/pk_body_imprint_cus_shadow.html#documentation", " argument is not NULL, it refers to an <B>array</B> of n_bodies ", "PK Reference - PK_BODY_imprint_cus_shadow");
top.note("headers/pk_body_knit.html#errors", " <B>array</B> or appears in both arrays", "PK Reference - PK_BODY_knit");
top.note("headers/pk_body_knit.html#documentation", " be knitted to the element in the matches <B>array</B>", "PK Reference - PK_BODY_knit");
top.note("headers/pk_body_knit_result_t.html#documentation", " unknit_edges: An <B>array</B> of all edges from the knitting pattern that", "PK Reference - PK_BODY_knit_result_t");
top.note("headers/pk_body_loft_face_clamp_t.html#declaration", " const PK_FACE_t *faces; --- <B>array</B> of clamping faces (NULL)", "PK Reference - PK_BODY_loft_face_clamp_t");
top.note("headers/pk_body_loft_face_clamp_t.html#documentation", " faces An <B>array</B> of faces, one for each clamped edge of", "PK Reference - PK_BODY_loft_face_clamp_t");
top.note("headers/pk_body_loft_vector_clamp_t.html#declaration", " const PK_VECTOR_t *tangents; --- <B>array</B> of derivative vectors (NULL)", "PK Reference - PK_BODY_loft_vector_clamp_t");
top.note("headers/pk_body_loft_vector_clamp_t.html#description", " an <B>array</B> of derivative vectors and an optional <B>array</B>", "PK Reference - PK_BODY_loft_vector_clamp_t");
top.note("headers/pk_body_loft_vector_clamp_t.html#documentation", " tangents An <B>array</B> of derivatives one for each vertex of vertices", "PK Reference - PK_BODY_loft_vector_clamp_t");
top.note("headers/pk_body_make_compound_o_t.html#documentation", " there will be an <B>array</B> in old_item_arrays containing", "PK Reference - PK_BODY_make_compound_o_t");
top.note("headers/pk_body_make_curves_outline.html#documentation", "the bodies <B>array</B> must not contain duplicates.", "PK Reference - PK_BODY_make_curves_outline");
top.note("headers/pk_body_make_lofted_body.html#documentation", "This function receives an <B>array</B> of profiles and constructs a body", "PK Reference - PK_BODY_make_lofted_body");
top.note("headers/pk_body_make_lofted_body_o_t.html#declaration", " --- <B>array</B> of derivative", "PK Reference - PK_BODY_make_lofted_body_o_t");
top.note("headers/pk_body_make_lofted_body_o_t.html#documentation", " guide_wires An <B>array</B> of oriented connected manifold wire bodies", "PK Reference - PK_BODY_make_lofted_body_o_t");
top.note("headers/pk_body_make_manifold_bodies.html#declaration", " PK_BODY_t **const components --- <B>array</B> of manifold bodies", "PK Reference - PK_BODY_make_manifold_bodies");
top.note("headers/pk_body_make_manifold_bodies.html#documentation", "If the given body is general, an <B>array</B> of manifold bodies is returned. The", "PK Reference - PK_BODY_make_manifold_bodies");
top.note("headers/pk_body_make_persp_outline.html#documentation", "the bodies <B>array</B> must not contain duplicates.", "PK Reference - PK_BODY_make_persp_outline");
top.note("headers/pk_body_make_persp_outline_r_t.html#documentation", " outlines An <B>array</B> of length n_outlines , each element", "PK Reference - PK_BODY_make_persp_outline_r_t");
top.note("headers/pk_body_make_section.html#documentation", "failure and, if possible, an <B>array</B> of entities. These entities may assist the", "PK Reference - PK_BODY_make_section");
top.note("headers/pk_body_make_section_o_t.html#documentation", " If this <B>array</B> is empty resultant bodies may contain", "PK Reference - PK_BODY_make_section_o_t");
top.note("headers/pk_body_make_section_r_t.html#declaration", " PK_section_report_r_t *reports; --- <B>array</B> of report structures", "PK Reference - PK_BODY_make_section_r_t");
top.note("headers/pk_body_make_section_r_t.html#documentation", " bodies The <B>array</B> of resultant bodies.", "PK Reference - PK_BODY_make_section_r_t");
top.note("headers/pk_body_make_section_with_surfs.html#documentation", "failure and, if possible, an <B>array</B> of entities. These entities may assist the", "PK Reference - PK_BODY_make_section_with_surfs");
top.note("headers/pk_body_make_spun_outline.html#documentation", "the bodies <B>array</B> must not contain duplicates.", "PK Reference - PK_BODY_make_spun_outline");
top.note("headers/pk_body_make_spun_outline_o_t.html#documentation", " exclude_faces <B>Array</B> of faces to exclude from outlining.", "PK Reference - PK_BODY_make_spun_outline_o_t");
top.note("headers/pk_body_make_swept_body.html#documentation", " product_topols is an <B>array</B> containing that lateral face", "PK Reference - PK_BODY_make_swept_body");
top.note("headers/pk_body_make_swept_body_2.html#documentation", " guides profile vertex (supplied in the profile_matches <B>array</B> in", "PK Reference - PK_BODY_make_swept_body_2");
top.note("headers/pk_body_make_swept_body_2_o_t.html#declaration", " --- <B>array</B> of path vertices to ignore", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_2_o_t.html#documentation", " ignorable_vertices An <B>array</B> of path and guide vertices that may be", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#declaration", " --- <B>array</B> of vertices to ignore", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#documentation", " ignorable_vertices An <B>array</B> of path vertices that may be ignored, for", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_make_swept_tool.html#documentation", " product_topols is an <B>array</B> containing that face.", "PK Reference - PK_BODY_make_swept_tool");
top.note("headers/pk_body_make_swept_tool_o_t.html#documentation", " cap_faces The <B>array</B> of cap faces of the tool. (NULL)", "PK Reference - PK_BODY_make_swept_tool_o_t");
top.note("headers/pk_body_offset_2.html#documentation", " , it indicates an operation failure and an <B>array</B>", "PK Reference - PK_BODY_offset_2");
top.note("headers/pk_body_offset_o_t.html#declaration", " --- faces in offset_faces <B>array</B> (NULL)", "PK Reference - PK_BODY_offset_o_t");
top.note("headers/pk_body_offset_o_t.html#documentation", " offset_faces The <B>array</B> of faces which are to be offset by", "PK Reference - PK_BODY_offset_o_t");
top.note("headers/pk_body_pick_topols.html#declaration", "const PK_PART_t bodies[], --- body <B>array</B>", "PK Reference - PK_BODY_pick_topols");
top.note("headers/pk_body_pick_topols.html#description", " Pick entities from an <B>array</B> of body instances by their proximity to a", "PK Reference - PK_BODY_pick_topols");
top.note("headers/pk_body_pick_topols.html#errors", " PK_ERROR_duplicate_array_item (MILD) body <B>array</B> contains duplicate bodies", "PK Reference - PK_BODY_pick_topols");
top.note("headers/pk_body_pick_topols.html#documentation", " picks faces, edges, vertices and frames from an <B>array</B> of", "PK Reference - PK_BODY_pick_topols");
top.note("headers/pk_body_pick_topols_o_t.html#declaration", " --- <B>array</B> of bodies to which a", "PK Reference - PK_BODY_pick_topols_o_t");
top.note("headers/pk_body_pick_topols_o_t.html#documentation", " topols_to_pick_from : An <B>array</B> containing the topologies to pick from", "PK Reference - PK_BODY_pick_topols_o_t");
top.note("headers/pk_body_pick_topols_r_t.html#documentation", "an index into the owning body <B>array</B> and possibly an associated transformation.", "PK Reference - PK_BODY_pick_topols_r_t");
top.note("headers/pk_body_problem_group_array_t.html#declaration", " PK_BODY_problem_group_t *<B>array</B>;", "PK Reference - PK_BODY_problem_group_array_t");
top.note("headers/pk_body_problem_group_array_t.html#description", " A structure to embody an <B>array</B> of structures of type PK_BODY_problem_group_t ", "PK Reference - PK_BODY_problem_group_array_t");
top.note("headers/pk_body_problem_group_t.html#documentation", " edges: An <B>array</B> of those edges.", "PK Reference - PK_BODY_problem_group_t");
top.note("headers/pk_body_section_with_sheet_2.html#documentation", "will be contained within the <B>array</B> of report structures, referenced via the", "PK Reference - PK_BODY_section_with_sheet_2");
top.note("headers/pk_body_sew_bodies.html#documentation", " a collection of sheet bodies presented in the <B>array</B>", "PK Reference - PK_BODY_sew_bodies");
top.note("headers/pk_body_sew_bodies_o_t.html#declaration", " double *iteration_bounds; --- <B>array</B> of gap width bounds", "PK Reference - PK_BODY_sew_bodies_o_t");
top.note("headers/pk_body_sew_bodies_o_t.html#documentation", " If iteration is requested and the <B>array</B> held in", "PK Reference - PK_BODY_sew_bodies_o_t");
top.note("headers/pk_body_simplify_geom.html#documentation", "The output <B>array</B> geoms is optional. If it is set to", "PK Reference - PK_BODY_simplify_geom");
top.note("headers/pk_body_spin.html#documentation", "<B>array</B> contains the topological entities extruded to create the", "PK Reference - PK_BODY_spin");
top.note("headers/pk_body_sweep.html#documentation", "<B>array</B> contains the topological entities extruded to create the", "PK Reference - PK_BODY_sweep");
top.note("headers/pk_body_sweep_fault_t.html#documentation", " fault_locations <B>array</B>, and the", "PK Reference - PK_BODY_sweep_fault_t");
top.note("headers/pk_body_sweep_law_discrete_t.html#documentation", " vertices An <B>array</B> of the vertices that have specified law values.", "PK Reference - PK_BODY_sweep_law_discrete_t");
top.note("headers/pk_body_sweep_tool_status_r_t.html#documentation", " faults An <B>array</B> indicating one or more possible problems in", "PK Reference - PK_BODY_sweep_tool_status_r_t");
top.note("headers/pk_body_taper_o_t.html#documentation", " methods <B>Array</B> of n_methods tapering methods to be", "PK Reference - PK_BODY_taper_o_t");
top.note("headers/pk_body_thicken_2.html#documentation", "code is normally accompanied by an <B>array</B> of entities which indicate where", "PK Reference - PK_BODY_thicken_2");
top.note("headers/pk_body_thicken_3.html#documentation", "possible, an <B>array</B> of entities involved in the failure is returned", "PK Reference - PK_BODY_thicken_3");
top.note("headers/pk_body_thicken_o_t.html#documentation", " faces <B>Array</B> of length n_faces , containing faces with", "PK Reference - PK_BODY_thicken_o_t");
top.note("headers/pk_body_transform.html#documentation", "in the exact <B>array</B> may indicate whether the surface is an exact", "PK Reference - PK_BODY_transform");
top.note("headers/pk_body_transform_2.html#documentation", " , it indicates an operation failure and an <B>array</B>", "PK Reference - PK_BODY_transform_2");
top.note("headers/pk_body_trim.html#documentation", "in the faces <B>array</B> will survive and all others will be deleted.", "PK Reference - PK_BODY_trim");
top.note("headers/pk_body_trim_neutral_sheets.html#declaration", "const PK_FACE_set_pair_t pairs[], --- <B>array</B> of pairs", "PK Reference - PK_BODY_trim_neutral_sheets");
top.note("headers/pk_body_trim_neutral_sheets.html#documentation", "length as the given <B>array</B> of pairs. Each entry in the returned arrays", "PK Reference - PK_BODY_trim_neutral_sheets");
top.note("headers/pk_body_trim_neutral_sheets_2.html#declaration", "const PK_FACE_set_pair_t pairs[], --- <B>array</B> of pairs", "PK Reference - PK_BODY_trim_neutral_sheets_2");
top.note("headers/pk_body_trim_neutral_sheets_2.html#documentation", "the same length as the given <B>array</B> of pairs. Each entry in the returned arrays", "PK Reference - PK_BODY_trim_neutral_sheets_2");
top.note("headers/pk_body_vertex_match_t.html#description", " This structure holds an <B>array</B> of matches, each of which describes an", "PK Reference - PK_BODY_vertex_match_t");
top.note("headers/pk_body_vertex_match_t.html#documentation", " matches An <B>array</B> of matches, each of which describes an", "PK Reference - PK_BODY_vertex_match_t");
top.note("headers/pk_body_vertex_matches_t.html#description", " This structure holds an <B>array</B> of mappings between bodies in a series, each", "PK Reference - PK_BODY_vertex_matches_t");
top.note("headers/pk_body_vertex_matches_t.html#documentation", " mappings An <B>array</B> of mappings, each of which describes", "PK Reference - PK_BODY_vertex_matches_t");
top.note("headers/pk_boolean_match_o_t.html#documentation", " match_regions <B>Array</B> of structures describing the matched", "PK Reference - PK_boolean_match_o_t");
top.note("headers/pk_boolean_r_t.html#documentation", " bodies The <B>array</B> of resultant bodies from the boolean operation. If", "PK Reference - PK_boolean_r_t");
top.note("headers/pk_boolean_region_select_o_t.html#documentation", " region. The <B>array</B> may contain a mixture of faces, edges", "PK Reference - PK_boolean_region_select_o_t");
top.note("headers/pk_boolean_report_r_t.html#documentation", " entities This <B>array</B> may contain topological or geometric entities", "PK Reference - PK_boolean_report_r_t");
top.note("headers/pk_boolean_result_t.html#documentation", " PK_boolean_result_failed_c The boolean failed. The bodies <B>array</B> will", "PK Reference - PK_boolean_result_t");
top.note("headers/pk_boolean_select_topolset_o_t.html#documentation", " topolset. The <B>array</B> may contain a mixture of solid", "PK Reference - PK_boolean_select_topolset_o_t");
top.note("headers/pk_bsurf_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_BSURF_t ", "PK Reference - PK_BSURF_array_t");
top.note("headers/pk_bsurf_array_t.html#documentation", " PK_BSURF_t *<B>array</B>; --- <B>array</B> of B geometry SURFaces", "PK Reference - PK_BSURF_array_t");
top.note("headers/pk_bsurf_ask_knots.html#documentation", "multiplicity) be returned. In this case the integer <B>array</B> of multiplicities", "PK Reference - PK_BSURF_ask_knots");
top.note("headers/pk_bsurf_create_constrained_o_t.html#documentation", " an <B>array</B> parallel to the normals <B>array</B>. It contains", "PK Reference - PK_BSURF_create_constrained_o_t");
top.note("headers/pk_bsurf_create_fitted_o_t.html#documentation", " u_interpolation_parms a strictly increasing <B>array</B> of length", "PK Reference - PK_BSURF_create_fitted_o_t");
top.note("headers/pk_bsurf_piecewise_sf_t.html#documentation", " in the <B>array</B> coeffs . Allowable values are 3 and 4.", "PK Reference - PK_BSURF_piecewise_sf_t");
top.note("headers/pk_bsurf_remove_knots_o_t.html#documentation", " knot_indices An <B>array</B> of length n_knot_indices . All values", "PK Reference - PK_BSURF_remove_knots_o_t");
top.note("headers/pk_bsurf_sf_t.html#documentation", " the number of doubles per vertex in the <B>array</B> vertex .", "PK Reference - PK_BSURF_sf_t");
top.note("headers/pk_bsurf_splinewise_sf_t.html#documentation", " positions <B>Array</B> of positions.", "PK Reference - PK_BSURF_splinewise_sf_t");
top.note("headers/pk_change_edge_geom_data_t.html#declaration", " const PK_change_edge_method_t *methods; --- <B>array</B> of edge control", "PK Reference - PK_change_edge_geom_data_t");
top.note("headers/pk_change_edge_geom_data_t.html#errors", " PK_ERROR_unsuitable_entity (MILD) The entities <B>array</B> has been supplied", "PK Reference - PK_change_edge_geom_data_t");
top.note("headers/pk_change_edge_geom_data_t.html#documentation", " The <B>array</B> default value is NULL.", "PK Reference - PK_change_edge_geom_data_t");
top.note("headers/pk_circle_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_CIRCLE_t ", "PK Reference - PK_CIRCLE_array_t");
top.note("headers/pk_circle_array_t.html#documentation", " PK_CIRCLE_t *<B>array</B>; --- <B>array</B> of CIRCLEs", "PK Reference - PK_CIRCLE_array_t");
top.note("headers/pk_class_array_t.html#description", " This structure contains an <B>array</B> of tokens of type PK_CLASS_t ", "PK Reference - PK_CLASS_array_t");
top.note("headers/pk_class_array_t.html#documentation", " PK_CLASS_t *<B>array</B>; --- <B>array</B> of CLASS tokens", "PK Reference - PK_CLASS_array_t");
top.note("headers/pk_clip_lattice_r_t.html#documentation", " error_ltopols This <B>array</B> may contain lattice topologies related to the", "PK Reference - PK_clip_lattice_r_t");
top.note("headers/pk_cone_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_CONE_t ", "PK Reference - PK_CONE_array_t");
top.note("headers/pk_cone_array_t.html#documentation", " PK_CONE_t *<B>array</B>; --- <B>array</B> of CONEs", "PK Reference - PK_CONE_array_t");
top.note("headers/pk_create_fault_t.html#documentation", " n_indices The length of the <B>array</B> indices (may be zero).", "PK Reference - PK_create_fault_t");
top.note("headers/pk_curve_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_CURVE_t ", "PK Reference - PK_CURVE_array_t");
top.note("headers/pk_curve_array_t.html#documentation", " PK_CURVE_t *<B>array</B>; --- <B>array</B> of CURVEs", "PK Reference - PK_CURVE_array_t");
top.note("headers/pk_curve_ask_edges.html#documentation", "The output <B>array</B> edges is optional. If it is set to", "PK Reference - PK_CURVE_ask_edges");
top.note("headers/pk_curve_ask_edges_nmnl.html#documentation", "The output <B>array</B> edges is optional. If it is set to", "PK Reference - PK_CURVE_ask_edges_nmnl");
top.note("headers/pk_curve_degens_t.html#documentation", " degen An <B>array</B> of length n_degen , holding information on each", "PK Reference - PK_CURVE_degens_t");
top.note("headers/pk_curve_eval.html#documentation", "In the <B>array</B> of returned data:", "PK Reference - PK_CURVE_eval");
top.note("headers/pk_curve_fix_degens_r_t.html#documentation", " curves An <B>array</B> of length n_curves , each element holding", "PK Reference - PK_CURVE_fix_degens_r_t");
top.note("headers/pk_curve_fix_self_int_r_t.html#documentation", " curves An <B>array</B> of length n_curves , each element holding information", "PK Reference - PK_CURVE_fix_self_int_r_t");
top.note("headers/pk_curve_general_user_t.html#declaration", " double *discontinuities; --- <B>array</B> of parameters at", "PK Reference - PK_CURVE_general_user_t");
top.note("headers/pk_curve_intersect_curve.html#documentation", "It returns an <B>array</B> of intersection vectors vectors , arrays of parameters", "PK Reference - PK_CURVE_intersect_curve");
top.note("headers/pk_curve_make_bcurve_array.html#description", " Given an <B>array</B> of curves and intervals this function creates", "PK Reference - PK_CURVE_make_bcurve_array");
top.note("headers/pk_curve_make_spcurves.html#documentation", " <B>Array</B> of SP-Curves of length n_spcurves.", "PK Reference - PK_CURVE_make_spcurves");
top.note("headers/pk_curve_make_spcurves_2.html#documentation", " <B>Array</B> of SP-curves of length n_spcurves.", "PK Reference - PK_CURVE_make_spcurves_2");
top.note("headers/pk_curve_make_wire_body_2.html#declaration", "int **const edge_index --- pos in original <B>array</B>", "PK Reference - PK_CURVE_make_wire_body_2");
top.note("headers/pk_curve_make_wire_body_2.html#description", " This function creates a wire body from an <B>array</B> of curves and intervals. The", "PK Reference - PK_CURVE_make_wire_body_2");
top.note("headers/pk_curve_make_wire_body_2.html#documentation", "interval in the <B>array</B> bounds . The wire may be closed. If", "PK Reference - PK_CURVE_make_wire_body_2");
top.note("headers/pk_curve_make_wire_body_o_t.html#documentation", " with an <B>array</B> of integers, indicating the position in", "PK Reference - PK_CURVE_make_wire_body_o_t");
top.note("headers/pk_curve_project.html#declaration", "const PK_CURVE_t curves[], --- <B>array</B> of tool curves", "PK Reference - PK_CURVE_project");
top.note("headers/pk_curve_project.html#errors", " PK_ERROR_not_in_same_body (MILD) The targets <B>array</B> contains", "PK Reference - PK_CURVE_project");
top.note("headers/pk_curve_project.html#documentation", "The targets <B>array</B> may contain a single body, a single surface,", "PK Reference - PK_CURVE_project");
top.note("headers/pk_curve_project_o_t.html#declaration", " PK_CLASS_array_t banned_classes; --- <B>array</B> of curve classes which are", "PK Reference - PK_CURVE_project_o_t");
top.note("headers/pk_curve_project_o_t.html#errors", " PK_ERROR_bad_class (MILD) The banned_classes <B>array</B>", "PK Reference - PK_CURVE_project_o_t");
top.note("headers/pk_curve_project_o_t.html#documentation", " banned_classes If this <B>array</B> is empty, the output curves may be of", "PK Reference - PK_CURVE_project_o_t");
top.note("headers/pk_curve_project_r_t.html#documentation", " geoms An <B>array</B> of length n_geoms , each element holding information", "PK Reference - PK_CURVE_project_r_t");
top.note("headers/pk_curve_self_int_t.html#documentation", " positions An <B>array</B> of length n_positions containing positions in", "PK Reference - PK_CURVE_self_int_t");
top.note("headers/pk_curve_self_ints_t.html#documentation", " self_int An <B>array</B> of length n_self_int , holding information on", "PK Reference - PK_CURVE_self_ints_t");
top.note("headers/pk_cyl_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_CYL_t ", "PK Reference - PK_CYL_array_t");
top.note("headers/pk_cyl_array_t.html#documentation", " PK_CYL_t *<B>array</B>; --- <B>array</B> of CYLinders", "PK Reference - PK_CYL_array_t");
top.note("headers/pk_debug_body_compare_r_t.html#documentation", " global_diffs <B>Array</B> of global difference structures", "PK Reference - PK_DEBUG_BODY_compare_r_t");
top.note("headers/pk_debug_check_fault_t.html#declaration", " PK_ITEM_array_t item_array; --- <B>array</B> of fault items", "PK Reference - PK_DEBUG_check_fault_t");
top.note("headers/pk_debug_data_t.html#declaration", " PK_GEOM_array_t geom_array; --- <B>array</B> of geoms", "PK Reference - PK_DEBUG_data_t");
top.note("headers/pk_debug_data_t.html#documentation", " geom_<B>array</B> Array of geometry.", "PK Reference - PK_DEBUG_data_t");
top.note("headers/pk_debug_face_pair_r_t.html#documentation", " local_diffs <B>Array</B> of return structures containing local", "PK Reference - PK_DEBUG_face_pair_r_t");
top.note("headers/pk_debug_session_check.html#documentation", "An <B>array</B> of up to max_faults (specified in the options", "PK Reference - PK_DEBUG_SESSION_check");
top.note("headers/pk_debug_session_check_o_t.html#documentation", " partitions <B>Array</B> of length n_partitions containing partitions", "PK Reference - PK_DEBUG_SESSION_check_o_t");
top.note("headers/pk_debug_session_watch_fns.html#description", " This function registers an <B>array</B> of PK functions that are to be watched", "PK Reference - PK_DEBUG_SESSION_watch_fns");
top.note("headers/pk_debug_session_watch_fns.html#documentation", "The application may register an <B>array</B> of PK functions to watch via an", "PK Reference - PK_DEBUG_SESSION_watch_fns");
top.note("headers/pk_debug_shuffle_start.html#description", " Initialises and starts the shuffling of return <B>array</B> arguments for some", "PK Reference - PK_DEBUG_shuffle_start");
top.note("headers/pk_debug_shuffle_start.html#documentation", "When shuffling is started, the return <B>array</B> arguments of some PK functions", "PK Reference - PK_DEBUG_shuffle_start");
top.note("headers/pk_debug_shuffle_stop.html#description", " Stops the shuffling of return <B>array</B> arguments.", "PK Reference - PK_DEBUG_shuffle_stop");
top.note("headers/pk_detail_def_hole_t.html#documentation", " components <B>array</B> of hole components ( PK_hole_component_t ). These", "PK Reference - PK_detail_def_hole_t");
top.note("headers/pk_double_array_t.html#declaration", " double *<B>array</B>;", "PK Reference - PK_double_array_t");
top.note("headers/pk_double_array_t.html#description", " This structure contains an <B>array</B> of doubles.", "PK Reference - PK_double_array_t");
top.note("headers/pk_double_array_t.html#documentation", " <B>array</B> <B>array</B> of doubles", "PK Reference - PK_double_array_t");
top.note("headers/pk_edge_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_EDGE_t ", "PK Reference - PK_EDGE_array_t");
top.note("headers/pk_edge_array_t.html#documentation", " PK_EDGE_t *<B>array</B>; --- <B>array</B> of EDGEs", "PK Reference - PK_EDGE_array_t");
top.note("headers/pk_edge_ask_faces.html#documentation", "The output <B>array</B> faces is optional. If it is set to", "PK Reference - PK_EDGE_ask_faces");
top.note("headers/pk_edge_ask_fins.html#documentation", " direction of the edge, successive fins in the <B>array</B> are", "PK Reference - PK_EDGE_ask_fins");
top.note("headers/pk_edge_ask_shells.html#documentation", "The output <B>array</B> shells is optional. If it is set to", "PK Reference - PK_EDGE_ask_shells");
top.note("headers/pk_edge_ask_vertices.html#documentation", "The first entry in the <B>array</B> vertices will be the start vertex,", "PK Reference - PK_EDGE_ask_vertices");
top.note("headers/pk_edge_attach_curves_o_t.html#declaration", " PK_LOGICAL_t have_senses; --- the senses <B>array</B> is set", "PK Reference - PK_EDGE_attach_curves_o_t");
top.note("headers/pk_edge_attach_curves_o_t.html#documentation", " intervals An <B>array</B> of length n_intervals containing the parametric", "PK Reference - PK_EDGE_attach_curves_o_t");
top.note("headers/pk_edge_check.html#documentation", "Faults are returned in an <B>array</B> of PK_check_fault_t structures.", "PK Reference - PK_EDGE_check");
top.note("headers/pk_edge_find_blend_topol.html#documentation", "The <B>array</B> edges will always contain the original edge edge", "PK Reference - PK_EDGE_find_blend_topol");
top.note("headers/pk_edge_find_deviation_2.html#documentation", " <B>array</B> of PK_EDGE_find_deviation_t . Each element of this <B>array</B>", "PK Reference - PK_EDGE_find_deviation_2");
top.note("headers/pk_edge_find_deviation_r_t.html#documentation", " regions The <B>array</B> of overlap regions.", "PK Reference - PK_EDGE_find_deviation_r_t");
top.note("headers/pk_edge_find_deviation_t.html#documentation", " distances <B>Array</B> of distances between sample points.", "PK Reference - PK_EDGE_find_deviation_t");
top.note("headers/pk_edge_find_g1_edges.html#documentation", "returns an unordered <B>array</B> containing the received edge and connected tangent", "PK Reference - PK_EDGE_find_g1_edges");
top.note("headers/pk_edge_make_faces_from_wire.html#documentation", "The <B>array</B> shared_loop indicates which loops should occur in the", "PK Reference - PK_EDGE_make_faces_from_wire");
top.note("headers/pk_edge_offset_on_body.html#documentation", "The first edge in the edges <B>array</B> is the primary edge. The", "PK Reference - PK_EDGE_offset_on_body");
top.note("headers/pk_edge_offset_on_body_r_t.html#documentation", " fault_entities An <B>array</B> of entities associated with the given status.", "PK Reference - PK_EDGE_offset_on_body_r_t");
top.note("headers/pk_edge_repair.html#description", " This function attempts to repair an <B>array</B> of edges, i.e. make them valid.", "PK Reference - PK_EDGE_repair");
top.note("headers/pk_edge_reverse_2.html#documentation", "For each edge in the <B>array</B> edges , all fins have their sense (as", "PK Reference - PK_EDGE_reverse_2");
top.note("headers/pk_edge_set_blend_chain.html#documentation", "requirements apply to the elements of this <B>array</B>:", "PK Reference - PK_EDGE_set_blend_chain");
top.note("headers/pk_edge_set_blend_chain_o_t.html#declaration", " double *primary_sizes; --- size parameter <B>array</B> on", "PK Reference - PK_EDGE_set_blend_chain_o_t");
top.note("headers/pk_edge_set_blend_chain_o_t.html#documentation", " An <B>array</B> of PK_VECTOR_t specifying where the blend parameters with", "PK Reference - PK_EDGE_set_blend_chain_o_t");
top.note("headers/pk_edge_set_blend_chamfer.html#documentation", "Attaches unfixed chamfer blends to a given <B>array</B> of edges.", "PK Reference - PK_EDGE_set_blend_chamfer");
top.note("headers/pk_edge_set_blend_constant.html#documentation", "Attaches unfixed constant radius blends to a given <B>array</B> of edges.", "PK Reference - PK_EDGE_set_blend_constant");
top.note("headers/pk_edge_set_blend_variable.html#documentation", " ranges_1 is an <B>array</B> of length n_ranges , consisting of values", "PK Reference - PK_EDGE_set_blend_variable");
top.note("headers/pk_ellipse_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_ELLIPSE_t ", "PK Reference - PK_ELLIPSE_array_t");
top.note("headers/pk_ellipse_array_t.html#documentation", " PK_ELLIPSE_t *<B>array</B>; --- <B>array</B> of ELLIPSEs", "PK Reference - PK_ELLIPSE_array_t");
top.note("headers/pk_emboss_sidewall_data_t.html#declaration", " --- <B>array</B> of edges of profile which", "PK Reference - PK_emboss_sidewall_data_t");
top.note("headers/pk_emboss_sidewall_data_t.html#documentation", " multi_taper_edges <B>Array</B> of edges of profile body which will use different", "PK Reference - PK_emboss_sidewall_data_t");
top.note("headers/pk_entity_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_ENTITY_t ", "PK Reference - PK_ENTITY_array_t");
top.note("headers/pk_entity_array_t.html#documentation", " PK_ENTITY_t *<B>array</B>; --- <B>array</B> of ENTITYs", "PK Reference - PK_ENTITY_array_t");
top.note("headers/pk_entity_ask_attribs.html#declaration", " PK_ATTRIB_t **const attribs --- <B>array</B> of attributes (optional)", "PK Reference - PK_ENTITY_ask_attribs");
top.note("headers/pk_entity_ask_attribs.html#documentation", "The output <B>array</B> attribs is optional. If it is set to", "PK Reference - PK_ENTITY_ask_attribs");
top.note("headers/pk_entity_ask_owning_groups.html#documentation", "The output <B>array</B> groups is optional. If it is set to", "PK Reference - PK_ENTITY_ask_owning_groups");
top.note("headers/pk_entity_ask_owning_groups_o_t.html#documentation", " option determines whether the <B>array</B> of groups ", "PK Reference - PK_ENTITY_ask_owning_groups_o_t");
top.note("headers/pk_entity_check_attribs.html#documentation", "The output <B>array</B> faults is only accessed if the option return_faults", "PK Reference - PK_ENTITY_check_attribs");
top.note("headers/pk_entity_check_attribs_o_t.html#documentation", " return <B>array</B>, or only the number of such faults.", "PK Reference - PK_ENTITY_check_attribs_o_t");
top.note("headers/pk_entity_delete.html#errors", " not in the given <B>array</B>", "PK Reference - PK_ENTITY_delete");
top.note("headers/pk_entity_find_reparam.html#errors", " or surface, or is an <B>array</B> of", "PK Reference - PK_ENTITY_find_reparam");
top.note("headers/pk_entity_find_reparam.html#documentation", "The given entities should be an <B>array</B> of one of the following: a single body", "PK Reference - PK_ENTITY_find_reparam");
top.note("headers/pk_entity_find_reparam_r_t.html#documentation", "records An <B>array</B> each entry of which specifies a preferred", "PK Reference - PK_ENTITY_find_reparam_r_t");
top.note("headers/pk_entity_range.html#declaration", " int n_entities_1, --- no. of entities in first <B>array</B>", "PK Reference - PK_ENTITY_range");
top.note("headers/pk_entity_range.html#documentation", "One input <B>array</B> cannot contain both geometrical and topological entities.", "PK Reference - PK_ENTITY_range");
top.note("headers/pk_entity_range_end_t.html#documentation", " parameters : an <B>array</B> of two parameters of the end position holding", "PK Reference - PK_ENTITY_range_end_t");
top.note("headers/pk_entity_range_o_t.html#declaration", " --- first entity <B>array</B> (0)", "PK Reference - PK_ENTITY_range_o_t");
top.note("headers/pk_entity_range_o_t.html#documentation", " n_guesses_1 : value indicating the length of the <B>array</B> estimate", "PK Reference - PK_ENTITY_range_o_t");
top.note("headers/pk_entity_range_r_t.html#declaration", " PK_range_result_t *results; --- range status <B>array</B>", "PK Reference - PK_ENTITY_range_r_t");
top.note("headers/pk_entity_range_r_t.html#documentation", "The function returns results <B>array</B> which elements can be one of four values:", "PK Reference - PK_ENTITY_range_r_t");
top.note("headers/pk_entity_range_vector.html#declaration", "const PK_ENTITY_t entities[], --- entity <B>array</B>", "PK Reference - PK_ENTITY_range_vector");
top.note("headers/pk_entity_range_vector.html#description", " function finds the global minimum separation between an <B>array</B>", "PK Reference - PK_ENTITY_range_vector");
top.note("headers/pk_entity_range_vector.html#documentation", "the <B>array</B> of entities entities and the <B>array</B> of positions", "PK Reference - PK_ENTITY_range_vector");
top.note("headers/pk_entity_range_vector_o_t.html#declaration", " --- <B>array</B> of entities for which a", "PK Reference - PK_ENTITY_range_vector_o_t");
top.note("headers/pk_entity_range_vector_o_t.html#documentation", " n_guesses : value indicating the length of the <B>array</B> estimate", "PK Reference - PK_ENTITY_range_vector_o_t");
top.note("headers/pk_entity_range_vector_r_t.html#declaration", " PK_range_result_t *results; --- status <B>array</B>", "PK Reference - PK_ENTITY_range_vector_r_t");
top.note("headers/pk_entity_range_vector_r_t.html#documentation", "The function returns results <B>array</B> which elements can be one of four values:", "PK Reference - PK_ENTITY_range_vector_r_t");
top.note("headers/pk_entity_set_user_field.html#documentation", " user_field is an <B>array</B> whose length is set by the user_field option", "PK Reference - PK_ENTITY_set_user_field");
top.note("headers/pk_entity_track_r_t.html#documentation", " track_records The <B>array</B> of tracking information records.", "PK Reference - PK_ENTITY_track_r_t");
top.note("headers/pk_error_sf_t.html#declaration", " --- is an <B>array</B>, the <B>array</B> index", "PK Reference - PK_ERROR_sf_t");
top.note("headers/pk_expr_sf_t.html#documentation", " sub_expr_names An <B>array</B> of length n_sub_exprs , containing the name of", "PK Reference - PK_EXPR_sf_t");
top.note("headers/pk_face_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_FACE_t ", "PK Reference - PK_FACE_array_t");
top.note("headers/pk_face_array_t.html#documentation", " PK_FACE_t *<B>array</B>; --- <B>array</B> of FACEs", "PK Reference - PK_FACE_array_t");
top.note("headers/pk_face_ask_edges.html#documentation", "The output <B>array</B> edges is optional. If it is set to", "PK Reference - PK_FACE_ask_edges");
top.note("headers/pk_face_ask_faces_adjacent.html#declaration", "const PK_FACE_t faces[], --- <B>array</B> of faces", "PK Reference - PK_FACE_ask_faces_adjacent");
top.note("headers/pk_face_ask_faces_adjacent.html#description", "<B>array</B> of faces", "PK Reference - PK_FACE_ask_faces_adjacent");
top.note("headers/pk_face_ask_loops.html#documentation", "The output <B>array</B> loops is optional. If it is set to", "PK Reference - PK_FACE_ask_loops");
top.note("headers/pk_face_ask_shells.html#documentation", "The first entry in the <B>array</B> shells will be the shell to the back", "PK Reference - PK_FACE_ask_shells");
top.note("headers/pk_face_ask_vertices.html#documentation", "The output <B>array</B> vertices is optional. If it is set to", "PK Reference - PK_FACE_ask_vertices");
top.note("headers/pk_face_boolean.html#documentation", " <B>array</B> within the select_region option structure.", "PK Reference - PK_FACE_boolean");
top.note("headers/pk_face_boolean_2.html#documentation", "are returned in an <B>array</B> within a return structure.", "PK Reference - PK_FACE_boolean_2");
top.note("headers/pk_face_change.html#errors", " PK_ERROR_duplicate_array_item (MILD) duplication in faces <B>array</B>", "PK Reference - PK_FACE_change");
top.note("headers/pk_face_change.html#documentation", "The face/operation association is realised through the mapping <B>array</B>,", "PK Reference - PK_FACE_change");
top.note("headers/pk_face_change_blend_o_t.html#errors", " faces <B>array</B> belong to.", "PK Reference - PK_FACE_change_blend_o_t");
top.note("headers/pk_face_change_blend_o_t.html#documentation", " orientations An <B>array</B> of length n_unders which determines which side of", "PK Reference - PK_FACE_change_blend_o_t");
top.note("headers/pk_face_change_data_taper_t.html#documentation", " references <B>Array</B> of the taper reference entities", "PK Reference - PK_FACE_change_data_taper_t");
top.note("headers/pk_face_change_deform_o_t.html#documentation", " matched_edges An <B>array</B> of length n_matched_edges . An edge should be", "PK Reference - PK_FACE_change_deform_o_t");
top.note("headers/pk_face_change_taper_o_t.html#documentation", " condition. Edges in this <B>array</B> should NOT also", "PK Reference - PK_FACE_change_taper_o_t");
top.note("headers/pk_face_check.html#documentation", "Faults are returned in an <B>array</B> of PK_check_fault_t structures.", "PK Reference - PK_FACE_check");
top.note("headers/pk_face_check_pair.html#documentation", "Faults are returned in an <B>array</B> of PK_check_fault_t structures.", "PK Reference - PK_FACE_check_pair");
top.note("headers/pk_face_classify_details.html#documentation", "Currently members of the details <B>array</B> may only take the values:", "PK Reference - PK_FACE_classify_details");
top.note("headers/pk_face_classify_details_r_t.html#declaration", " PK_detail_def_t *detail_defs; --- <B>array</B> of detail definitions", "PK Reference - PK_FACE_classify_details_r_t");
top.note("headers/pk_face_classify_details_r_t.html#documentation", " detail_defs <B>array</B> of detail definitions", "PK Reference - PK_FACE_classify_details_r_t");
top.note("headers/pk_face_contains_vectors.html#documentation", "The positions must be represented either as an <B>array</B> of coordinates or as an", "PK Reference - PK_FACE_contains_vectors");
top.note("headers/pk_face_contains_vectors_o_t.html#documentation", "Where both are supplied, corresponding elements of each <B>array</B> must represent", "PK Reference - PK_FACE_contains_vectors_o_t");
top.note("headers/pk_face_delete_facesets.html#documentation", "function returns the index in the facesets <B>array</B> of that faceset.", "PK Reference - PK_FACE_delete_facesets");
top.note("headers/pk_face_delete_facesets_o_t.html#declaration", " PK_detail_t *details; --- <B>array</B> of details (NULL)", "PK Reference - PK_FACE_delete_facesets_o_t");
top.note("headers/pk_face_delete_facesets_o_t.html#documentation", " zero is equivalent to giving an <B>array</B> of length one", "PK Reference - PK_FACE_delete_facesets_o_t");
top.note("headers/pk_face_delete_from_sheet.html#declaration", "const PK_FACE_t faces[], --- <B>array</B> of faces", "PK Reference - PK_FACE_delete_from_sheet");
top.note("headers/pk_face_delete_from_sheet.html#documentation", "PK_LOGICAL_false, the function will return an <B>array</B> containing multiple", "PK Reference - PK_FACE_delete_from_sheet");
top.note("headers/pk_face_details_hole_o_t.html#documentation", " include_zero_depth whether the <B>array</B> of components in the", "PK Reference - PK_FACE_details_hole_o_t");
top.note("headers/pk_face_emboss.html#documentation", " failure and an <B>array</B> of entities involved is returned", "PK Reference - PK_FACE_emboss");
top.note("headers/pk_face_find_blend_unders_r_t.html#documentation", " An <B>array</B> of facesets, each faceset contains an <B>array</B>", "PK Reference - PK_FACE_find_blend_unders_r_t");
top.note("headers/pk_face_fix_mesh_defects.html#declaration", "const PK_FACE_t faces[], --- <B>array</B> of faces to process", "PK Reference - PK_FACE_fix_mesh_defects");
top.note("headers/pk_face_fix_mesh_defects_r_t.html#documentation", " defects : An <B>array</B> of remaining and introduced defects.", "PK Reference - PK_FACE_fix_mesh_defects_r_t");
top.note("headers/pk_face_hollow_2.html#documentation", " been split, so a single face in one <B>array</B> corresponds to two or", "PK Reference - PK_FACE_hollow_2");
top.note("headers/pk_face_hollow_3.html#documentation", " , it indicates an operation failure and an <B>array</B>", "PK Reference - PK_FACE_hollow_3");
top.note("headers/pk_face_identify_blends.html#description", " Given an <B>array</B> of faces (all from the same body) and", "PK Reference - PK_FACE_identify_blends");
top.note("headers/pk_face_identify_blends_r_t.html#documentation", " <B>array</B> of blend facesets, each faceset contains an <B>array</B>", "PK Reference - PK_FACE_identify_blends_r_t");
top.note("headers/pk_face_imprint_curves_2.html#description", " This function imprints an <B>array</B> of curves onto a face, thereby creating new", "PK Reference - PK_FACE_imprint_curves_2");
top.note("headers/pk_face_imprint_curves_isocline.html#documentation", "The output <B>array</B> ret_faces is optional. If it is set to", "PK Reference - PK_FACE_imprint_curves_isocline");
top.note("headers/pk_face_imprint_cus_normal.html#declaration", "const PK_FACE_t targets[], --- <B>array</B> of faces", "PK Reference - PK_FACE_imprint_cus_normal");
top.note("headers/pk_face_imprint_cus_normal.html#description", " the given <B>array</B> of curves on the given <B>array</B> of faces", "PK Reference - PK_FACE_imprint_cus_normal");
top.note("headers/pk_face_imprint_cus_vec.html#declaration", "const PK_FACE_t targets[], --- <B>array</B> of faces", "PK Reference - PK_FACE_imprint_cus_vec");
top.note("headers/pk_face_imprint_cus_vec.html#description", " the given <B>array</B> of curves on the given <B>array</B> of faces", "PK Reference - PK_FACE_imprint_cus_vec");
top.note("headers/pk_face_imprint_cus_vector.html#declaration", "const PK_FACE_t targets[], --- <B>array</B> of faces", "PK Reference - PK_FACE_imprint_cus_vector");
top.note("headers/pk_face_imprint_cus_vector.html#description", " the given <B>array</B> of curves on the given <B>array</B> of faces", "PK Reference - PK_FACE_imprint_cus_vector");
top.note("headers/pk_face_inst_tools_r_t.html#documentation", " instance_indices An integer <B>array</B> of length n_instances which indicates", "PK Reference - PK_FACE_inst_tools_r_t");
top.note("headers/pk_face_instance_bodies.html#documentation", " body in tool <B>array</B>", "PK Reference - PK_FACE_instance_bodies");
top.note("headers/pk_face_instance_tools.html#errors", "PK_ERROR_duplicate_array_item duplicate face in target or tool <B>array</B>", "PK Reference - PK_FACE_instance_tools");
top.note("headers/pk_face_intersect_curve.html#documentation", "and a face. It returns an <B>array</B> of intersection vectors vectors ,", "PK Reference - PK_FACE_intersect_curve");
top.note("headers/pk_face_make_3_face_blend.html#documentation", " left_wall_faces An <B>array</B> of the faces which make up the left", "PK Reference - PK_FACE_make_3_face_blend");
top.note("headers/pk_face_make_3_face_blend_r_t.html#documentation", " topols an <B>array</B> of topological entities associated with a status", "PK Reference - PK_FACE_make_3_face_blend_r_t");
top.note("headers/pk_face_make_blend.html#documentation", " left_wall_faces an <B>array</B> of the faces which make up the left", "PK Reference - PK_FACE_make_blend");
top.note("headers/pk_face_make_blend_o_t.html#documentation", " An <B>array</B> of edge tags is given.", "PK Reference - PK_FACE_make_blend_o_t");
top.note("headers/pk_face_make_neutral_sheet_o_t.html#declaration", " *methods; --- <B>array</B> of construction methods", "PK Reference - PK_FACE_make_neutral_sheet_o_t");
top.note("headers/pk_face_make_neutral_sheet_o_t.html#documentation", " contains an <B>array</B> of more than one element, the error", "PK Reference - PK_FACE_make_neutral_sheet_o_t");
top.note("headers/pk_face_make_sect_with_sfs.html#documentation", "failure and, if possible, an <B>array</B> of entities. These entities may assist the", "PK Reference - PK_FACE_make_sect_with_sfs");
top.note("headers/pk_face_make_sect_with_sfs_r_t.html#declaration", " PK_section_report_r_t *reports; --- <B>array</B> of report structures", "PK Reference - PK_FACE_make_sect_with_sfs_r_t");
top.note("headers/pk_face_make_sect_with_sfs_r_t.html#documentation", " bodies The <B>array</B> of resultant bodies.", "PK Reference - PK_FACE_make_sect_with_sfs_r_t");
top.note("headers/pk_face_make_sheet_bodies.html#declaration", "const PK_FACE_t faces[], --- <B>array</B> of faces", "PK Reference - PK_FACE_make_sheet_bodies");
top.note("headers/pk_face_make_sheet_body.html#declaration", "const PK_FACE_t faces[], --- <B>array</B> of faces", "PK Reference - PK_FACE_make_sheet_body");
top.note("headers/pk_face_neutral_causes_array_t.html#declaration", " int n_causes; --- Number of face causes in <B>array</B>", "PK Reference - PK_FACE_neutral_causes_array_t");
top.note("headers/pk_face_neutral_causes_array_t.html#description", " This data structure contains an <B>array</B> of PK_FACE_neutral_causes_t ", "PK Reference - PK_FACE_neutral_causes_array_t");
top.note("headers/pk_face_neutral_causes_array_t.html#documentation", "Each element of the <B>array</B> contains the tracking information for one", "PK Reference - PK_FACE_neutral_causes_array_t");
top.note("headers/pk_face_offset_2.html#documentation", " , it indicates an operation failure and an <B>array</B>", "PK Reference - PK_FACE_offset_2");
top.note("headers/pk_face_output_surf_trimmed.html#documentation", " spcurves consists of an <B>array</B> of SP-curves which describe the boundary", "PK Reference - PK_FACE_output_surf_trimmed");
top.note("headers/pk_face_output_surf_trimmed_o_t.html#documentation", " want_geoms : Requests the return of the <B>array</B> of geometries ( geoms )", "PK Reference - PK_FACE_output_surf_trimmed_o_t");
top.note("headers/pk_face_pattern.html#documentation", "the data contained in the patterns <B>array</B> :", "PK Reference - PK_FACE_pattern");
top.note("headers/pk_face_pattern_2.html#documentation", " patterns <B>array</B> :", "PK Reference - PK_FACE_pattern_2");
top.note("headers/pk_face_pattern_2_o_t.html#declaration", " PK_pattern_face_map_t *face_maps; --- <B>array</B> of face maps for pattern", "PK Reference - PK_FACE_pattern_2_o_t");
top.note("headers/pk_face_pattern_2_o_t.html#documentation", " face_maps <B>Array</B> of face maps. Each map is for an instance", "PK Reference - PK_FACE_pattern_2_o_t");
top.note("headers/pk_face_pattern_2_r_t.html#documentation", " patterns The <B>array</B> of pattern instance results. If the result ", "PK Reference - PK_FACE_pattern_2_r_t");
top.note("headers/pk_face_pattern_data_r_t.html#documentation", " relationship between this <B>array</B> and the input <B>array</B> of", "PK Reference - PK_FACE_pattern_data_r_t");
top.note("headers/pk_face_pattern_instance_r_t.html#documentation", " <B>array</B> and the pattern_faces <B>array</B> passed to", "PK Reference - PK_FACE_pattern_instance_r_t");
top.note("headers/pk_face_pattern_o_t.html#declaration", " PK_pattern_face_map_t *face_maps; --- <B>array</B> of face maps for pattern", "PK Reference - PK_FACE_pattern_o_t");
top.note("headers/pk_face_pattern_o_t.html#documentation", " face_maps <B>Array</B> of face maps. Each map is for an instance", "PK Reference - PK_FACE_pattern_o_t");
top.note("headers/pk_face_pattern_r_t.html#documentation", " patterns The <B>array</B> of pattern instance results. If the result ", "PK Reference - PK_FACE_pattern_r_t");
top.note("headers/pk_face_reparameterise_surf.html#errors", " PK_ERROR_duplicate_array_item (MILD) duplication in faces <B>array</B>", "PK Reference - PK_FACE_reparameterise_surf");
top.note("headers/pk_face_reparameterise_surf_o_t.html#declaration", " PK_GEOM_array_t construction_geoms; --- <B>array</B> of construction", "PK Reference - PK_FACE_reparameterise_surf_o_t");
top.note("headers/pk_face_reparameterise_surf_o_t.html#documentation", " construction_geoms <B>array</B> of construction geometries that are", "PK Reference - PK_FACE_reparameterise_surf_o_t");
top.note("headers/pk_face_reparameterise_surf_r_t.html#documentation", " faces : An <B>array</B> of faces being communicated back to the", "PK Reference - PK_FACE_reparameterise_surf_r_t");
top.note("headers/pk_face_replace_surfs_2.html#documentation", "code is normally accompanied by an <B>array</B> of entities which indicate where", "PK Reference - PK_FACE_replace_surfs_2");
top.note("headers/pk_face_replace_surfs_3.html#documentation", " flag, supplied to the function via the senses <B>array</B>, for a", "PK Reference - PK_FACE_replace_surfs_3");
top.note("headers/pk_face_replace_surfs_r_t.html#documentation", " failure, this <B>array</B> may contain topological or geometric", "PK Reference - PK_FACE_replace_surfs_r_t");
top.note("headers/pk_face_replace_with_sheet.html#documentation", " , it indicates an operation failure and an <B>array</B>", "PK Reference - PK_FACE_replace_with_sheet");
top.note("headers/pk_face_reverse.html#documentation", "For each face in the <B>array</B> faces , their orientation gets reversed and their", "PK Reference - PK_FACE_reverse");
top.note("headers/pk_face_section_with_sheet.html#documentation", "but will be put into the appropriate <B>array</B> within the results structure.", "PK Reference - PK_FACE_section_with_sheet");
top.note("headers/pk_face_section_with_sheet_2.html#documentation", "but will be put into the appropriate <B>array</B> within the results structure.", "PK Reference - PK_FACE_section_with_sheet_2");
top.note("headers/pk_face_simplify_geom.html#documentation", "The output <B>array</B> geoms is optional. If the want_geoms flag in", "PK Reference - PK_FACE_simplify_geom");
top.note("headers/pk_face_spin.html#documentation", "<B>array</B> contains the topological entities extruded to create the", "PK Reference - PK_FACE_spin");
top.note("headers/pk_face_sweep.html#documentation", "<B>array</B> contains the topological entities extruded to create the", "PK Reference - PK_FACE_sweep");
top.note("headers/pk_face_taper.html#documentation", " , it indicates an operation failure and an <B>array</B>", "PK Reference - PK_FACE_taper");
top.note("headers/pk_face_taper_o_t.html#declaration", " --- of this <B>array</B> is the same as", "PK Reference - PK_FACE_taper_o_t");
top.note("headers/pk_face_taper_o_t.html#documentation", " condition. Edges in this <B>array</B> should NOT also", "PK Reference - PK_FACE_taper_o_t");
top.note("headers/pk_face_tracking_r_t.html#documentation", " in the given <B>array</B> will have an index value of 0, those", "PK Reference - PK_FACE_tracking_r_t");
top.note("headers/pk_face_transform.html#documentation", "element in the exact <B>array</B> indicate whether the surface is an exact", "PK Reference - PK_FACE_transform");
top.note("headers/pk_face_transform_2.html#documentation", " , it indicates an operation failure and an <B>array</B>", "PK Reference - PK_FACE_transform_2");
top.note("headers/pk_fcurve_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_FCURVE_t ", "PK Reference - PK_FCURVE_array_t");
top.note("headers/pk_fcurve_array_t.html#documentation", " PK_FCURVE_t *<B>array</B>; --- <B>array</B> of Foreign CURVEs", "PK Reference - PK_FCURVE_array_t");
top.note("headers/pk_fgevsu_f_t.html#documentation", "rectangular <B>array</B> derivatives request) or FGEVTR (indicating a triangular", "PK Reference - PK_FGEVSU_f_t");
top.note("headers/pk_fgprsu_f_t.html#documentation", "<B>array</B> and the periodicity flags <B>array</B>.", "PK Reference - PK_FGPRSU_f_t");
top.note("headers/pk_field_names_t.html#description", " This union describes an <B>array</B> of either native-character strings, or Unicode", "PK Reference - PK_field_names_t");
top.note("headers/pk_fill_hole_point_data_t.html#documentation", " points A pointer to the <B>array</B> of points.", "PK Reference - PK_fill_hole_point_data_t");
top.note("headers/pk_fin_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_FIN_t ", "PK Reference - PK_FIN_array_t");
top.note("headers/pk_fin_array_t.html#documentation", " PK_FIN_t *<B>array</B>; --- <B>array</B> of FINs", "PK Reference - PK_FIN_array_t");
top.note("headers/pk_fin_find_mtopols.html#documentation", " function returns an <B>array</B> of mvertices and/or an <B>array</B> of mfins which", "PK Reference - PK_FIN_find_mtopols");
top.note("headers/pk_fin_find_mtopols_o_t.html#documentation", " <B>array</B> of mvertices is also returned.", "PK Reference - PK_FIN_find_mtopols_o_t");
top.note("headers/pk_find_reparam_record_r_t.html#declaration", " PK_GEOM_t *geoms; --- <B>Array</B> of geometries that are", "PK Reference - PK_find_reparam_record_r_t");
top.note("headers/pk_find_reparam_record_r_t.html#documentation", " topols An <B>array</B> of topologies whose shape depends on at", "PK Reference - PK_find_reparam_record_r_t");
top.note("headers/pk_fsurf_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_FSURF_t ", "PK Reference - PK_FSURF_array_t");
top.note("headers/pk_fsurf_array_t.html#documentation", " PK_FSURF_t *<B>array</B>; --- <B>array</B> of Foreign SURFaces", "PK Reference - PK_FSURF_array_t");
top.note("headers/pk_fxf_error_t.html#documentation", " topols an <B>array</B> of topological entities associated with the fault", "PK Reference - PK_fxf_error_t");
top.note("headers/pk_fxf_fault_t.html#documentation", " <B>array</B> of faces.", "PK Reference - PK_fxf_fault_t");
top.note("headers/pk_geom_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_GEOM_t ", "PK Reference - PK_GEOM_array_t");
top.note("headers/pk_geom_array_t.html#documentation", " PK_GEOM_t *<B>array</B>; --- <B>array</B> of GEOMetrical entities", "PK Reference - PK_GEOM_array_t");
top.note("headers/pk_geom_ask_dependents.html#documentation", "The output <B>array</B> dependents is optional. If it is set to", "PK Reference - PK_GEOM_ask_dependents");
top.note("headers/pk_geom_ask_geom_owners.html#documentation", "The output <B>array</B> owners is optional. If it is set to", "PK Reference - PK_GEOM_ask_geom_owners");
top.note("headers/pk_geom_check.html#documentation", "Faults are returned in an <B>array</B> of PK_check_fault_t structures.", "PK Reference - PK_GEOM_check");
top.note("headers/pk_geom_copy.html#documentation", "Each geometry in geoms is copied. The <B>array</B> geoms may contain any mixture", "PK Reference - PK_GEOM_copy");
top.note("headers/pk_geom_copy_r_t.html#documentation", " <B>array</B>. This <B>array</B> has length equal to n_geoms ( the number", "PK Reference - PK_GEOM_copy_r_t");
top.note("headers/pk_geom_enlarge.html#declaration", " --- enlarged geometries ( this <B>array</B>", "PK Reference - PK_GEOM_enlarge");
top.note("headers/pk_geom_enlarge_r_t.html#declaration", " PK_GEOM_enlarge_t *results; --- results <B>array</B>", "PK Reference - PK_GEOM_enlarge_r_t");
top.note("headers/pk_geom_enlarge_r_t.html#documentation", " The results <B>array</B> parallel to the input geoms <B>array</B>.", "PK Reference - PK_GEOM_enlarge_r_t");
top.note("headers/pk_geom_range.html#documentation", "an <B>array</B> of two structures of type PK_range_end_t , which", "PK Reference - PK_GEOM_range");
top.note("headers/pk_geom_range_array.html#declaration", " int n_geoms_1, --- no. entities in 1st <B>array</B>", "PK Reference - PK_GEOM_range_array");
top.note("headers/pk_geom_range_array.html#documentation", "and an <B>array</B> of two structure of type PK_range_end_t , which", "PK Reference - PK_GEOM_range_array");
top.note("headers/pk_geom_range_array_o_t.html#documentation", " param_bounds : an <B>array</B> of two arrays of structures for supplying", "PK Reference - PK_GEOM_range_array_o_t");
top.note("headers/pk_geom_range_array_vector.html#declaration", "const PK_GEOM_t geoms[], --- geometrical <B>array</B>", "PK Reference - PK_GEOM_range_array_vector");
top.note("headers/pk_geom_range_array_vector.html#description", " function finds the global minimum separation between an <B>array</B>", "PK Reference - PK_GEOM_range_array_vector");
top.note("headers/pk_geom_range_array_vector.html#documentation", "the <B>array</B> of geometrical entities geoms and the position vector", "PK Reference - PK_GEOM_range_array_vector");
top.note("headers/pk_geom_range_array_vector_o_t.html#description", "<B>array</B> of geometrical entities and a position.", "PK Reference - PK_GEOM_range_array_vector_o_t");
top.note("headers/pk_geom_range_local.html#documentation", " returned in ranges , this consists of an <B>array</B>", "PK Reference - PK_GEOM_range_local");
top.note("headers/pk_geom_range_local_vector.html#documentation", " returned in ranges , this consists of an <B>array</B>", "PK Reference - PK_GEOM_range_local_vector");
top.note("headers/pk_geom_range_o_t.html#documentation", " guesses : An <B>array</B> of two estimates structures, one for each end", "PK Reference - PK_GEOM_range_o_t");
top.note("headers/pk_geom_range_vector.html#documentation", " parameters : an <B>array</B> of two parameters of the end position holding", "PK Reference - PK_GEOM_range_vector");
top.note("headers/pk_geom_range_vector_many.html#declaration", "const PK_VECTOR_t vectors[], --- position <B>array</B>", "PK Reference - PK_GEOM_range_vector_many");
top.note("headers/pk_geom_range_vector_many.html#documentation", "any vector selected from the input <B>array</B> vectors can be found in the", "PK Reference - PK_GEOM_range_vector_many");
top.note("headers/pk_geom_range_vector_many_o_t.html#documentation", " guesses an <B>array</B> of estimate structures, for the end of the", "PK Reference - PK_GEOM_range_vector_many_o_t");
top.note("headers/pk_geom_range_vector_o_t.html#documentation", " parameters : an <B>array</B> of up to 2 parameters", "PK Reference - PK_GEOM_range_vector_o_t");
top.note("headers/pk_geom_render.html#documentation", " transfs is not NULL, it should be an <B>array</B> containing one PK_TRANSF_t for", "PK Reference - PK_GEOM_render");
top.note("headers/pk_geom_render_line.html#errors", " PK_ERROR_duplicate_array_item geom has duplicates but no transf <B>array</B>", "PK Reference - PK_GEOM_render_line");
top.note("headers/pk_geom_render_line.html#documentation", "The geoms <B>array</B> may not contain duplicates in this case.", "PK Reference - PK_GEOM_render_line");
top.note("headers/pk_geom_render_o_t.html#declaration", " PK_ENTITY_t *entities_with_scales;--- <B>Array</B> of entities for which a", "PK Reference - PK_GEOM_render_o_t");
top.note("headers/pk_geom_render_o_t.html#documentation", " be of length n_entities_with_scales , it takes an <B>array</B> of", "PK Reference - PK_GEOM_render_o_t");
top.note("headers/pk_geom_transform_2.html#description", " This function transforms the <B>array</B> of given geometric entities by the given", "PK Reference - PK_GEOM_transform_2");
top.note("headers/pk_geom_transform_2.html#documentation", "<B>array</B>, whereas the new transformations will create new geometric", "PK Reference - PK_GEOM_transform_2");
top.note("headers/pk_geom_transform_o_t.html#declaration", " PK_LOGICAL_t want_out_geoms;--- fill return <B>array</B> with new geom", "PK Reference - PK_GEOM_transform_o_t");
top.note("headers/pk_geom_transform_o_t.html#documentation", " want_out_geoms If set to PK_LOGICAL_true, the out_geoms <B>array</B> for", "PK Reference - PK_GEOM_transform_o_t");
top.note("headers/pk_gooppx_f_t.html#documentation", " nreals - length of the real <B>array</B> = 4", "PK Reference - PK_GOOPPX_f_t");
top.note("headers/pk_goopsg_f_t.html#documentation", " ntags , tags - an <B>array</B> of tags associated with the segment.", "PK Reference - PK_GOOPSG_f_t");
top.note("headers/pk_gosgmt_f_t.html#documentation", " ntags , tags - an <B>array</B> of tags associated with the segment.", "PK Reference - PK_GOSGMT_f_t");
top.note("headers/pk_group_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_GROUP_t ", "PK Reference - PK_GROUP_array_t");
top.note("headers/pk_group_array_t.html#documentation", " PK_GROUP_t *<B>array</B>; --- <B>array</B> of GROUPs", "PK Reference - PK_GROUP_array_t");
top.note("headers/pk_group_ask_closure_o_t.html#documentation", " want_attribs Whether an <B>array</B> of closing attributes is required.", "PK Reference - PK_GROUP_ask_closure_o_t");
top.note("headers/pk_group_ask_controls_r_t.html#documentation", " n_int_arrays This is the length of the <B>array</B> int_arrays . This can be", "PK Reference - PK_GROUP_ask_controls_r_t");
top.note("headers/pk_group_ask_entities.html#documentation", "The returned <B>array</B> entities is optional. If it is set to", "PK Reference - PK_GROUP_ask_entities");
top.note("headers/pk_group_create_from_ents_o_t.html#declaration", " --- <B>array</B> of entities to be assigned", "PK Reference - PK_GROUP_create_from_ents_o_t");
top.note("headers/pk_group_create_from_ents_o_t.html#documentation", " labelled_entities An <B>array</B> of entities to be assigned the labels given", "PK Reference - PK_GROUP_create_from_ents_o_t");
top.note("headers/pk_group_find_entities_o_t.html#documentation", " want_entities Whether to return an <B>array</B> of entities instead of", "PK Reference - PK_GROUP_find_entities_o_t");
top.note("headers/pk_group_merge_entities.html#description", " This function merges the given <B>array</B> of entities into the given group.", "PK Reference - PK_GROUP_merge_entities");
top.note("headers/pk_group_merge_entities.html#documentation", "The <B>array</B> entities may contain duplicates, and any of its", "PK Reference - PK_GROUP_merge_entities");
top.note("headers/pk_group_remove_entities.html#description", "the given <B>array</B> of entities.", "PK Reference - PK_GROUP_remove_entities");
top.note("headers/pk_group_remove_entities.html#documentation", "The <B>array</B> entities may include duplicates and entities which are", "PK Reference - PK_GROUP_remove_entities");
top.note("headers/pk_icurve_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_ICURVE_t ", "PK Reference - PK_ICURVE_array_t");
top.note("headers/pk_icurve_array_t.html#documentation", " PK_ICURVE_t *<B>array</B>; --- <B>array</B> of Intersection CURVEs", "PK Reference - PK_ICURVE_array_t");
top.note("headers/pk_identify_facesets_r_t.html#documentation", " body. Each <B>array</B> element represents a", "PK Reference - PK_identify_facesets_r_t");
top.note("headers/pk_imprint_face_hidden_t.html#documentation", " whether other faces in the input <B>array</B>", "PK Reference - PK_imprint_face_hidden_t");
top.note("headers/pk_imprint_r_t.html#documentation", " target_edges The <B>array</B> of corresponding target edges.", "PK Reference - PK_imprint_r_t");
top.note("headers/pk_instance_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_INSTANCE_t ", "PK Reference - PK_INSTANCE_array_t");
top.note("headers/pk_instance_array_t.html#documentation", " PK_INSTANCE_t *<B>array</B>; --- <B>array</B> of INSTANCEs", "PK Reference - PK_INSTANCE_array_t");
top.note("headers/pk_int_array_t.html#declaration", " int *<B>array</B>;", "PK Reference - PK_int_array_t");
top.note("headers/pk_int_array_t.html#description", " This structure contains an <B>array</B> of ints.", "PK Reference - PK_int_array_t");
top.note("headers/pk_int_array_t.html#documentation", " <B>array</B> : <B>array</B> of ints", "PK Reference - PK_int_array_t");
top.note("headers/pk_item_array_t.html#description", " This structure contains an <B>array</B> of items of type PK_ITEM_t ", "PK Reference - PK_ITEM_array_t");
top.note("headers/pk_item_array_t.html#documentation", " PK_ITEM_t *<B>array</B>; --- <B>array</B> of ITEMs", "PK Reference - PK_ITEM_array_t");
top.note("headers/pk_lattice_ask_regions_o_t.html#documentation", " want_senses Controls whether an <B>array</B>, senses , of the senses of the", "PK Reference - PK_LATTICE_ask_regions_o_t");
top.note("headers/pk_lattice_ask_regions_r_t.html#documentation", " want_senses was set to PK_LOGICAL_false, otherwise the <B>array</B>", "PK Reference - PK_LATTICE_ask_regions_r_t");
top.note("headers/pk_lattice_clip.html#documentation", " clipping operation has succeeded, results will contain an <B>array</B> of", "PK Reference - PK_LATTICE_clip");
top.note("headers/pk_lattice_clip_o_t.html#documentation", " clip_entities An <B>array</B> of n_clip_entities entities with which", "PK Reference - PK_LATTICE_clip_o_t");
top.note("headers/pk_lattice_combine.html#declaration", " PK_LATTICE_t lattices[], --- <B>array</B> of lattices", "PK Reference - PK_LATTICE_combine");
top.note("headers/pk_lattice_graph_cone_o_t.html#documentation", " absolute to the existing lballs and the lball_positions <B>array</B>", "PK Reference - PK_LATTICE_graph_cone_o_t");
top.note("headers/pk_lattice_graph_cyl_o_t.html#documentation", " absolute to the existing lballs and the lball_positions <B>array</B>", "PK Reference - PK_LATTICE_graph_cyl_o_t");
top.note("headers/pk_lattice_make_bodies_r_t.html#documentation", " bodies The <B>array</B> contains the bodies created from the lattice.", "PK Reference - PK_LATTICE_make_bodies_r_t");
top.note("headers/pk_law_sf_t.html#documentation", " the number of doubles per vertex in the <B>array</B>", "PK Reference - PK_LAW_sf_t");
top.note("headers/pk_lball_ask_lballs_adj_r_t.html#documentation", " lballs_adj An <B>array</B> of length n_lballs_adj , each element holding an", "PK Reference - PK_LBALL_ask_lballs_adj_r_t");
top.note("headers/pk_lball_ask_lrods_r_t.html#documentation", " lrods An <B>array</B> of length n_lrods , each element holding an", "PK Reference - PK_LBALL_ask_lrods_r_t");
top.note("headers/pk_line_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_LINE_t ", "PK Reference - PK_LINE_array_t");
top.note("headers/pk_line_array_t.html#documentation", " PK_LINE_t *<B>array</B>; --- <B>array</B> of LINEs", "PK Reference - PK_LINE_array_t");
top.note("headers/pk_loop_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_LOOP_t ", "PK Reference - PK_LOOP_array_t");
top.note("headers/pk_loop_array_t.html#documentation", " PK_LOOP_t *<B>array</B>; --- <B>array</B> of LOOPs", "PK Reference - PK_LOOP_array_t");
top.note("headers/pk_loop_ask_edges.html#documentation", "The output <B>array</B> edges is optional. If it is set to", "PK Reference - PK_LOOP_ask_edges");
top.note("headers/pk_loop_ask_fins.html#documentation", "The output <B>array</B> fins is optional. If it is set to", "PK Reference - PK_LOOP_ask_fins");
top.note("headers/pk_loop_ask_vertices.html#documentation", "The output <B>array</B> vertices is optional. If it is set to", "PK Reference - PK_LOOP_ask_vertices");
top.note("headers/pk_ltopol_ask_box_o_t.html#description", " optional controls for querying the box of an <B>array</B> of ltopols.", "PK Reference - PK_LTOPOL_ask_box_o_t");
top.note("headers/pk_ltopol_ask_box_r_t.html#documentation", " bounding_box The box bounding the <B>array</B> of ltopols.", "PK Reference - PK_LTOPOL_ask_box_r_t");
top.note("headers/pk_mesh_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_MESH_t ", "PK Reference - PK_MESH_array_t");
top.note("headers/pk_mesh_array_t.html#documentation", " PK_MESH_t *<B>array</B>; --- <B>array</B> of mesh surfaces", "PK Reference - PK_MESH_array_t");
top.note("headers/pk_mesh_defect_array_f.html#declaration", " PK_MESH_defect_array_t *const <B>array</B> --- structure to free", "PK Reference - PK_MESH_defect_array_f");
top.note("headers/pk_mesh_defect_array_f.html#documentation", " free all the PK memory referenced by the <B>array</B> structure.", "PK Reference - PK_MESH_defect_array_f");
top.note("headers/pk_mesh_facet_fan_t.html#declaration", " --- the fan_indices <B>array</B>", "PK Reference - PK_MESH_facet_fan_t");
top.note("headers/pk_mesh_facet_fan_t.html#documentation", " is a collection of facets described by an <B>array</B> of indices.", "PK Reference - PK_MESH_facet_fan_t");
top.note("headers/pk_mesh_facet_index_t.html#documentation", "relative to the vertex_positions <B>array</B> ordering.", "PK Reference - PK_MESH_facet_index_t");
top.note("headers/pk_mesh_facet_strip_t.html#declaration", " --- <B>array</B>", "PK Reference - PK_MESH_facet_strip_t");
top.note("headers/pk_mesh_facet_strip_t.html#documentation", " is a collection of facets described by an <B>array</B> of indices,", "PK Reference - PK_MESH_facet_strip_t");
top.note("headers/pk_mesh_facet_vector_t.html#documentation", " n_vertex_positions The number of vertices in the <B>array</B> vertex_positions .", "PK Reference - PK_MESH_facet_vector_t");
top.note("headers/pk_mesh_fill_holes_o_t.html#declaration", " --- holes <B>array</B> (0)", "PK Reference - PK_MESH_fill_holes_o_t");
top.note("headers/pk_mesh_fill_holes_o_t.html#documentation", " input_holes An <B>array</B> of PK_MFIN_t , each of which must be", "PK Reference - PK_MESH_fill_holes_o_t");
top.note("headers/pk_mesh_fix_defects.html#declaration", " PK_MESH_defect_array_t **const defect_array --- defect <B>array</B> for each", "PK Reference - PK_MESH_fix_defects");
top.note("headers/pk_mesh_fix_defects.html#documentation", "The function returns the resultant meshes in the <B>array</B> resultant_meshes , of", "PK Reference - PK_MESH_fix_defects");
top.note("headers/pk_mesh_imprint_vectors.html#description", " This function imprints an <B>array</B> of vectors onto a mesh.", "PK Reference - PK_MESH_imprint_vectors");
top.note("headers/pk_mesh_imprint_vectors.html#documentation", "The function may optionally return an mvertex <B>array</B> of the same length as the", "PK Reference - PK_MESH_imprint_vectors");
top.note("headers/pk_mesh_imprint_vectors_o_t.html#documentation", " want_mvertices If set to PK_LOGICAL_true, an <B>array</B> of mvertices will", "PK Reference - PK_MESH_imprint_vectors_o_t");
top.note("headers/pk_mesh_imprint_vectors_r_t.html#description", " the nature of the success or failure, an <B>array</B> of", "PK Reference - PK_MESH_imprint_vectors_r_t");
top.note("headers/pk_mesh_imprint_vectors_r_t.html#documentation", " in the options structure, then this <B>array</B> will contain", "PK Reference - PK_MESH_imprint_vectors_r_t");
top.note("headers/pk_mesh_make_surf_trimmed.html#documentation", " spcurves consists of an <B>array</B> of SP-curves which describe the boundary", "PK Reference - PK_MESH_make_surf_trimmed");
top.note("headers/pk_mesh_store_normals_o_t.html#errors", " <B>array</B> is not -1 and does not lie between", "PK Reference - PK_MESH_store_normals_o_t");
top.note("headers/pk_mesh_store_normals_o_t.html#documentation", " mtopols field can be used to specify an <B>array</B> of unique mtopols", "PK Reference - PK_MESH_store_normals_o_t");
top.note("headers/pk_mfacet_array_t.html#declaration", " PK_MFACET_t *<B>array</B>;", "PK Reference - PK_MFACET_array_t");
top.note("headers/pk_mfacet_array_t.html#description", " This structure contains an <B>array</B> of PK_MFACET_t .", "PK Reference - PK_MFACET_array_t");
top.note("headers/pk_mfacet_array_t.html#documentation", " <B>array</B> <B>array</B> of elements of type PK_MFACET_t ", "PK Reference - PK_MFACET_array_t");
top.note("headers/pk_mfin_array_t.html#declaration", " PK_MFIN_t *<B>array</B>;", "PK Reference - PK_MFIN_array_t");
top.note("headers/pk_mfin_array_t.html#description", " This structure contains an <B>array</B> of PK_MFIN_t .", "PK Reference - PK_MFIN_array_t");
top.note("headers/pk_mfin_array_t.html#documentation", " <B>array</B> <B>array</B> of elements of type PK_MFIN_t ", "PK Reference - PK_MFIN_array_t");
top.note("headers/pk_mtopol_make_meshes_o_t.html#documentation", " faces An <B>array</B> of length n_faces containing the faces", "PK Reference - PK_MTOPOL_make_meshes_o_t");
top.note("headers/pk_mtopol_map_r_t.html#documentation", " map_records The <B>array</B> of mapping information records.", "PK Reference - PK_MTOPOL_map_r_t");
top.note("headers/pk_mvertex_ask_mfacets.html#documentation", "The output <B>array</B> mfacets is optional. If it is set to", "PK Reference - PK_MVERTEX_ask_mfacets");
top.note("headers/pk_mvertex_ask_mvertices_ring.html#documentation", "The output <B>array</B> mvertices_ring is optional. If it is set to", "PK Reference - PK_MVERTEX_ask_mvertices_ring");
top.note("headers/pk_offset_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_OFFSET_t ", "PK Reference - PK_OFFSET_array_t");
top.note("headers/pk_offset_array_t.html#documentation", " PK_OFFSET_t *<B>array</B>; --- <B>array</B> of OFFSET surfaces", "PK Reference - PK_OFFSET_array_t");
top.note("headers/pk_outline_curve_t.html#documentation", " curves An <B>array</B> of length n_curves , each element holding", "PK Reference - PK_outline_curve_t");
top.note("headers/pk_part_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_PART_t ", "PK Reference - PK_PART_array_t");
top.note("headers/pk_part_array_t.html#documentation", " PK_PART_t *<B>array</B>; --- <B>array</B> of PARTs", "PK Reference - PK_PART_array_t");
top.note("headers/pk_part_ask_all_attdefs.html#documentation", "The output <B>array</B> attdefs is optional. If it is set to", "PK Reference - PK_PART_ask_all_attdefs");
top.note("headers/pk_part_ask_all_attribs.html#documentation", "The output <B>array</B> attribs is optional. If it is set to", "PK Reference - PK_PART_ask_all_attribs");
top.note("headers/pk_part_ask_attribs_cb_o_t.html#documentation", " want_attribs Whether to return an <B>array</B> of selected attributes", "PK Reference - PK_PART_ask_attribs_cb_o_t");
top.note("headers/pk_part_ask_con_lattices.html#documentation", "The output <B>array</B> con_lattices is optional. If it is set to", "PK Reference - PK_PART_ask_con_lattices");
top.note("headers/pk_part_ask_construction_curves.html#documentation", "The output <B>array</B> con_curves is optional. If it is set to", "PK Reference - PK_PART_ask_construction_curves");
top.note("headers/pk_part_ask_construction_points.html#documentation", "The output <B>array</B> con_points is optional. If it is set to", "PK Reference - PK_PART_ask_construction_points");
top.note("headers/pk_part_ask_construction_surfs.html#documentation", "The output <B>array</B> con_surfs is optional. If it is set to", "PK Reference - PK_PART_ask_construction_surfs");
top.note("headers/pk_part_ask_geoms.html#documentation", "The output <B>array</B> geoms is optional. If it is set to", "PK Reference - PK_PART_ask_geoms");
top.note("headers/pk_part_ask_groups.html#documentation", "The output <B>array</B> groups is optional. If it is set to", "PK Reference - PK_PART_ask_groups");
top.note("headers/pk_part_ask_groups_o_t.html#documentation", " determines whether the <B>array</B> of groups is", "PK Reference - PK_PART_ask_groups_o_t");
top.note("headers/pk_part_ask_ref_instances.html#documentation", "The output <B>array</B> instances is optional. If it is set to", "PK Reference - PK_PART_ask_ref_instances");
top.note("headers/pk_part_delete_attribs.html#documentation", " attributes to be deleted are given in the <B>array</B>", "PK Reference - PK_PART_delete_attribs");
top.note("headers/pk_part_receive_meshes.html#description", "loaded for the <B>array</B> of parts specified.", "PK Reference - PK_PART_receive_meshes");
top.note("headers/pk_part_receive_meshes.html#documentation", "The output owners is an optional <B>array</B> of entities for which", "PK Reference - PK_PART_receive_meshes");
top.note("headers/pk_part_receive_meshes_o_t.html#documentation", " want_owners PK_LOGICAL_true if the optional <B>array</B> owners should be", "PK Reference - PK_PART_receive_meshes_o_t");
top.note("headers/pk_part_receive_o_t.html#documentation", " <B>array</B> passed by the application to part transmit.", "PK Reference - PK_PART_receive_o_t");
top.note("headers/pk_part_remove_geoms.html#description", "entities which are also in the given <B>array</B> of geoms.", "PK Reference - PK_PART_remove_geoms");
top.note("headers/pk_partition_ask_appitems.html#documentation", "The output <B>array</B> appitems is optional. If it is set to", "PK Reference - PK_PARTITION_ask_appitems");
top.note("headers/pk_partition_ask_assemblies.html#documentation", "The output <B>array</B> assemblies is optional. If it is set to", "PK Reference - PK_PARTITION_ask_assemblies");
top.note("headers/pk_partition_ask_bodies.html#documentation", "The output <B>array</B> bodies is optional. If it is set to", "PK Reference - PK_PARTITION_ask_bodies");
top.note("headers/pk_partition_ask_geoms.html#documentation", "The output <B>array</B> geoms is optional. If it is set to", "PK Reference - PK_PARTITION_ask_geoms");
top.note("headers/pk_partition_ask_ki_lists.html#documentation", "The output <B>array</B> lists is optional. If it is set to", "PK Reference - PK_PARTITION_ask_ki_lists");
top.note("headers/pk_partition_ask_pmarks.html#documentation", "The output <B>array</B> pmarks is optional. If it is set to", "PK Reference - PK_PARTITION_ask_pmarks");
top.note("headers/pk_partition_ask_pmarks_2_o_t.html#declaration", " PK_LOGICAL_t want_pmarks; --- whether to return an <B>array</B> of", "PK Reference - PK_PARTITION_ask_pmarks_2_o_t");
top.note("headers/pk_partition_ask_pmarks_2_o_t.html#documentation", " want_pmarks whether to return an <B>array</B> of pmarks. If it is set to", "PK Reference - PK_PARTITION_ask_pmarks_2_o_t");
top.note("headers/pk_partition_ask_pmarks_2_r_t.html#declaration", " PK_PMARK_t *pmarks; --- <B>array</B> of pmarks, if requested", "PK Reference - PK_PARTITION_ask_pmarks_2_r_t");
top.note("headers/pk_partition_ask_pmarks_2_r_t.html#documentation", " pmarks the <B>array</B> of pmarks, if requested.", "PK Reference - PK_PARTITION_ask_pmarks_2_r_t");
top.note("headers/pk_partition_ask_transfs.html#documentation", "The output <B>array</B> transfs is optional. If it is set to", "PK Reference - PK_PARTITION_ask_transfs");
top.note("headers/pk_partition_clone_pmark_o_t.html#documentation", " want_new_entities Whether to return an <B>array</B> of created entities instead", "PK Reference - PK_PARTITION_clone_pmark_o_t");
top.note("headers/pk_partition_is_clone_o_t.html#declaration", " PK_ENTITY_array_t entities; --- an <B>array</B> of entities", "PK Reference - PK_PARTITION_is_clone_o_t");
top.note("headers/pk_partition_is_clone_o_t.html#documentation", " is PK_LOGICAL_false and the length of the entities <B>array</B> is", "PK Reference - PK_PARTITION_is_clone_o_t");
top.note("headers/pk_partition_make_pmark_o_t.html#documentation", " want_new_entities Whether to return an <B>array</B> of created entities instead", "PK Reference - PK_PARTITION_make_pmark_o_t");
top.note("headers/pk_partition_merge.html#documentation", "The pmarks <B>array</B> must contain for each of the partitions ,", "PK Reference - PK_PARTITION_merge");
top.note("headers/pk_partition_receive_meshes.html#documentation", "The output owners is an optional <B>array</B> of entities or partitions for which", "PK Reference - PK_PARTITION_receive_meshes");
top.note("headers/pk_partition_receive_meshes_o_t.html#documentation", " want_owners PK_LOGICAL_true if the optional <B>array</B> owners should be", "PK Reference - PK_PARTITION_receive_meshes_o_t");
top.note("headers/pk_partition_receive_o_t.html#documentation", " an <B>array</B> of child body identifiers if the body", "PK Reference - PK_PARTITION_receive_o_t");
top.note("headers/pk_partition_reset_attribs.html#documentation", " the attribute is one of those in the <B>array</B> attdefs , the", "PK Reference - PK_PARTITION_reset_attribs");
top.note("headers/pk_pattern_trim_data_t.html#documentation", " curves consists of an <B>array</B> of bounded curves which describe the boundary", "PK Reference - PK_pattern_trim_data_t");
top.note("headers/pk_plane_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_PLANE_t ", "PK Reference - PK_PLANE_array_t");
top.note("headers/pk_plane_array_t.html#documentation", " PK_PLANE_t *<B>array</B>; --- <B>array</B> of PLANEs", "PK Reference - PK_PLANE_array_t");
top.note("headers/pk_pline_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_PLINE_t ", "PK Reference - PK_PLINE_array_t");
top.note("headers/pk_pline_array_t.html#documentation", " PK_PLINE_t *<B>array</B>; --- <B>array</B> of PolyLINEs", "PK Reference - PK_PLINE_array_t");
top.note("headers/pk_pline_sf_t.html#documentation", " positions This is an <B>array</B> of vectors that contains the positions of", "PK Reference - PK_PLINE_sf_t");
top.note("headers/pk_pmark_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_PMARK_t ", "PK Reference - PK_PMARK_array_t");
top.note("headers/pk_pmark_array_t.html#documentation", " PK_PMARK_t *<B>array</B>; --- <B>array</B> of PMARKs", "PK Reference - PK_PMARK_array_t");
top.note("headers/pk_pmark_ask_entities_o_t.html#documentation", " want_new_entities Whether to return an <B>array</B> of created entities instead", "PK Reference - PK_PMARK_ask_entities_o_t");
top.note("headers/pk_pmark_ask_following.html#documentation", "The output <B>array</B> following is optional. If it is set to", "PK Reference - PK_PMARK_ask_following");
top.note("headers/pk_pmark_ask_marks.html#documentation", "The output <B>array</B> marks is optional. If it is set to", "PK Reference - PK_PMARK_ask_marks");
top.note("headers/pk_pmark_delete.html#declaration", "const PK_PMARK_t *pmarks, --- pmark <B>array</B>", "PK Reference - PK_PMARK_delete");
top.note("headers/pk_pmark_delete.html#description", " deletes the given partition marks. It returns an <B>array</B> of", "PK Reference - PK_PMARK_delete");
top.note("headers/pk_pmark_delete.html#documentation", "in the pmarks <B>array</B>).", "PK Reference - PK_PMARK_delete");
top.note("headers/pk_pmark_goto_o_t.html#documentation", " del_attdefs <B>Array</B> of attribute definitions. Only pass attributes with", "PK Reference - PK_PMARK_goto_o_t");
top.note("headers/pk_point_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_POINT_t ", "PK Reference - PK_POINT_array_t");
top.note("headers/pk_point_array_t.html#documentation", " PK_POINT_t *<B>array</B>; --- <B>array</B> of POINTs", "PK Reference - PK_POINT_array_t");
top.note("headers/pk_proj_face_hidden_t.html#documentation", " whether other faces in the input <B>array</B>", "PK Reference - PK_proj_face_hidden_t");
top.note("headers/pk_range_1_r_array_t.html#declaration", " PK_range_1_r_t *<B>array</B>;", "PK Reference - PK_range_1_r_array_t");
top.note("headers/pk_range_2_r_array_t.html#declaration", " PK_range_2_r_t *<B>array</B>;", "PK Reference - PK_range_2_r_array_t");
top.note("headers/pk_region_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_REGION_t ", "PK Reference - PK_REGION_array_t");
top.note("headers/pk_region_array_t.html#documentation", " PK_REGION_t *<B>array</B>; --- <B>array</B> of REGIONs", "PK Reference - PK_REGION_array_t");
top.note("headers/pk_region_ask_lattices_o_t.html#documentation", " want_senses Controls whether an <B>array</B>, senses , of the senses of the", "PK Reference - PK_REGION_ask_lattices_o_t");
top.note("headers/pk_region_ask_lattices_r_t.html#documentation", " PK_LOGICAL_false, otherwise the <B>array</B> will be parallel to", "PK Reference - PK_REGION_ask_lattices_r_t");
top.note("headers/pk_region_ask_shells.html#documentation", "The output <B>array</B> shells is optional. If it is set to", "PK Reference - PK_REGION_ask_shells");
top.note("headers/pk_region_embed_lattices_o_t.html#documentation", " want_frames Controls whether an <B>array</B> of frames created by the", "PK Reference - PK_REGION_embed_lattices_o_t");
top.note("headers/pk_region_embed_lattices_r_t.html#documentation", " n_frames If requested, the length of the frames <B>array</B>, otherwise zero.", "PK Reference - PK_REGION_embed_lattices_r_t");
top.note("headers/pk_render_transparent_t.html#documentation", " PK_render_transparent_index_c : Specify an <B>array</B> of body occurrences", "PK Reference - PK_render_transparent_t");
top.note("headers/pk_replace_edge_data_t.html#documentation", " edges <B>Array</B> of the edges.", "PK Reference - PK_replace_edge_data_t");
top.note("headers/pk_replace_help_points_t.html#documentation", " topologies <B>Array</B> of the topologies to help modify. All the topologies", "PK Reference - PK_replace_help_points_t");
top.note("headers/pk_replace_patch_data_t.html#documentation", " patch_type Indicates whether each face in target_patches <B>array</B> will", "PK Reference - PK_replace_patch_data_t");
top.note("headers/pk_replace_patch_t.html#documentation", " will be replaced the corresponding face in tool_patches <B>array</B> with", "PK Reference - PK_replace_patch_t");
top.note("headers/pk_replace_variation_data_t.html#documentation", " supplied for the faces in variation_faces <B>array</B> are the", "PK Reference - PK_replace_variation_data_t");
top.note("headers/pk_replace_vertex_data_t.html#documentation", " vertices <B>Array</B> of the vertices to modify.", "PK Reference - PK_replace_vertex_data_t");
top.note("headers/pk_report_3_t.html#documentation", "- a parallel <B>array</B> of old classes containing the class of the", "PK Reference - PK_REPORT_3_t");
top.note("headers/pk_report_4_t.html#documentation", "- An <B>array</B> of 4 int_arrays each of length equal to", "PK Reference - PK_REPORT_4_t");
top.note("headers/pk_report_record_1_t.html#documentation", " old_items an <B>array</B> of items which existed before the operation for", "PK Reference - PK_REPORT_record_1_t");
top.note("headers/pk_report_record_2_t.html#description", " is a REPORT record containing a status, an <B>array</B> of arrays of", "PK Reference - PK_REPORT_record_2_t");
top.note("headers/pk_report_record_2_t.html#documentation", " old_item_arrays an <B>array</B> of length n_old_item_arrays of PK_int_array_t ", "PK Reference - PK_REPORT_record_2_t");
top.note("headers/pk_report_record_3_t.html#documentation", " old_item_arrays an <B>array</B> of length n_old_item_arrays of PK_int_array_t ", "PK Reference - PK_REPORT_record_3_t");
top.note("headers/pk_report_record_4_t.html#documentation", " old_item_arrays an <B>array</B> of length n_old_item_arrays of PK_int_array_t ", "PK Reference - PK_REPORT_record_4_t");
top.note("headers/pk_section_2_r_t.html#declaration", " PK_section_report_r_t *reports; --- <B>array</B> of report structures", "PK Reference - PK_section_2_r_t");
top.note("headers/pk_section_2_r_t.html#documentation", " front_bodies The <B>array</B> of resultant bodies in front of the", "PK Reference - PK_section_2_r_t");
top.note("headers/pk_section_r_t.html#documentation", " front_bodies The <B>array</B> of resultant bodies in front of the", "PK Reference - PK_section_r_t");
top.note("headers/pk_section_report_r_t.html#documentation", " entities This <B>array</B> may contain topological or geometric entities", "PK Reference - PK_section_report_r_t");
top.note("headers/pk_session_ask_attdefs_o_t.html#documentation", " want_attdefs Whether to return an <B>array</B> of attribute definitions instead", "PK Reference - PK_SESSION_ask_attdefs_o_t");
top.note("headers/pk_session_ask_partitions.html#documentation", "The output <B>array</B> partitions is optional. If it is set to", "PK Reference - PK_SESSION_ask_partitions");
top.note("headers/pk_session_ask_parts.html#documentation", "The output <B>array</B> parts is optional. If it is set to", "PK Reference - PK_SESSION_ask_parts");
top.note("headers/pk_session_set_rebuild_history.html#documentation", " If any of the values supplied in rebuild_history <B>array</B> are", "PK Reference - PK_SESSION_set_rebuild_history");
top.note("headers/pk_session_watch_tags.html#description", " This function registers an <B>array</B> of tagged entities which are to be watched", "PK Reference - PK_SESSION_watch_tags");
top.note("headers/pk_session_watch_tags.html#documentation", "The application may register an <B>array</B> of tagged entities to watch via a", "PK Reference - PK_SESSION_watch_tags");
top.note("headers/pk_shell_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_SHELL_t ", "PK Reference - PK_SHELL_array_t");
top.note("headers/pk_shell_array_t.html#documentation", " PK_SHELL_t *<B>array</B>; --- <B>array</B> of SHELLs", "PK Reference - PK_SHELL_array_t");
top.note("headers/pk_shell_ask_wireframe_edges.html#documentation", "The output <B>array</B> edges is optional. If it is set to", "PK Reference - PK_SHELL_ask_wireframe_edges");
top.note("headers/pk_spcurve_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_SPCURVE_t ", "PK Reference - PK_SPCURVE_array_t");
top.note("headers/pk_spcurve_array_t.html#documentation", " PK_SPCURVE_t *<B>array</B>; --- <B>array</B> of Surface Parameter CURVEs", "PK Reference - PK_SPCURVE_array_t");
top.note("headers/pk_sphere_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_SPHERE_t ", "PK Reference - PK_SPHERE_array_t");
top.note("headers/pk_sphere_array_t.html#documentation", " PK_SPHERE_t *<B>array</B>; --- <B>array</B> of SPHEREs", "PK Reference - PK_SPHERE_array_t");
top.note("headers/pk_spun_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_SPUN_t ", "PK Reference - PK_SPUN_array_t");
top.note("headers/pk_spun_array_t.html#documentation", " PK_SPUN_t *<B>array</B>; --- <B>array</B> of SPUN surfaces", "PK Reference - PK_SPUN_array_t");
top.note("headers/pk_surf_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_SURF_t ", "PK Reference - PK_SURF_array_t");
top.note("headers/pk_surf_array_t.html#documentation", " PK_SURF_t *<B>array</B>; --- <B>array</B> of SURFaces", "PK Reference - PK_SURF_array_t");
top.note("headers/pk_surf_ask_faces.html#documentation", "The output <B>array</B> faces is optional. If it is set to", "PK Reference - PK_SURF_ask_faces");
top.note("headers/pk_surf_degens_t.html#documentation", " degen An <B>array</B> of length n_degen , holding information on each", "PK Reference - PK_SURF_degens_t");
top.note("headers/pk_surf_eval.html#declaration", " PK_LOGICAL_t triangular, --- triangular derivative <B>array</B> required", "PK Reference - PK_SURF_eval");
top.note("headers/pk_surf_eval.html#documentation", "whether the returned <B>array</B> of derivatives is triangular or not.", "PK Reference - PK_SURF_eval");
top.note("headers/pk_surf_eval_grid.html#declaration", " PK_LOGICAL_t triangular, --- triangular derivative <B>array</B> required", "PK Reference - PK_SURF_eval_grid");
top.note("headers/pk_surf_eval_grid.html#documentation", "The return argument p is a vector <B>array</B> returning the points, the", "PK Reference - PK_SURF_eval_grid");
top.note("headers/pk_surf_eval_handed.html#declaration", " PK_LOGICAL_t triangular, --- triangular derivative <B>array</B> required", "PK Reference - PK_SURF_eval_handed");
top.note("headers/pk_surf_eval_with_normal.html#declaration", " PK_LOGICAL_t triangular, --- triangular derivative <B>array</B> required", "PK Reference - PK_SURF_eval_with_normal");
top.note("headers/pk_surf_eval_with_normal_handed.html#declaration", " PK_LOGICAL_t triangular, --- triangular derivative <B>array</B> required", "PK Reference - PK_SURF_eval_with_normal_handed");
top.note("headers/pk_surf_find_discontinuity.html#documentation", " discontinuities are found using the above criteria, an <B>array</B>", "PK Reference - PK_SURF_find_discontinuity");
top.note("headers/pk_surf_find_min_radii.html#documentation", " The magnitude of the radius held in the <B>array</B> radii . It will have a", "PK Reference - PK_SURF_find_min_radii");
top.note("headers/pk_surf_fix_degens_o_t.html#documentation", " entry in the <B>array</B> is for the minimum radius in the", "PK Reference - PK_SURF_fix_degens_o_t");
top.note("headers/pk_surf_fix_degens_r_t.html#documentation", " surface. The first entry in the <B>array</B> is for the minimum", "PK Reference - PK_SURF_fix_degens_r_t");
top.note("headers/pk_surf_fix_self_int_r_t.html#documentation", " surfs An <B>array</B> of length n_surfs , each element holding information", "PK Reference - PK_SURF_fix_self_int_r_t");
top.note("headers/pk_surf_general_eval_f_t.html#documentation", "The return argument p is an <B>array</B> of doubles returning the point and", "PK Reference - PK_SURF_general_eval_f_t");
top.note("headers/pk_surf_general_user_t.html#declaration", " double *u_discontinuities; --- <B>array</B> of u parameters", "PK Reference - PK_SURF_general_user_t");
top.note("headers/pk_surf_intersect_curve.html#documentation", "surface. It returns an <B>array</B> of intersection coordinates and", "PK Reference - PK_SURF_intersect_curve");
top.note("headers/pk_surf_make_bsurf_array.html#description", " Given an <B>array</B> of surfaces and uvboxes this function will return", "PK Reference - PK_SURF_make_bsurf_array");
top.note("headers/pk_surf_make_bsurf_array.html#documentation", " results is an <B>array</B> of PK_SURF_make_bsurf_res_t of length n_surfs . Each", "PK Reference - PK_SURF_make_bsurf_array");
top.note("headers/pk_surf_make_bsurf_array_o_t.html#description", " This structure holds optional controls on converting an <B>array</B> of surfaces into", "PK Reference - PK_SURF_make_bsurf_array_o_t");
top.note("headers/pk_surf_make_sheet_trimmed.html#documentation", " spcurves consists of an <B>array</B> of curves which describe the boundary", "PK Reference - PK_SURF_make_sheet_trimmed");
top.note("headers/pk_surf_self_int_t.html#documentation", " positions An <B>array</B> of length n_positions containing positions in", "PK Reference - PK_SURF_self_int_t");
top.note("headers/pk_surf_self_ints_t.html#documentation", " self_int An <B>array</B> of length n_self_int , holding information on", "PK Reference - PK_SURF_self_ints_t");
top.note("headers/pk_surf_trim_data_t.html#documentation", " spcurves consists of an <B>array</B> of bounded curves which describe the boundary", "PK Reference - PK_SURF_trim_data_t");
top.note("headers/pk_sweep_face_clamp_t.html#declaration", " const PK_EDGE_t *edges; --- <B>array</B> of clamped profile edges", "PK Reference - PK_sweep_face_clamp_t");
top.note("headers/pk_sweep_face_clamp_t.html#documentation", " edges An <B>array</B> of edges where sweep derivatives are clamped by", "PK Reference - PK_sweep_face_clamp_t");
top.note("headers/pk_sweep_guide_clamp_dirn_t.html#documentation", " directions An <B>array</B> of directions one for each vertex of vertices", "PK Reference - PK_sweep_guide_clamp_dirn_t");
top.note("headers/pk_sweep_guide_control_t.html#documentation", " profile_matches An <B>array</B> of vertices, the length of which should be", "PK Reference - PK_sweep_guide_control_t");
top.note("headers/pk_swept_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_SWEPT_t ", "PK Reference - PK_SWEPT_array_t");
top.note("headers/pk_swept_array_t.html#documentation", " PK_SWEPT_t *<B>array</B>; --- <B>array</B> of SWEPT surfaces", "PK Reference - PK_SWEPT_array_t");
top.note("headers/pk_thread_ask_function_run.html#documentation", "For each function specified in the functions <B>array</B>, the corresponding value", "PK Reference - PK_THREAD_ask_function_run");
top.note("headers/pk_thread_lock_partitions.html#documentation", "<B>array</B>, together with the value of lock_type :", "PK Reference - PK_THREAD_lock_partitions");
top.note("headers/pk_thread_lock_partitions_o_t.html#documentation", " the <B>array</B> of locked partitions will be", "PK Reference - PK_THREAD_lock_partitions_o_t");
top.note("headers/pk_thread_set_function_run.html#documentation", "For each function specified in the functions <B>array</B>, the corresponding value", "PK Reference - PK_THREAD_set_function_run");
top.note("headers/pk_topol_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_TOPOL_t ", "PK Reference - PK_TOPOL_array_t");
top.note("headers/pk_topol_array_t.html#documentation", " PK_TOPOL_t *<B>array</B>; --- <B>array</B> of TOPOLogical entities", "PK Reference - PK_TOPOL_array_t");
top.note("headers/pk_topol_ask_entities_by_attdef.html#documentation", "The output <B>array</B> entities is optional. If it is set to", "PK Reference - PK_TOPOL_ask_entities_by_attdef");
top.note("headers/pk_topol_clash.html#declaration", "const PK_TOPOL_t targets[], --- <B>Array</B> of target topols", "PK Reference - PK_TOPOL_clash");
top.note("headers/pk_topol_clash_o_t.html#declaration", " --- <B>array</B> of parts for which a scale factor", "PK Reference - PK_TOPOL_clash_o_t");
top.note("headers/pk_topol_clash_o_t.html#documentation", " op_ex1 <B>Array</B> of first bodies of topology exclusion body pairs.", "PK Reference - PK_TOPOL_clash_o_t");
top.note("headers/pk_topol_delete_redundant_2.html#declaration", "const PK_TOPOL_t topols[], --- <B>array</B> of topols", "PK Reference - PK_TOPOL_delete_redundant_2");
top.note("headers/pk_topol_delete_redundant_2.html#documentation", "Redundant topologies are removed from the given <B>array</B> of topols, which may be", "PK Reference - PK_TOPOL_delete_redundant_2");
top.note("headers/pk_topol_delete_redundant_2_o_t.html#declaration", "const PK_TOPOL_t *protected_topols; --- protected topology <B>array</B>", "PK Reference - PK_TOPOL_delete_redundant_2_o_t");
top.note("headers/pk_topol_eval_mass_props.html#declaration", "const PK_TOPOL_t topols[], --- topological entities <B>array</B>", "PK Reference - PK_TOPOL_eval_mass_props");
top.note("headers/pk_topol_eval_mass_props.html#documentation", "No other types are acceptable. The <B>array</B> of topologies topols must all", "PK Reference - PK_TOPOL_eval_mass_props");
top.note("headers/pk_topol_eval_mass_props_o_t.html#declaration", " const PK_TRANSF_t *transfs; --- <B>array</B> of transformations (NULL)", "PK Reference - PK_TOPOL_eval_mass_props_o_t");
top.note("headers/pk_topol_eval_mass_props_o_t.html#errors", " transfs <B>array</B> is not a rigid motion", "PK Reference - PK_TOPOL_eval_mass_props_o_t");
top.note("headers/pk_topol_eval_mass_props_o_t.html#documentation", " bound For each returned <B>array</B>, the initial entries give the", "PK Reference - PK_TOPOL_eval_mass_props_o_t");
top.note("headers/pk_topol_facet.html#errors", " PK_ERROR_duplicate_array_item topol has duplicates but no transf <B>array</B>", "PK Reference - PK_TOPOL_facet");
top.note("headers/pk_topol_facet.html#documentation", "(and the topols <B>array</B> cannot contain duplicates).", "PK Reference - PK_TOPOL_facet");
top.note("headers/pk_topol_facet_2.html#errors", " PK_ERROR_duplicate_array_item topol has duplicates but no transf <B>array</B>", "PK Reference - PK_TOPOL_facet_2");
top.note("headers/pk_topol_facet_2.html#documentation", "(and the topols <B>array</B> cannot contain duplicates).", "PK Reference - PK_TOPOL_facet_2");
top.note("headers/pk_topol_facet_2_r_t.html#description", "returned as well as an <B>array</B> of PK_TOPOL_facet_table_t structures.", "PK Reference - PK_TOPOL_facet_2_r_t");
top.note("headers/pk_topol_facet_choice_2_o_t.html#documentation", "If faceting an <B>array</B> of faces or a mixture of bodies and", "PK Reference - PK_TOPOL_facet_choice_2_o_t");
top.note("headers/pk_topol_facet_choice_o_t.html#documentation", "the possibility of <B>array</B> bounds errors occurring in the future.", "PK Reference - PK_TOPOL_facet_choice_o_t");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#declaration", " int n_view_directions;--- <B>array</B> of view directions in which", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#errors", " <B>array</B> does not lie between 0 and", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#documentation", " If the application inputs an <B>array</B> of faces, Parasolid recognises faces that", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#declaration", " int n_loops; --- <B>array</B> of loops in sheet bodies to", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#errors", " topols_with_local_tols <B>array</B> (MILD)", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#documentation", " If the application inputs an <B>array</B> of faces, Parasolid recognises faces that", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_facet_r_t.html#documentation", " - an <B>array</B> pointer", "PK Reference - PK_TOPOL_facet_r_t");
top.note("headers/pk_topol_facet_table_t.html#documentation", "This form of table is implemented as an <B>array</B> of structures, with each", "PK Reference - PK_TOPOL_facet_table_t");
top.note("headers/pk_topol_fctab_incr_faces_t.html#documentation", "returns faces that have been added to the <B>array</B> of faces supplied to facetting", "PK Reference - PK_TOPOL_fctab_incr_faces_t");
top.note("headers/pk_topol_find_box_2.html#documentation", " is not NULL then it must be an <B>array</B> of length n_topols ", "PK Reference - PK_TOPOL_find_box_2");
top.note("headers/pk_topol_find_box_2_o_t.html#declaration", " PK_PART_t *parts_with_scales; --- <B>array</B> of parts for which a", "PK Reference - PK_TOPOL_find_box_2_o_t");
top.note("headers/pk_topol_find_box_2_o_t.html#documentation", " parts_with_scales This <B>array</B>, of length n_parts_with_scales , contains", "PK Reference - PK_TOPOL_find_box_2_o_t");
top.note("headers/pk_topol_find_box_2_r_t.html#documentation", " topol_boxes If individual topology boxes are requested, this <B>array</B>", "PK Reference - PK_TOPOL_find_box_2_r_t");
top.note("headers/pk_topol_find_frames_o_t.html#documentation", " want_geoms Controls whether an <B>array</B>, geoms , of the geometries of the", "PK Reference - PK_TOPOL_find_frames_o_t");
top.note("headers/pk_topol_find_frames_r_t.html#documentation", " PK_LOGICAL_false, otherwise the <B>array</B> will be parallel to", "PK Reference - PK_TOPOL_find_frames_r_t");
top.note("headers/pk_topol_find_nabox.html#documentation", " is not NULL then it must be an <B>array</B> of length n_topols ", "PK Reference - PK_TOPOL_find_nabox");
top.note("headers/pk_topol_find_nabox_o_t.html#declaration", " --- <B>array</B> of parts for which a", "PK Reference - PK_TOPOL_find_nabox_o_t");
top.note("headers/pk_topol_find_nabox_o_t.html#documentation", " parts_with_scales This <B>array</B>, of length n_parts_with_scales , contains", "PK Reference - PK_TOPOL_find_nabox_o_t");
top.note("headers/pk_topol_identify_redundant.html#declaration", "const PK_TOPOL_t topols[], --- <B>array</B> of topols", "PK Reference - PK_TOPOL_identify_redundant");
top.note("headers/pk_topol_identify_redundant.html#documentation", "Redundant topologies are identified from the given <B>array</B> of topols, which may", "PK Reference - PK_TOPOL_identify_redundant");
top.note("headers/pk_topol_imprint_frames.html#description", " imprints frames on their owning regions. The topols <B>array</B> may", "PK Reference - PK_TOPOL_imprint_frames");
top.note("headers/pk_topol_local_r_t.html#documentation", " , and the entities are returned in the <B>array</B>", "PK Reference - PK_TOPOL_local_r_t");
top.note("headers/pk_topol_make_facet_topol.html#description", " This function generates facet geometry for an <B>array</B> of faces and edges from the", "PK Reference - PK_TOPOL_make_facet_topol");
top.note("headers/pk_topol_make_facet_topol.html#errors", " PK_ERROR_wrong_entity The topols <B>array</B> contains an item which is", "PK Reference - PK_TOPOL_make_facet_topol");
top.note("headers/pk_topol_make_facet_topol_o_t.html#declaration", " PK_LOGICAL_t return_modified; --- Whether to return an <B>array</B>", "PK Reference - PK_TOPOL_make_facet_topol_o_t");
top.note("headers/pk_topol_make_facet_topol_o_t.html#documentation", " input <B>array</B> contains faces with facet geometry", "PK Reference - PK_TOPOL_make_facet_topol_o_t");
top.note("headers/pk_topol_make_general_body.html#declaration", "const PK_TOPOL_t topols[], --- <B>array</B> of topologies", "PK Reference - PK_TOPOL_make_general_body");
top.note("headers/pk_topol_make_general_body.html#documentation", " body will be returned in body . The <B>array</B> copy_topols is", "PK Reference - PK_TOPOL_make_general_body");
top.note("headers/pk_topol_range.html#documentation", "an <B>array</B> of two structures of type PK_range_end_t , which", "PK Reference - PK_TOPOL_range");
top.note("headers/pk_topol_range_array.html#declaration", " int n_topols_1, --- no. entities in 1st <B>array</B>", "PK Reference - PK_TOPOL_range_array");
top.note("headers/pk_topol_range_array.html#documentation", "and an <B>array</B> of two structures of type PK_range_end_t , which", "PK Reference - PK_TOPOL_range_array");
top.note("headers/pk_topol_range_array_vector.html#declaration", "const PK_TOPOL_t topols[], --- topological <B>array</B>", "PK Reference - PK_TOPOL_range_array_vector");
top.note("headers/pk_topol_range_array_vector.html#description", " function finds the global minimum separation between an <B>array</B>", "PK Reference - PK_TOPOL_range_array_vector");
top.note("headers/pk_topol_range_array_vector.html#documentation", "the <B>array</B> of topological entities topols and the position vector", "PK Reference - PK_TOPOL_range_array_vector");
top.note("headers/pk_topol_range_array_vector_o_t.html#description", "<B>array</B> of topological entities and a position.", "PK Reference - PK_TOPOL_range_array_vector_o_t");
top.note("headers/pk_topol_range_geom.html#documentation", "and an <B>array</B> of two structures of type PK_range_end_t , which", "PK Reference - PK_TOPOL_range_geom");
top.note("headers/pk_topol_range_geom_array.html#declaration", " --- in topological <B>array</B>", "PK Reference - PK_TOPOL_range_geom_array");
top.note("headers/pk_topol_range_geom_array.html#description", " the global minimum / maximum separation between an <B>array</B>", "PK Reference - PK_TOPOL_range_geom_array");
top.note("headers/pk_topol_range_geom_array.html#documentation", "an <B>array</B> of topological entities topols and an <B>array</B> of", "PK Reference - PK_TOPOL_range_geom_array");
top.note("headers/pk_topol_range_geom_array_o_t.html#description", "between an <B>array</B> of topological entities and an <B>array</B> of geometrical", "PK Reference - PK_TOPOL_range_geom_array_o_t");
top.note("headers/pk_topol_range_geom_array_o_t.html#documentation", " param_bounds : an <B>array</B> of structures for supplying parameter range", "PK Reference - PK_TOPOL_range_geom_array_o_t");
top.note("headers/pk_topol_range_geom_o_t.html#documentation", " guesses : An <B>array</B> of two estimate structures, one for each end", "PK Reference - PK_TOPOL_range_geom_o_t");
top.note("headers/pk_topol_range_local.html#documentation", " returned in ranges , this consists of an <B>array</B>", "PK Reference - PK_TOPOL_range_local");
top.note("headers/pk_topol_range_local_vector.html#documentation", " returned in ranges , this consists of an <B>array</B>", "PK Reference - PK_TOPOL_range_local_vector");
top.note("headers/pk_topol_range_o_t.html#documentation", " guesses : An <B>array</B> of two estimate structures, one for each end", "PK Reference - PK_TOPOL_range_o_t");
top.note("headers/pk_topol_range_vector.html#documentation", " parameters : an <B>array</B> of two parameters of the end position holding", "PK Reference - PK_TOPOL_range_vector");
top.note("headers/pk_topol_range_vector_o_t.html#documentation", " parameters : an <B>array</B> of up to 2 parameters", "PK Reference - PK_TOPOL_range_vector_o_t");
top.note("headers/pk_topol_render_facet.html#errors", " PK_ERROR_duplicate_array_item topol has duplicates but no transf <B>array</B>", "PK Reference - PK_TOPOL_render_facet");
top.note("headers/pk_topol_render_facet.html#documentation", "(and the topols <B>array</B> cannot contain duplicates).", "PK Reference - PK_TOPOL_render_facet");
top.note("headers/pk_topol_render_line.html#description", " Render an <B>array</B> of topological entities through GO as either a", "PK Reference - PK_TOPOL_render_line");
top.note("headers/pk_topol_render_line.html#errors", " PK_ERROR_duplicate_array_item topol has duplicates but no transf <B>array</B>", "PK Reference - PK_TOPOL_render_line");
top.note("headers/pk_topol_render_line.html#documentation", "The topols <B>array</B> may not contain duplicates in this case.", "PK Reference - PK_TOPOL_render_line");
top.note("headers/pk_topol_render_line_o_t.html#declaration", " --- first <B>array</B> of body occurrences to", "PK Reference - PK_TOPOL_render_line_o_t");
top.note("headers/pk_topol_render_line_o_t.html#documentation", "optional list of body indices into the topols <B>array</B> may be specified", "PK Reference - PK_TOPOL_render_line_o_t");
top.note("headers/pk_topol_render_volume.html#description", "geometry of an <B>array</B> of bodies or regions.", "PK Reference - PK_TOPOL_render_volume");
top.note("headers/pk_topol_render_volume.html#errors", " topol_transfs <B>array</B> was supplied. (MILD)", "PK Reference - PK_TOPOL_render_volume");
top.note("headers/pk_topol_render_volume.html#documentation", " can be an <B>array</B> of bodies or an <B>array</B> of regions. If", "PK Reference - PK_TOPOL_render_volume");
top.note("headers/pk_topol_render_volume_o_t.html#declaration", " int n_bodies_with_scales;--- <B>Array</B> of bodies for which", "PK Reference - PK_TOPOL_render_volume_o_t");
top.note("headers/pk_topol_render_volume_o_t.html#documentation", "This field, of length n_bodies_with_scales , is an <B>array</B> of unique bodies", "PK Reference - PK_TOPOL_render_volume_o_t");
top.note("headers/pk_topol_track_r_t.html#documentation", " track_records The <B>array</B> of tracking information records.", "PK Reference - PK_TOPOL_track_r_t");
top.note("headers/pk_torus_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_TORUS_t ", "PK Reference - PK_TORUS_array_t");
top.note("headers/pk_torus_array_t.html#documentation", " PK_TORUS_t *<B>array</B>; --- <B>array</B> of TORUSs", "PK Reference - PK_TORUS_array_t");
top.note("headers/pk_transf_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_TRANSF_t ", "PK Reference - PK_TRANSF_array_t");
top.note("headers/pk_transf_array_t.html#documentation", " PK_TRANSF_t *<B>array</B>; --- <B>array</B> of TRANSFormations", "PK Reference - PK_TRANSF_array_t");
top.note("headers/pk_transf_check.html#documentation", "Faults are returned in an <B>array</B> of PK_check_fault_t structures.", "PK Reference - PK_TRANSF_check");
top.note("headers/pk_transf_sf_t.html#documentation", "The <B>array</B> matrix contains the components that make up the", "PK Reference - PK_TRANSF_sf_t");
top.note("headers/pk_trcurve_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_TRCURVE_t ", "PK Reference - PK_TRCURVE_array_t");
top.note("headers/pk_trcurve_array_t.html#documentation", " PK_TRCURVE_t *<B>array</B>; --- <B>array</B> of TRimmed CURVEs", "PK Reference - PK_TRCURVE_array_t");
top.note("headers/pk_vector_array_t.html#declaration", " PK_VECTOR_t *<B>array</B>;", "PK Reference - PK_VECTOR_array_t");
top.note("headers/pk_vector_array_t.html#description", " This structure contains an <B>array</B> of PK_VECTOR_t .", "PK Reference - PK_VECTOR_array_t");
top.note("headers/pk_vector_array_t.html#documentation", " <B>array</B> <B>array</B> of PK_VECTOR_t ", "PK Reference - PK_VECTOR_array_t");
top.note("headers/pk_vertex_array_t.html#description", " This structure contains an <B>array</B> of entities of type PK_VERTEX_t ", "PK Reference - PK_VERTEX_array_t");
top.note("headers/pk_vertex_array_t.html#documentation", " PK_VERTEX_t *<B>array</B>; --- <B>array</B> of VERTEXs", "PK Reference - PK_VERTEX_array_t");
top.note("headers/pk_vertex_ask_faces.html#documentation", "The output <B>array</B> faces is optional. If it is set to", "PK Reference - PK_VERTEX_ask_faces");
top.note("headers/pk_vertex_ask_isolated_loops.html#documentation", "The output <B>array</B> loops is optional. If it is set to", "PK Reference - PK_VERTEX_ask_isolated_loops");
top.note("headers/pk_vertex_ask_shells.html#documentation", "The output <B>array</B> shells is optional. If it is set to", "PK Reference - PK_VERTEX_ask_shells");
top.note("chapters/di_chap.03.html#50511935_pgfId-274202", " the <B>array</B> have the same type); if an <B>array</B> or pointer argument is supplied as NULL, this", "Downward Interfaces - File Handling");
top.note("chapters/di_chap.05.html#50511937_pgfId-274088", " the index of the body (in the entity <B>array</B>) plus 1. ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274090", " is instanced more than once in the entity <B>array</B>, and each instance is output in a separate", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274269", " <B>array</B>. The contents of this <B>array</B> depend on the segment type. For example, for", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274274", " <B>array</B>. This is an <B>array</B> of integers, the first of which is always", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274289", " The remaining <B>array</B> entries, which are given as well as the", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274387", " <B>array</B> always contains the model space box of the", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274391", " it represents. The length and contents of this <B>array</B> depend on the line type, as specified by", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274549", " Note that the double type <B>array</B> holding a poly-line is of length 3*ngeom. ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274743", " supplied in the 10th element of the integer <B>array</B>. ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274788", " supplied in the 10th element of the integer <B>array</B>. ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275000", " at the first vertex given in the geom <B>array</B>, see below. The second edge tag is for", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275045", " in Figure 4-2 and Figure 4-3 . The <B>array</B> consists of five blocks of data, as follows:", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-284971", " <B>array</B> explaining visibility codes, smoothness codes and regional data", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-321695", " <B>array</B> explaining viewport codes and sharp mfin codes ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275316", " <B>array</B> is of length 3 (i.e. ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275322", " <B>array</B> is of length 7 for a segment with", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.09.html#50511941_pgfId-286026", " (which is open) from the <B>array</B> ", "Downward Interfaces - PK_DELTA Functions");
top.note("chapters/di_chap.09.html#50511941_pgfId-286036", " char *bytes /* <B>array</B> in which to store read bytes */ ", "Downward Interfaces - PK_DELTA Functions");
top.note("chapters/di_chap.09.html#50511941_pgfId-286039", " (which is open) to the <B>array</B> ", "Downward Interfaces - PK_DELTA Functions");
top.note("chapters/di_chap.09.html#50511941_pgfId-286040", " then no data should be written to the <B>array</B>, but the file position should be advanced. ", "Downward Interfaces - PK_DELTA Functions");
top.note("chapters/kd_chap.05.html#50475010_pgfId-273889", " an <B>array</B> as an integer length and an <B>array</B> as separate arguments, the LISP function just uses", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.05.html#50475010_pgfId-273908", " an application if it does not want the <B>array</B> of things returned. ", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.05.html#50475010_pgfId-281460", " function with optional logical arguments saying whether the <B>array</B> is to be returned or not. These arguments", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/fg_chap.02.html#50462725_pgfId-273891", " the specific position and derivatives required and an <B>array</B> in which these evaluations are to be placed.", "FG Manual - Introduction and Summary");
top.note("chapters/fg_chap.02.html#50462725_pgfId-273912", " PK_FSURF_create receive the curve, surface respectively and an <B>array</B> into which the returned key string is written.", "FG Manual - Introduction and Summary");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274678", " rvals is a pointer to a real <B>array</B> containing (a, n, w) ", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274679", " essentially the same arguments, except that a double <B>array</B> of length 1 has been allocated by Parasolid", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-281889", " FGPRSU, FGEVSU) are made by passing the fg_data <B>array</B>, as initialized here - the key is no", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-281890", " which uses secure data stored in the fg_data <B>array</B>, FGCRSU needs to implement the loading of this", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-282074", " way. The only differences are that the range <B>array</B> only has two entries, range[0] and range[1], for", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274715", " derivative is stored in three elements of this <B>array</B>. ", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-282519", " points to the correct position in the results <B>array</B>. More details on these issues are given below.", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-282520", " important NOT to set elements of the results <B>array</B> that have not been successfully calculated. ", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274726", " <B>array</B> passed down to the evaluator. The specification of", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274727", " is stored in 3 successive locations in the <B>array</B>. For example, if 6 results are required then", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274728", " <B>array</B> as follows: ", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274729", " is FGEVSQ. In this case a rectangular <B>array</B> of derivatives is required. ", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274732", " <B>array</B> in row order. For example, counting from position", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274735", " a derivative is NOT available then the corresponding <B>array</B> elements should be returned unmodified. For example, if", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274736", " nu=nv=2 and triang=1 the pattern of the results <B>array</B> is as follows: ", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274760", " supply an <B>array</B> of real numbers and/or an <B>array</B> of integers to the evaluator. In most cases", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274762", " cast character strings into elements of the real <B>array</B> creates difficulties in generating transmit files. ", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274770", " is requested. This first element of the Frustrum <B>array</B> is intended to be used to implement this", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.04.html#50462726_pgfId-273850", " user defined double <B>array</B> length available to evaluator ", "FG Manual - Modeling using Foreign Geometry");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274136", " KI integer <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274156", " KI real <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274186", " FG data <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274309", " KI integer <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274329", " KI real <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274359", " FG data <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274451", " KI integer <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274461", " KI real <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274471", " FG data <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274592", " KI integer <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274602", " KI real <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274612", " FG data <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274662", " Triangular <B>array</B> flag ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274723", " <B>array</B> of derivatives) or FGEVTR (indicating a triangular <B>array</B> of derivatives request). The arguments nu, nv specify", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-283792", " KI integer <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-283802", " KI real <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-283812", " FG data <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-283682", " KI integer <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-283692", " KI real <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-283702", " FG data <B>array</B> ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274991", " set the range <B>array</B> and the periodicity flags <B>array</B>. ", "FG Manual - FG Module Interface Functions");
top.note("chapters/wn_chap.02.html#50466820_pgfId-7858919", " Parasolid V36.0 allows you to convert an <B>array</B> of regions or a single input body containing", "What's New in Parasolid - What&#8217;s New in Parasolid V36.0");
top.note("chapters/wn_chap.02.html#50466820_pgfId-7753876", " V36.0, you can now calculate distances between an <B>array</B> of vectors and a single topology. This can", "What's New in Parasolid - What&#8217;s New in Parasolid V36.0");
top.display();
//-->
</SCRIPT>
</HEAD>
<BODY bgcolor=#FFFFFF link=#0F3A68 vlink=#878787 alink=#FF7600 leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
</BODY>
</HTML>
