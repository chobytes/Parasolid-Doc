<HTML>
<HEAD>
<LINK REL=STYLESHEET HREF=../ps_doc.css CHARSET=ISO-8859-1 TYPE=text/css>
<SCRIPT LANGUAGE="JavaScript">
<!--

top.note("chapters/fd_chap.002.html#50409781_marker-298038", "minimum body (that is, a <B>point</B> in space), and extend it a step at", "Functional Description -  Introduction To Parasolid");
top.note("chapters/fd_chap.002.html#50409781_pgfId-298124", " for tracking purposes, such as marking the start <B>point</B> in a tool path. Several field types (real,", "Functional Description -  Introduction To Parasolid");
top.note("chapters/fd_chap.003.html#50409782_pgfId-298393", " usual C convention for a double precision floating <B>point</B> number ", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.003.html#50409782_pgfId-299798", " of tags remaining in a session at any <B>point</B>, you can call PK_SESSION_ask_tags_remaining . ", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.003.html#50409782_pgfId-299822", " deleted by rolling the modeler back to a <B>point</B> before the entity was created ", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.007.html#50409787_pgfId-405810", " /* <B>Point</B> to each of the frustrum functions you are supplying", "Functional Description - Supplying A Frustrum");
top.note("chapters/fd_chap.010.html#50409790_pgfId-335201", " PK_VECTOR_t <B>point</B>; ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-335208", " /* Specify <B>point</B> */ ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-335209", " option.vectors = &amp;<B>point</B>; ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-556597", " pointer to Parasolid. Parasolid sets the pointer to <B>point</B> to the returned information. These arguments usually appear", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-294865", " are structures of fixed size but they may <B>point</B> to variable length arrays. ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.011.html#50409791_pgfId-303699", " it useful or necessary to store a three-space <B>point</B> along with a face or an edge in", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.011.html#50409791_pgfId-311195", " (<B>point</B>) and an ", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.011.html#50409791_pgfId-312477", " call receives the same line and the other <B>point</B> that the line passes through. ", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.015.html#50409796_pgfId-294949", " an attached geometric entity - a surface, curve, <B>point</B> or lattice - for a fully defined, valid", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_marker-808565", " of a region. A vertex has a single <B>point</B>, which may be null. ", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_marker-295631", " For example, you might want to attach a <B>point</B> to a body that represents its centre of", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-295741", " 14.3.4 <B>Point</B> ", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-295861", " of the faces) in a solid body must <B>point</B> away from the solid region. ", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-295862", " a void inside a solid) the face normals <B>point</B> inwards; that is, away from the solid. ", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-295898", " is inside out, so that the face normals <B>point</B> into the solid. Such a body is called", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-295902", " Face normals must also <B>point</B> away from the body for manifold sheet bodies.", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-295991", " application requires a face normal at a given <B>point</B>, then it needs to call both this function", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-296111", " an edge or fin direction at a given <B>point</B>, then it needs to call one of these", "Functional Description - Model Structure");
top.note("chapters/fd_chap.016.html#50409797_pgfId-294747", " space. If an acorn body has only one <B>point</B>, then it is a minimum body, as described", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-294923", " of the solid, and the face normals always <B>point</B> away from the solid. ", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-294983", " one shell and one vertex with the given <B>point</B> attached. ", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-295219", " could be used, for example, to create a <B>point</B> which represents the center of gravity of a", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-296239", " of its region, and therefore represents a single <B>point</B> subtracted from that region. ", "Functional Description - Body Types");
top.note("chapters/fd_chap.017.html#50409798_pgfId-294989", " edges which, topologically, should meet at a common <B>point</B> have attached geometric data that does not intersect.", "Functional Description - Session And Local Precision");
top.note("chapters/fd_chap.017.html#50409798_pgfId-294997", " represents the minimum distance (in 3-space) that a <B>point</B> and an entity must be apart in order", "Functional Description - Session And Local Precision");
top.note("chapters/fd_chap.017.html#50409798_pgfId-295361", " radius of a sphere of uncertainty around the <B>point</B> of the vertex. The lower the precision, the", "Functional Description - Session And Local Precision");
top.note("chapters/fd_chap.018.html#50409799_pgfId-308211", " <B>Point</B> (PK_CLASS_<B>point</B>). See Section 14.3.4, <B>Point</B> for more information. ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-309747", " <B>Point</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-326255", " 17.2.10 <B>Point</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-309981", " PK_POINT_create uses the standard form to create a <B>point</B>. PK_POINT_sf_t contains a field that specifies a cartesian", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-310286", "P is a <B>point</B> on the line, and is specified using the", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-297827", " The reference <B>point</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_marker-297826", " parameter t represents the signed distance of the <B>point</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-297935", " take any value of t and returns a <B>point</B> on the circle. ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_marker-298063", " and the same center as the ellipse. The <B>point</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-298120", " However, the parameterisation is arranged so that a <B>point</B> on the curve retains its parameter value, even", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-310854", "P is a <B>point</B> on the plane and is specified using the", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-298233", " The reference <B>point</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-298237", " v both represent distances: the distance of the <B>point</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311059", "P is a <B>point</B> on the cylinder axis and is specified using", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-298368", " The reference <B>point</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-298372", "R(u, v) to the reference <B>point</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311137", "P is a <B>point</B> on the cone axis, and is specified using", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311138", " at the <B>point</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-298565", " The reference <B>point</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-298570", "R(u, v) to the reference <B>point</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311361", " Note: The surface normals <B>point</B> away from the centre of the sphere. ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311447", " distance of the current <B>point</B> from the corresponding <B>point</B> on the section curve.", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311568", "P is a reference <B>point</B> on the axis. ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-299395", "A and a reference <B>point</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.019.html#50409800_pgfId-294786", "x is a <B>point</B> in space and f is a function of", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-296080", " to remove any such knots at some later <B>point</B> in order to make the part valid. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-299476", " respect to the v parameter at each spline <B>point</B> of the row should be supplied. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300497", "t to give a <B>point</B> ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300618", " that can be used as a sample data <B>point</B> for the new B-geometry. This function needs to", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300717", " . Each position in this array denotes a <B>point</B> in the cloud of constraining points used to", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-301919", " degeneracy may be supplied either as a single <B>point</B> or as a degenerate b-spline curve. By using", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-316579", " space of the surface reduces to a single <B>point</B> of Cartesian space. In this region one or", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-316587", " At any <B>point</B> a B-surface may only be degenerate in one", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-316986", " defined as a smooth, G1-continuous surface, from any <B>point</B> of which the minimum distance to the underlying", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.021.html#50409802_pgfId-570512", " the region. The facet normals for these facets <B>point</B> out of the region. ", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386723", " body, face, edge, fin, vertex, surface, curve, or <B>point</B>. ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-381801", " default), then the position is a three space <B>point</B>, which must lie on the surface. If ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386674", " Evaluates a <B>point</B> on the curve or surface, at the supplied", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-388452", " default), then the position is a three space <B>point</B>, which must lie on the curve. If ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-378074", " at the <B>point</B> sbx_projection. sbx_projection is the closest <B>point</B> on the surface to the position. In this", "Functional Description - Expressions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-306606", " Is the entity a curve, surface or <B>point</B>? ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-306850", " Which part owns the given <B>point</B>? ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-306855", " Find the vertex connected to the given <B>point</B> ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-306976", " radius is non-zero, the planar face containing the <B>point</B> supplied (to PK_BODY_create_solid_cone ) is the base face.", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-380666", " Evaluates a <B>point</B> and its derivatives at a given parameter on", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-380681", " Evaluates a <B>point</B> and its derivatives at a given parameter pair", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-380697", " given curve is not periodic, then the returned <B>point</B> and derivatives are evaluated on the curve extension;", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-380698", " not periodic in that parameter, then the returned <B>point</B> and derivatives are sometimes evaluated. ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-309343", " pair in this range which maps to that <B>point</B>. ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-309677", " Finds the extreme <B>point</B> on the edge/face/body. ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-309688", " as vectors. The function looks for the furthest <B>point</B> on the body in the first direction specified.", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-309695", " , which shows how Parasolid finds the extreme <B>point</B> on a cube when the X, -Y, and", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-309836", " Figure 27-4 Finding the extreme <B>point</B> in a body ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-734831", " <B>point</B> ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-734833", " A <B>point</B> at which ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310049", " two faces are not coincident. At least one <B>point</B> on the boundary of ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310053", " two faces are not coincident. At least one <B>point</B> on the boundary of ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310057", " two faces are not coincident. At least one <B>point</B> on ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310061", " two faces are not coincident. At least one <B>point</B> on ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310106", " the degeneracy occurs, if it occupies a single <B>point</B> in space. ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310111", " A 3-space position, or else the middle <B>point</B> if the degeneracy does not have zero width.", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.029.html#50409809_pgfId-294754", " The inertia tensor about a <B>point</B>, where the <B>point</B> is the centre of gravity.", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.029.html#50409809_pgfId-295341", " vector from the center of mass to a <B>point</B> in the volume ", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.029.html#50409809_pgfId-295352", " moments of inertia about a <B>point</B>, where the <B>point</B> is the centre of gravity as defined in", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296882", " <B>Point</B>, curve, surface ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296896", " <B>Point</B>, curve, surface ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296912", " <B>Point</B>, curve, surface ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296926", " <B>Point</B>, curve, surface ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-373221", " Vertex, edge, face, body, surface, curve, <B>point</B> ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296942", " <B>Point</B>, curve, surface ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296948", " <B>Point</B>, curve, surface ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296962", " <B>Point</B>, curve, surface ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-373446", " Vertex, fin, edge, face, body, surface, curve, <B>point</B> ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297052", "in the returned range_data, when the <B>point</B> of minimum separation between the topological entity and", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297205", " <B>Point</B>, curve, surface ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297219", " <B>Point</B>, curve, surface ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.031.html#50409811_pgfId-294989", " abut when they share a common curve or <B>point</B> in space which lies on the bounding topology", "Functional Description - Clash Detection Of Bodies");
top.note("chapters/fd_chap.031.html#50409811_pgfId-294990", " Two edges abut when they share a common <B>point</B> in space which lies on the bounding topology", "Functional Description - Clash Detection Of Bodies");
top.note("chapters/fd_chap.031.html#50409811_pgfId-295009", " If there is a common <B>point</B> in space that lies within the bounding topology", "Functional Description - Clash Detection Of Bodies");
top.note("chapters/fd_chap.031.html#50409811_pgfId-295013", " If no common <B>point</B> exists, but the bounding topologies of the two", "Functional Description - Clash Detection Of Bodies");
top.note("chapters/fd_chap.032.html#50409812_pgfId-294727", " body is invalid then roll back to a <B>point</B> before the local operations, and try a different", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-294763", " check a <B>point</B>, curve, surface, or lattice ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-378717", " sense and belong to the same edge but <B>point</B> to different vertices. ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-378739", " Fin does not <B>point</B> to vertex ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-378742", ") does not <B>point</B> to that vertex. ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-378744", " Fin does not <B>point</B> to vertex ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-331458", " the resulting face normal senses of the pyramid <B>point</B> into the body. ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-296900", " body is invalid then roll back to a <B>point</B> before the local operation, and try a different", "Functional Description - Checking");
top.note("chapters/fd_chap.036.html#50409817_pgfId-314686", " must not evaluate to a <B>point</B> coincident with any vertex on ", "Functional Description - Splitting Topology");
top.note("chapters/fd_chap.038.html#50409820_pgfId-528775", " of bodies, as seen from a perspective view <B>point</B> as shown in ", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-308910", " A <B>point</B> through which the plane being used to project", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.040.html#50409822_pgfId-294740", " a helical curve or surface by sweep a <B>point</B> or curve about an axis. See Section 39.5,", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-1042102", " surfaces can also be created from a starting <B>point</B> or curve using PK_POINT_make_helical_curve and PK_CURVE_make_helical_surf . See", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-296973", " of whichever of the specified faces that path <B>point</B> is coincident with. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-729529", " an edge between two lock faces at the <B>point</B> where it exits the lock faces, then either", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-297250", " of the profile is tangent to the corresponding <B>point</B> on the path, and thus varies along the", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-297408", " A <B>point</B>, used in conjunction with ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-297707", " on the profile itself: it can be any <B>point</B> in space, and the swept body will be", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-297915", " the swept body at the start (and end) <B>point</B> of such sweeps, as shown in ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-299051", " in contact with the guide wires at any <B>point</B>, unless the curve method is used. See Section", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-299057", " option. Each vertex marks a <B>point</B> on the guide wire corresponding to a particular", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-1496814", " to the input profiles. Each vertex indicates a <B>point</B> on the profile that corresponds to the relevant", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-299370", " specified, or when a rotation lock is specified (<B>point</B> A). ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-300295", " of the contact points is at a fixed <B>point</B> on the profile; the other is free to", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-300333", " By default, Parasolid assumes that no trim <B>point</B> information is required. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-300555", " option with the <B>point</B> method (PK_sweep_guide_point_c) on a model of a pipe", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-300690", " with the <B>point</B> method ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-300695", " option with the <B>point</B> method (PK_sweep_guide_point_c) on a model with two guide", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-540984", " Figure 39-56 Effect of lateral scaling on the <B>point</B> and project methods of sweeping ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-301783", " in a circular motion. The distance of the <B>point</B> or curve from the axis, together with its", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-301894", " <B>Point</B> ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-301896", " A reference <B>point</B> for the path of the helix. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-301963", " Sweep a <B>point</B> about an axis, producing a helical curve ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-301976", "<B>point</B> ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-301978", " helical curve. The helix need not include the <B>point</B> itself. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-306270", "<B>point</B> ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302031", "<B>point</B> ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302032", "<B>point</B> ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302041", " starts at <B>point</B> and ends at X ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302045", " starts at -X and ends at <B>point</B> ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302049", " starts at -X and ends at X, with <B>point</B> in the middle of the path ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302053", " at x and ends at X, so that <B>point</B> is not contained in the helix at all.", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302055", " have on helices created from the same reference <B>point</B> is illustrated in ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302112", " to create different helices for a single reference <B>point</B> ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302139", "dist is the distance from the starting <B>point</B> to the axis. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302150", " Starting <B>point</B> is 5 from the axis. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302154", " Starting <B>point</B> is 5 from the axis. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302158", " Starting <B>point</B> is 10 from the axis. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-302162", " Starting <B>point</B> is 10 from the axis. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.041.html#50409823_pgfId-366972", " parallel to the path tangent at any interior <B>point</B> of the path edge unless the edge is", "Functional Description - Sweeping Tool Bodies Along a Path");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295978", " occupies a single <B>point</B> in space. A degenerate <B>point</B> profile is specified as a minimal body. ", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-457953", " half circle that intersects both profiles at a <B>point</B> one third from the left of each profile.", "Functional Description - Lofting");
top.note("chapters/fd_chap.044.html#50409826_pgfId-297643", " the cap area of the end cap must <B>point</B> to the positive side of the draw direction.", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.044.html#50409826_pgfId-297644", " supplying a sheet profile, the face normals should <B>point</B> to the positive side of the draw direction.", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.044.html#50409826_pgfId-297646", " the duct-like sheet forming the sidewall body must <B>point</B> outwards for pad emboss features and inwards for", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.050.html#50409833_pgfId-295524", " Notice that no extension is necessary at any <B>point</B> where the boundary edge is already inside the", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-296082", " edge are tangent to each other at the <B>point</B> where the edge intersects the edge to extend", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-296801", " Extend to a specified <B>point</B> ", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-296921", "(a) to a specified <B>point</B> ", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-296941", " <B>point</B> to extend to, if extending to a <B>point</B>.", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-297045", " example shown, extending the specified surface to the <B>point</B> shown would result in a self-intersection, thereby creating", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-297047", " the surface is extended as far as the <B>point</B> of self-intersection, as indicated in the illustration. ", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-297431", " extending a surface to a <B>point</B> already on the surface ", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.052.html#50409836_pgfId-919402", " To produce a vector projection, where a given <B>point</B> on the curve is projected from the curve", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-1101423", " along a ray away from a given eye <B>point</B> onto a target, the ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362759", " , the projected B-curve is split at the <B>point</B> of self-intersection. ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362760", " , the projected B-curve is split at the <B>point</B> of self-intersection and the projected line curve and", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362830", " Do not create <B>point</B> projections, unless it is necessary for the validity", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-760687", " Create <B>point</B> projections and vertex imprints if the input line", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362834", " additionally for all projected curves that are tolerantly <B>point</B>-like, with respect to operation and local topological tolerances.", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362884", " into PK_CURVE_project and is therefore projected as a <B>point</B>. ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-559129", " Figure 51-9 Creating <B>point</B> and line projections from three lines ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394075", " you do not want to specify a help <B>point</B> for a corresponding element in ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394176", " be made to succeed by specifying a help <B>point</B> which lies in the region that you want", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394250", " to take if a selector without a help <B>point</B> is split by the chosen boolean operation. ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394363", " a solid target. The tool has one help <B>point</B> in a topolset and the ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394482", " One face on the tool has a help <B>point</B> and is set to exclude the mid-face. The", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394524", "and a help <B>point</B> is set on the tool body. ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-467022", " you cannot extend their imprinted edges from the <B>point</B> of intersection, as illustrated in ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.054.html#50409838_pgfId-303311", " wire target, the target is split at the <B>point</B> of intersection, and both bodies are returned. This", "Functional Description - Manifold Booleans");
top.note("chapters/fd_chap.056.html#50409840_pgfId-294956", " is treated as a merge event from the <B>point</B> of view of attributes and attribute callbacks. ", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.060.html#50409845_pgfId-324134", " Each <B>point</B> on an edge is offset within its normal", "Functional Description - Offsetting");
top.note("chapters/fd_chap.062.html#50409847_pgfId-297595", " fails on valid sheet bodies that have a <B>point</B> contact vertex, such as the example shown in", "Functional Description - Thickening");
top.note("chapters/fd_chap.062.html#50409847_pgfId-297634", " Figure 61-3 Thickening a sheet body with a <B>point</B> contact vertex ", "Functional Description - Thickening");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296318", " in which the normals of the adjacent faces <B>point</B> in towards each other. ", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296319", " in which the normals of the adjacent faces <B>point</B> away from each other. ", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.067.html#50409853_pgfId-296840", " <B>point</B> on the original surface maps to a <B>point</B> at the same parameters on the replacement surface.", "Functional Description - Replacing The Surfaces Of Faces");
top.note("chapters/fd_chap.067.html#50409853_pgfId-296841", " variational surfaces meet smoothly maps to the same <B>point</B> on either face (to within the specified tolerance).", "Functional Description - Replacing The Surfaces Of Faces");
top.note("chapters/fd_chap.068.html#50409854_marker-1408546", " surface is a surface such that, at any <B>point</B> on the surface, the angle between the steepest", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.068.html#50409854_pgfId-1455888", " how to determine the normal associated with a <B>point</B> on a mesh. This can either be a", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1419312", " to repair miter at concave corners at the <B>point</B> where it intersects the parting body. This option", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.071.html#50409857_pgfId-363103", " shape of the patch using an array of <B>point</B> (position) data. ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-363105", " Section 70.3.6, Using <B>point</B> (position) data to control the shape of the", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-363173", " 70.3.6 Using <B>point</B> (position) data to control the shape of the", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-376193", " normals within the <B>point</B> set data. Default: No <B>point</B> data set is", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-376222", " a patch is controlled using an array of <B>point</B> data. ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-364727", " 70-14 Controlling the shape of a patch with <B>point</B> data ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-295715", " A single acorn vertex, used as a <B>point</B> through which the resulting patch must pass. ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-296050", " This produces a patch that contains a sharp <B>point</B> at the position of the supporting body. ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.072.html#50409858_pgfId-296779", " to the circle or ellipse normal and the <B>point</B>, about which the circle or ellipse is spun,", "Functional Description - Moving Faces");
top.note("chapters/fd_chap.072.html#50409858_pgfId-296788", " a general body with non-manifold vertices for every <B>point</B> contact. ", "Functional Description - Moving Faces");
top.note("chapters/fd_chap.072.html#50409858_pgfId-296858", " sheet bodies that touch the spin axis at <B>point</B> contacts ", "Functional Description - Moving Faces");
top.note("chapters/fd_chap.074.html#50409860_pgfId-932847", " Each <B>point</B> on the surface of the face is displaced", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-949401", " Every <B>point</B> on the supplied surface is displaced by the", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-464437", " outcomes are possible, the one with the closest <B>point</B> to the supplied geometry is chosen. See Section", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-307409", " arrays are situated at the <B>point</B> in time at which the callback is invoked.", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.076.html#50409863_pgfId-306539", " conic cross-section blend with asymmetric ranges at that <B>point</B> or a constant-width blend. ", "Functional Description - Edge Blending Overview");
top.note("chapters/fd_chap.076.html#50409863_pgfId-309270", " or strictly between zero and one for every <B>point</B> along the VRB. You cannot have a mixture", "Functional Description - Edge Blending Overview");
top.note("chapters/fd_chap.077.html#50409864_pgfId-714518", " arrays are used to create a <B>point</B> on the blend spine, as well as contact", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-602021", " the precise shape of the cross-section at each <B>point</B> along the ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-612011", " cross-section is elliptical, parabolic, or hyperbolic at each <B>point</B> along the ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-728936", " section at the appropriate end. At the corresponding <B>point</B> in the ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-619845", " include the fins attached to those edges that <B>point</B> towards the non-smooth vertex in the corresponding entry", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-1179643", " The apex is a <B>point</B> where the tangents from two underlying faces at", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-1180054", " points and the tangent plane of the contact <B>point</B> on the other side of the blend. ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-297926", " stop a blend short of its natural finishing <B>point</B> using any of the following methods: ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-297936", " can automatically stop the blend short at the <B>point</B> where it meets a neighboring blend. See Creating", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298213", " specified, Parasolid defines a plane by projecting the <B>point</B> orthogonally onto the blend spine. This plane is", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298425", " the blend at a suitable isoparameter, given a <B>point</B> on an edge to be blended. ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298442", " points. Each <B>point</B> should lie on the associated edge in the", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-299322", " An array of 3 doubles indicating the limit <B>point</B> on this edge. ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.078.html#50409865_pgfId-1084219", " the cliff edge becomes unstable and at that <B>point</B> the overflow becomes a notch overflow by default.", "Functional Description - Edge Blend Overflows");
top.note("chapters/fd_chap.079.html#50409866_pgfId-298746", " blend walls. You can define where the contact <B>point</B> lies either ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-299007", " the left wall of the blend at each <B>point</B> along the blend spine. If supplied alone (without", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-299011", " the right wall of the blend at each <B>point</B> along the blend spine. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-299525", " variable chordal width of the blend at any <B>point</B> along the blend spine. See ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-299532", " the variable ratio of the blend at any <B>point</B> along the blend spine. The ratio describes the", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-1379253", " points and the tangent plane of the contact <B>point</B> on the relevant side of the blend. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-305285", " an appropriate curvature-continuous blend from the supplied contact <B>point</B> data. You can have more control over the", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-896784", " The deepest <B>point</B> of the blend by specifying depth information: ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-305619", " along the blend, it is defined as the <B>point</B> on the blend surface that is furthest from", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-305613", " an indication of the position of the depth <B>point</B> along the chord between the contact points, within", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-305626", "depth <B>point</B>, and are illustrated in ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-894126", " parameters that set the position of the depth <B>point</B> as follows: ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-306149", " is constant at each <B>point</B> along the blend spine. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-307173", " constant parameter line that is calculated from the <B>point</B> at which the supplied plane intersects the blend", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-308207", " . The direction of the fin at the <B>point</B> of intersection then determines which side of the", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-309135", " or not to stop the blend at the <B>point</B> where the blend becomes too shallow. This takes", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-309137", " PK_blend_run_out_angle_c : stop the blend at the <B>point</B> where the angle subtended by the blend equals", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-309146", " blend, finally stopping the blend short at the <B>point</B> where it equals the specified ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-310911", "help <B>point</B> to indicate which of the possible blends should", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311219", " face as possible; the further away a help <B>point</B> is, the harder it is for Parasolid to", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311228", " may help improve performance. However, if the help <B>point</B> is not close to the blend, it will", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-713953", " conflicting multiple blends, you must supply a help <B>point</B> if you want to have any control over", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311311", " Note: You can also supply a help <B>point</B> to identify a position at which to generate", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311333", " Whether or not a help <B>point</B> is supplied in ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311337", " ambiguity in the supplied data. If a help <B>point</B> is supplied, you should set ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-852039", " In general, if you are specifying a help <B>point</B>, we recommend that ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311471", " at a specific position, identified using a help <B>point</B> ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-313205", " how you can create a blend skeleton from <B>point</B> and curve geometry, rather than generating a blend", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-296210", " If you specify a plane, then the <B>point</B> of intersection is determined by the parameter curve", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-296211", " the <B>point</B> of intersection is determined by the <B>point</B> that", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-296251", " intersects a capping plane at more than one <B>point</B>, it is trimmed at the intersection closest to", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-296279", " created depending on whether you supply a help <B>point</B> are shown in ", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-296321", " default behaviour to PK_FACE_make_blend . If no help <B>point</B> information is specified, PK_FACE_make_3_face_blend looks for multiple solutions,", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.081.html#50409868_pgfId-295250", " edge if the range is reduced to the <B>point</B> where it doesnt overlap the edge loop. ", "Functional Description - Interpreting Edge Blending Error Codes");
top.note("chapters/fd_chap.081.html#50409868_pgfId-321987", " cases, the rolling ball gets stuck at the <B>point</B> where the radius of curvature is smaller than", "Functional Description - Interpreting Edge Blending Error Codes");
top.note("chapters/fd_chap.082.html#50409869_pgfId-305655", ". These indicate which sheet(s) clashed and the <B>point</B> at which they clashed. ", "Functional Description - Interpreting Face-Face Blending Error Codes");
top.note("chapters/fd_chap.082.html#50409869_pgfId-305689", ", representing a <B>point</B> where the spine is unsuitable. ", "Functional Description - Interpreting Face-Face Blending Error Codes");
top.note("chapters/fd_chap.085.html#50409873_pgfId-352186", " a polyline is attached to an edge, each <B>point</B> will correspond to a mesh vertex along the", "Functional Description - Facet Model Structure");
top.note("chapters/fd_chap.088.html#50409876_pgfId-433645", " the shape of the mesh, such that any <B>point</B> on the new mesh wont be more than", "Functional Description - Checking and Repairing Mesh Data");
top.note("chapters/fd_chap.090.html#50409878_pgfId-339098", " of (C0) discontinuity across every mfin, and every <B>point</B> on an mfin has multiple parameterisations. Meshes, of", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.090.html#50409878_pgfId-340408", " Like any other type of surface, any <B>point</B> on a mesh has an associated normal. Broadly", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.092.html#50409881_pgfId-295189", " to remove any such discontinuities at some later <B>point</B> in order to make the part valid. ", "Functional Description - Importing Data");
top.note("chapters/fd_chap.092.html#50409881_pgfId-295619", " From this data Parasolid computes vertex <B>point</B> and tolerance: ", "Functional Description - Importing Data");
top.note("chapters/fd_chap.092.html#50409881_pgfId-295629", " P is the average centroid <B>point</B> computed using end of C1 and start of", "Functional Description - Importing Data");
top.note("chapters/fd_chap.092.html#50409881_pgfId-297884", " For faces bounding voids this means the normals <B>point</B> into the void. Face normals are determined by:", "Functional Description - Importing Data");
top.note("chapters/fd_chap.092.html#50409881_pgfId-297914", " as T-sheets or solid regions meeting at a <B>point</B> are not permitted. ", "Functional Description - Importing Data");
top.note("chapters/fd_chap.093.html#50409882_pgfId-308888", " when the parameterisation is bunched up to a <B>point</B> in one direction, at a parametric singularity. An", "Functional Description - Exporting Data");
top.note("chapters/fd_chap.093.html#50409882_pgfId-309738", " making it smaller the boundary becomes a pinprick <B>point</B>. ", "Functional Description - Exporting Data");
top.note("chapters/fd_chap.093.html#50409882_pgfId-310213", " values, u and v, maps to a single <B>point</B> in space. Typically this function is only defined", "Functional Description - Exporting Data");
top.note("chapters/fd_chap.093.html#50409882_pgfId-310221", " range, or interval. Each value maps onto a <B>point</B> in space, and so we have created a", "Functional Description - Exporting Data");
top.note("chapters/fd_chap.096.html#50409886_pgfId-294751", " loop, edge, fin, vertex, frame, lattice, surface, curve, <B>point</B>, group ", "Functional Description - Attribute Definitions");
top.note("chapters/fd_chap.096.html#50409886_pgfId-294947", " start <B>point</B> or direction of movement of the tool that", "Functional Description - Attribute Definitions");
top.note("chapters/fd_chap.099.html#50409889_pgfId-294729", " used to undo changes made after a certain <B>point</B>, indicated by a ", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-294738", " possible to roll back a model to the <B>point</B> where a feature was added, reapply the modified", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-415012", " attribute to be a no-roll attribute at any <B>point</B> in the current session. Once an attribute is", "Functional Description - Rollback");
top.note("chapters/fd_chap.100.html#50409890_pgfId-294731", " <B>Point</B> only: PK_CLASS_<B>point</B> ", "Functional Description - Groups");
top.note("chapters/fd_chap.101.html#50409891_pgfId-294921", " all of the different entity classes, e.g. a <B>point</B> cannot be merged or split as these operations", "Functional Description - Bulletin Board");
top.note("chapters/fd_chap.101.html#50409891_pgfId-295005", " If a <B>point</B> is created and copied, PK_BB_output_events would return two", "Functional Description - Bulletin Board");
top.note("chapters/fd_chap.101.html#50409891_pgfId-295042", " 1 is the copying of <B>point</B> 249 to <B>point</B> 250 (for a copy event the new entity", "Functional Description - Bulletin Board");
top.note("chapters/fd_chap.102.html#50409892_pgfId-295393", " partition itself had already been received at that <B>point</B>. ", "Functional Description - Archives");
top.note("chapters/fd_chap.102.html#50409892_pgfId-295394", " deleted when rolling the session back to a <B>point</B> before the delta was received: any pmarks received", "Functional Description - Archives");
top.note("chapters/fd_chap.107.html#50409898_pgfId-304390", " outputs an additional parameter with each visibility transition <B>point</B> corresponding to its position along the polyline. ", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-294903", " defines a <B>point</B> on one of the hatching planes which allows", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-295012", " all radial faces using some/all of the floating <B>point</B> values supplied in the options structure as detailed", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-295019", " all radial faces using some/all of the floating <B>point</B> values supplied in the options structure as above;", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.108.html#50409899_pgfId-294800", " a ray, which passes through the current view <B>point</B> and in the current viewing direction. ", "Functional Description - Display Tolerances");
top.note("chapters/fd_chap.109.html#50409900_pgfId-333313", " satisfied. However, if the process comes to a <B>point</B> where a facet has been produced which is", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-342858", " facets. Despite the change in curvature around the <B>point</B> of inflection, this facet can still satisfy the", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-342873", " Split facets around the <B>point</B> of inflection so as to increase the number", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-342878", " can be achieved when splitting facets around the <B>point</B> of inflection. ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.111.html#50409902_pgfId-294788", " mesh has a set of associated geometric information (<B>point</B>, normal, parameter, derivative, principal directions and curvatures) that", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-294912", " added. By convention, the fins around a facet <B>point</B> anti-clockwise when the facet mesh is viewed from", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-295040", " in turn are bound to the vertices they <B>point</B> to. You can describe this information in tabular", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-295573", " Note: Fins in an interior hole <B>point</B> in a clockwise direction when viewed outside the", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-296828", " Return one or more intermediate tables to <B>point</B> the data container to the appropriate geometric data.", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-297395", " top-facing model face), even though both those fins <B>point</B> to the same facet vertex. ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-297879", " Facet <B>point</B> to topology. See Section 110.6.4 . ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-297889", " index points to a facet, and the values <B>point</B> to the originating model faces. Sets of facets", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-298664", " table maps each facet <B>point</B> on a face boundary to the associated vertex,", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-298665", " If a facet <B>point</B> corresponds to a model vertex, then the vertex", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-298666", " Otherwise, the model edge that the facet <B>point</B> lies on is returned, if that edge is", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-298671", " with edges. The one exception is the facet <B>point</B> on the tolerant edge; this is associated with", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-426975", " For model faces, a facet <B>point</B> is deemed to lie off the face if", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-426976", " For tolerant model edges, a facet <B>point</B> is deemed to lie off the edge if", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294794", " the reciprocal of the distance between the eye <B>point</B> and the view plane. ", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294797", " then the eye <B>point</B> is deemed to be at infinity and the", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294825", " = 1/w is the distance from the eye <B>point</B> to the view plane. ", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.113.html#50409904_pgfId-301166", " Warning: When using approximate picking, intersection <B>point</B> and distance values returned by PK_BODY_pick_topols are approximate,", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.113.html#50409904_pgfId-301328", " a ray which passes through the current view <B>point</B> and in the current viewing direction (transformed from", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.115.html#50409907_pgfId-294968", " there is an exclusive function waiting for a <B>point</B> where no threads are inside Parasolid. Conversely, an", "Functional Description - Calling Parasolid From Multiple Threads");
top.note("chapters/fd_chap.117.html#50409909_pgfId-294799", " session so that work done up to that <B>point</B> is not lost if the session stops unexpectedly.", "Functional Description - Session Support");
top.note("chapters/fd_chap.118.html#50409910_pgfId-379973", " emulate any release (full or patch) from the <B>point</B> at which you first implemented the consolidated system.", "Functional Description - Version Controls");
top.note("chapters/fd_chap.118.html#50409910_pgfId-378165", " Calculating <B>point</B> contacts between surfaces ", "Functional Description - Version Controls");
top.note("chapters/fd_chap.118.html#50409910_pgfId-378609", " <B>Point</B> surface closest approach ", "Functional Description - Version Controls");
top.note("chapters/fd_chap.118.html#50409910_pgfId-378933", " Identifying the end <B>point</B> of a cliff between tangent blends ", "Functional Description - Version Controls");
top.note("chapters/fd_chap.119.html#50409911_pgfId-413801", " At some <B>point</B> after this, the rebuild fails. The application attempts", "Functional Description - Implementing Version Control In Applications");
top.note("chapters/fd_chap.122.html#50409915_pgfId-294793", " // processing instruction initiates (at some <B>point</B>) ", "Functional Description - Error Handling ");
top.note("chapters/fd_chap.122.html#50409915_pgfId-294893", " any exceptions must be thrown back to a <B>point</B> outside of any PK function calls; they must", "Functional Description - Error Handling ");
top.note("chapters/fd_chap.123.html#50409916_pgfId-294821", " continue in the interrupted routine at the next <B>point</B> after the signal occurred. ", "Functional Description - Signal Handling");
top.note("chapters/fd_chap.123.html#50409916_marker-294910", " function, which resumes normal execution until a safe <B>point</B> is reached, when the abort request will be", "Functional Description - Signal Handling");
top.note("chapters/fd_chap.123.html#50409916_pgfId-294931", " tell Parasolid to abort at the next safe <B>point</B> ", "Functional Description - Signal Handling");
top.note("chapters/fd_chap.123.html#50409916_pgfId-294947", " if too much time elapses before a safe <B>point</B> in the code has been reached. This gets", "Functional Description - Signal Handling");
top.note("chapters/fd_chap.123.html#50409916_pgfId-295346", " however, they must be thrown back to a <B>point</B> outside of any PK function calls, and not", "Functional Description - Signal Handling");
top.note("chapters/fd_chap.124.html#50409918_pgfId-285539", " value of this attribute is treated as a <B>point</B> mass. ", "Functional Description - System Attribute Definitions");
top.note("chapters/fd_chap.125.html#50409919_pgfId-320701", " the curve to have less continuity at that <B>point</B> than is formally required for a spline. A", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-315601", " can continue to be evaluated with the same <B>point</B> reoccurring every period. ", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287087", " sum to one and are non-negative. Thus each <B>point</B> P(t) on the curve is defined as a", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287088", " B-spline curve obeys a stronger hull property: any <B>point</B> P(t) on the curves is inside the convex", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287261", " method stores the derivatives evaluated at the start <B>point</B> of each segment, allowing the curve to be", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287276", " The <B>point</B> is stored first, followed by the 1st derivative", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287701", " The <B>point</B> is supplied first, followed by the u derivatives", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285910", " The rest connects the DLL name and entry <B>point</B> to the function being declared, and declares the", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275520", " weight associated with it. Also called a control <B>point</B>. ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275523", " convex hulls for various subsets of the control <B>point</B> set, which enclose portions of the spline. ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275578", " In Parasolid all face normals <B>point</B> out of the material of the body. For", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275694", " state of the modelling session at a given <B>point</B>, by creating a pmark in each partition. ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-293056", " of zero dimension - it is just a <B>point</B> in space. Topologically it comprises of a single", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275705", " is inside out, so that the face normals <B>point</B> into the solid. The only operation that can", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275709", " A normal to a surface at a <B>point</B> on that surface is a vector which is", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275728", " The surface from any <B>point</B> on which the minimum distance to the underlying", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275764", " Partition mark - <B>point</B> in a modelling session when a rollback mark", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275767", " <B>Point</B> ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275856", " or vertex, representing the minimum distance that a <B>point</B> and an entity must be apart in order", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-206242", " help <B>point</B> options 1287 ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-207292", " help <B>point</B> options, face-face blend 1287 ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-208289", " face-face blend help <B>point</B> 1287 ", "Functional Description - ZGlossary");
top.note("chapters/ov_chap.03.html#50442274_pgfId-351678", " information contained in the documentation is your first <B>point</B> of reference for anything you wish to know", "Overview of Parasolid - About Parasolid");
top.note("chapters/ov_chap.04.html#50442254_marker-283679", " <B>point</B> in space. A vertex has a single <B>point</B>,", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_marker-288776", " normals of each face must always <B>point</B> away from the solid region: ", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_pgfId-288779", " For an outer shell, the normals <B>point</B> away from each other. ", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_pgfId-389643", " a void inside a solid) the face normals <B>point</B> towards each other. ", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_marker-390271", " , that is, a body whose face normals <B>point</B> the wrong way. Such bodies can easily be", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_pgfId-288888", " For sheet bodies, face normals must also <B>point</B> away from the body. The face normals in", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_marker-285313", " For example, you might want to attach a <B>point</B> to a body that represents its center of", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_pgfId-285144", " <B>Point</B> ", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_pgfId-290068", " Only entities of surface, curve and <B>point</B> classes may also be attached directly to bodies", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_pgfId-289317", " edges which, topologically, should meet at a common <B>point</B> have attached geometric data that does not intersect.", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.04.html#50442254_pgfId-290537", " an invalidity, you should roll back to a <B>point</B> before the appropriate local operation and try a", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.05.html#50442271_pgfId-318604", " treating them as a single body from that <B>point</B> on. ", "Overview of Parasolid - Booleans and Related Functionality");
top.note("chapters/ov_chap.07.html#50442276_pgfId-291503", " possible. When a sheet is extended to a <B>point</B> where no underlying surface is available, you can", "Overview of Parasolid - Working with Sheets and Wires");
top.note("chapters/ov_chap.07.html#50442276_pgfId-1018339", " of bodies, as seen from a perspective view <B>point</B> as shown in ", "Overview of Parasolid - Working with Sheets and Wires");
top.note("chapters/ov_chap.11.html#50442244_pgfId-847302", " to stop it short of its natural finishing <B>point</B>, using either vertex or edge limits, or information", "Overview of Parasolid - Blending");
top.note("chapters/ov_chap.14.html#50442249_pgfId-276065", " Detect whether a <B>point</B> is contained inside or outside an entity, or", "Overview of Parasolid - Enquiring Model Data and Identifying Details");
top.note("chapters/ov_chap.16.html#50442289_pgfId-276673", " the state it was in at some previous <B>point</B> in time. This is especially true of design", "Overview of Parasolid - Application Support");
top.note("chapters/ov_chap.16.html#50442289_pgfId-278073", " modelling session or the current partition. At any <B>point</B>, you can move to one of these marks,", "Overview of Parasolid - Application Support");
top.note("chapters/ov_chap.16.html#50442289_pgfId-280557", " needs to roll back a model to the <B>point</B> where a feature was added, reapply the modified", "Overview of Parasolid - Application Support");
top.note("chapters/ov_chap.16.html#50442289_pgfId-279929", " At this <B>point</B>, the user decides that one edge of the", "Overview of Parasolid - Application Support");
top.note("chapters/ov_chap.17.html#50442275_pgfId-281181", " relevant creation function that specifies the radius, center <B>point</B> and reference direction for the circle. ", "Overview of Parasolid - Writing Parasolid Applications");
top.note("chapters/p2_chap.03.html#sec_b_1_1", " size and shape of its owner (e.g. start <B>point</B> or direction of movement of the tool that", "PK Reference - PK token Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.05.html#sec_d_1_app", " topols and a vector in points representing a <B>point</B> where the guide is unsuitable. ", "PK Reference - PK token Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.07.html#sec_f_1_1", " curve or <B>point</B>", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_2", " on <B>point</B> of intersection (MILD)", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_3", " PK_ERROR_cant_find_extreme 1051 PK_BODY_find_extreme failed to find extreme <B>point</B>", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_4", " PK_ERROR_cant_get_point 5031 PK_BODY_offset_planar_wire Unable to get new vertex <B>point</B> to fill a gap.", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.09.html#sec_h_1_1", " PK_ERROR_bad_box 909 PK_BODY_create_sheet_planar (MILD) at least one <B>point</B> lies outside of", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_2", " PK_ERROR_cant_find_extreme 1051 PK_BODY_find_extreme failed to find extreme <B>point</B>", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_3", " PK_ERROR_has_parent 28 PK_VERTEX_attach_points <B>point</B> is already attached", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_4", " PK_ERROR_point_contact 5122 PK_BODY_thicken <B>point</B> contact found in sheet body", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.10.html#sec_i_1_1", " PK_BCURVE_splinewise_sf_t 911 PK_ERROR_bad_position a spline <B>point</B> is outside size box (MILD)", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_2", " <B>point</B> of the curve are not distinct", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_3", " PK_LOOP_offset_planar 5031 PK_ERROR_cant_get_point Unable to get new vertex <B>point</B> to fill a gap.", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_4", " PK_VERTEX_attach_points 28 PK_ERROR_has_parent <B>point</B> is already attached", "PK Reference - PK Error Codes (Functional)");
top.note("headers/pk_3_face_blend_t.html#documentation", " representing a <B>point</B> where the guide", "PK Reference - PK_3_face_blend_t");
top.note("headers/pk_assembly_check_o_t.html#documentation", "PK_GEOM_state_degenerate_c | geom | | <B>point</B> in", "PK Reference - PK_ASSEMBLY_check_o_t");
top.note("headers/pk_attdef_class_t.html#documentation", " of its owner (e.g. start <B>point</B> or", "PK Reference - PK_ATTDEF_class_t");
top.note("headers/pk_bb_output_events.html#documentation", "For example: if a <B>point</B> is created and copied and the bulletin board", "PK Reference - PK_BB_output_events");
top.note("headers/pk_bcurve_create_by_fitting.html#documentation", " fit one or more bcurves to sets of <B>point</B> and", "PK Reference - PK_BCURVE_create_by_fitting");
top.note("headers/pk_bcurve_create_fitted_o_t.html#documentation", " the evaluated <B>point</B> will be within fitting", "PK Reference - PK_BCURVE_create_fitted_o_t");
top.note("headers/pk_bcurve_fit_err_method_t.html#documentation", " PK_BCURVE_fit_err_parm_c match sample <B>point</B> to <B>point</B> on bcurve", "PK Reference - PK_BCURVE_fit_err_method_t");
top.note("headers/pk_bcurve_fit_eval_f_t.html#declaration", " PK_VECTOR_t *const <B>point</B>, --- sample <B>point</B> at parameter ", "PK Reference - PK_BCURVE_fit_eval_f_t");
top.note("headers/pk_bcurve_fit_eval_f_t.html#documentation", "a 3-space vector in <B>point</B> .", "PK Reference - PK_BCURVE_fit_eval_f_t");
top.note("headers/pk_bcurve_make_bsurf_lofted.html#documentation", "<B>point</B> and one extra control vertex. This means that", "PK Reference - PK_BCURVE_make_bsurf_lofted");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#declaration", " PK_VECTOR_t v_degen_vector; --- position vector of <B>point</B> degeneracy", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#documentation", " contains a derivative for each spline <B>point</B> (1) of the", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_splinewise_sf_t.html#errors", " PK_ERROR_bad_position a spline <B>point</B> is outside size box (MILD)", "PK Reference - PK_BCURVE_splinewise_sf_t");
top.note("headers/pk_blend_convexity_t.html#documentation", "the blend <B>point</B> in towards each other. A blend is convex", "PK Reference - PK_blend_convexity_t");
top.note("headers/pk_blend_limit_data_t.html#documentation", " will be the closest <B>point</B> on the blend spine to the location", "PK Reference - PK_blend_limit_data_t");
top.note("headers/pk_blend_limit_type_t.html#documentation", " PK_blend_limit_type_edge_c The associated limit <B>point</B> in the", "PK Reference - PK_blend_limit_type_t");
top.note("headers/pk_blend_output_rib_t.html#documentation", " PK_blend_output_rib_at_help_c return a single rib at the help <B>point</B>", "PK Reference - PK_blend_output_rib_t");
top.note("headers/pk_blend_range_t.html#documentation", " plane of the contact <B>point</B> on the relevant", "PK Reference - PK_blend_range_t");
top.note("headers/pk_blend_rib_control_t.html#documentation", " interval_parms to null. The help <B>point</B> at which the rib is evaluated", "PK Reference - PK_blend_rib_control_t");
top.note("headers/pk_blend_shape_t.html#documentation", " is used to determine the maximum depth, depth <B>point</B>,", "PK Reference - PK_blend_shape_t");
top.note("headers/pk_blend_size_t.html#documentation", " of the contact <B>point</B> on the relevant side of the", "PK Reference - PK_blend_size_t");
top.note("headers/pk_body_boolean_2.html#errors", " PK_ERROR_bad_position bad choice of help <B>point</B> for topolset", "PK Reference - PK_BODY_boolean_2");
top.note("headers/pk_body_boolean_2.html#documentation", " only be coincident with the imprint at the <B>point</B> associated with", "PK Reference - PK_BODY_boolean_2");
top.note("headers/pk_body_boolean_o_t.html#documentation", " merge event from the <B>point</B> of view of attribute", "PK Reference - PK_BODY_boolean_o_t");
top.note("headers/pk_body_check_o_t.html#documentation", "PK_GEOM_state_self_int_c | self-intersecting | <B>point</B> on the", "PK Reference - PK_BODY_check_o_t");
top.note("headers/pk_body_contains_vector.html#description", " This function determines whether the <B>point</B> represented by the given", "PK Reference - PK_BODY_contains_vector");
top.note("headers/pk_body_contains_vector.html#documentation", "the body and coincides with or contains the <B>point</B> is also returned.", "PK Reference - PK_BODY_contains_vector");
top.note("headers/pk_body_create_sheet_planar.html#errors", " PK_ERROR_bad_box (MILD) at least one <B>point</B> lies outside of", "PK Reference - PK_BODY_create_sheet_planar");
top.note("headers/pk_body_emboss.html#documentation", "<B>point</B> to the positive side of the emboss direction.", "PK Reference - PK_BODY_emboss");
top.note("headers/pk_body_enlarge.html#documentation", " points are all computed by putting the original <B>point</B> through the", "PK Reference - PK_BODY_enlarge");
top.note("headers/pk_body_fill_hole_o_t.html#declaration", " --- Number of sets of <B>point</B> data", "PK Reference - PK_BODY_fill_hole_o_t");
top.note("headers/pk_body_fill_hole_o_t.html#documentation", " The number of supporting <B>point</B> sets to be supplied.", "PK Reference - PK_BODY_fill_hole_o_t");
top.note("headers/pk_body_find_extreme.html#declaration", " PK_VECTOR_t *const extreme, --- position of extreme <B>point</B>", "PK Reference - PK_BODY_find_extreme");
top.note("headers/pk_body_find_extreme.html#description", " This function finds the extreme <B>point</B> on the given body in direction_1 .", "PK Reference - PK_BODY_find_extreme");
top.note("headers/pk_body_find_extreme.html#errors", " PK_ERROR_cant_find_extreme failed to find extreme <B>point</B>", "PK Reference - PK_BODY_find_extreme");
top.note("headers/pk_body_fix_blends.html#documentation", " For faces derived from a limit <B>point</B> the array will instead contain", "PK Reference - PK_BODY_fix_blends");
top.note("headers/pk_body_hollow.html#documentation", " an edge can offset to a <B>point</B> or a face can become absorbed into", "PK Reference - PK_BODY_hollow");
top.note("headers/pk_body_imprint_curve.html#documentation", " The position of the <B>point</B> of the single vertex of the body is", "PK Reference - PK_BODY_imprint_curve");
top.note("headers/pk_body_imprint_cus_normal_o_t.html#documentation", " will be trimmed at the <B>point</B> of self-intersection.", "PK Reference - PK_BODY_imprint_cus_normal_o_t");
top.note("headers/pk_body_imprint_cus_vec_o_t.html#documentation", " will be trimmed at the <B>point</B> of self-intersection.", "PK Reference - PK_BODY_imprint_cus_vec_o_t");
top.note("headers/pk_body_imprint_faces_o_t.html#documentation", " trimmed at the <B>point</B> of self-intersection.", "PK Reference - PK_BODY_imprint_faces_o_t");
top.note("headers/pk_body_imprint_o_t.html#documentation", " trimmed at the <B>point</B> of self-intersection.", "PK Reference - PK_BODY_imprint_o_t");
top.note("headers/pk_body_loft_status_r_t.html#documentation", " fault_location The three space <B>point</B> where the fault is located, or from", "PK Reference - PK_BODY_loft_status_r_t");
top.note("headers/pk_body_make_lofted_body.html#documentation", " Minimum or Degenerate <B>Point</B> Profiles", "PK Reference - PK_BODY_make_lofted_body");
top.note("headers/pk_body_make_swept_body.html#documentation", " of rotation about the path tangent at the <B>point</B> on the path", "PK Reference - PK_BODY_make_swept_body");
top.note("headers/pk_body_make_swept_body_2.html#documentation", " to the guide wires, such that a profile <B>point</B> located at a", "PK Reference - PK_BODY_make_swept_body_2");
top.note("headers/pk_body_make_swept_body_2_o_t.html#declaration", " PK_VECTOR_t scale_point;--- defining <B>point</B> for scale laws of", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_2_o_t.html#documentation", " scale_point A position vector indicating the defining <B>point</B> for a", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#declaration", " PK_VECTOR_t scale_point; --- defining <B>point</B> for scale", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#documentation", " scale_point A position vector indicating the defining <B>point</B> for a", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_make_swept_tool_o_t.html#documentation", " <B>point</B> of a path edge, unless the edge is", "PK Reference - PK_BODY_make_swept_tool_o_t");
top.note("headers/pk_body_offset.html#documentation", " can offset to a <B>point</B> or a face can become absorbed into the", "PK Reference - PK_BODY_offset");
top.note("headers/pk_body_offset_planar_wire.html#errors", " PK_ERROR_cant_get_point Unable to get new vertex <B>point</B> to fill a gap.", "PK Reference - PK_BODY_offset_planar_wire");
top.note("headers/pk_body_patterned_t.html#documentation", " of tangential contacts (e.g. <B>point</B>", "PK Reference - PK_BODY_patterned_t");
top.note("headers/pk_body_pick_topols_o_t.html#declaration", " PK_VECTOR_t near_point; --- <B>point</B> on near_plane", "PK Reference - PK_BODY_pick_topols_o_t");
top.note("headers/pk_body_pick_topols_o_t.html#documentation", " picked. To be considered for picking, the intersection <B>point</B> between", "PK Reference - PK_BODY_pick_topols_o_t");
top.note("headers/pk_body_pick_topols_r_t.html#documentation", "If faces are being picked, the intersect <B>point</B> is the exact intersection", "PK Reference - PK_BODY_pick_topols_r_t");
top.note("headers/pk_body_repair_shells.html#documentation", " will be reversed in order to have them <B>point</B> away from solid regions", "PK Reference - PK_BODY_repair_shells");
top.note("headers/pk_body_spin.html#documentation", " single <B>point</B>, but it may be coincident with any edges", "PK Reference - PK_BODY_spin");
top.note("headers/pk_body_sweep_alignment_t.html#documentation", " corresponding guide <B>point</B> will be a fixed", "PK Reference - PK_BODY_sweep_alignment_t");
top.note("headers/pk_body_sweep_fault_t.html#documentation", " at some <B>point</B>", "PK Reference - PK_BODY_sweep_fault_t");
top.note("headers/pk_body_sweep_status_r_t.html#documentation", " fault_location The three space <B>point</B> where the error is located, or from", "PK Reference - PK_BODY_sweep_status_r_t");
top.note("headers/pk_body_taper_o_t.html#declaration", " --- highest <B>point</B> (NULL)", "PK Reference - PK_BODY_taper_o_t");
top.note("headers/pk_body_taper_o_t.html#documentation", " surfaces created from their highest <B>point</B> with respect", "PK Reference - PK_BODY_taper_o_t");
top.note("headers/pk_body_thicken.html#errors", " PK_ERROR_point_contact <B>point</B> contact found in sheet body", "PK Reference - PK_BODY_thicken");
top.note("headers/pk_body_thicken.html#documentation", " edge may offset to a <B>point</B> or a face become absorbed into the body.", "PK Reference - PK_BODY_thicken");
top.note("headers/pk_body_thicken_2.html#documentation", " edge may offset to a <B>point</B> or a face become absorbed into the body.", "PK Reference - PK_BODY_thicken_2");
top.note("headers/pk_body_transform.html#documentation", " points are all computed by putting the original <B>point</B> through the", "PK Reference - PK_BODY_transform");
top.note("headers/pk_body_transform_2.html#documentation", " points are all computed by putting the original <B>point</B> through the", "PK Reference - PK_BODY_transform_2");
top.note("headers/pk_boolean_material_t.html#documentation", " PK_boolean_material_inside_c face normals <B>point</B> away from solid material", "PK Reference - PK_boolean_material_t");
top.note("headers/pk_boolean_region_select_o_t.html#documentation", "to it, or a help <B>point</B> in the interior of the region. A selectors", "PK Reference - PK_boolean_region_select_o_t");
top.note("headers/pk_boolean_select_topolset_o_t.html#documentation", " selector is split by the boolean, a help <B>point</B> may be given", "PK Reference - PK_boolean_select_topolset_o_t");
top.note("headers/pk_bsurf_splinewise_sf_t.html#errors", " PK_ERROR_bad_position a spline <B>point</B> is outside size box (MILD)", "PK Reference - PK_BSURF_splinewise_sf_t");
top.note("headers/pk_check_fault_t.html#documentation", "<B>point</B> then its zero values can be ignored and", "PK Reference - PK_check_fault_t");
top.note("headers/pk_check_state_t.html#documentation", " to the same edge but <B>point</B> to different", "PK Reference - PK_check_state_t");
top.note("headers/pk_curve_eval.html#declaration", " PK_VECTOR_t p[] --- <B>point</B> and derivatives.", "PK Reference - PK_CURVE_eval");
top.note("headers/pk_curve_eval.html#description", " This function evaluates a <B>point</B> and derivatives at a given parameter on the", "PK Reference - PK_CURVE_eval");
top.note("headers/pk_curve_eval.html#documentation", "The function calculates the Cartesian coordinates of the <B>point</B> at the given", "PK Reference - PK_CURVE_eval");
top.note("headers/pk_curve_eval_handed.html#declaration", " PK_VECTOR_t p[] --- <B>point</B> and derivatives.", "PK Reference - PK_CURVE_eval_handed");
top.note("headers/pk_curve_eval_handed.html#documentation", " handed version of PK_CURVE_eval , which evaluates the <B>point</B>", "PK Reference - PK_CURVE_eval_handed");
top.note("headers/pk_curve_eval_with_tan_handed.html#declaration", " PK_VECTOR_t p[], --- <B>point</B> and derivatives.", "PK Reference - PK_CURVE_eval_with_tan_handed");
top.note("headers/pk_curve_eval_with_tan_handed.html#documentation", "Like PK_CURVE_eval_with_tangent this function evaluates a <B>point</B>, derivatives", "PK Reference - PK_CURVE_eval_with_tan_handed");
top.note("headers/pk_curve_eval_with_tangent.html#declaration", " PK_VECTOR_t p[], --- <B>point</B> and derivatives.", "PK Reference - PK_CURVE_eval_with_tangent");
top.note("headers/pk_curve_eval_with_tangent.html#description", " This function evaluates a <B>point</B>, derivatives and tangent at a given parameter", "PK Reference - PK_CURVE_eval_with_tangent");
top.note("headers/pk_curve_find_vectors.html#errors", " <B>point</B> of the curve are not distinct", "PK Reference - PK_CURVE_find_vectors");
top.note("headers/pk_curve_find_vectors_o_t.html#documentation", "Notation: The \"start <B>point</B>\" of the curve is the position vector corresponding", "PK Reference - PK_CURVE_find_vectors_o_t");
top.note("headers/pk_curve_fix_self_int.html#errors", " on <B>point</B> of intersection (MILD)", "PK Reference - PK_CURVE_fix_self_int");
top.note("headers/pk_curve_fix_self_int_o_t.html#documentation", " include the <B>point</B> at parameter param on the input", "PK Reference - PK_CURVE_fix_self_int_o_t");
top.note("headers/pk_curve_general_eval_f_t.html#declaration", " double *const derivs --- <B>point</B> and derivatives", "PK Reference - PK_CURVE_general_eval_f_t");
top.note("headers/pk_curve_general_eval_f_t.html#documentation", "return the <B>point</B> and, optionally, derivatives of the function at parameter.", "PK Reference - PK_CURVE_general_eval_f_t");
top.note("headers/pk_curve_make_approx.html#documentation", " supplied curve is a straight line then its <B>point</B> will be moved to", "PK Reference - PK_CURVE_make_approx");
top.note("headers/pk_curve_make_surf_isocline.html#documentation", "a <B>point</B> on the actual geometry may deviate from its", "PK Reference - PK_CURVE_make_surf_isocline");
top.note("headers/pk_curve_parameterise_vector.html#description", " Find parameter of <B>point</B> on curve", "PK Reference - PK_CURVE_parameterise_vector");
top.note("headers/pk_curve_self_int_t.html#documentation", " intersecting. If a parametric region is a <B>point</B>, the", "PK Reference - PK_CURVE_self_int_t");
top.note("headers/pk_debug_session_watch_fns.html#documentation", "<B>point</B> when one of the watched functions is entered.", "PK Reference - PK_DEBUG_SESSION_watch_fns");
top.note("headers/pk_debug_try_error_handler.html#description", "use. The <B>point</B> of this is to allow testing of run-time", "PK Reference - PK_DEBUG_try_error_handler");
top.note("headers/pk_edge_ask_convexity_o_t.html#documentation", " normals at any <B>point</B> along the edge that is", "PK Reference - PK_EDGE_ask_convexity_o_t");
top.note("headers/pk_edge_ask_geometry.html#documentation", "both ends are returned as the periodic seam <B>point</B>, and t_int , if", "PK Reference - PK_EDGE_ask_geometry");
top.note("headers/pk_edge_ask_geometry_nmnl.html#documentation", "both ends are returned as the periodic seam <B>point</B>, and t_int , if", "PK Reference - PK_EDGE_ask_geometry_nmnl");
top.note("headers/pk_edge_attach_curves_2.html#errors", " PK_ERROR_cant_get_point (MILD) Unable to find the <B>point</B>", "PK Reference - PK_EDGE_attach_curves_2");
top.note("headers/pk_edge_curve_dir_t.html#documentation", " PK_EDGE_curve_dir_point_c Use a <B>point</B> and direction to determine", "PK Reference - PK_EDGE_curve_dir_t");
top.note("headers/pk_edge_curve_direction_t.html#declaration", " PK_VECTOR_t <B>point</B>; --- <B>point</B> to be used with direction", "PK Reference - PK_EDGE_curve_direction_t");
top.note("headers/pk_edge_curve_direction_t.html#documentation", " <B>point</B> : <B>point</B> and direction are to be supplied together to", "PK Reference - PK_EDGE_curve_direction_t");
top.note("headers/pk_edge_euler_open_zip.html#errors", " PK_ERROR_no_common_vertex fin doesnt <B>point</B> to a vertex of edge ", "PK Reference - PK_EDGE_euler_open_zip");
top.note("headers/pk_edge_find_extreme.html#declaration", " PK_VECTOR_t *const extreme, --- position of extreme <B>point</B>", "PK Reference - PK_EDGE_find_extreme");
top.note("headers/pk_edge_find_extreme.html#description", " This function finds the extreme <B>point</B> on the given edge in direction_1 .", "PK Reference - PK_EDGE_find_extreme");
top.note("headers/pk_edge_find_extreme.html#errors", " PK_ERROR_cant_find_extreme failed to find extreme <B>point</B>", "PK Reference - PK_EDGE_find_extreme");
top.note("headers/pk_edge_imprint_point.html#declaration", " PK_POINT_t <B>point</B>, --- <B>point</B> to imprint", "PK Reference - PK_EDGE_imprint_point");
top.note("headers/pk_edge_imprint_point.html#description", " This function imprints a <B>point</B> onto an edge, thereby creating a", "PK Reference - PK_EDGE_imprint_point");
top.note("headers/pk_edge_imprint_point.html#errors", " PK_ERROR_coincident <B>point</B> coincident with existing vertex", "PK Reference - PK_EDGE_imprint_point");
top.note("headers/pk_edge_imprint_point.html#documentation", "If edge is accurate, <B>point</B> is required to lie on the edge curve.", "PK Reference - PK_EDGE_imprint_point");
top.note("headers/pk_edge_offset_on_body.html#documentation", "Each <B>point</B> on the edges will be offset within the", "PK Reference - PK_EDGE_offset_on_body");
top.note("headers/pk_edge_offset_on_body_r_t.html#documentation", " PK_offset_on_body_fail_c: A vertex or edge and a <B>point</B>", "PK Reference - PK_EDGE_offset_on_body_r_t");
top.note("headers/pk_edge_optimise_o_t.html#documentation", " is considered short, if no <B>point</B> on edge", "PK Reference - PK_EDGE_optimise_o_t");
top.note("headers/pk_edge_propagate_orientation.html#documentation", " edges in the wire body are made to <B>point</B> along the wire body in the same", "PK Reference - PK_EDGE_propagate_orientation");
top.note("headers/pk_edge_reset_precision.html#documentation", "<B>point</B> with all the other edge curves meeting there.", "PK Reference - PK_EDGE_reset_precision");
top.note("headers/pk_edge_reset_precision_2.html#documentation", "<B>point</B> with all the other edge curves meeting there.", "PK Reference - PK_EDGE_reset_precision_2");
top.note("headers/pk_edge_set_blend_chain_o_t.html#documentation", " between the contact <B>point</B> on that side and the blends apex.", "PK Reference - PK_EDGE_set_blend_chain_o_t");
top.note("headers/pk_edge_set_precision.html#documentation", " The <B>point</B> on the vertex will be recomputed.", "PK Reference - PK_EDGE_set_precision");
top.note("headers/pk_edge_set_precision_2.html#documentation", " The <B>point</B> on the vertex will be recomputed.", "PK Reference - PK_EDGE_set_precision_2");
top.note("headers/pk_edge_split_at_param.html#errors", " a <B>point</B> coincident with edge", "PK Reference - PK_EDGE_split_at_param");
top.note("headers/pk_entity_check_attribs_o_t.html#documentation", " |- <B>POINT</B> |", "PK Reference - PK_ENTITY_check_attribs_o_t");
top.note("headers/pk_entity_copy.html#documentation", "Surface, Curve, <B>Point</B>:", "PK Reference - PK_ENTITY_copy");
top.note("headers/pk_entity_copy_2.html#documentation", "assembly; instance; body; surface; curve; <B>point</B>; transformation and group", "PK Reference - PK_ENTITY_copy_2");
top.note("headers/pk_entity_range_end_t.html#documentation", " | <B>point</B> | none | none |", "PK Reference - PK_ENTITY_range_end_t");
top.note("headers/pk_face_attach_surfs.html#documentation", " `senses[i] is PK_LOGICAL_true then the face normal will <B>point</B> in the", "PK Reference - PK_FACE_attach_surfs");
top.note("headers/pk_face_boolean.html#documentation", " to specify a <B>point</B> and a face. The <B>point</B>", "PK Reference - PK_FACE_boolean");
top.note("headers/pk_face_boolean_2.html#documentation", " to specify a <B>point</B> and a face. The <B>point</B>", "PK Reference - PK_FACE_boolean_2");
top.note("headers/pk_face_boolean_o_t.html#documentation", " merge event from the <B>point</B> of view of attribute", "PK Reference - PK_FACE_boolean_o_t");
top.note("headers/pk_face_change_data_radiate_t.html#documentation", " radial_displacement Each <B>point</B> on the surface of the face is translated", "PK Reference - PK_FACE_change_data_radiate_t");
top.note("headers/pk_face_change_o_t.html#documentation", " vertex <B>point</B> replacements. Refer to its documentation", "PK Reference - PK_FACE_change_o_t");
top.note("headers/pk_face_check_pair.html#documentation", "PK_FACE_state_bad_face_face_c | face | face | <B>point</B> in region of", "PK Reference - PK_FACE_check_pair");
top.note("headers/pk_face_coi_t.html#documentation", " <B>point</B> on the boundary of face No. 1 is", "PK Reference - PK_FACE_coi_t");
top.note("headers/pk_face_emboss.html#documentation", " sheet profile, overall face normals are expected to <B>point</B>", "PK Reference - PK_FACE_emboss");
top.note("headers/pk_face_find_extreme.html#declaration", " PK_VECTOR_t *const extreme, --- position of extreme <B>point</B>", "PK Reference - PK_FACE_find_extreme");
top.note("headers/pk_face_find_extreme.html#description", " This function finds the extreme <B>point</B> on the given face in direction_1 .", "PK Reference - PK_FACE_find_extreme");
top.note("headers/pk_face_find_extreme.html#errors", " PK_ERROR_cant_find_extreme failed to find extreme <B>point</B> (MILD)", "PK Reference - PK_FACE_find_extreme");
top.note("headers/pk_face_hollow.html#documentation", " an edge can offset to a <B>point</B> or a face can become absorbed into", "PK Reference - PK_FACE_hollow");
top.note("headers/pk_face_hollow_2.html#documentation", " an edge can offset to a <B>point</B> or a face can become absorbed into", "PK Reference - PK_FACE_hollow_2");
top.note("headers/pk_face_imprint_curves_isocline.html#documentation", "a <B>point</B> on the actual geometry may deviate from its", "PK Reference - PK_FACE_imprint_curves_isocline");
top.note("headers/pk_face_imprint_cus_isoclin.html#documentation", "a <B>point</B> on the actual geometry may deviate from its", "PK Reference - PK_FACE_imprint_cus_isoclin");
top.note("headers/pk_face_imprint_cus_normal_o_t.html#documentation", " will be trimmed at the <B>point</B> of self-intersection.", "PK Reference - PK_FACE_imprint_cus_normal_o_t");
top.note("headers/pk_face_imprint_cus_vec_o_t.html#documentation", " will be trimmed at the <B>point</B> of self-intersection.", "PK Reference - PK_FACE_imprint_cus_vec_o_t");
top.note("headers/pk_face_imprint_faces_o_t.html#documentation", " will be trimmed at the <B>point</B> of self-intersection.", "PK Reference - PK_FACE_imprint_faces_o_t");
top.note("headers/pk_face_imprint_o_t.html#documentation", " will be trimmed at the <B>point</B> of self-intersection.", "PK Reference - PK_FACE_imprint_o_t");
top.note("headers/pk_face_imprint_point.html#declaration", " PK_POINT_t <B>point</B>, --- <B>point</B> to imprint onto face", "PK Reference - PK_FACE_imprint_point");
top.note("headers/pk_face_imprint_point.html#description", " This function imprints a <B>point</B> onto a face, thereby creating a new vertex.", "PK Reference - PK_FACE_imprint_point");
top.note("headers/pk_face_imprint_point.html#documentation", "general body. If <B>point</B> was an orphan then it will be attached", "PK Reference - PK_FACE_imprint_point");
top.note("headers/pk_face_install_surfs_isocline.html#documentation", "a <B>point</B> on the actual geometry may deviate from its", "PK Reference - PK_FACE_install_surfs_isocline");
top.note("headers/pk_face_instance_bodies_o_t.html#documentation", " trimmed at the <B>point</B> of self-intersection.", "PK Reference - PK_FACE_instance_bodies_o_t");
top.note("headers/pk_face_intersect_curve.html#documentation", " surface of the face intersect in a single <B>point</B>", "PK Reference - PK_FACE_intersect_curve");
top.note("headers/pk_face_intersect_face.html#declaration", " int *const n_vectors, --- number of <B>point</B> intersections", "PK Reference - PK_FACE_intersect_face");
top.note("headers/pk_face_intersect_face.html#documentation", " make <B>point</B> contact. n_vectors indicates the number of intersection points.", "PK Reference - PK_FACE_intersect_face");
top.note("headers/pk_face_intersect_face_o_t.html#documentation", " The option vector enables a <B>point</B> on a branch of the intersection to be", "PK Reference - PK_FACE_intersect_face_o_t");
top.note("headers/pk_face_intersect_surf.html#declaration", " int *const n_vectors, --- number of <B>point</B> intersections", "PK Reference - PK_FACE_intersect_surf");
top.note("headers/pk_face_intersect_surf.html#documentation", " and face make <B>point</B> contact. n_vectors indicates the number of intersection", "PK Reference - PK_FACE_intersect_surf");
top.note("headers/pk_face_intersect_surf_o_t.html#documentation", " The option vector enables a <B>point</B> on a branch of the intersection to be", "PK Reference - PK_FACE_intersect_surf_o_t");
top.note("headers/pk_face_is_coincident.html#declaration", " PK_VECTOR_t *const <B>point</B> --- non-coincidence <B>point</B>", "PK Reference - PK_FACE_is_coincident");
top.note("headers/pk_face_is_coincident.html#documentation", "position vector is returned in <B>point</B> indicating where the faces are", "PK Reference - PK_FACE_is_coincident");
top.note("headers/pk_face_is_periodic.html#documentation", " the parameter can be completed at the same <B>point</B> at", "PK Reference - PK_FACE_is_periodic");
top.note("headers/pk_face_make_3_face_blend_o_t.html#declaration", " --- whether help <B>point</B> is provided", "PK Reference - PK_FACE_make_3_face_blend_o_t");
top.note("headers/pk_face_make_3_face_blend_o_t.html#documentation", " have_help_point Whether a help <B>point</B> is provided.", "PK Reference - PK_FACE_make_3_face_blend_o_t");
top.note("headers/pk_face_make_blend_o_t.html#declaration", " --- whether help <B>point</B> is provided", "PK Reference - PK_FACE_make_blend_o_t");
top.note("headers/pk_face_make_blend_o_t.html#documentation", " have_help_point Whether a help <B>point</B> is provided", "PK Reference - PK_FACE_make_blend_o_t");
top.note("headers/pk_face_make_neutral_sheet_2.html#documentation", " will be created such that each <B>point</B> on it satisfies the following", "PK Reference - PK_FACE_make_neutral_sheet_2");
top.note("headers/pk_face_offset.html#documentation", " can offset to a <B>point</B> or a face can become absorbed into the", "PK Reference - PK_FACE_offset");
top.note("headers/pk_face_replace_surfs_o_t.html#documentation", " vertex <B>point</B> replacements. Refer to its documentation", "PK Reference - PK_FACE_replace_surfs_o_t");
top.note("headers/pk_face_taper.html#documentation", "a <B>point</B> on the actual geometry may deviate from its", "PK Reference - PK_FACE_taper");
top.note("headers/pk_facet_pt_report_t.html#documentation", "<B>point</B> lies off model topology. It has the following", "PK Reference - PK_facet_pt_report_t");
top.note("headers/pk_fill_hole_point_data_t.html#description", " This structure holds controls for supplying <B>point</B> data to a", "PK Reference - PK_fill_hole_point_data_t");
top.note("headers/pk_fill_hole_point_data_t.html#documentation", "The <B>point</B> data structure has the following fields.", "PK Reference - PK_fill_hole_point_data_t");
top.note("headers/pk_fin_ask_geometry.html#documentation", "both ends are returned as the periodic seam <B>point</B>, and t_int , if", "PK Reference - PK_FIN_ask_geometry");
top.note("headers/pk_fin_euler_glue.html#documentation", " second edge are all inserted at the same <B>point</B> in the cyclic", "PK Reference - PK_FIN_euler_glue");
top.note("headers/pk_fin_find_curve_parameter.html#declaration", "double t_est, --- estimate of parameter <B>point</B> t ", "PK Reference - PK_FIN_find_curve_parameter");
top.note("headers/pk_fin_find_mtopols.html#documentation", " also returned which is PK_LOGICAL_true if the mfins <B>point</B> in the same", "PK Reference - PK_FIN_find_mtopols");
top.note("headers/pk_fxf_fault_t.html#documentation", " and the <B>point</B> at which they clashed.", "PK Reference - PK_fxf_fault_t");
top.note("headers/pk_geom_category_t.html#documentation", "classic geometry and lattice, <B>point</B> or absent geometry is considered to be", "PK Reference - PK_GEOM_category_t");
top.note("headers/pk_geom_check_o_t.html#documentation", " Position : A <B>point</B> from the intersecting region", "PK Reference - PK_GEOM_check_o_t");
top.note("headers/pk_geom_range.html#documentation", " - <B>point</B>, curve, and surface.", "PK Reference - PK_GEOM_range");
top.note("headers/pk_geom_range_array.html#documentation", " | <B>point</B> | none | none |", "PK Reference - PK_GEOM_range_array");
top.note("headers/pk_geom_range_array_vector.html#documentation", " | <B>point</B> | none | none |", "PK Reference - PK_GEOM_range_array_vector");
top.note("headers/pk_geom_range_local.html#documentation", " | <B>point</B> | none | none |", "PK Reference - PK_GEOM_range_local");
top.note("headers/pk_geom_range_local_vector.html#documentation", " | <B>point</B> | none | none |", "PK Reference - PK_GEOM_range_local_vector");
top.note("headers/pk_geom_range_vector.html#documentation", " | <B>point</B> | none | none |", "PK Reference - PK_GEOM_range_vector");
top.note("headers/pk_geom_range_vector_many.html#documentation", " | <B>point</B> | none | none |", "PK Reference - PK_GEOM_range_vector_many");
top.note("headers/pk_geom_t.html#documentation", " - PK_POINT_t : a <B>point</B>", "PK Reference - PK_GEOM_t");
top.note("headers/pk_geom_transform.html#documentation", " in_geom is a <B>point</B> then out_geom is a <B>point</B>.", "PK Reference - PK_GEOM_transform");
top.note("headers/pk_geom_transform_2.html#documentation", " of geometry in the array in_geoms is a <B>point</B> or lattice then the", "PK Reference - PK_GEOM_transform_2");
top.note("headers/pk_gosgmt_f_t.html#documentation", " start <B>point</B>, end <B>point</B>, line direction.", "PK Reference - PK_GOSGMT_f_t");
top.note("headers/pk_hole_component_t.html#documentation", " distance from the holes axis to the extreme <B>point</B> on", "PK Reference - PK_hole_component_t");
top.note("headers/pk_instance_change_part.html#declaration", " PK_PART_t part --- part to <B>point</B> to", "PK Reference - PK_INSTANCE_change_part");
top.note("headers/pk_intersect_fc_t.html#documentation", " single <B>point</B> but does not pass through it.", "PK Reference - PK_intersect_fc_t");
top.note("headers/pk_lattice_clip.html#documentation", "partition, every <B>point</B> in a particular portion of the nabox must", "PK Reference - PK_LATTICE_clip");
top.note("headers/pk_line_sf_t.html#declaration", " PK_AXIS1_sf_t basis_set; --- a cartesian <B>point</B> and a direction", "PK Reference - PK_LINE_sf_t");
top.note("headers/pk_local_status_t.html#documentation", " PK_local_status_point_contact_c <B>point</B> contact found in sheet body", "PK Reference - PK_local_status_t");
top.note("headers/pk_measure_t.html#documentation", " the start <B>point</B> to the end <B>point</B> of the", "PK Reference - PK_measure_t");
top.note("headers/pk_mfacet_find_perimeters.html#documentation", "mloop may <B>point</B> to the same mvertex. See here for more", "PK Reference - PK_MFACET_find_perimeters");
top.note("headers/pk_mvertex_ask_normals.html#documentation", "for all of the mfins which <B>point</B> at that mvertex. In the case of any", "PK Reference - PK_MVERTEX_ask_normals");
top.note("headers/pk_neutral_method_t.html#documentation", " neutral surface such that each <B>point</B> on it", "PK Reference - PK_neutral_method_t");
top.note("headers/pk_offset_sf_t.html#documentation", "from the underlying surface by adding to each <B>point</B> on it the unit normal", "PK Reference - PK_OFFSET_sf_t");
top.note("headers/pk_part_add_geoms.html#errors", " curve or <B>point</B>", "PK Reference - PK_PART_add_geoms");
top.note("headers/pk_part_delete_attribs_o_t.html#documentation", " all lattice, surface, curve and <B>point</B> entities.", "PK Reference - PK_PART_delete_attribs_o_t");
top.note("headers/pk_partition_ask_facet_geom.html#documentation", "This function returns partition categories of none, <B>point</B>, classic, facet,", "PK Reference - PK_PARTITION_ask_facet_geom");
top.note("headers/pk_partition_receive_version.html#documentation", " build_number will be 0. Note that for most <B>point</B> releases of Parasolid, this", "PK Reference - PK_PARTITION_receive_version");
top.note("headers/pk_partition_receive_version_b.html#documentation", " build_number will be 0. Note that for most <B>point</B> releases of Parasolid, this", "PK Reference - PK_PARTITION_receive_version_b");
top.note("headers/pk_partition_receive_version_u.html#documentation", " build_number will be 0. Note that for most <B>point</B> releases of Parasolid, this", "PK Reference - PK_PARTITION_receive_version_u");
top.note("headers/pk_plane_sf_t.html#declaration", " PK_AXIS2_sf_t basis_set; --- <B>point</B>, normal, drn of constant v lines", "PK Reference - PK_PLANE_sf_t");
top.note("headers/pk_point_ask.html#declaration", " PK_POINT_t <B>point</B>, --- <B>point</B>", "PK Reference - PK_POINT_ask");
top.note("headers/pk_point_ask_part.html#declaration", " PK_POINT_t <B>point</B>, --- a <B>point</B>", "PK Reference - PK_POINT_ask_part");
top.note("headers/pk_point_ask_part.html#description", " function returns the part which owns the given <B>point</B>, if there is one,", "PK Reference - PK_POINT_ask_part");
top.note("headers/pk_point_ask_part.html#documentation", "The <B>point</B> may either be attached directly to a vertex", "PK Reference - PK_POINT_ask_part");
top.note("headers/pk_point_ask_vertex.html#declaration", " PK_POINT_t <B>point</B>, --- a <B>point</B>", "PK Reference - PK_POINT_ask_vertex");
top.note("headers/pk_point_ask_vertex.html#description", " function returns the vertex connected to the given <B>point</B>, if there is one,", "PK Reference - PK_POINT_ask_vertex");
top.note("headers/pk_point_create.html#declaration", " const PK_POINT_sf_t *point_sf, --- <B>point</B> standard form", "PK Reference - PK_POINT_create");
top.note("headers/pk_point_create.html#description", " This function creates a <B>point</B> from the given standard form. See", "PK Reference - PK_POINT_create");
top.note("headers/pk_point_make_helical_curve.html#declaration", " PK_POINT_t <B>point</B>, --- <B>point</B>", "PK Reference - PK_POINT_make_helical_curve");
top.note("headers/pk_point_make_helical_curve.html#description", " helix, tapered helix or spiral by sweeping a <B>point</B>", "PK Reference - PK_POINT_make_helical_curve");
top.note("headers/pk_point_make_helical_curve.html#documentation", "The <B>point</B> is swept around the axis to form a", "PK Reference - PK_POINT_make_helical_curve");
top.note("headers/pk_point_make_minimum_body.html#declaration", " PK_POINT_t <B>point</B>, --- <B>point</B>", "PK Reference - PK_POINT_make_minimum_body");
top.note("headers/pk_point_make_minimum_body.html#description", "given <B>point</B> .", "PK Reference - PK_POINT_make_minimum_body");
top.note("headers/pk_point_sf_t.html#description", " This is the standard form of a <B>POINT</B> which is located at the given position.", "PK Reference - PK_POINT_sf_t");
top.note("headers/pk_point_t.html#description", " This type represents a <B>POINT</B> in 3D space.", "PK Reference - PK_POINT_t");
top.note("headers/pk_point_t.html#documentation", "A <B>point</B> is a type of geometry (PK_CLASS_point is a", "PK Reference - PK_POINT_t");
top.note("headers/pk_proj_geom_t.html#documentation", " The projected geometry (either a curve or a <B>point</B>).", "PK Reference - PK_proj_geom_t");
top.note("headers/pk_proj_max_dist_t.html#documentation", " projection of any <B>point</B> of the originator", "PK Reference - PK_proj_max_dist_t");
top.note("headers/pk_proj_method_t.html#documentation", " normals. A given <B>point</B> on a curve is projected", "PK Reference - PK_proj_method_t");
top.note("headers/pk_proj_to_points_t.html#documentation", "This datatype controls the creation of <B>point</B> projections.", "PK Reference - PK_proj_to_points_t");
top.note("headers/pk_region_imprint_curve.html#documentation", " The position of the <B>point</B> of the single vertex of the body is", "PK Reference - PK_REGION_imprint_curve");
top.note("headers/pk_region_imprint_point.html#declaration", " PK_POINT_t <B>point</B>, --- <B>point</B> to imprint onto region", "PK Reference - PK_REGION_imprint_point");
top.note("headers/pk_region_imprint_point.html#description", " This function imprints a <B>point</B> onto a region, thereby creating a new acorn", "PK Reference - PK_REGION_imprint_point");
top.note("headers/pk_region_imprint_point.html#documentation", "shell will be created to contain it. If <B>point</B> was an orphan then it will be", "PK Reference - PK_REGION_imprint_point");
top.note("headers/pk_render_planar_t.html#documentation", " plane positions to a <B>point</B>", "PK Reference - PK_render_planar_t");
top.note("headers/pk_render_radial_t.html#documentation", " radial positions to a <B>point</B>", "PK Reference - PK_render_radial_t");
top.note("headers/pk_replace_help_points_t.html#declaration", " const PK_VECTOR_t *positions; --- help <B>point</B> positions (NULL)", "PK Reference - PK_replace_help_points_t");
top.note("headers/pk_replace_help_points_t.html#description", "structure. It contains the help <B>point</B> positions to be used to", "PK Reference - PK_replace_help_points_t");
top.note("headers/pk_report_1_t.html#documentation", " PK_REPORT_1_point_contact_c <B>point</B> contact found in sheet body", "PK Reference - PK_REPORT_1_t");
top.note("headers/pk_report_3_t.html#documentation", " an array of 3 doubles indicating the limit <B>point</B> on this edge.", "PK Reference - PK_REPORT_3_t");
top.note("headers/pk_report_record_1_t.html#documentation", " PK_REPORT_1_point_contact_c : 1 VERTEX Vertex where <B>point</B> contact has", "PK Reference - PK_REPORT_record_1_t");
top.note("headers/pk_session_register_fru_o_t.html#documentation", " To unregister a Frustrum function, its field should <B>point</B> to", "PK Reference - PK_SESSION_register_fru_o_t");
top.note("headers/pk_session_start.html#documentation", " would affect Parasolid (e.g. the format of floating <B>point</B> numbers or the", "PK Reference - PK_SESSION_start");
top.note("headers/pk_surf_create_blend.html#declaration", " PK_VECTOR_t start, --- help <B>point</B> for start", "PK Reference - PK_SURF_create_blend");
top.note("headers/pk_surf_eval.html#declaration", " PK_VECTOR_t p[] --- <B>point</B> and derivatives", "PK Reference - PK_SURF_eval");
top.note("headers/pk_surf_eval.html#description", " This function evaluates a <B>point</B> and derivatives at a parameter pair on", "PK Reference - PK_SURF_eval");
top.note("headers/pk_surf_eval.html#documentation", "The function calculates the cartesian coordinates of the <B>point</B> at the", "PK Reference - PK_SURF_eval");
top.note("headers/pk_surf_eval_grid.html#documentation", " p[0] is the <B>point</B> evaluated at u[0], v[0]", "PK Reference - PK_SURF_eval_grid");
top.note("headers/pk_surf_eval_handed.html#declaration", " PK_VECTOR_t p[] --- <B>point</B> and derivatives", "PK Reference - PK_SURF_eval_handed");
top.note("headers/pk_surf_eval_handed.html#documentation", " the handed version of PK_SURF_eval which evaluates a <B>point</B> and", "PK Reference - PK_SURF_eval_handed");
top.note("headers/pk_surf_eval_with_normal.html#declaration", " PK_VECTOR_t p[], --- <B>point</B> and derivatives", "PK Reference - PK_SURF_eval_with_normal");
top.note("headers/pk_surf_eval_with_normal.html#description", " This function evaluates a <B>point</B>, derivatives and normal at a parameter pair", "PK Reference - PK_SURF_eval_with_normal");
top.note("headers/pk_surf_eval_with_normal.html#documentation", " be returned for normal even at a singular <B>point</B> of the surface.", "PK Reference - PK_SURF_eval_with_normal");
top.note("headers/pk_surf_eval_with_normal_handed.html#declaration", " PK_VECTOR_t p[], --- <B>point</B> and derivatives", "PK Reference - PK_SURF_eval_with_normal_handed");
top.note("headers/pk_surf_eval_with_normal_handed.html#documentation", "<B>point</B>, derivatives and normal at a parameter pair on", "PK Reference - PK_SURF_eval_with_normal_handed");
top.note("headers/pk_surf_extend_o_t.html#declaration", " PK_VECTOR_t extension_point; --- <B>point</B> to extend to", "PK Reference - PK_SURF_extend_o_t");
top.note("headers/pk_surf_extend_o_t.html#documentation", " extension_point A three-space <B>point</B> to extend the surface to. This field", "PK Reference - PK_SURF_extend_o_t");
top.note("headers/pk_surf_find_vectors_o_t.html#documentation", " The \"start <B>point</B>\" of the path curve is the position vector", "PK Reference - PK_SURF_find_vectors_o_t");
top.note("headers/pk_surf_fix_self_int_o_t.html#documentation", " surface(s) will include the <B>point</B> at parameters uv_param ", "PK Reference - PK_SURF_fix_self_int_o_t");
top.note("headers/pk_surf_general_eval_f_t.html#declaration", " double *const p --- <B>point</B> and derivatives", "PK Reference - PK_SURF_general_eval_f_t");
top.note("headers/pk_surf_general_eval_f_t.html#documentation", " function calculates the model space coordinates of the <B>point</B> at the", "PK Reference - PK_SURF_general_eval_f_t");
top.note("headers/pk_surf_intersect_surf.html#declaration", " int *const n_vectors, --- number of <B>point</B> intersections", "PK Reference - PK_SURF_intersect_surf");
top.note("headers/pk_surf_intersect_surf.html#documentation", " make <B>point</B> contact. n_vectors indicates the number of intersection points.", "PK Reference - PK_SURF_intersect_surf");
top.note("headers/pk_surf_intersect_surf_o_t.html#documentation", " The option vector enables a <B>point</B> on a branch of the intersection to be", "PK Reference - PK_SURF_intersect_surf_o_t");
top.note("headers/pk_surf_make_curves_isocline.html#documentation", " upper bound on the distance by which a <B>point</B> on the", "PK Reference - PK_SURF_make_curves_isocline");
top.note("headers/pk_surf_make_cus_isocline.html#documentation", " upper bound on the distance by which a <B>point</B> on the", "PK Reference - PK_SURF_make_cus_isocline");
top.note("headers/pk_surf_make_sheet_trimmed.html#documentation", " centroid <B>point</B> of all the trimmed curve ends meeting at", "PK Reference - PK_SURF_make_sheet_trimmed");
top.note("headers/pk_surf_offset.html#documentation", "with that obtained by adding to each <B>point</B> on the underlying_surf ", "PK Reference - PK_SURF_offset");
top.note("headers/pk_surf_parameterise_vector.html#description", " Find parameters of a <B>point</B> on a surface", "PK Reference - PK_SURF_parameterise_vector");
top.note("headers/pk_surf_parameterise_vector.html#documentation", "Returns the parameters of the given <B>point</B>, provided that it lies on the", "PK Reference - PK_SURF_parameterise_vector");
top.note("headers/pk_sweep_guide_control_t.html#documentation", " should be specified which indicates the <B>point</B> on the guide", "PK Reference - PK_sweep_guide_control_t");
top.note("headers/pk_sweep_guide_method_t.html#documentation", " scaled, such that the <B>point</B> located at one of", "PK Reference - PK_sweep_guide_method_t");
top.note("headers/pk_sweep_tool_fault_t.html#documentation", " at some <B>point</B>", "PK Reference - PK_sweep_tool_fault_t");
top.note("headers/pk_taper_method_t.html#documentation", " is that from a <B>point</B> on the reference edges", "PK Reference - PK_taper_method_t");
top.note("headers/pk_topol_categorise_geom.html#documentation", "This function returns categories of none, <B>point</B>, classic, facet, and mixed.", "PK Reference - PK_TOPOL_categorise_geom");
top.note("headers/pk_topol_clash.html#documentation", "Two entities interfere if there exists a <B>point</B> in space which lies", "PK Reference - PK_TOPOL_clash");
top.note("headers/pk_topol_eval_mass_props.html#documentation", " (a vertex with density is regarded as a <B>point</B> mass, so the", "PK Reference - PK_TOPOL_eval_mass_props");
top.note("headers/pk_topol_facet_choice_o_t.html#documentation", "The tables of facet vertex data <B>point</B> to tables of coordinate, parameter", "PK Reference - PK_TOPOL_facet_choice_o_t");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#documentation", " every <B>point</B> is backwards facing. If a face cannot quickly", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#documentation", " every <B>point</B> is backwards facing. If a face cannot quickly", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_fctab_data_point_t.html#declaration", " int *<B>point</B>;", "PK Reference - PK_TOPOL_fctab_data_point_t");
top.note("headers/pk_topol_fctab_data_point_t.html#documentation", "which maps data indices into a table of <B>point</B> indices.", "PK Reference - PK_TOPOL_fctab_data_point_t");
top.note("headers/pk_topol_fctab_error_object_t.html#documentation", " PK_facet_fault_pt_off_edge_0_c The facet <B>point</B> associated with the specified", "PK Reference - PK_TOPOL_fctab_error_object_t");
top.note("headers/pk_topol_fctab_fin_data_t.html#documentation", "together the <B>point</B>, normal, parameter, derivative and curvature information at", "PK Reference - PK_TOPOL_fctab_fin_data_t");
top.note("headers/pk_topol_fctab_point_topol_t.html#declaration", " int <B>point</B>;", "PK Reference - PK_TOPOL_fctab_point_topol_t");
top.note("headers/pk_topol_fctab_point_topol_t.html#documentation", "which maps facet <B>point</B> indices on face boundaries to their associated model", "PK Reference - PK_TOPOL_fctab_point_topol_t");
top.note("headers/pk_topol_fctab_vertex_point_t.html#declaration", " int *<B>point</B>;", "PK Reference - PK_TOPOL_fctab_vertex_point_t");
top.note("headers/pk_topol_fctab_vertex_point_t.html#documentation", "into a table of <B>point</B> indices (geometry).", "PK Reference - PK_TOPOL_fctab_vertex_point_t");
top.note("headers/pk_topol_local_r_t.html#documentation", " PK_local_status_point_contact_c : 1 VERTEX Vertex where <B>point</B> contact has", "PK Reference - PK_TOPOL_local_r_t");
top.note("headers/pk_topol_range.html#documentation", " (ie. it is possible to move from solution <B>point</B>", "PK Reference - PK_TOPOL_range");
top.note("headers/pk_topol_range_array.html#documentation", " (ie. it is possible to move from solution <B>point</B>", "PK Reference - PK_TOPOL_range_array");
top.note("headers/pk_topol_range_array_vector.html#documentation", " a <B>point</B> on the geometric entity that the solution was", "PK Reference - PK_TOPOL_range_array_vector");
top.note("headers/pk_topol_range_geom.html#documentation", " - geom : <B>point</B>, curve, surface.", "PK Reference - PK_TOPOL_range_geom");
top.note("headers/pk_topol_range_geom_array.html#documentation", " - geoms : <B>point</B>, curve and, surface.", "PK Reference - PK_TOPOL_range_geom_array");
top.note("headers/pk_topol_range_local.html#documentation", " (ie. it is possible to move from solution <B>point</B>", "PK Reference - PK_TOPOL_range_local");
top.note("headers/pk_topol_range_local_vector.html#documentation", " a <B>point</B> on the geometric entity that the solution was", "PK Reference - PK_TOPOL_range_local_vector");
top.note("headers/pk_topol_range_vector.html#documentation", " a <B>point</B> on the geometric entity that the solution was", "PK Reference - PK_TOPOL_range_vector");
top.note("headers/pk_topol_render_volume.html#documentation", " the GO. The normals will be oriented to <B>point</B> out of", "PK Reference - PK_TOPOL_render_volume");
top.note("headers/pk_torus_sf_t.html#documentation", " singular <B>point</B>, on its axis of rotation.", "PK Reference - PK_TORUS_sf_t");
top.note("headers/pk_vector_transform.html#declaration", " PK_VECTOR_t p, --- original <B>point</B>", "PK Reference - PK_VECTOR_transform");
top.note("headers/pk_vertex_ask_point.html#declaration", " PK_POINT_t *const <B>point</B> --- its <B>point</B> (possibly PK_ENTITY_null)", "PK Reference - PK_VERTEX_ask_point");
top.note("headers/pk_vertex_ask_point.html#description", " This function returns the <B>point</B> at the given vertex, if one exists, otherwise", "PK Reference - PK_VERTEX_ask_point");
top.note("headers/pk_vertex_attach_points.html#errors", " PK_ERROR_has_parent <B>point</B> is already attached", "PK Reference - PK_VERTEX_attach_points");
top.note("headers/pk_vertex_attach_points.html#documentation", "Points may not be shared. No <B>point</B> may belong to a different body.", "PK Reference - PK_VERTEX_attach_points");
top.note("headers/pk_vertex_optimise.html#documentation", " distance to the closest <B>point</B> on the curve.", "PK Reference - PK_VERTEX_optimise");
top.note("headers/pk_vertex_set_precision.html#documentation", "of uncertainty around the <B>point</B> of the vertex. Setting the precision", "PK Reference - PK_VERTEX_set_precision");
top.note("chapters/di_chap.03.html#50511935_pgfId-274183", " by a floating <B>point</B> representation (with a decimal <B>point</B>) or an exponent and mantissa representation (with an", "Downward Interfaces - File Handling");
top.note("chapters/di_chap.05.html#50511937_marker-320923", "<B>point</B> indices . These are output only when the", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274406", " start <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274410", " end <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274427", " center <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274447", " center <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274459", " start <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274463", " end <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274475", " center <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274503", " center <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274523", " start <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274527", " end <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274539", " start <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274543", " second <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274547", " nth <B>point</B>, where i = 3(n-1) ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-335251", " center <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-335337", " start <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-335341", " end <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-335415", " start <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-335419", " end <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-274953", " contains <B>point</B> indices, as for edges. ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275031", " left of the segment after the first transition <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275032", " right of the segment after the first transition <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275033", " left of the segment after the second transition <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275034", " left of the segment after the nth transition <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275035", " right of the segment after the nth transition <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-324871", ", holds the <B>point</B> indices for the visibility transition points if regional", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275202", " polyline is equal to the distance between the <B>point</B> and the start measured along the polyline, divided", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275203", " the polyline on which the associated visibility transition <B>point</B> lies. ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275217", "t measured from the <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275224", " Given a visibility transition <B>point</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275312", " data is of two types: adjacent faces, and <B>point</B> indices. ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275318", " the line, which is required to interpret the <B>point</B> indices correctly: ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275321", " 4.5.2 <B>Point</B> indices ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275323", " of B should be regarded as the same <B>point</B> in the two-dimensional picture, ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.06.html#50511938_pgfId-274000", " types (e.g. for endian byte ordering and floating <B>point</B> representation). The read functions must be handed the", "Downward Interfaces - Registering the Frustrum");
top.note("chapters/di_chap.18.html#50511950_pgfId-731248", " <B>Point</B> Indices 54 ", "Downward Interfaces - ZIndex");
top.note("chapters/di_chap.18.html#50511950_pgfId-731267", " <B>point</B> indices 37, 54 ", "Downward Interfaces - ZIndex");
top.note("chapters/di_chap.18.html#50511950_pgfId-731323", " <B>point</B> indices 37 ", "Downward Interfaces - ZIndex");
top.note("chapters/kd_chap.02.html#50475009_pgfId-273942", " may simply be a set of geometric data (<B>point</B>, direction, radius, etc.) or it may also include", "KID Manual - Kernel Interface Driver (KID) - an Overview");
top.note("chapters/kd_chap.04.html#50475012_pgfId-273861", " graphical pick is made with the cursor, a <B>point</B> and a direction are recorded. These vectors are", "KID Manual - Object-Oriented KID");
top.note("chapters/kd_chap.05.html#50475010_pgfId-281034", " numeric atom without decimal <B>point</B> ", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.05.html#50475010_pgfId-281038", " numeric atom with or without decimal <B>point</B> ", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.06.html#50475013_pgfId-273845", "<B>point</B> ", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-281381", "> (b1 radius 20; <B>point</B> (10 10 10); create", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-281301", "> ( bar height 30; radius 5; <B>point</B> ( cube top ); create ) ", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-273896", " parameters are sides, radius, height (mandatory) <B>point</B>, direction (default table). The radius may be omitted", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-273906", " can create a minimum body from a single <B>point</B>, a wire body from a list of unconnected", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-281200", "> (( define c0 p_line ) <B>point</B> ( 0 0 0 ); ", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-281162", "> (c1 <B>point</B> (3 2 0)) -- center of circle", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-281128", "> (c2 <B>point</B> (0 10 0)) -- center of ellipse", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-281096", " > (( define c0 p_line ) <B>point</B> ( 0 0 0 ); ", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-281068", "> (s1 <B>point</B> (0 0 0); direction (1 0 0))", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-281047", " > (( define c0 p_line ) <B>point</B> ( 0 0 0 ); ", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-281039", " > (( define c0 p_line ) <B>point</B> ( 0 0 0 ); ", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-281030", " > (( define s0 p_planar ) <B>point</B> (0 0 0); ", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-280992", " > (( define s0 p_planar ) <B>point</B> ( 0 0 0 ); ", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-280912", " <B>point</B> ( 11 0 0 ); normal ( 1", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.06.html#50475013_pgfId-280878", "> (( define t0 p_rotation ) <B>point</B> ( 11 0 0 ); ", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.07.html#50475033_pgfId-273963", " are direction, <B>point</B> and angle, all are required. ", "KID Manual - Operations on Bodies, Curves, Surfaces, etc.");
top.note("chapters/kd_chap.07.html#50475033_pgfId-283568", " > (b3 <B>point</B> (0 0 0); direction (1 0 0) ;", "KID Manual - Operations on Bodies, Curves, Surfaces, etc.");
top.note("chapters/kd_chap.07.html#50475033_pgfId-274204", " a <B>point</B> on the direction axis, and ", "KID Manual - Operations on Bodies, Curves, Surfaces, etc.");
top.note("chapters/kd_chap.07.html#50475033_pgfId-282665", "> (b2 <B>point</B> (0 0 0); direction (0 0 1); angle", "KID Manual - Operations on Bodies, Curves, Surfaces, etc.");
top.note("chapters/kd_chap.07.html#50475033_pgfId-282642", "> (b3 <B>point</B> (0 0 0 ); direction (0 0 1);", "KID Manual - Operations on Bodies, Curves, Surfaces, etc.");
top.note("chapters/kd_chap.08.html#50475021_pgfId-279691", "> (b2 radius 1; height 10; <B>point</B> (0 5 5); ", "KID Manual - Local Operation Functions");
top.note("chapters/kd_chap.08.html#50475021_marker-273904", " and conical surfaces. It has taper properties of <B>point</B>, direction and angle, which define the taper plane", "KID Manual - Local Operation Functions");
top.note("chapters/kd_chap.08.html#50475021_pgfId-273908", " degrees about a taper plane, defined by the <B>point</B> and direction parameters: ", "KID Manual - Local Operation Functions");
top.note("chapters/kd_chap.08.html#50475021_pgfId-279628", " > ( f1 <B>point</B> (0 0 10); direction (0 0 1); angle", "KID Manual - Local Operation Functions");
top.note("chapters/kd_chap.10.html#50475015_pgfId-273858", " if the curve is a circle, the center <B>point</B>, axis and radius are printed out. ", "KID Manual - Enquiries");
top.note("chapters/kd_chap.10.html#50475015_pgfId-280123", " > (c1 enquire <B>point</B>) -->(0 0 0)", "KID Manual - Enquiries");
top.note("chapters/kd_chap.10.html#50475015_pgfId-280087", " leave only those faces which clash with this <B>point</B> f1", "KID Manual - Enquiries");
top.note("chapters/kd_chap.10.html#50475015_pgfId-273952", " faces, edges and vertices. For a single vertex <B>point</B>, the box extremes are identical. ", "KID Manual - Enquiries");
top.note("chapters/kd_chap.10.html#50475015_pgfId-273964", " 9.6 Enquiring on a supplied <B>point</B>", "KID Manual - Enquiries");
top.note("chapters/kd_chap.10.html#50475015_pgfId-273968", " provides a means of testing whether a supplied <B>point</B> is contained in, on or outside a body,", "KID Manual - Enquiries");
top.note("chapters/kd_chap.13.html#50475017_pgfId-280818", " -- view from specified <B>point</B> ", "KID Manual - Viewing Environment and Definition");
top.note("chapters/kd_chap.13.html#50475017_pgfId-273870", " <B>point</B> to the ", "KID Manual - Viewing Environment and Definition");
top.note("chapters/kd_chap.13.html#50475017_pgfId-273955", " They rotate the viewing direction and the from <B>point</B> about the image by the given amount. The", "KID Manual - Viewing Environment and Definition");
top.note("chapters/kd_chap.14.html#50475018_pgfId-286660", "((define c0 p_cylinder) height 20; <B>point</B> (0 0 5); ", "KID Manual - KID Rendering");
top.note("chapters/kd_chap.15.html#50475034_pgfId-273900", " in model space), the nearest entity to that <B>point</B> in the current view direction is picked. Only", "KID Manual - Picking");
top.note("chapters/kd_chap.15.html#50475034_pgfId-273904", " of use could be applied when an eye <B>point</B> and view direction are already known, for example", "KID Manual - Picking");
top.note("chapters/kd_chap.15.html#50475034_pgfId-280325", " contain the <B>point</B> (0 0 0) i.e. 1 tag only", "KID Manual - Picking");
top.note("chapters/kd_chap.15.html#50475034_pgfId-280269", "> (f1 pick_using (equal (f1 enquire <B>point</B>) (0.0 0.0 0.0)))", "KID Manual - Picking");
top.note("chapters/kd_chap.15.html#50475034_pgfId-280245", "> (s1 <B>point</B> (0 0 50); direction (0 0 1); create)", "KID Manual - Picking");
top.note("chapters/kd_chap.15.html#50475034_pgfId-280190", " leave only those faces which clash with this <B>point</B>,", "KID Manual - Picking");
top.note("chapters/kd_chap.17.html#50475020_pgfId-274284", " solid modeller. It contains everything from a single <B>point</B> to an assembly. Functions to modify or remove", "KID Manual - KID Class Structure");
top.note("chapters/kd_chap.17.html#50475020_pgfId-290654", " closest approach to <B>point</B> or entity ", "KID Manual - KID Class Structure");
top.note("chapters/kd_chap.17.html#50475020_pgfId-291610", " <B>point</B> ", "KID Manual - KID Class Structure");
top.note("chapters/kd_chap.17.html#50475020_pgfId-291614", " vertex to which <B>point</B> is attached ", "KID Manual - KID Class Structure");
top.note("chapters/kd_chap.17.html#50475020_pgfId-292000", " picks <B>point</B> sequence ", "KID Manual - KID Class Structure");
top.note("chapters/kd_chap.17.html#50475020_pgfId-276523", " eye <B>point</B> ", "KID Manual - KID Class Structure");
top.note("chapters/kd_chap.17.html#50475020_pgfId-276529", " view <B>point</B> ", "KID Manual - KID Class Structure");
top.note("chapters/kd_chap.21.html#50475022_pgfId-279829", "(blo x 5; y 5 ; z 5; <B>point</B> (15 30 -15); create)", "KID Manual - KID Examples");
top.note("chapters/kd_chap.21.html#50475022_pgfId-279871", "(c1 radius 10; height 80; <B>point</B> (-40 0 0); direction (1 0 0); create)", "KID Manual - KID Examples");
top.note("chapters/kd_chap.21.html#50475022_pgfId-279973", "(s1 radius 2; <B>point</B> (5 5 10); create)", "KID Manual - KID Examples");
top.note("chapters/kd_chap.21.html#50475022_pgfId-279976", " -- set modeller roll <B>point</B>", "KID Manual - KID Examples");
top.note("chapters/kd_chap.21.html#50475022_pgfId-279946", "(plin1 <B>point</B> (0 0 20); direction (1 0 0); create)", "KID Manual - KID Examples");
top.note("chapters/kd_chap.24.html#50475028_pgfId-36012", " enquiring on a supplied <B>point</B> ", "KID Manual - Machine Dependency in KID");
top.note("chapters/kd_chap.24.html#50475028_pgfId-36131", " on a supplied <B>point</B> ", "KID Manual - Machine Dependency in KID");
top.note("chapters/fg_chap.03.html#50462724_pgfId-281887", "3. It is at this <B>point</B> in the code that any validation of data", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.05.html#50462729_pgfId-274068", " the whole edge must degenerate to a <B>point</B>, ", "FG Manual - Geometric Restrictions");
top.note("chapters/in_chap.06.html#50520099_pgfId-290023", " Windows, the %P_SCHEMA% environment variable is assumed to <B>point</B> to a directory on an NTFS file system.", "Installation Notes - Using Parasolid");
top.note("chapters/in_chap.07.html#50520100_pgfId-325481", " Section 6.4, &#8220;Floating-<B>point</B> information&#8221; , describes platform-specific floating <B>point</B> information. ", "Installation Notes - Environment");
top.note("chapters/in_chap.07.html#50520100_pgfId-790015", " special pragma to avoid the use of &#8220;floating <B>point</B> contractions.&#8221; Do not use Visual Studio 2019 versions", "Installation Notes - Environment");
top.note("chapters/in_chap.07.html#50520100_pgfId-567793", " The <B>point</B> of overwriting the return address is that when", "Installation Notes - Environment");
top.note("chapters/in_chap.08.html#50520101_pgfId-278554", "Recommended floating <B>point</B> traps ", "Installation Notes - Floating-Point Traps");
top.display();
//-->
</SCRIPT>
</HEAD>
<BODY bgcolor=#FFFFFF link=#0F3A68 vlink=#878787 alink=#FF7600 leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
</BODY>
</HTML>
