<HTML>
<HEAD>
<LINK REL=STYLESHEET HREF=../ps_doc.css CHARSET=ISO-8859-1 TYPE=text/css>
<SCRIPT LANGUAGE="JavaScript">
<!--

top.note("chapters/fd_chap.003.html#50409782_pgfId-298429", " a 3-space <B>vector</B> with coordinate fields (3 doubles): ", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.003.html#50409782_pgfId-298441", " PK_VECTOR_t , but it must be a unit <B>vector</B> (enforced by argument checking) ", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.010.html#50409790_pgfId-294870", " and space for the knot <B>vector</B> is allocated by Parasolid. ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.011.html#50409791_pgfId-315343", " body you have already created, together with a <B>vector</B> path that defines the direction of the sweep.", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.018.html#50409799_pgfId-608628", " the knot <B>vector</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-309995", " specify the curve to be swept and the <B>vector</B> direction of the sweep. PK_SWEPT_ask returns the standard", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-310146", "R is a <B>vector</B> valued function of a parameter t. Surfaces have", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-310147", " two PK functions, PK_CURVE_ask_interval and PK_SURF_ask_uvbox . The <B>vector</B> valued functions ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-310287", "D is its direction (unit <B>vector</B>) and is specified using the ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-297938", "Y axis is given by the <B>vector</B> cross product of ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-298234", "Y axis is the <B>vector</B> product of the plane normal ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-298369", "Y axis is the <B>vector</B> cross product of the cylinder axis ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311139", "A is the cone axis (unit <B>vector</B>). ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-298567", "Y axis is the <B>vector</B> product of the ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311186", " A is the torus axis (unit <B>vector</B>), ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-298718", " The Y axis is the <B>vector</B> product of the torus axis ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_marker-311215", "Y axis is the <B>vector</B> product of the sphere axis A and the", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311443", " (unit <B>vector</B>). ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311550", "A is the spin axis direction (unit <B>vector</B>), where A is ", "Functional Description - Geometry");
top.note("chapters/fd_chap.019.html#50409800_pgfId-298590", " end (a natural end condition), specify a zero <B>vector</B> as the 2nd derivative at the corresponding position.", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300342", " be specified. This <B>vector</B> is called a twist <B>vector</B>. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-302240", " can be amalgamated. That is, the resulting knot <B>vector</B> for the curves is the union of all", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-302637", " Similar to splining, a knot <B>vector</B> for the loft direction may be supplied. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-314515", " PK_BSURF_reparameterise to rescale (uniformly) and translate the knot <B>vector</B> of a given B-curve or B-surface, respectively. B-surfaces", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.022.html#50409803_pgfId-374499", " The translation <B>vector</B> of the supplied transformation. ", "Functional Description - Transformations");
top.note("chapters/fd_chap.022.html#50409803_pgfId-376016", " The perspective <B>vector</B> of the supplied transformation ", "Functional Description - Transformations");
top.note("chapters/fd_chap.026.html#50409768_pgfId-332434", " the variable position, which should also be a <B>vector</B>. ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-373114", " multiply (real*real or real*<B>vector</B>), cross product (<B>vector</B>*<B>vector</B>) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-385740", " any of its sub-classes. The form of a <B>vector</B> is an array of three reals. ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386264", " position would be a <B>vector</B> variable defined by the PK function ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-384746", " length (<B>vector</B> v) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-384748", " Returns the magnitude of the supplied <B>vector</B> v. ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-384790", " <B>vector</B> ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-384792", " normalise (<B>vector</B> v) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-384794", " unit <B>vector</B> parallel to v, of the zero <B>vector</B> if", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-384898", " dot (<B>vector</B> v0, <B>vector</B> v1) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-384850", " element (<B>vector</B> v, integer index) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-384852", " Returns the index-th component of the supplied <B>vector</B> v. The index must be 1, 2 or", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-375891", " <B>vector</B> ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-375893", " <B>vector</B> (real x, real y, real z) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-375895", " Creates a <B>vector</B> value. ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386651", " ( PK_ENTITY_t entity, <B>vector</B> start, <B>vector</B> end) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386718", " <B>vector</B> ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386721", " ( PK_ENTITY_t entity, <B>vector</B> position) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-372902", " <B>vector</B> ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-376260", " ( PK_ENTITY_t entity, <B>vector</B> position, bool ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-381801", " as the first and second components of the <B>vector</B> respectively. ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386697", " <B>vector</B> ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386700", " ( PK_GEOM_t geom, <B>vector</B> position) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386702", " parameters u and v are returned as the <B>vector</B> (u, v, 0).The position must lie on the", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386669", " <B>vector</B> ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386672", " ( PK_GEOM_t geom, <B>vector</B> parameters) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386674", " the first and second components of the parameters <B>vector</B> respectively. ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-388367", " <B>vector</B> ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-388410", " ( PK_ENTITY_t entity, <B>vector</B> position, bool ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-388452", " curve, supplied as the first component of the <B>vector</B> ", "Functional Description - Expressions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-306679", " in the surface of the face, The returned <B>vector</B> always lies in the interior of the given", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-309874", " 27.6.3 <B>Vector</B> comparison ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-309888", " Tests whether a <B>vector</B> is zero within the current session precision. ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-309896", " should create a unit <B>vector</B> from the derivative <B>vector</B> using PK_VECTOR_normalise . ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310458", " A position <B>vector</B> corresponding to the distance along the curve. See", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310472", " A position <B>vector</B> that corresponds to the ratio of distances along", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310529", " the curve as an input measurement, one position <B>vector</B> is returned as shown in ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310613", " is used as an input measurement, one position <B>vector</B> is returned as shown in ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310655", " the chord B. For example, to return a <B>vector</B> halfway along the chord ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-576638", " Whether a position <B>vector</B> is supplied to help find the path curve.", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-581605", " A position <B>vector</B> to help find the path curve. ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-575603", " Whether a projection direction <B>vector</B> is supplied. See Section 27.6.13.1, Defining the path", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-581790", " A <B>vector</B> indicating the direction of the projection. ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.029.html#50409809_pgfId-294750", " function at a given position with the position <B>vector</B> itself over the whole amount being considered. ", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.029.html#50409809_pgfId-295328", " function at a given position with the position <B>vector</B> itself over the whole volume being considered. It", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.029.html#50409809_pgfId-295341", "r is the <B>vector</B> from the center of mass to a point", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296928", "<B>vector</B> functions in subsequent sections (the last two also", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297036", "Available in: all functions except <B>vector</B> functions. ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297052", " Specifies whether to return a <B>vector</B> and parameter on the ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297053", "Available in: all <B>vector</B> functions that involve at least one topological entity", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297061", " let you provide either a parameter or a <B>vector</B> that represents a place on the entity that", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-355925", " the surface. This requires extra computation time and <B>vector</B> positions near complex areas of the surfaces (e.g", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297117", " estimate, since providing an estimate for a known <B>vector</B> would be meaningless. The option name is ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297147", " <B>vector</B> ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297149", " contains the corresponding position. You can supply a <B>vector</B> if the solution is to be found on", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297175", " For all <B>vector</B> functions, a PK_range_1_r_t is returned which contains details", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.032.html#50409812_pgfId-296093", " Non-unit-length <B>vector</B> field ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-296096", " A <B>vector</B> field required to be of unit length is", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-296108", " Position <B>vector</B> field out of range ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-296111", " A position <B>vector</B> field is out of range (usually outside size", "Functional Description - Checking");
top.note("chapters/fd_chap.038.html#50409820_pgfId-516028", " A location <B>vector</B> that defines the surface that the outlines are", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-516032", " A direction <B>vector</B> that defines the axis direction of the cylinder", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.039.html#50409821_pgfId-294752", "bounds ) must be ordered along this <B>vector</B> so that the start comes first. ", "Functional Description - Creating Extruded Bodies");
top.note("chapters/fd_chap.039.html#50409821_pgfId-294984", " The unit <B>vector</B> that defines the direction of extrusion. ", "Functional Description - Creating Extruded Bodies");
top.note("chapters/fd_chap.039.html#50409821_pgfId-295238", " extrude in the opposite direction to the path <B>vector</B> the forward field of the bound is set", "Functional Description - Creating Extruded Bodies");
top.note("chapters/fd_chap.040.html#50409822_pgfId-296955", " A unit <B>vector</B> determining the lock direction. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-297330", " A unit <B>vector</B> that specifies the direction in which to apply", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-299412", " take the form of a specified reference direction <B>vector</B> (known as a ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.041.html#50409823_pgfId-300094", " the swept tool. It must be a unit <B>vector</B> and is used if ", "Functional Description - Sweeping Tool Bodies Along a Path");
top.note("chapters/fd_chap.042.html#50409824_pgfId-537291", " When supplying a <B>vector</B> clamp (see Section 41.3, Specifying derivative conditions )", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-534236", " of a non-periodic loft, providing there are no <B>vector</B>, face, or planar clamps at that end, and", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-534246", " be supplied. Clamps of an individual type are <B>vector</B>, face, planar and none. A combination of these", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-534250", " With a <B>vector</B> clamp, a tangent <B>vector</B> is applied to vertices of the profile or", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-534251", " constrain, or you can supply a single tangent <B>vector</B> to be applied across the whole profile or", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-534252", " structure controls the <B>vector</B> clamps in a given profile using the following", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-790116", " of clamp supplied in PK_BODY_loft_deriv_conds_t is one of <B>vector</B>, face or planar then only the corresponding clamp", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295982", "<B>Vector</B> Clamp: clamp produces a more general termination which may or may not be smooth, by constraining the loft to interpolate the specified derivatives at the degenerate end. The clamp may have one of the following: ", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295983", " A single tangent <B>vector</B> ", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295985", " One tangent <B>vector</B> for each vertex on the adjacent profile ", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295986", " vectors are supplied is significant: the first tangent <B>vector</B> in the clamp is associated with the start", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-296596", " <B>Vector</B> clamp operations ", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-296762", " <B>Vector</B> clamp operations ", "Functional Description - Lofting");
top.note("chapters/fd_chap.052.html#50409836_pgfId-559656", " supplied, in which case a projection in a <B>vector</B> direction is performed. The resultant projected curves and", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-1099559", " Whether to perform a normal, <B>vector</B>, or perspective projection. See Section 51.2.6, Choosing the", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362453", " The direction of the <B>vector</B> projection of the curve when ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362458", " of the <B>vector</B> projection is both positive and negative (Default: PK_LOGICAL_false).", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362472", " from the input curve. The distance of a <B>vector</B> projection is measured along ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362486", " the projection.This option can only be used for <B>vector</B> projections to faces or bodies (Default: PK_proj_connect_none_c ).", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362519", " whether to project a curve using a normal, <B>vector</B>, or perspective projection. All of these options are", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-1100979", " 51.2.6.2 <B>Vector</B> projection ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-919402", " To produce a <B>vector</B> projection, where a given point on the curve", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-1101147", " For <B>vector</B> projections, ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-975472", " Note: This option does not support <B>vector</B> projections to surfaces. ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362603", "Figure 51-5 shows three cases of a downward <B>vector</B> projection of a curve onto a body. ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-558906", " Figure 51-5 <B>Vector</B> projection of a curve using ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-523950", " Note: This option can only be used for <B>vector</B> projection of curves to faces or bodies. ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-295212", " to imprint in both directions along the specified <B>vector</B>. Using the default options, you can only do", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-295394", " appear to intersect when viewed along the projection <B>vector</B>. This can be problematic: to produce a valid", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-295406", " appear to intersect when viewed along the projection <B>vector</B>, the curves at the points of intersection are", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-295410", " appears to intersect when viewed along the projection <B>vector</B>, the function call fails with PK_ERROR_cant_do_imprint. ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-295428", " when viewed in the direction of the project <B>vector</B>, a successful imprint is only possible if ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-295468", " appear to intersect when viewed along the projection <B>vector</B> can be successfully imprinted onto a body by", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-295511", " several curves that only intersect along the projection <B>vector</B> ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-296271", " 51.5.7 Controlling how curves are imprinted along a <B>vector</B> ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-296272", " are calculated by projecting the curves along that <B>vector</B>. ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394990", " A unit <B>vector</B> that specifies the sweep direction to use when", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.058.html#50409842_pgfId-338034", " Section 27.6.3, <B>Vector</B> comparison ", "Functional Description - Intersections");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296952", " For through-holes, this option specifies a <B>vector</B> that determines at which end of the through-hole", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.068.html#50409854_pgfId-950670", " both stages, the functionality requires a draw direction <B>vector</B> pointing into the mold and a draft angle.", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.079.html#50409866_pgfId-307445", " spine that is closest to the planes location <B>vector</B> (i.e the ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311219", " A help point is a 3-space <B>vector</B> that is used to distinguish between multiple possible", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311337", " A 3-space <B>vector</B> that represents a help point that PK_FACE_make_blend can", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-313149", " that order. (For calculating the sense, this cross-product <B>vector</B> takes the place of a face normal when", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-296210", " at the intersection closest to the planes location <B>vector</B> (i.e the ", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-296271", " A 3 space <B>vector</B> that is used to distinguish between multiple possible", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.082.html#50409869_pgfId-305592", " The associated data is a <B>vector</B> in ", "Functional Description - Interpreting Face-Face Blending Error Codes");
top.note("chapters/fd_chap.082.html#50409869_pgfId-305655", " The associated data is a <B>vector</B> in ", "Functional Description - Interpreting Face-Face Blending Error Codes");
top.note("chapters/fd_chap.085.html#50409873_pgfId-435034", " Returns the normal <B>vector</B> of the given mfacet. ", "Functional Description - Facet Model Structure");
top.note("chapters/fd_chap.087.html#50409875_pgfId-344069", " one of four types; index, strip, fan, and <B>vector</B> or a mix of these types. See Section", "Functional Description - Creating PSM Data From Foreign Facet Data");
top.note("chapters/fd_chap.087.html#50409875_pgfId-332997", " types of data blocks (index, strip, fan, and <B>vector</B>) that can be returned by each call to", "Functional Description - Creating PSM Data From Foreign Facet Data");
top.note("chapters/fd_chap.087.html#50409875_pgfId-334541", " 86.4.1.4 <B>Vector</B> mesh ", "Functional Description - Creating PSM Data From Foreign Facet Data");
top.note("chapters/fd_chap.087.html#50409875_pgfId-334537", " Figure 86-4 Example of a <B>vector</B> mesh ", "Functional Description - Creating PSM Data From Foreign Facet Data");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343025", " array of position vectors, and for each position <B>vector</B> specified, PK_MESH_find_laminar_mfins returns the closest chain of connected", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.093.html#50409882_pgfId-310215", " We can consider this <B>vector</B> valued function as three scalar valued functions, with", "Functional Description - Exporting Data");
top.note("chapters/fd_chap.096.html#50409886_pgfId-294761", " <B>vector</B> (displacement <B>vector</B> - direction and magnitude) ", "Functional Description - Attribute Definitions");
top.note("chapters/fd_chap.096.html#50409886_pgfId-294762", " coordinate (position <B>vector</B>) ", "Functional Description - Attribute Definitions");
top.note("chapters/fd_chap.097.html#50409887_pgfId-294731", " <B>Vector</B> (PK_ATTRIB_field_<B>vector</B>_c) ", "Functional Description - Attributes");
top.note("chapters/fd_chap.097.html#50409887_pgfId-304809", " functions are used to access fields of type <B>vector</B>, coordinate and direction. ", "Functional Description - Attributes");
top.note("chapters/fd_chap.097.html#50409887_pgfId-295114", " field type; only the four geometric field types (<B>vector</B>, direction, coordinate and axis) are affected, and each", "Functional Description - Attributes");
top.note("chapters/fd_chap.097.html#50409887_pgfId-295116", " <B>Vector</B> and direction fields are affected by rotation and reflection,", "Functional Description - Attributes");
top.note("chapters/fd_chap.109.html#50409900_pgfId-313209", " takes an array of unit vectors, each unit <B>vector</B> defining a different view direction. A corresponding ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.111.html#50409902_pgfId-297838", " the face normal cannot be calculated, a zero <B>vector</B> is returned. This event is rare but you", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294753", " as a post multiplier of a homogeneous row <B>vector</B>: ", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294765", " The row <B>vector</B> ", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294766", " The column <B>vector</B> ", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294784", " must be orthonormal: each row/column is a unit <B>vector</B> and the rows/columns are each three mutually orthogonal", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294808", " If P is the zero <B>vector</B>, then w is also zero, and the view", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294810", " is a <B>vector</B> that represents the position from which the part", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294815", " For perspective views, the perspective <B>vector</B> P must be parallel to the view direction", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.118.html#50409910_pgfId-378687", " <B>Vector</B> curve imprinting ", "Functional Description - Version Controls");
top.note("chapters/fd_chap.124.html#50409918_pgfId-285618", " real values define the hatch orientation as a <B>vector</B> and a spacing between consecutive planes. ", "Functional Description - System Attribute Definitions");
top.note("chapters/fd_chap.124.html#50409918_pgfId-285690", " position <B>vector</B> ", "Functional Description - System Attribute Definitions");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287397", " the u-knot <B>vector</B> (a list of values of u) gives the", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287398", " the v-knot <B>vector</B> (a list of values of v) gives the", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275422", " of the curves will create the same knot <B>vector</B> for each curve by addition of corresponding knot", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275477", " The <B>vector</B> between two points on a curve. ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275541", " The first derivative of a curve is a <B>vector</B> valued function whose value at any parameter is", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275659", " Knot <B>Vector</B> ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275660", " or B-curve. Together with the order, the knot <B>vector</B> uniquely defines a set of B-spline basis functions.", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275709", " The normal is usually described by a unit <B>vector</B>. ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275721", " Non-uniform means that the values in the knot <B>vector</B> are not necessarily uniformly spaced and may even", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275742", " it lies on a curve/edge and the distance <B>vector</B> from the entity is perpendicular to the tangent,", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275743", " on a surface or face with the distance <B>vector</B> being parallel/anti-parallel to the surface/face normal at the", "Functional Description - ZGlossary");
top.note("chapters/ov_chap.04.html#50442254_pgfId-546906", " one of four forms; index, strip, fan, and <B>vector</B>, which are shown in ", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.16.html#50442289_pgfId-284231", " <B>vector</B> ", "Overview of Parasolid - Application Support");
top.note("chapters/p2_chap.03.html#sec_b_1_1", " PK_ATTRIB_state_non_unit_vec_c 13849 a <B>vector</B> field required to be of unit length is", "PK Reference - PK token Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.05.html#sec_d_1_app", " an edge or vertex in topols and a <B>vector</B> in points representing a point where the guide", "PK Reference - PK token Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.07.html#sec_f_1_1", " PK_ERROR_bad_index 29 PK_ATTRIB_ask_nth_vector The field has no <B>vector</B> with this index", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_2", " PK_ERROR_bad_knots 978 PK_BCURVE_ask_splinewise curve has unsuitable knot <B>vector</B>", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_4", " PK_ERROR_field_of_wrong_type 5014 PK_ATTRIB_ask_named_vectors The field is not a <B>vector</B>, coordinate", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.09.html#sec_h_1_1", " PK_ERROR_bad_derivative 979 PK_BCURVE_make_bsurf_lofted_o_t derivative or twist <B>vector</B> too large", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_2", " PK_ERROR_field_of_wrong_type 5014 PK_ATTRIB_ask_named_vectors The field is not a <B>vector</B>, coordinate", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_3", " twist <B>vector</B> has been supplied,", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_4", " PK_ERROR_zero_vector 5124 PK_VECTOR_is_parallel <B>vector</B> is zero <B>vector</B> (MILD)", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.10.html#sec_i_1_1", " PK_ATTRIB_ask_named_vectors 5014 PK_ERROR_field_of_wrong_type The field is not a <B>vector</B>, coordinate", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_2", " PK_FACE_intersect_face 67 PK_ERROR_not_on_curve (SERIOUS) seed <B>vector</B> provided does not lie on", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_4", " PK_VECTOR_is_parallel 5124 PK_ERROR_zero_vector <B>vector</B> is zero <B>vector</B> (MILD)", "PK Reference - PK Error Codes (Functional)");
top.note("headers/pk_3_face_blend_t.html#documentation", " The associated data is a <B>vector</B> in points ", "PK Reference - PK_3_face_blend_t");
top.note("headers/pk_attdef_sf_2_t.html#documentation", " <B>vector</B> and direction fields are acted on by the", "PK Reference - PK_ATTDEF_sf_2_t");
top.note("headers/pk_attdef_sf_t.html#documentation", " <B>vector</B> and direction fields are acted on by the", "PK Reference - PK_ATTDEF_sf_t");
top.note("headers/pk_attrib_ask_named_vectors.html#errors", " PK_ERROR_field_of_wrong_type The field is not a <B>vector</B>, coordinate", "PK Reference - PK_ATTRIB_ask_named_vectors");
top.note("headers/pk_attrib_ask_named_vectors.html#documentation", "The field should be of type <B>vector</B>, coordinate or direction.", "PK Reference - PK_ATTRIB_ask_named_vectors");
top.note("headers/pk_attrib_ask_nth_vector.html#declaration", "int index, --- index of <B>vector</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_nth_vector");
top.note("headers/pk_attrib_ask_nth_vector.html#description", " This function returns a single element of the <B>vector</B> array from field", "PK Reference - PK_ATTRIB_ask_nth_vector");
top.note("headers/pk_attrib_ask_nth_vector.html#errors", " PK_ERROR_field_of_wrong_type The field is not a <B>vector</B>, coordinate or", "PK Reference - PK_ATTRIB_ask_nth_vector");
top.note("headers/pk_attrib_ask_nth_vector.html#documentation", "The field should be of type <B>vector</B>, coordinate or direction.", "PK Reference - PK_ATTRIB_ask_nth_vector");
top.note("headers/pk_attrib_ask_vectors.html#errors", " PK_ERROR_field_of_wrong_type The field is not a <B>vector</B>, coordinate", "PK Reference - PK_ATTRIB_ask_vectors");
top.note("headers/pk_attrib_ask_vectors.html#documentation", "The field should be of type <B>vector</B>, coordinate or direction.", "PK Reference - PK_ATTRIB_ask_vectors");
top.note("headers/pk_attrib_set_named_vectors.html#errors", " PK_ERROR_field_of_wrong_type (MILD) The field is not a <B>vector</B> field", "PK Reference - PK_ATTRIB_set_named_vectors");
top.note("headers/pk_attrib_set_named_vectors.html#documentation", "The field should be of type <B>vector</B>, coordinate or direction.", "PK Reference - PK_ATTRIB_set_named_vectors");
top.note("headers/pk_attrib_set_vectors.html#errors", " PK_ERROR_field_of_wrong_type (MILD) The field is not a <B>vector</B> field", "PK Reference - PK_ATTRIB_set_vectors");
top.note("headers/pk_attrib_set_vectors.html#documentation", "The field should be of type <B>vector</B>, coordinate or direction.", "PK Reference - PK_ATTRIB_set_vectors");
top.note("headers/pk_bcurve_ask_knots.html#documentation", "Optionally one may specify that the full knot <B>vector</B> (expanded according to", "PK Reference - PK_BCURVE_ask_knots");
top.note("headers/pk_bcurve_ask_knots_o_t.html#documentation", " want_expanded_knots Specifies if a full knot <B>vector</B> expanded according to", "PK Reference - PK_BCURVE_ask_knots_o_t");
top.note("headers/pk_bcurve_ask_splinewise.html#errors", " PK_ERROR_bad_knots curve has unsuitable knot <B>vector</B>", "PK Reference - PK_BCURVE_ask_splinewise");
top.note("headers/pk_bcurve_fit_eval_f_t.html#documentation", "a 3-space <B>vector</B> in point .", "PK Reference - PK_BCURVE_fit_eval_f_t");
top.note("headers/pk_bcurve_make_bsurf_lofted.html#documentation", "they all share the same knot <B>vector</B>, then a surface is produced which is", "PK Reference - PK_BCURVE_make_bsurf_lofted");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#declaration", " u_v; --- how lower u lower v twist <B>vector</B>", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#errors", " PK_ERROR_bad_derivative derivative or twist <B>vector</B> too large", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#documentation", " u_v whether a twist <B>vector</B> for the lower u lower v corner", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_piecewise_sf_t.html#documentation", " field gives the number of doubles per coefficient <B>vector</B>", "PK Reference - PK_BCURVE_piecewise_sf_t");
top.note("headers/pk_bcurve_reparameterise.html#description", " performs a rescaling and translation of the knot <B>vector</B>", "PK Reference - PK_BCURVE_reparameterise");
top.note("headers/pk_bcurve_splinewise_sf_t.html#declaration", " PK_PARAM_knot_t how_knot; --- How knot <B>vector</B> defined", "PK Reference - PK_BCURVE_splinewise_sf_t");
top.note("headers/pk_bcurve_splinewise_sf_t.html#documentation", " how_knot How the knot <B>vector</B> is defined.", "PK Reference - PK_BCURVE_splinewise_sf_t");
top.note("headers/pk_bcurve_sweep.html#declaration", " PK_VECTOR_t path, --- translation <B>vector</B>", "PK Reference - PK_BCURVE_sweep");
top.note("headers/pk_bcurve_sweep.html#errors", " PK_ERROR_null_direction zero length path <B>vector</B> given", "PK Reference - PK_BCURVE_sweep");
top.note("headers/pk_bcurve_sweep.html#documentation", "The bcurve is moved along the path <B>vector</B> sweeping out a bsurf .", "PK Reference - PK_BCURVE_sweep");
top.note("headers/pk_blend_cap_data_t.html#documentation", " identified as that closest to the planes location <B>vector</B>", "PK Reference - PK_blend_cap_data_t");
top.note("headers/pk_blend_constraint_t.html#documentation", " location <B>vector</B> (i.e. `basis_set.location in PK_PLANE_sf_t ).", "PK Reference - PK_blend_constraint_t");
top.note("headers/pk_blend_limit_type_t.html#documentation", " <B>vector</B> in the same structure is ignored", "PK Reference - PK_blend_limit_type_t");
top.note("headers/pk_body_contains_vector.html#declaration", " PK_VECTOR_t <B>vector</B>, --- the position <B>vector</B>", "PK Reference - PK_BODY_contains_vector");
top.note("headers/pk_body_contains_vector.html#description", "position <B>vector</B> lies inside, outside, or on the boundary of", "PK Reference - PK_BODY_contains_vector");
top.note("headers/pk_body_create_sheet_planar.html#documentation", "as vectors . For each position <B>vector</B> in vectors , the corresponding entry", "PK Reference - PK_BODY_create_sheet_planar");
top.note("headers/pk_body_create_sheet_planar_o_t.html#documentation", " where the loops field is specified, for each <B>vector</B> in vectors ,", "PK Reference - PK_BODY_create_sheet_planar_o_t");
top.note("headers/pk_body_emboss.html#documentation", "PK_BODY_emboss requires a unit <B>vector</B> to be supplied in the draw_direction ", "PK Reference - PK_BODY_emboss");
top.note("headers/pk_body_extrude.html#documentation", "given path <B>vector</B> between two bounds.", "PK Reference - PK_BODY_extrude");
top.note("headers/pk_body_imprint_cus_vec_o_t.html#declaration", " --- <B>vector</B> direction.", "PK Reference - PK_BODY_imprint_cus_vec_o_t");
top.note("headers/pk_body_imprint_cus_vec_o_t.html#documentation", " and negative <B>vector</B> direction and edges visible in", "PK Reference - PK_BODY_imprint_cus_vec_o_t");
top.note("headers/pk_body_loft_clamp_type_t.html#documentation", " supplied in the <B>vector</B> clamp. Tangents are", "PK Reference - PK_BODY_loft_clamp_type_t");
top.note("headers/pk_body_loft_deriv_conds_t.html#documentation", " planar_clamp Specifies a normal <B>vector</B> that defines a plane", "PK Reference - PK_BODY_loft_deriv_conds_t");
top.note("headers/pk_body_loft_face_clamp_t.html#documentation", "If used in conjuction with a <B>vector</B> clamp, as a composite clamp, the directions", "PK Reference - PK_BODY_loft_face_clamp_t");
top.note("headers/pk_body_loft_fault_t.html#documentation", " For example, if <B>vector</B> clamps are declared", "PK Reference - PK_BODY_loft_fault_t");
top.note("headers/pk_body_loft_planar_clamp_t.html#description", " This structure holds the normal <B>vector</B> of plane and magnitude of derivatives", "PK Reference - PK_BODY_loft_planar_clamp_t");
top.note("headers/pk_body_loft_planar_clamp_t.html#documentation", " normal The normal <B>vector</B> of the plane for clamping the loft. All", "PK Reference - PK_BODY_loft_planar_clamp_t");
top.note("headers/pk_body_loft_vector_clamp_t.html#declaration", " int n_magnitudes; --- number of <B>vector</B> magnitudes (0)", "PK Reference - PK_BODY_loft_vector_clamp_t");
top.note("headers/pk_body_loft_vector_clamp_t.html#documentation", "<B>vector</B> clamps.", "PK Reference - PK_BODY_loft_vector_clamp_t");
top.note("headers/pk_body_make_lofted_body.html#documentation", " o If a <B>vector</B> clamp is supplied for a profile that has", "PK Reference - PK_BODY_make_lofted_body");
top.note("headers/pk_body_make_persp_outline_o_t.html#documentation", " project_location A location <B>vector</B> that defines the surface onto which", "PK Reference - PK_BODY_make_persp_outline_o_t");
top.note("headers/pk_body_make_swept_body_2.html#documentation", " is about the <B>vector</B> twist_direction .", "PK Reference - PK_BODY_make_swept_body_2");
top.note("headers/pk_body_make_swept_body_2_o_t.html#documentation", " scale_point A position <B>vector</B> indicating the defining point for a", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#documentation", " scale_point A position <B>vector</B> indicating the defining point for a", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_sweep.html#declaration", " PK_VECTOR_t path, --- translation <B>vector</B>", "PK Reference - PK_BODY_sweep");
top.note("headers/pk_body_sweep.html#documentation", " to be swept is moved along the path <B>vector</B> leaving lateral", "PK Reference - PK_BODY_sweep");
top.note("headers/pk_body_thicken_2.html#errors", " punch direction is not a unit <B>vector</B>", "PK Reference - PK_BODY_thicken_2");
top.note("headers/pk_body_thicken_3.html#errors", " punch direction is not a unit <B>vector</B>", "PK Reference - PK_BODY_thicken_3");
top.note("headers/pk_body_thicken_o_t.html#declaration", " --- (zero <B>vector</B>) [NF]", "PK Reference - PK_BODY_thicken_o_t");
top.note("headers/pk_body_thicken_o_t.html#documentation", " punch_dir <B>Vector</B> of the punch direction. This must be set if", "PK Reference - PK_BODY_thicken_o_t");
top.note("headers/pk_bound_def_t.html#documentation", " in the direction of the given path <B>vector</B>, or on the other", "PK Reference - PK_bound_def_t");
top.note("headers/pk_bound_t.html#documentation", " opposite direction to the path <B>vector</B> is", "PK Reference - PK_bound_t");
top.note("headers/pk_bsurf_ask_knots.html#declaration", " PK_PARAM_direction_t u_or_v, --- which knot <B>vector</B> to return", "PK Reference - PK_BSURF_ask_knots");
top.note("headers/pk_bsurf_ask_knots.html#documentation", "Optionally one may specify that the full knot <B>vector</B> (expanded according to", "PK Reference - PK_BSURF_ask_knots");
top.note("headers/pk_bsurf_ask_knots_o_t.html#documentation", " want_expanded_knots Specifies if a full knot <B>vector</B> expanded according to", "PK Reference - PK_BSURF_ask_knots_o_t");
top.note("headers/pk_bsurf_ask_splinewise.html#errors", " PK_ERROR_bad_knots surface has unsuitable knot <B>vector</B>", "PK Reference - PK_BSURF_ask_splinewise");
top.note("headers/pk_bsurf_piecewise_sf_t.html#documentation", " field gives the number of doubles per coefficient <B>vector</B>", "PK Reference - PK_BSURF_piecewise_sf_t");
top.note("headers/pk_bsurf_splinewise_sf_t.html#declaration", " PK_PARAM_knot_t u_how_knot; --- How u knot <B>vector</B> defined", "PK Reference - PK_BSURF_splinewise_sf_t");
top.note("headers/pk_bsurf_splinewise_sf_t.html#documentation", " u_how_knot How the u knot <B>vector</B> is defined.", "PK Reference - PK_BSURF_splinewise_sf_t");
top.note("headers/pk_check_fault_t.html#documentation", " set to (0.0, 0.0, 0.0). If the position <B>vector</B> does not describe a", "PK Reference - PK_check_fault_t");
top.note("headers/pk_check_state_t.html#documentation", " PK_ATTRIB_state_non_unit_vec_c a <B>vector</B> field required to be of unit", "PK Reference - PK_check_state_t");
top.note("headers/pk_curve_find_min_radius.html#declaration", " PK_VECTOR_t *const position, --- position <B>vector</B> where minimum occurs", "PK Reference - PK_CURVE_find_min_radius");
top.note("headers/pk_curve_find_min_radius.html#documentation", " 2: A position <B>vector</B> indicating where on the curve the minimum of", "PK Reference - PK_CURVE_find_min_radius");
top.note("headers/pk_curve_find_vector_interval.html#declaration", " PK_VECTOR_t vector_1, --- first position <B>vector</B>", "PK Reference - PK_CURVE_find_vector_interval");
top.note("headers/pk_curve_find_vectors.html#documentation", "position <B>vector</B> will be matched to its corresponding entry in", "PK Reference - PK_CURVE_find_vectors");
top.note("headers/pk_curve_find_vectors_o_t.html#documentation", " \"start point\" of the curve is the position <B>vector</B> corresponding", "PK Reference - PK_CURVE_find_vectors_o_t");
top.note("headers/pk_curve_find_vectors_r_t.html#documentation", "If PK_CURVE_find_vectors successfully determines a position <B>vector</B>", "PK Reference - PK_CURVE_find_vectors_r_t");
top.note("headers/pk_curve_find_vectors_t.html#documentation", "<B>vector</B> was found or not.", "PK Reference - PK_CURVE_find_vectors_t");
top.note("headers/pk_curve_project.html#documentation", "supplied <B>vector</B> direction), an empty results structure is returned.", "PK Reference - PK_CURVE_project");
top.note("headers/pk_curve_project_o_t.html#documentation", " method Whether to perform a normal, <B>vector</B> or perspective", "PK Reference - PK_CURVE_project_o_t");
top.note("headers/pk_detail_def_hole_t.html#documentation", " The origin s ref_direction is a <B>vector</B> orthogonal to the", "PK Reference - PK_detail_def_hole_t");
top.note("headers/pk_edge_contains_vector.html#declaration", " PK_VECTOR_t <B>vector</B>, --- the position <B>vector</B>", "PK Reference - PK_EDGE_contains_vector");
top.note("headers/pk_edge_contains_vector.html#description", " This function determines whether the given position <B>vector</B> coincides with", "PK Reference - PK_EDGE_contains_vector");
top.note("headers/pk_edge_contains_vector.html#documentation", "If <B>vector</B> does not coincide with the edge then topol", "PK Reference - PK_EDGE_contains_vector");
top.note("headers/pk_entity_range_end_t.html#declaration", " PK_VECTOR_t <B>vector</B>; --- end position (0.0, 0.0, 0.0)", "PK Reference - PK_ENTITY_range_end_t");
top.note("headers/pk_entity_range_end_t.html#documentation", " <B>vector</B> : the end position on entity .", "PK Reference - PK_ENTITY_range_end_t");
top.note("headers/pk_entity_range_o_t.html#declaration", " PK_range_param_entity_t param_entity; --- option to return a <B>vector</B> and", "PK Reference - PK_ENTITY_range_o_t");
top.note("headers/pk_entity_range_o_t.html#documentation", " param_entity : option to return a <B>vector</B> and parameter on the sub-entity", "PK Reference - PK_ENTITY_range_o_t");
top.note("headers/pk_entity_range_vector_o_t.html#declaration", " PK_range_param_entity_t param_entity; --- option to return a <B>vector</B> and", "PK Reference - PK_ENTITY_range_vector_o_t");
top.note("headers/pk_entity_range_vector_o_t.html#documentation", " param_entity : option to return a <B>vector</B> and parameter on the sub-entity", "PK Reference - PK_ENTITY_range_vector_o_t");
top.note("headers/pk_expr_value_t.html#declaration", " PK_VECTOR_t <B>vector</B>;", "PK Reference - PK_EXPR_value_t");
top.note("headers/pk_expr_value_t.html#description", "type of integer, real, <B>vector</B> or entity.", "PK Reference - PK_EXPR_value_t");
top.note("headers/pk_expr_value_t.html#documentation", " <B>vector</B> The value, if type is set to PK_EXPR_value_type_vector_c", "PK Reference - PK_EXPR_value_t");
top.note("headers/pk_face_change_deform_o_t.html#documentation", " position (<B>vector</B>) - An input position located on the", "PK Reference - PK_FACE_change_deform_o_t");
top.note("headers/pk_face_contains_vectors.html#documentation", " Null <B>vector</B> lies outside the face", "PK Reference - PK_FACE_contains_vectors");
top.note("headers/pk_face_contains_vectors_o_t.html#declaration", " PK_LOGICAL_t is_on_surf; --- whether position <B>vector</B> is assumed", "PK Reference - PK_FACE_contains_vectors_o_t");
top.note("headers/pk_face_contains_vectors_o_t.html#documentation", "lie on the faces surface. If a <B>vector</B> is given off the surface then spurious", "PK Reference - PK_FACE_contains_vectors_o_t");
top.note("headers/pk_face_details_hole_o_t.html#declaration", " PK_VECTOR_t up; --- up <B>vector</B> for through holes", "PK Reference - PK_FACE_details_hole_o_t");
top.note("headers/pk_face_details_hole_o_t.html#documentation", " holes origin s axis and the up <B>vector</B> positive.", "PK Reference - PK_FACE_details_hole_o_t");
top.note("headers/pk_face_emboss.html#documentation", "PK_FACE_emboss requires a unit <B>vector</B> to be supplied in the draw_direction ", "PK Reference - PK_FACE_emboss");
top.note("headers/pk_face_find_interior_vec.html#declaration", " --- <B>vector</B>", "PK Reference - PK_FACE_find_interior_vec");
top.note("headers/pk_face_find_interior_vec.html#description", " The function returns an arbitrary <B>vector</B> interior to the given face, and the", "PK Reference - PK_FACE_find_interior_vec");
top.note("headers/pk_face_find_interior_vec_o_t.html#description", " Holds optional controls for finding a <B>vector</B> interior to the face provided.", "PK Reference - PK_FACE_find_interior_vec_o_t");
top.note("headers/pk_face_imprint_cus_vec.html#description", "by projecting them locally along the given <B>vector</B> direction. The faces must", "PK Reference - PK_FACE_imprint_cus_vec");
top.note("headers/pk_face_imprint_cus_vec_o_t.html#declaration", " --- <B>vector</B> direction.", "PK Reference - PK_FACE_imprint_cus_vec_o_t");
top.note("headers/pk_face_imprint_cus_vec_o_t.html#documentation", " and negative <B>vector</B> direction and edges visible in", "PK Reference - PK_FACE_imprint_cus_vec_o_t");
top.note("headers/pk_face_imprint_cus_vector.html#description", " ) by projecting them locally along the given <B>vector</B>", "PK Reference - PK_FACE_imprint_cus_vector");
top.note("headers/pk_face_intersect_face.html#errors", " PK_ERROR_not_on_curve (SERIOUS) seed <B>vector</B> provided does not lie on", "PK Reference - PK_FACE_intersect_face");
top.note("headers/pk_face_intersect_face_o_t.html#declaration", " PK_LOGICAL_t have_vector; --- whether seed <B>vector</B> provided", "PK Reference - PK_FACE_intersect_face_o_t");
top.note("headers/pk_face_intersect_face_o_t.html#documentation", " The option have_vector indicates whether a <B>vector</B> has been specified.", "PK Reference - PK_FACE_intersect_face_o_t");
top.note("headers/pk_face_intersect_surf.html#errors", " PK_ERROR_not_on_curve (SERIOUS) seed <B>vector</B> provided does not lie on", "PK Reference - PK_FACE_intersect_surf");
top.note("headers/pk_face_intersect_surf_o_t.html#declaration", " PK_LOGICAL_t have_vector; --- whether seed <B>vector</B> provided", "PK Reference - PK_FACE_intersect_surf_o_t");
top.note("headers/pk_face_intersect_surf_o_t.html#documentation", " The option have_vector indicates whether a <B>vector</B> has been specified.", "PK Reference - PK_FACE_intersect_surf_o_t");
top.note("headers/pk_face_is_coincident.html#documentation", "position <B>vector</B> is returned in point indicating where the faces", "PK Reference - PK_FACE_is_coincident");
top.note("headers/pk_face_make_3_face_blend_o_t.html#documentation", " location <B>vector</B> (i.e. `basis_set.location in", "PK Reference - PK_FACE_make_3_face_blend_o_t");
top.note("headers/pk_face_make_blend_o_t.html#documentation", " A <B>vector</B>, which will be used to differentiate between", "PK Reference - PK_FACE_make_blend_o_t");
top.note("headers/pk_face_sweep.html#declaration", " PK_VECTOR_t path, --- translation <B>vector</B>", "PK Reference - PK_FACE_sweep");
top.note("headers/pk_face_sweep.html#documentation", " to be swept are moved along the path <B>vector</B> leaving lateral", "PK Reference - PK_FACE_sweep");
top.note("headers/pk_fill_hole_clamp_planar_t.html#documentation", " normal A unit normal <B>vector</B> of the planar clamp. The normals of all", "PK Reference - PK_fill_hole_clamp_planar_t");
top.note("headers/pk_fxf_fault_t.html#documentation", " The associated data is a <B>vector</B> in points ", "PK Reference - PK_fxf_fault_t");
top.note("headers/pk_geom_check_o_t.html#documentation", " Position : a <B>vector</B> (t,0,0) where the parameter t", "PK Reference - PK_GEOM_check_o_t");
top.note("headers/pk_geom_range.html#documentation", " <B>vector</B> : the end position on entity .", "PK Reference - PK_GEOM_range");
top.note("headers/pk_geom_range_array.html#documentation", " <B>vector</B> : the end position on entity .", "PK Reference - PK_GEOM_range_array");
top.note("headers/pk_geom_range_array_vector.html#declaration", " PK_VECTOR_t <B>vector</B>, --- position <B>vector</B>", "PK Reference - PK_GEOM_range_array_vector");
top.note("headers/pk_geom_range_array_vector.html#documentation", " of geometrical entities geoms and the position <B>vector</B> <B>vector</B> .", "PK Reference - PK_GEOM_range_array_vector");
top.note("headers/pk_geom_range_local.html#documentation", " <B>vector</B> : the end position on entity .", "PK Reference - PK_GEOM_range_local");
top.note("headers/pk_geom_range_local_vector.html#declaration", " PK_VECTOR_t <B>vector</B>, --- position <B>vector</B>", "PK Reference - PK_GEOM_range_local_vector");
top.note("headers/pk_geom_range_local_vector.html#documentation", "the geometrical entity geom and a position <B>vector</B> <B>vector</B> .", "PK Reference - PK_GEOM_range_local_vector");
top.note("headers/pk_geom_range_o_t.html#documentation", " <B>vector</B> : end position <B>vector</B>.", "PK Reference - PK_GEOM_range_o_t");
top.note("headers/pk_geom_range_vector.html#declaration", " PK_VECTOR_t <B>vector</B>, --- position <B>vector</B>", "PK Reference - PK_GEOM_range_vector");
top.note("headers/pk_geom_range_vector.html#documentation", "geometrical entity geom and a position <B>vector</B> <B>vector</B> .", "PK Reference - PK_GEOM_range_vector");
top.note("headers/pk_geom_range_vector_many.html#documentation", "any <B>vector</B> selected from the input array vectors can be", "PK Reference - PK_GEOM_range_vector_many");
top.note("headers/pk_geom_range_vector_many_o_t.html#documentation", " <B>vector</B> end position <B>vector</B>.", "PK Reference - PK_GEOM_range_vector_many_o_t");
top.note("headers/pk_geom_range_vector_o_t.html#documentation", " <B>vector</B> : end position <B>vector</B>.", "PK Reference - PK_GEOM_range_vector_o_t");
top.note("headers/pk_gosgmt_f_t.html#documentation", " the <B>vector</B> cross product of the major axis with the", "PK Reference - PK_GOSGMT_f_t");
top.note("headers/pk_imprint_intersect_t.html#documentation", "imprint direction <B>vector</B>).", "PK Reference - PK_imprint_intersect_t");
top.note("headers/pk_mesh_facet_t.html#declaration", " PK_MESH_facet_vector_t *<B>vector</B>;", "PK Reference - PK_MESH_facet_t");
top.note("headers/pk_mesh_imprint_vectors.html#documentation", " where the ith mvertex comes from the ith <B>vector</B>. Note that", "PK Reference - PK_MESH_imprint_vectors");
top.note("headers/pk_mesh_imprint_vectors_o_t.html#declaration", " PK_MTOPOL_t *mtopols; --- mtopol containing each <B>vector</B>", "PK Reference - PK_MESH_imprint_vectors_o_t");
top.note("headers/pk_mesh_imprint_vectors_o_t.html#documentation", " <B>vector</B> lies on the ith mtopol. Supplying mtopols may", "PK Reference - PK_MESH_imprint_vectors_o_t");
top.note("headers/pk_mesh_imprint_vectors_r_t.html#documentation", " which could not be resolved into a single <B>vector</B>", "PK Reference - PK_MESH_imprint_vectors_r_t");
top.note("headers/pk_mfacet_ask_normal.html#declaration", " PK_VECTOR1_t *const normal ---the normal <B>vector</B> of the mfacet", "PK Reference - PK_MFACET_ask_normal");
top.note("headers/pk_mfacet_ask_normal.html#description", " This function returns the normal <B>vector</B> of mfacet .", "PK Reference - PK_MFACET_ask_normal");
top.note("headers/pk_mfacet_ask_positions.html#documentation", "`positions[0] is the position <B>vector</B> at the mvertex pointed to by the mfin", "PK Reference - PK_MFACET_ask_positions");
top.note("headers/pk_mvertex_set_positions.html#documentation", " has its position set to be the position <B>vector</B> in", "PK Reference - PK_MVERTEX_set_positions");
top.note("headers/pk_offset_sf_t.html#documentation", "<B>vector</B> scaled by the offset_distance . The offset_distance must", "PK Reference - PK_OFFSET_sf_t");
top.note("headers/pk_param_degen_t.html#documentation", " PK_PARAM_degen_vector_c degenerate position <B>vector</B> beyond end", "PK Reference - PK_PARAM_degen_t");
top.note("headers/pk_param_end_t.html#documentation", " PK_PARAM_end_clamped_vector_c end derivative <B>vector</B>(s) supplied", "PK Reference - PK_PARAM_end_t");
top.note("headers/pk_param_knot_t.html#documentation", "This datatype is used to specify the knot <B>vector</B> of splinewise", "PK Reference - PK_PARAM_knot_t");
top.note("headers/pk_pline_sf_t.html#documentation", " parameterisation. The position <B>vector</B> which would close", "PK Reference - PK_PLINE_sf_t");
top.note("headers/pk_proj_method_t.html#documentation", "PK_proj_method_vector_c A <B>vector</B> projection is performed in the direction", "PK Reference - PK_proj_method_t");
top.note("headers/pk_range_end_t.html#declaration", " PK_VECTOR_t <B>vector</B>; --- end position (0.0, 0.0, 0.0)", "PK Reference - PK_range_end_t");
top.note("headers/pk_range_guess_t.html#declaration", " PK_VECTOR_t <B>vector</B>; --- end position (0.0, 0.0, 0.0)", "PK Reference - PK_range_guess_t");
top.note("headers/pk_range_guess_t.html#documentation", "may be provided in <B>vector</B> . <B>vector</B> is expected to be on or close to", "PK Reference - PK_range_guess_t");
top.note("headers/pk_range_param_entity_t.html#documentation", "Option to return a <B>vector</B> and parameters on the sub-entity if a sub-entity", "PK Reference - PK_range_param_entity_t");
top.note("headers/pk_render_planar_t.html#documentation", " PK_render_planar_free_c : planar hatch using <B>vector</B> in planar_axis ", "PK Reference - PK_render_planar_t");
top.note("headers/pk_report_3_t.html#documentation", " array[1], array[2] - the components of a position <B>vector</B> on the", "PK Reference - PK_REPORT_3_t");
top.note("headers/pk_surf_create_blend_o_t.html#declaration", " PK_VECTOR_t help; --- help <B>vector</B>", "PK Reference - PK_SURF_create_blend_o_t");
top.note("headers/pk_surf_curve_t.html#documentation", " PK_SURF_curve_vec_proj_c: <B>Vector</B> projection.", "PK Reference - PK_SURF_curve_t");
top.note("headers/pk_surf_eval.html#documentation", "The return argument p is a <B>vector</B> array returning the point and possibly", "PK Reference - PK_SURF_eval");
top.note("headers/pk_surf_eval_grid.html#documentation", "The return argument p is a <B>vector</B> array returning the points, the", "PK Reference - PK_SURF_eval_grid");
top.note("headers/pk_surf_find_min_radii.html#documentation", " 2: A position <B>vector</B> indicating where on the surface the minimum of", "PK Reference - PK_SURF_find_min_radii");
top.note("headers/pk_surf_find_vectors_o_t.html#declaration", " PK_VECTOR_t help_point; --- help position <B>vector</B>", "PK Reference - PK_SURF_find_vectors_o_t");
top.note("headers/pk_surf_find_vectors_o_t.html#documentation", " point\" of the path curve is the position <B>vector</B>", "PK Reference - PK_SURF_find_vectors_o_t");
top.note("headers/pk_surf_find_vectors_r_t.html#documentation", "If PK_SURF_find_vectors successfully determines a position <B>vector</B>", "PK Reference - PK_SURF_find_vectors_r_t");
top.note("headers/pk_surf_find_vectors_t.html#documentation", "This token provides status information about whether a <B>vector</B> was found.", "PK Reference - PK_SURF_find_vectors_t");
top.note("headers/pk_surf_intersect_surf_o_t.html#declaration", " PK_LOGICAL_t have_vector; --- whether seed <B>vector</B> provided", "PK Reference - PK_SURF_intersect_surf_o_t");
top.note("headers/pk_surf_intersect_surf_o_t.html#documentation", " The option have_vector indicates whether a <B>vector</B> has been specified.", "PK Reference - PK_SURF_intersect_surf_o_t");
top.note("headers/pk_surf_offset.html#documentation", "a unit normal <B>vector</B> scaled by the offset_distance .", "PK Reference - PK_SURF_offset");
top.note("headers/pk_sweep_guide_clamp_dirn_t.html#documentation", " or a single <B>vector</B> \"constant\". (NULL)", "PK Reference - PK_sweep_guide_clamp_dirn_t");
top.note("headers/pk_swept_sf_t.html#declaration", " PK_VECTOR1_t direction; --- <B>vector</B> direction to sweep", "PK Reference - PK_SWEPT_sf_t");
top.note("headers/pk_topol_eval_mass_props_o_t.html#documentation", " correspond to a sphere centred on the answer <B>vector</B> and", "PK Reference - PK_TOPOL_eval_mass_props_o_t");
top.note("headers/pk_topol_facet_choice_o_t.html#documentation", " vertex_normal (for the index of its surface normal <B>vector</B>)", "PK Reference - PK_TOPOL_facet_choice_o_t");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#documentation", " The <B>vector</B> T represents a translation", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#documentation", " The <B>vector</B> T represents a translation", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_fctab_error_facet_t.html#documentation", " The <B>vector</B> referenced by this vertexs", "PK Reference - PK_TOPOL_fctab_error_facet_t");
top.note("headers/pk_topol_fctab_error_object_t.html#documentation", " The <B>vector</B> referenced by this datas", "PK Reference - PK_TOPOL_fctab_error_object_t");
top.note("headers/pk_topol_fctab_fin_data_t.html#documentation", " data_normal_idx (for the index of its face normal <B>vector</B>)", "PK Reference - PK_TOPOL_fctab_fin_data_t");
top.note("headers/pk_topol_fctab_vertex_point_t.html#documentation", " vertex_normal (for the index of its surface normal <B>vector</B>)", "PK Reference - PK_TOPOL_fctab_vertex_point_t");
top.note("headers/pk_topol_range.html#documentation", " <B>vector</B> : the end position on entity .", "PK Reference - PK_TOPOL_range");
top.note("headers/pk_topol_range_array.html#documentation", " <B>vector</B> : the end position on entity .", "PK Reference - PK_TOPOL_range_array");
top.note("headers/pk_topol_range_array_vector.html#declaration", " PK_VECTOR_t <B>vector</B>, --- position <B>vector</B>", "PK Reference - PK_TOPOL_range_array_vector");
top.note("headers/pk_topol_range_array_vector.html#documentation", " of topological entities topols and the position <B>vector</B> <B>vector</B> .", "PK Reference - PK_TOPOL_range_array_vector");
top.note("headers/pk_topol_range_array_vector_o_t.html#declaration", " PK_range_param_entity_t param_entity; --- option to return a <B>vector</B> and", "PK Reference - PK_TOPOL_range_array_vector_o_t");
top.note("headers/pk_topol_range_array_vector_o_t.html#documentation", " param_entity : option to return a <B>vector</B> and parameter on the sub-entity", "PK Reference - PK_TOPOL_range_array_vector_o_t");
top.note("headers/pk_topol_range_geom.html#documentation", " <B>vector</B> : the end position on entity .", "PK Reference - PK_TOPOL_range_geom");
top.note("headers/pk_topol_range_geom_array.html#documentation", " <B>vector</B> : the end position on entity .", "PK Reference - PK_TOPOL_range_geom_array");
top.note("headers/pk_topol_range_geom_o_t.html#documentation", " <B>vector</B> : end position <B>vector</B>.", "PK Reference - PK_TOPOL_range_geom_o_t");
top.note("headers/pk_topol_range_local.html#documentation", " <B>vector</B> : the end position on entity .", "PK Reference - PK_TOPOL_range_local");
top.note("headers/pk_topol_range_local_vector.html#declaration", " PK_VECTOR_t <B>vector</B>, --- position <B>vector</B>", "PK Reference - PK_TOPOL_range_local_vector");
top.note("headers/pk_topol_range_local_vector.html#documentation", "the topological entity topol and the position <B>vector</B> <B>vector</B> .", "PK Reference - PK_TOPOL_range_local_vector");
top.note("headers/pk_topol_range_local_vector_o_t.html#declaration", " PK_range_param_entity_t param_entity;--- option to return a <B>vector</B> and", "PK Reference - PK_TOPOL_range_local_vector_o_t");
top.note("headers/pk_topol_range_local_vector_o_t.html#documentation", " param_entity : option to return a <B>vector</B> and parameter on the sub-entity", "PK Reference - PK_TOPOL_range_local_vector_o_t");
top.note("headers/pk_topol_range_o_t.html#documentation", " <B>vector</B> : end position <B>vector</B>.", "PK Reference - PK_TOPOL_range_o_t");
top.note("headers/pk_topol_range_vector.html#declaration", " PK_VECTOR_t <B>vector</B>, --- position", "PK Reference - PK_TOPOL_range_vector");
top.note("headers/pk_topol_range_vector.html#documentation", "the position <B>vector</B> <B>vector</B> .", "PK Reference - PK_TOPOL_range_vector");
top.note("headers/pk_topol_range_vector_o_t.html#declaration", " PK_range_param_entity_t param_entity; --- option to return a <B>vector</B> and", "PK Reference - PK_TOPOL_range_vector_o_t");
top.note("headers/pk_topol_range_vector_o_t.html#documentation", " <B>vector</B> : end position <B>vector</B>.", "PK Reference - PK_TOPOL_range_vector_o_t");
top.note("headers/pk_transf_create_view.html#description", " returns a valid viewing transform given a unit <B>vector</B> that", "PK Reference - PK_TRANSF_create_view");
top.note("headers/pk_transf_create_view.html#documentation", "This function accepts a normalised direction <B>vector</B> and creates a viewing", "PK Reference - PK_TRANSF_create_view");
top.note("headers/pk_transf_create_view_o_t.html#declaration", " PK_LOGICAL_t have_eye_position; --- whether a perspective <B>vector</B> exists", "PK Reference - PK_TRANSF_create_view_o_t");
top.note("headers/pk_vector1_t.html#errors", " PK_ERROR_not_a_unit_vector <B>vector</B> magnitude is not 1.0", "PK Reference - PK_VECTOR1_t");
top.note("headers/pk_vector1_t.html#documentation", " type is identical to PK_VECTOR_t except that the <B>vector</B> magnitude must", "PK Reference - PK_VECTOR1_t");
top.note("headers/pk_vector_is_parallel.html#errors", " PK_ERROR_zero_vector <B>vector</B> is zero <B>vector</B> (MILD)", "PK Reference - PK_VECTOR_is_parallel");
top.note("headers/pk_vector_is_zero.html#description", " This function tests whether the given <B>vector</B> vec is zero within the", "PK Reference - PK_VECTOR_is_zero");
top.note("headers/pk_vector_make_view_transf.html#documentation", "This function accepts a normalised direction <B>vector</B> and creates a viewing", "PK Reference - PK_VECTOR_make_view_transf");
top.note("headers/pk_vector_normalise.html#declaration", " PK_VECTOR_t vec, --- direction <B>vector</B>", "PK Reference - PK_VECTOR_normalise");
top.note("headers/pk_vector_normalise.html#description", " <B>vector</B> is normalised, unless the magnitude of the <B>vector</B>", "PK Reference - PK_VECTOR_normalise");
top.note("headers/pk_vector_perpendicular.html#declaration", " PK_VECTOR1_t vector1, --- <B>vector</B>(normalised)", "PK Reference - PK_VECTOR_perpendicular");
top.note("headers/pk_vector_perpendicular.html#documentation", "produces a third normalised <B>vector</B> which is perpendicular to vector1. If", "PK Reference - PK_VECTOR_perpendicular");
top.note("headers/pk_vector_t.html#documentation", " `coord[0] X component of <B>vector</B>", "PK Reference - PK_VECTOR_t");
top.note("headers/pk_vector_transform.html#description", " function applies the given transform to the position <B>vector</B> and", "PK Reference - PK_VECTOR_transform");
top.note("headers/pk_vector_transform_direction.html#description", " function applies the given transformation to the direction <B>vector</B> and", "PK Reference - PK_VECTOR_transform_direction");
top.note("headers/pk_vertex_sweep.html#declaration", " PK_VECTOR_t path, --- translation <B>vector</B>", "PK Reference - PK_VERTEX_sweep");
top.note("headers/pk_vertex_sweep.html#documentation", " to be swept is moved along the path <B>vector</B> leaving a lateral", "PK Reference - PK_VERTEX_sweep");
top.note("chapters/di_chap.05.html#50511937_pgfId-274245", " third column of the matrix by a zero <B>vector</B>: ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275195", " are sets of four values, defining both the <B>vector</B> position of the change in visibility and its", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275196", " geom[0...2] <B>vector</B> position of first change in visibility ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275198", " geom[i...i+2] nth <B>vector</B> position, where i = 4(n-1) ", "Downward Interfaces - Graphical Output");
top.note("chapters/kd_chap.05.html#50475010_pgfId-280850", " ) ( token tag ... ) ( token <B>vector</B> ...)", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.06.html#50475013_pgfId-273906", " on a body, from a given list of <B>vector</B> points. The user can create a minimum body", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.07.html#50475033_pgfId-273958", " set, or by the magnitude of the direction <B>vector</B> if the distance property is not set. ", "KID Manual - Operations on Bodies, Curves, Surfaces, etc.");
top.note("chapters/kd_chap.07.html#50475033_pgfId-273982", " a face(set) by the supplied direction <B>vector</B>: ", "KID Manual - Operations on Bodies, Curves, Surfaces, etc.");
top.note("chapters/kd_chap.07.html#50475033_pgfId-283494", " will be moved by the direction <B>vector</B> ", "KID Manual - Operations on Bodies, Curves, Surfaces, etc.");
top.note("chapters/kd_chap.07.html#50475033_pgfId-274197", " function takes a <B>vector</B> as its argument. ", "KID Manual - Operations on Bodies, Curves, Surfaces, etc.");
top.note("chapters/kd_chap.10.html#50475015_pgfId-273860", " of those components are sub-assemblies; and its box <B>vector</B> are printed out. ", "KID Manual - Enquiries");
top.note("chapters/kd_chap.11.html#50475016_pgfId-273862", " structure can be of type: real, integer, string, <B>vector</B>, coordinate, direction or axis. ", "KID Manual - Attributes in KID");
top.note("chapters/kd_chap.11.html#50475016_pgfId-279954", "> ( myatt structure ( string <B>vector</B> real <B>vector</B> real ))", "KID Manual - Attributes in KID");
top.note("chapters/kd_chap.11.html#50475016_pgfId-273870", " to reflect the implied structure of axis, coordinate, <B>vector</B> and direction subfields. Since an object may have", "KID Manual - Attributes in KID");
top.note("chapters/kd_chap.11.html#50475016_pgfId-279915", " -- an attribute structure with 2 <B>vector</B> fields ", "KID Manual - Attributes in KID");
top.note("chapters/kd_chap.13.html#50475017_pgfId-273870", " the view direction is the <B>vector</B> from the ", "KID Manual - Viewing Environment and Definition");
top.note("chapters/kd_chap.15.html#50475034_pgfId-273900", " invoked with just one argument ( the position <B>vector</B> of the eye point in model space), the", "KID Manual - Picking");
top.note("chapters/kd_chap.15.html#50475034_pgfId-273977", " 14.4 Picking <B>vector</B> points", "KID Manual - Picking");
top.note("chapters/kd_chap.15.html#50475034_pgfId-273982", " and thus employ the cursor to select the <B>vector</B> points. Consider the following examples: ", "KID Manual - Picking");
top.note("chapters/kd_chap.15.html#50475034_pgfId-273999", " the user having moved the cursor. The selected <B>vector</B> points are located on the graphics viewing plane.", "KID Manual - Picking");
top.note("chapters/kd_chap.17.html#50475020_pgfId-290522", " box (return box <B>vector</B>) item ", "KID Manual - KID Class Structure");
top.note("chapters/kd_chap.17.html#50475020_pgfId-276535", " define <B>vector</B> as vertical in view ", "KID Manual - KID Class Structure");
top.note("chapters/kd_chap.24.html#50475028_pgfId-36504", " <B>vector</B> points ", "KID Manual - Machine Dependency in KID");
top.note("chapters/kd_chap.24.html#50475028_pgfId-37093", " <B>vector</B> points ", "KID Manual - Machine Dependency in KID");
top.note("chapters/fg_chap.05.html#50462729_pgfId-274057", " continuous if it has a continuous unit tangent <B>vector</B>, and to be C1 continuous if position and", "FG Manual - Geometric Restrictions");
top.note("chapters/fg_chap.05.html#50462729_pgfId-274058", " continuous if it has a continuous unit normal <B>vector</B>, and to be C1 continuous if position and", "FG Manual - Geometric Restrictions");
top.note("chapters/wn_chap.02.html#50466820_pgfId-7753876", " performance improvements when working with large numbers of <B>vector</B> positions. Previously, you could only supply a single", "What's New in Parasolid - What&#8217;s New in Parasolid V36.0");
top.display();
//-->
</SCRIPT>
</HEAD>
<BODY bgcolor=#FFFFFF link=#0F3A68 vlink=#878787 alink=#FF7600 leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
</BODY>
</HTML>
