<HTML>
<HEAD>
<LINK REL=STYLESHEET HREF=../ps_doc.css CHARSET=ISO-8859-1 TYPE=text/css>
<SCRIPT LANGUAGE="JavaScript">
<!--

top.note("chapters/fd_chap.003.html#50409782_pgfId-299840", " There is a special constant tag called <B>PK_ENTITY_null</B>, which is defined in the include file ", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.019.html#50409800_pgfId-314467", " steep, then there is no solution and the value <B>PK_ENTITY_null</B> is returned. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.030.html#50409810_pgfId-397783", " If these arguments are set to <B>PK_ENTITY_null</B>, the entities in the array are not transformed.", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.038.html#50409820_pgfId-308832", " If an element in this array is <B>PK_ENTITY_null</B>, then no transformation is applied to the corresponding", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-308833", " If the entire array is <B>PK_ENTITY_null</B>, then no transformations are applied to any of", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-559523", " Default: <B>PK_ENTITY_null</B> ", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.039.html#50409821_pgfId-295071", " The default is <B>PK_ENTITY_null</B>, which should also be used if ", "Functional Description - Creating Extruded Bodies");
top.note("chapters/fd_chap.044.html#50409826_pgfId-295441", " value if any other tapering method is used. Default: <B>PK_ENTITY_null</B> ", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.044.html#50409826_pgfId-297625", " sidewall body, PK_BODY_emboss assumes that the profile, if not <B>PK_ENTITY_null</B>, lies on the supplied sidewall. ", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394075", ", and so on. You should specify <B>PK_ENTITY_null</B> if you do not want to specify a help", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394668", " (Default: <B>PK_ENTITY_null</B>, <B>PK_ENTITY_null</B>) ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.067.html#50409853_pgfId-297161", " is <B>PK_ENTITY_null</B>, then any geometry already associated with its edge", "Functional Description - Replacing The Surfaces Of Faces");
top.note("chapters/fd_chap.067.html#50409853_pgfId-297193", " If you use <B>PK_ENTITY_null</B> values in the ", "Functional Description - Replacing The Surfaces Of Faces");
top.note("chapters/fd_chap.068.html#50409854_pgfId-1395194", " Default: <B>PK_ENTITY_null</B> ", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.068.html#50409854_pgfId-1395260", " Default: <B>PK_ENTITY_null</B> ", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306680", " If <B>PK_ENTITY_null</B> is supplied, then the edges original geometry should be", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306711", " If the entity is <B>PK_ENTITY_null</B>, but the edges existing geometry cannot be used.", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.077.html#50409864_pgfId-585017", " chain are equal, and the rho values array is <B>PK_ENTITY_null</B> or all rho values are zero (see Section 76.2.2.4", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-717111", " are specified, and the rho values array is <B>PK_ENTITY_null</B> or all rho values are zero(see Section 76.2.2.4 ),", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-585018", " chain are different, and the rho values array is <B>PK_ENTITY_null</B> or all rho values are zero (see Section 76.2.2.4", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.106.html#50409897_pgfId-295225", " An array entry of <B>PK_ENTITY_null</B> denotes that a particular entity should not be transformed.", "Functional Description - Rendering Functions");
top.note("chapters/fd_chap.122.html#50409915_pgfId-319051", " <B>PK_ENTITY_null</B> ", "Functional Description - Error Handling ");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275716", " The equivalent PK value is <B>PK_ENTITY_null</B>. ", "Functional Description - ZGlossary");
top.note("chapters/p2_chap.03.html#sec_b_1_1", " PK_replace_use_existing_c 22662 For edges whose corresponding curve is <B>PK_ENTITY_null</B>, treat as PK_replace_use_yes_c. Edges for which a curve", "PK Reference - PK token Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.05.html#sec_d_1_app", " PK_replace_use_existing_c 22662 For edges whose corresponding curve is <B>PK_ENTITY_null</B>, treat as PK_replace_use_yes_c. Edges for which a curve", "PK Reference - PK token Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.07.html#sec_f_1_1", " or <B>PK_ENTITY_null</B>", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_4", " <B>PK_ENTITY_null</B>", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.09.html#sec_h_1_1", " set to <B>PK_ENTITY_null</B> when the", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_3", " <B>PK_ENTITY_null</B>", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_4", " or <B>PK_ENTITY_null</B>", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.10.html#sec_i_1_1", " set to <B>PK_ENTITY_null</B> when the", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_2", " to <B>PK_ENTITY_null</B> when taper_method is", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_3", " <B>PK_ENTITY_null</B>", "PK Reference - PK Error Codes (Functional)");
top.note("headers/pk_assembly_ask_parts_transfs.html#declaration", " --- (may be <B>PK_ENTITY_null</B>)", "PK Reference - PK_ASSEMBLY_ask_parts_transfs");
top.note("headers/pk_assembly_transform.html#declaration", " PK_TRANSF_t transf --- transform (may be <B>PK_ENTITY_null</B>)", "PK Reference - PK_ASSEMBLY_transform");
top.note("headers/pk_attdef_find.html#declaration", " --- (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_ATTDEF_find");
top.note("headers/pk_attdef_find.html#documentation", "If no attribute definition with the given name exists, then <B>PK_ENTITY_null</B>", "PK Reference - PK_ATTDEF_find");
top.note("headers/pk_bcurve_create_by_fitting.html#declaration", " --- possibly <B>PK_ENTITY_null</B>", "PK Reference - PK_BCURVE_create_by_fitting");
top.note("headers/pk_bcurve_create_fitted_o_t.html#documentation", " `curve.curve.parasolid_curve = <B>PK_ENTITY_null</B>", "PK Reference - PK_BCURVE_create_fitted_o_t");
top.note("headers/pk_blend_constraint_t.html#declaration", " --- (<B>PK_ENTITY_null</B>)", "PK Reference - PK_blend_constraint_t");
top.note("headers/pk_blend_delete_unders_data_t.html#errors", " or <B>PK_ENTITY_null</B>", "PK Reference - PK_blend_delete_unders_data_t");
top.note("headers/pk_blend_delete_unders_data_t.html#documentation", "<B>PK_ENTITY_null</B> supplied as their underlying entities, where the <B>PK_ENTITY_null</B>", "PK Reference - PK_blend_delete_unders_data_t");
top.note("headers/pk_blend_shape_t.html#declaration", " --- (<B>PK_ENTITY_null</B>)", "PK Reference - PK_blend_shape_t");
top.note("headers/pk_body_ask_first_edge.html#declaration", " PK_EDGE_t *const first_edge --- an edge (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_BODY_ask_first_edge");
top.note("headers/pk_body_ask_first_face.html#declaration", " PK_FACE_t *const first_face --- a face (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_BODY_ask_first_face");
top.note("headers/pk_body_ask_parent.html#declaration", " PK_BODY_t *const parent --- parent (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_BODY_ask_parent");
top.note("headers/pk_body_emboss.html#documentation", "<B>PK_ENTITY_null</B> is only acceptable for supplied sidewall. If a sidewall body", "PK Reference - PK_BODY_emboss");
top.note("headers/pk_body_extend_o_t.html#declaration", " --- (<B>PK_ENTITY_null</B>)", "PK Reference - PK_BODY_extend_o_t");
top.note("headers/pk_body_extrude.html#documentation", " If the option extruded_body is not <B>PK_ENTITY_null</B>, this body is used to", "PK Reference - PK_BODY_extrude");
top.note("headers/pk_body_extrude_o_t.html#declaration", " --- <B>PK_ENTITY_null</B>,", "PK Reference - PK_BODY_extrude_o_t");
top.note("headers/pk_body_fill_hole_o_t.html#declaration", " --- ( <B>PK_ENTITY_null</B> ) [NF]", "PK Reference - PK_BODY_fill_hole_o_t");
top.note("headers/pk_body_fix_blends.html#declaration", " --- (may be <B>PK_ENTITY_null</B>)", "PK Reference - PK_BODY_fix_blends");
top.note("headers/pk_body_fix_blends_o_t.html#documentation", " <B>PK_ENTITY_null</B> and fault_topol will be set to one of the", "PK Reference - PK_BODY_fix_blends_o_t");
top.note("headers/pk_body_make_facet_body.html#documentation", "If transf is not <B>PK_ENTITY_null</B> and it only contains translation and rotation", "PK Reference - PK_BODY_make_facet_body");
top.note("headers/pk_body_make_persp_outline_o_t.html#declaration", " --- (<B>PK_ENTITY_null</B>)", "PK Reference - PK_BODY_make_persp_outline_o_t");
top.note("headers/pk_body_make_persp_outline_o_t.html#errors", " set to <B>PK_ENTITY_null</B> when the", "PK Reference - PK_BODY_make_persp_outline_o_t");
top.note("headers/pk_body_make_swept_body_2.html#documentation", "a path is not required. In these cases, <B>PK_ENTITY_null</B> should be specified for", "PK Reference - PK_BODY_make_swept_body_2");
top.note("headers/pk_body_make_swept_tool_o_t.html#declaration", " --- (<B>PK_ENTITY_null</B>)", "PK Reference - PK_BODY_make_swept_tool_o_t");
top.note("headers/pk_body_make_swept_tool_o_t.html#documentation", " lie in the plane normal to the path. (<B>PK_ENTITY_null</B>)", "PK Reference - PK_BODY_make_swept_tool_o_t");
top.note("headers/pk_boolean_match_region_o_t.html#declaration", " PK_TOPOL_t regions[2]; --- (<B>PK_ENTITY_null</B>, <B>PK_ENTITY_null</B>)", "PK Reference - PK_boolean_match_region_o_t");
top.note("headers/pk_boolean_region_select_o_t.html#documentation", "<B>PK_ENTITY_null</B> may be given, in which case the closest face from the tool", "PK Reference - PK_boolean_region_select_o_t");
top.note("headers/pk_bsurf_create_constrained_o_t.html#declaration", " --- projection (<B>PK_ENTITY_null</B>)", "PK Reference - PK_BSURF_create_constrained_o_t");
top.note("headers/pk_bsurf_create_constrained_o_t.html#documentation", " (<B>PK_ENTITY_null</B>)", "PK Reference - PK_BSURF_create_constrained_o_t");
top.note("headers/pk_bsurf_create_fitted_o_t.html#documentation", " `surf.surf.parasolid_surf = <B>PK_ENTITY_null</B>", "PK Reference - PK_BSURF_create_fitted_o_t");
top.note("headers/pk_change_edge_geom_data_t.html#documentation", " <B>PK_ENTITY_null</B> this_indicates that the geometry of the", "PK Reference - PK_change_edge_geom_data_t");
top.note("headers/pk_check_fault_t.html#declaration", " --- (may be <B>PK_ENTITY_null</B>)", "PK Reference - PK_check_fault_t");
top.note("headers/pk_check_fault_t.html#documentation", "<B>PK_ENTITY_null</B>, and if position is not used (no description is given in the", "PK Reference - PK_check_fault_t");
top.note("headers/pk_curve_ask_fin.html#declaration", " PK_FIN_t *const fin --- owning fin (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_CURVE_ask_fin");
top.note("headers/pk_curve_ask_part.html#declaration", " PK_PART_t *const part --- owning part (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_CURVE_ask_part");
top.note("headers/pk_curve_general_t.html#documentation", " Parasolid can process. (<B>PK_ENTITY_null</B>)", "PK Reference - PK_CURVE_general_t");
top.note("headers/pk_curve_intersect_curve_o_t.html#declaration", " --- <B>PK_ENTITY_null</B> (<B>PK_ENTITY_null</B>)", "PK Reference - PK_CURVE_intersect_curve_o_t");
top.note("headers/pk_curve_make_bcurve_res_t.html#documentation", " bcurve : Resultant B-curve. This may be <B>PK_ENTITY_null</B>", "PK Reference - PK_CURVE_make_bcurve_res_t");
top.note("headers/pk_debug_local_diffs_r_t.html#documentation", " master_entity The entity (or <B>PK_ENTITY_null</B>) in the master body.", "PK Reference - PK_DEBUG_local_diffs_r_t");
top.note("headers/pk_edge_ask_curve.html#declaration", " PK_CURVE_t *const curve --- its curve (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_EDGE_ask_curve");
top.note("headers/pk_edge_ask_curve_nmnl.html#declaration", " PK_CURVE_t *const curve --- its curve (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_EDGE_ask_curve_nmnl");
top.note("headers/pk_edge_ask_first_fin.html#declaration", " PK_FIN_t *const first_fin --- the first fin (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_EDGE_ask_first_fin");
top.note("headers/pk_edge_ask_first_fin.html#description", " edge is wireframe and so has no fins, then <B>PK_ENTITY_null</B> will be", "PK Reference - PK_EDGE_ask_first_fin");
top.note("headers/pk_edge_ask_geometry.html#declaration", " PK_CURVE_t *const curve, --- curve of edge (may be <B>PK_ENTITY_null</B>)", "PK Reference - PK_EDGE_ask_geometry");
top.note("headers/pk_edge_ask_geometry.html#documentation", "otherwise <B>PK_ENTITY_null</B> will be returned. If curve is returned as", "PK Reference - PK_EDGE_ask_geometry");
top.note("headers/pk_edge_ask_geometry_nmnl.html#declaration", " PK_CURVE_t *const curve, --- curve of edge (may be <B>PK_ENTITY_null</B>)", "PK Reference - PK_EDGE_ask_geometry_nmnl");
top.note("headers/pk_edge_ask_geometry_nmnl.html#documentation", "returned, otherwise <B>PK_ENTITY_null</B> will be returned. If curve is returned as", "PK Reference - PK_EDGE_ask_geometry_nmnl");
top.note("headers/pk_edge_ask_next_in_body.html#declaration", " PK_EDGE_t *const next --- the next edge (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_EDGE_ask_next_in_body");
top.note("headers/pk_edge_ask_next_in_body.html#documentation", "by PK_BODY_ask_edges . If the edge is the last in the body, then <B>PK_ENTITY_null</B>", "PK Reference - PK_EDGE_ask_next_in_body");
top.note("headers/pk_edge_ask_oriented_curve.html#declaration", " PK_CURVE_t *const curve, --- the curve (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_EDGE_ask_oriented_curve");
top.note("headers/pk_edge_ask_oriented_curve.html#documentation", "returned as <B>PK_ENTITY_null</B>, and the value of orientation is unspecified.", "PK Reference - PK_EDGE_ask_oriented_curve");
top.note("headers/pk_edge_ask_vertices.html#declaration", " PK_VERTEX_t vertices[2] --- vertices (possibly both <B>PK_ENTITY_null</B>)", "PK Reference - PK_EDGE_ask_vertices");
top.note("headers/pk_edge_curve_direction_t.html#declaration", " --- (<B>PK_ENTITY_null</B>)", "PK Reference - PK_EDGE_curve_direction_t");
top.note("headers/pk_edge_imprint_point.html#declaration", " PK_EDGE_t *const new_edge --- new edge (may be <B>PK_ENTITY_null</B>)", "PK Reference - PK_EDGE_imprint_point");
top.note("headers/pk_edge_is_planar.html#declaration", " --- otherwise <B>PK_ENTITY_null</B>", "PK Reference - PK_EDGE_is_planar");
top.note("headers/pk_edge_set_blend_constant_o_t.html#declaration", " PK_EDGE_t cliff_edge; --- top of cliff (<B>PK_ENTITY_null</B>) [NF]", "PK Reference - PK_EDGE_set_blend_constant_o_t");
top.note("headers/pk_edge_split_at_param.html#documentation", "originally had no vertices, new_edge will be returned as <B>PK_ENTITY_null</B>,", "PK Reference - PK_EDGE_split_at_param");
top.note("headers/pk_emboss_sidewall_data_t.html#declaration", " --- (<B>PK_ENTITY_null</B>)", "PK Reference - PK_emboss_sidewall_data_t");
top.note("headers/pk_entity_ask_attribs.html#description", "<B>PK_ENTITY_null</B>, then all attributes of any type are returned.", "PK Reference - PK_ENTITY_ask_attribs");
top.note("headers/pk_entity_ask_description.html#documentation", " the entity. If the tag value is set to <B>PK_ENTITY_null</B>,", "PK Reference - PK_ENTITY_ask_description");
top.note("headers/pk_entity_ask_first_attrib.html#declaration", " --- (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_ENTITY_ask_first_attrib");
top.note("headers/pk_entity_ask_first_attrib.html#documentation", "If there are no such attributes, then <B>PK_ENTITY_null</B> is returned.", "PK Reference - PK_ENTITY_ask_first_attrib");
top.note("headers/pk_entity_check_attribs.html#documentation", " the given attribute definition. attdef can be set to <B>PK_ENTITY_null</B>, in", "PK Reference - PK_ENTITY_check_attribs");
top.note("headers/pk_entity_delete_attribs.html#description", "<B>PK_ENTITY_null</B>, all attributes, of any type, are deleted.", "PK Reference - PK_ENTITY_delete_attribs");
top.note("headers/pk_entity_range.html#documentation", "perspective component set, or <B>PK_ENTITY_null</B> (in which case it is treated as", "PK Reference - PK_ENTITY_range");
top.note("headers/pk_entity_range_end_t.html#declaration", " --- (<B>PK_ENTITY_null</B>)", "PK Reference - PK_ENTITY_range_end_t");
top.note("headers/pk_entity_range_vector.html#documentation", "perspective component set, or <B>PK_ENTITY_null</B> (in which case it is treated as", "PK Reference - PK_ENTITY_range_vector");
top.note("headers/pk_error_sf_t.html#declaration", " --- <B>PK_ENTITY_null</B>", "PK Reference - PK_ERROR_sf_t");
top.note("headers/pk_face_ask_first_loop.html#declaration", " PK_LOOP_t *const first_loop --- the first loop (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_FACE_ask_first_loop");
top.note("headers/pk_face_ask_first_loop.html#documentation", "<B>PK_ENTITY_null</B> will be returned.", "PK Reference - PK_FACE_ask_first_loop");
top.note("headers/pk_face_ask_next_in_body.html#declaration", " PK_FACE_t *const next --- the next face (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_FACE_ask_next_in_body");
top.note("headers/pk_face_ask_next_in_body.html#documentation", " PK_BODY_ask_faces . If the face is the last in the body, then <B>PK_ENTITY_null</B>", "PK Reference - PK_FACE_ask_next_in_body");
top.note("headers/pk_face_ask_oriented_surf.html#declaration", " PK_SURF_t *const surf, --- the surface (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_FACE_ask_oriented_surf");
top.note("headers/pk_face_ask_oriented_surf.html#documentation", " face has no surface then surf is returned as <B>PK_ENTITY_null</B>, and", "PK Reference - PK_FACE_ask_oriented_surf");
top.note("headers/pk_face_ask_surf.html#declaration", " PK_SURF_t *const surf --- its surface (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_FACE_ask_surf");
top.note("headers/pk_face_change_data_offset_t.html#documentation", " If the offset option reference is <B>PK_ENTITY_null</B>", "PK Reference - PK_FACE_change_data_offset_t");
top.note("headers/pk_face_change_offset_o_t.html#declaration", " PK_FACE_t reference; --- reference face (<B>PK_ENTITY_null</B>)", "PK Reference - PK_FACE_change_offset_o_t");
top.note("headers/pk_face_change_offset_o_t.html#documentation", " If reference is set to <B>PK_ENTITY_null</B>, then", "PK Reference - PK_FACE_change_offset_o_t");
top.note("headers/pk_face_change_taper_o_t.html#declaration", " PK_BODY_t parting_body; --- parting body (<B>PK_ENTITY_null</B>)", "PK Reference - PK_FACE_change_taper_o_t");
top.note("headers/pk_face_emboss.html#errors", " to <B>PK_ENTITY_null</B> when taper_method is", "PK Reference - PK_FACE_emboss");
top.note("headers/pk_face_emboss.html#documentation", "<B>PK_ENTITY_null</B> is only acceptable for supplied sidewall. If a sidewall body", "PK Reference - PK_FACE_emboss");
top.note("headers/pk_face_find_outer_loop.html#documentation", "<B>PK_ENTITY_null</B> will be returned.", "PK Reference - PK_FACE_find_outer_loop");
top.note("headers/pk_face_hollow_2.html#documentation", "<B>PK_ENTITY_null</B>) and so there is still not necessarily a one to one", "PK Reference - PK_FACE_hollow_2");
top.note("headers/pk_face_intersect_curve.html#documentation", " | or <B>PK_ENTITY_null</B> | the surface of the face", "PK Reference - PK_FACE_intersect_curve");
top.note("headers/pk_face_is_coincident_o_t.html#declaration", " --- (<B>PK_ENTITY_null</B>)", "PK Reference - PK_FACE_is_coincident_o_t");
top.note("headers/pk_face_make_blend_o_t.html#declaration", " --- (<B>PK_ENTITY_null</B>)", "PK Reference - PK_FACE_make_blend_o_t");
top.note("headers/pk_face_pattern_2.html#documentation", " original_faces array, but <B>PK_ENTITY_null</B> will be the corresponding entry", "PK Reference - PK_FACE_pattern_2");
top.note("headers/pk_face_taper_o_t.html#declaration", " PK_SURF_t top_surface; --- top surface (<B>PK_ENTITY_null</B>)", "PK Reference - PK_FACE_taper_o_t");
top.note("headers/pk_fcurve_sf_t.html#declaration", " PK_TRANSF_t transf; --- transformation (may be <B>PK_ENTITY_null</B>)", "PK Reference - PK_FCURVE_sf_t");
top.note("headers/pk_fin_ask_curve.html#declaration", " PK_CURVE_t *const curve --- its curve (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_FIN_ask_curve");
top.note("headers/pk_fin_ask_geometry.html#declaration", " PK_CURVE_t *const curve, --- curve of fin (may be <B>PK_ENTITY_null</B>)", "PK Reference - PK_FIN_ask_geometry");
top.note("headers/pk_fin_ask_geometry.html#documentation", "otherwise <B>PK_ENTITY_null</B> will be returned. If curve is returned as", "PK Reference - PK_FIN_ask_geometry");
top.note("headers/pk_fin_ask_oriented_curve.html#declaration", " PK_CURVE_t *const curve, --- the curve (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_FIN_ask_oriented_curve");
top.note("headers/pk_fin_ask_oriented_curve.html#documentation", "returned as <B>PK_ENTITY_null</B>, and the value of orientation is unspecified.", "PK Reference - PK_FIN_ask_oriented_curve");
top.note("headers/pk_frame_ask_owner.html#description", "otherwise <B>PK_ENTITY_NULL</B>", "PK Reference - PK_FRAME_ask_owner");
top.note("headers/pk_fsurf_sf_t.html#declaration", " PK_TRANSF_t transf; --- transformation (may be <B>PK_ENTITY_null</B>)", "PK Reference - PK_FSURF_sf_t");
top.note("headers/pk_geom_enlarge.html#declaration", " --- <B>PK_ENTITY_null</B> entries )", "PK Reference - PK_GEOM_enlarge");
top.note("headers/pk_geom_range.html#documentation", " sub_entity : not applicable, <B>PK_ENTITY_null</B> will be returned.", "PK Reference - PK_GEOM_range");
top.note("headers/pk_geom_range_array.html#documentation", " sub_entity : not applicable, <B>PK_ENTITY_null</B> will be returned.", "PK Reference - PK_GEOM_range_array");
top.note("headers/pk_geom_range_array_vector.html#documentation", " sub_entity : not applicable, <B>PK_ENTITY_null</B> will be returned.", "PK Reference - PK_GEOM_range_array_vector");
top.note("headers/pk_geom_range_local.html#documentation", " sub_entity : not applicable, <B>PK_ENTITY_null</B> will be returned.", "PK Reference - PK_GEOM_range_local");
top.note("headers/pk_geom_range_local_vector.html#documentation", " sub_entity : not applicable, <B>PK_ENTITY_null</B> will be returned.", "PK Reference - PK_GEOM_range_local_vector");
top.note("headers/pk_geom_range_vector.html#documentation", " sub_entity : not applicable, <B>PK_ENTITY_null</B> will be returned.", "PK Reference - PK_GEOM_range_vector");
top.note("headers/pk_geom_range_vector_many.html#documentation", " sub_entity not applicable, <B>PK_ENTITY_null</B> will be returned.", "PK Reference - PK_GEOM_range_vector_many");
top.note("headers/pk_geom_render.html#documentation", "<B>PK_ENTITY_null</B>, indicating that the corresponding entity in geoms is not to", "PK Reference - PK_GEOM_render");
top.note("headers/pk_geom_render_line.html#documentation", "If a geom_transfs entry is set to <B>PK_ENTITY_null</B>, it implies that the", "PK Reference - PK_GEOM_render_line");
top.note("headers/pk_instance_replace_transf.html#declaration", " --- (may be <B>PK_ENTITY_null</B>)", "PK Reference - PK_INSTANCE_replace_transf");
top.note("headers/pk_instance_replace_transf.html#documentation", "transform is not <B>PK_ENTITY_null</B>, then it must be an orphan in the", "PK Reference - PK_INSTANCE_replace_transf");
top.note("headers/pk_instance_sf_t.html#declaration", " --- reflection or <B>PK_ENTITY_null</B>)", "PK Reference - PK_INSTANCE_sf_t");
top.note("headers/pk_instance_sf_t.html#documentation", "<B>PK_ENTITY_null</B>, then it is treated as the identity transform.", "PK Reference - PK_INSTANCE_sf_t");
top.note("headers/pk_instance_transform.html#declaration", " PK_TRANSF_t transf --- transform (may be <B>PK_ENTITY_null</B>)", "PK Reference - PK_INSTANCE_transform");
top.note("headers/pk_lattice_ask_part.html#declaration", " PK_PART_t *const part --- owning part (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_LATTICE_ask_part");
top.note("headers/pk_loop_ask_first_fin.html#declaration", " PK_FIN_t *const first_fin --- the first fin (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_LOOP_ask_first_fin");
top.note("headers/pk_loop_ask_first_fin.html#documentation", " an isolated loop, and so has no fins, then <B>PK_ENTITY_null</B> will", "PK Reference - PK_LOOP_ask_first_fin");
top.note("headers/pk_loop_ask_next_in_face.html#declaration", " PK_LOOP_t *const next --- the next loop (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_LOOP_ask_next_in_face");
top.note("headers/pk_loop_ask_next_in_face.html#documentation", " If the loop is the last in the face, <B>PK_ENTITY_null</B> will", "PK Reference - PK_LOOP_ask_next_in_face");
top.note("headers/pk_loop_euler_delete_make_edge.html#errors", " <B>PK_ENTITY_null</B>", "PK Reference - PK_LOOP_euler_delete_make_edge");
top.note("headers/pk_ltopol_is_null_m.html#documentation", " (l).lattice == <B>PK_ENTITY_null</B> && (l).ltopol == 0 ? \", "PK Reference - PK_LTOPOL_is_null_m");
top.note("headers/pk_ltopol_null_m.html#documentation", "A null ltopol is a PK_LTOPOL_t with lattice=<B>PK_ENTITY_null</B> and ltopol=0.", "PK Reference - PK_LTOPOL_null_m");
top.note("headers/pk_mtopol_is_null_m.html#documentation", " (m).mesh == <B>PK_ENTITY_null</B> && (m).mtopol == 0 ? \", "PK Reference - PK_MTOPOL_is_null_m");
top.note("headers/pk_mtopol_null_m.html#documentation", "A null mtopol is a PK_MTOPOL_t with mesh=<B>PK_ENTITY_null</B> and mtopol=0.", "PK Reference - PK_MTOPOL_null_m");
top.note("headers/pk_part_ask_all_attribs.html#description", "<B>PK_ENTITY_null</B>, all attributes are returned, of any type.", "PK Reference - PK_PART_ask_all_attribs");
top.note("headers/pk_part_ask_attribs_cb_o_t.html#declaration", " PK_ATTDEF_t attdef; --- attribute definition (<B>PK_ENTITY_null</B>)", "PK Reference - PK_PART_ask_attribs_cb_o_t");
top.note("headers/pk_part_ask_attribs_cb_o_t.html#documentation", " callback function. If the definition is <B>PK_ENTITY_null</B>,", "PK Reference - PK_PART_ask_attribs_cb_o_t");
top.note("headers/pk_part_delete_attribs.html#documentation", " attdefs . If any of the definitions is <B>PK_ENTITY_null</B>, all attributes", "PK Reference - PK_PART_delete_attribs");
top.note("headers/pk_part_find_entity_by_ident.html#declaration", " PK_ENTITY_t *const entity --- entity (may be <B>PK_ENTITY_null</B>)", "PK Reference - PK_PART_find_entity_by_ident");
top.note("headers/pk_part_find_entity_by_ident.html#documentation", " entity with the given identifier is not found then <B>PK_ENTITY_null</B> is", "PK Reference - PK_PART_find_entity_by_ident");
top.note("headers/pk_point_ask_part.html#declaration", " PK_PART_t *const part --- owning part (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_POINT_ask_part");
top.note("headers/pk_point_ask_vertex.html#declaration", " PK_VERTEX_t *const vertex --- owning vertex (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_POINT_ask_vertex");
top.note("headers/pk_range_end_t.html#declaration", " --- (<B>PK_ENTITY_null</B>)", "PK Reference - PK_range_end_t");
top.note("headers/pk_replace_edge_data_t.html#documentation", " The value <B>PK_ENTITY_null</B> in this array indicates that the", "PK Reference - PK_replace_edge_data_t");
top.note("headers/pk_replace_use_t.html#documentation", " <B>PK_ENTITY_null</B>, treat as PK_replace_use_yes_c.", "PK Reference - PK_replace_use_t");
top.note("headers/pk_shell_ask_acorn_vertex.html#declaration", " PK_VERTEX_t *const vertex --- its acorn vertex (or <B>PK_ENTITY_null</B>)", "PK Reference - PK_SHELL_ask_acorn_vertex");
top.note("headers/pk_shell_ask_acorn_vertex.html#description", "is of type PK_SHELL_type_acorn_c, otherwise <B>PK_ENTITY_null</B> is returned.", "PK Reference - PK_SHELL_ask_acorn_vertex");
top.note("headers/pk_surf_ask_part.html#declaration", " PK_PART_t *const part --- owning part (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_SURF_ask_part");
top.note("headers/pk_surf_general_t.html#documentation", " Parasolid can process. (<B>PK_ENTITY_null</B>)", "PK Reference - PK_SURF_general_t");
top.note("headers/pk_surf_make_bsurf_res_t.html#documentation", " bsurf : Resultant B-surface. This may be <B>PK_ENTITY_null</B>", "PK Reference - PK_SURF_make_bsurf_res_t");
top.note("headers/pk_topol_ask_entities_by_attdef.html#declaration", " --- ( may be <B>PK_ENTITY_null</B> )", "PK Reference - PK_TOPOL_ask_entities_by_attdef");
top.note("headers/pk_topol_ask_entities_by_attdef.html#documentation", " <B>PK_ENTITY_null</B>, meaning an attribute of any attribute definition.", "PK Reference - PK_TOPOL_ask_entities_by_attdef");
top.note("headers/pk_topol_clash.html#documentation", "If you supply <B>PK_ENTITY_null</B> in place of a transform,", "PK Reference - PK_TOPOL_clash");
top.note("headers/pk_topol_clash_o_t.html#declaration", " --- ( <B>PK_ENTITY_null</B> )", "PK Reference - PK_TOPOL_clash_o_t");
top.note("headers/pk_topol_eval_mass_props_o_t.html#documentation", " reflection, or <B>PK_ENTITY_null</B> (in which case it is", "PK Reference - PK_TOPOL_eval_mass_props_o_t");
top.note("headers/pk_topol_facet.html#documentation", " . Any entry in the topol_transfs array can be <B>PK_ENTITY_null</B>,", "PK Reference - PK_TOPOL_facet");
top.note("headers/pk_topol_facet_2.html#documentation", " . Any entry in the topol_transfs array can be <B>PK_ENTITY_null</B>,", "PK Reference - PK_TOPOL_facet_2");
top.note("headers/pk_topol_find_box_2.html#documentation", "<B>PK_ENTITY_null</B> indicating that the corresponding entry in topols is not", "PK Reference - PK_TOPOL_find_box_2");
top.note("headers/pk_topol_find_nabox.html#documentation", "corresponding entity in transfs . Any entry in transfs may be <B>PK_ENTITY_null</B>", "PK Reference - PK_TOPOL_find_nabox");
top.note("headers/pk_topol_render_facet.html#documentation", "Any entry in the topol_transfs array can be <B>PK_ENTITY_null</B>, indicating that", "PK Reference - PK_TOPOL_render_facet");
top.note("headers/pk_topol_render_line.html#documentation", "If a topol_transfs entry is set to <B>PK_ENTITY_null</B>, it implies that the", "PK Reference - PK_TOPOL_render_line");
top.note("headers/pk_topol_render_volume.html#documentation", "Any entry in the topol_transfs array can be <B>PK_ENTITY_null</B>, indicating that", "PK Reference - PK_TOPOL_render_volume");
top.note("headers/pk_vertex_ask_point.html#declaration", " PK_POINT_t *const point --- its point (possibly <B>PK_ENTITY_null</B>)", "PK Reference - PK_VERTEX_ask_point");
top.note("chapters/di_chap.05.html#50511937_pgfId-275317", " <B>PK_ENTITY_null</B> indicates that the region of the picture on that", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-302903", " in the rendered image, shown in red. For simplicity, <B>PK_ENTITY_null</B> is shown as 0 in the illustration, and ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-304220", " For each segment with only one adjacent face, <B>PK_ENTITY_null</B> is returned for the side that has no face.", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-303898", " segment that is completely obscured in the rendered image, <B>PK_ENTITY_null</B> is returned for both left and right faces. ", "Downward Interfaces - Graphical Output");
top.display();
//-->
</SCRIPT>
</HEAD>
<BODY bgcolor=#FFFFFF link=#0F3A68 vlink=#878787 alink=#FF7600 leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
</BODY>
</HTML>
