<HTML>
<HEAD>
<LINK REL=STYLESHEET HREF=../ps_doc.css CHARSET=ISO-8859-1 TYPE=text/css>
<SCRIPT LANGUAGE="JavaScript">
<!--

top.note("chapters/fd_chap.010.html#50409790_pgfId-556513", " type **<B>const</B> name ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-556522", " int * <B>const</B> n_faces, // number of faces (>= 0) ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-556523", " PK_FACE_t ** <B>const</B> faces // faces (optional) ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-335125", " 9.2.5 Use of <B>const</B> ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-294794", "<B>const</B> ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-294796", " <B>const</B> PK_LINE_sf_t *line_sf ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-294797", "int *<B>const</B> n_edges ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-556542", "<B>const</B> ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-556546", " <B>const</B> type *arg ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-387353", "type *<B>const</B> name ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-556597", "type **<B>const</B> name ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-556608", "type **<B>const</B> name ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-294867", " PK_BCURVE_sf_t *<B>const</B> bcurve_sf ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-294872", " type **<B>const</B> name ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.097.html#50409887_pgfId-325889", " (<B>const</B> PK_ATTDEF_sf_2_t *attdef_sf, ", "Functional Description - Attributes");
top.note("chapters/fd_chap.097.html#50409887_pgfId-325896", " <B>const</B> int field_lengths[], ", "Functional Description - Attributes");
top.note("chapters/fd_chap.097.html#50409887_pgfId-325903", " <B>const</B> PK_ATTRIB_field_values_t field_values[], ", "Functional Description - Attributes");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285266", " typedef <B>const</B> char *( * PK_ATTDEF_name_cb_f_t ) ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285268", " <B>const</B> PK_ATTDEF_sf_2_t *, /* attribute definition standard form */", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285293", " <B>const</B> PK_FACE_t [], /* faces in hole detail */", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285319", "<B>const</B> ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285738", " int (*open_rd) ( int keylen, <B>const</B> char* key, int *strid); ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285739", " int (*open_wr) ( int keylen, <B>const</B> char* key, int *strid); ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285747", " int (*wr_chars) ( int strid, int n, <B>const</B> char *data); ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285748", " int (*wr_bytes) ( int strid, int n, <B>const</B> unsigned char ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285750", " int (*wr_shorts) ( int strid, int n, <B>const</B> short *data); ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285751", " int (*wr_ints) ( int strid, int n, <B>const</B> int *data); ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285752", " int (*wr_doubles) ( int strid, int n, <B>const</B> double *data); ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285756", " int (*open_uc_rd) ( <B>const</B> PK_UCHAR_t *key, int *strid); ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285757", " int (*open_uc_wr) ( <B>const</B> PK_UCHAR_t *key, int *strid); ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285759", " ( int guise, int keylen, <B>const</B> char* key, int *strid); ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285761", " ( int guise, int keylen, <B>const</B> char* key, int *strid); ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285763", " ( int guise, <B>const</B> PK_UCHAR_t *key, int *strid); ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285765", " ( int guise, <B>const</B> PK_UCHAR_t *key, int *strid); ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285885", " PK_LOGICAL_t * <B>const</B> is_appitem ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285920", " <B>const</B> double doubles[] /* doubles to set */ ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285967", " <B>const</B> PK_BCURVE_create_fitted_o_t *options, /* options for fitting */ ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285968", " PK_BCURVE_t * <B>const</B> *bcurve, /* B-curve fit to input */ ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285969", " PK_BCURVE_fitted_fault_t * <B>const</B> *fault /* any faults found */ ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-286151", " <B>const</B> PK_SESSION_applio_t *new /* functions to register (may be", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-286241", " <B>const</B> char* field_name, /* field name */ ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-286242", " <B>const</B> PK_UCHAR_t * string /* null-terminated string to set", "Functional Description - How the C# Binding is Implemented");
top.note("headers/pk_appitem_ask.html#declaration", "<B>const</B> PK_APPITEM_t appitems[], --- appitems", "PK Reference - PK_APPITEM_ask");
top.note("headers/pk_appitem_create.html#declaration", "<B>const</B> PK_POINTER_t pointers[],", "PK Reference - PK_APPITEM_create");
top.note("headers/pk_appitem_delete.html#declaration", "<B>const</B> PK_APPITEM_t appitems[] --- appitem to receive message", "PK Reference - PK_APPITEM_delete");
top.note("headers/pk_appitem_is.html#declaration", " PK_LOGICAL_t *<B>const</B> is_appitem", "PK Reference - PK_APPITEM_is");
top.note("headers/pk_appitem_reset_pointers.html#declaration", "<B>const</B> PK_APPITEM_t appitems[], --- appitems", "PK Reference - PK_APPITEM_reset_pointers");
top.note("headers/pk_assembly_ask_instances.html#declaration", " int *<B>const</B> n_instances, --- number of instances in assembly (>=0)", "PK Reference - PK_ASSEMBLY_ask_instances");
top.note("headers/pk_assembly_ask_parts.html#declaration", " int *<B>const</B> n_parts, --- number of parts in assembly (>=0)", "PK Reference - PK_ASSEMBLY_ask_parts");
top.note("headers/pk_assembly_ask_parts_transfs.html#declaration", " int *<B>const</B> n_parts, --- number of parts in assembly (>=0)", "PK Reference - PK_ASSEMBLY_ask_parts_transfs");
top.note("headers/pk_assembly_check.html#declaration", "<B>const</B> PK_ASSEMBLY_check_o_t *options, --- options structure", "PK Reference - PK_ASSEMBLY_check");
top.note("headers/pk_assembly_check_r_f.html#declaration", " PK_ASSEMBLY_check_r_t *<B>const</B> result --- result structure", "PK Reference - PK_ASSEMBLY_check_r_f");
top.note("headers/pk_assembly_create_empty.html#declaration", " PK_ASSEMBLY_t *<B>const</B> assembly --- created assembly", "PK Reference - PK_ASSEMBLY_create_empty");
top.note("headers/pk_assembly_make_level_assembly.html#declaration", " PK_ASSEMBLY_t *<B>const</B> level_assembly --- level assembly", "PK Reference - PK_ASSEMBLY_make_level_assembly");
top.note("headers/pk_attdef_ask.html#declaration", " PK_ATTDEF_sf_t *<B>const</B> attsf", "PK Reference - PK_ATTDEF_ask");
top.note("headers/pk_attdef_ask_2.html#declaration", " PK_ATTDEF_sf_2_t *<B>const</B> attsf", "PK Reference - PK_ATTDEF_ask_2");
top.note("headers/pk_attdef_ask_callback_flags.html#declaration", " PK_ATTDEF_callback_flags_t *<B>const</B> flags --- callback flags", "PK Reference - PK_ATTDEF_ask_callback_flags");
top.note("headers/pk_attdef_ask_callbacks.html#declaration", " PK_ATTDEF_callback_fns_t *<B>const</B> callbacks --- callback functions", "PK Reference - PK_ATTDEF_ask_callbacks");
top.note("headers/pk_attdef_copy_callback_f_t.html#declaration", "<B>const</B> PK_ATTRIB_t attribs[], --- attribs on old_entity ", "PK Reference - PK_ATTDEF_copy_callback_f_t");
top.note("headers/pk_attdef_create.html#declaration", " <B>const</B> PK_ATTDEF_sf_t *attsf,", "PK Reference - PK_ATTDEF_create");
top.note("headers/pk_attdef_create_2.html#declaration", " <B>const</B> PK_ATTDEF_sf_2_t *attsf,", "PK Reference - PK_ATTDEF_create_2");
top.note("headers/pk_attdef_delete_callback_f_t.html#declaration", "<B>const</B> PK_ATTRIB_t attribs[] --- attribs on entity ", "PK Reference - PK_ATTDEF_delete_callback_f_t");
top.note("headers/pk_attdef_find.html#declaration", " <B>const</B> char *name, --- attribute definition name", "PK Reference - PK_ATTDEF_find");
top.note("headers/pk_attdef_is_group_closing.html#declaration", "<B>const</B> PK_ATTDEF_is_group_closing_o_t *options, --- options", "PK Reference - PK_ATTDEF_is_group_closing");
top.note("headers/pk_attdef_merge_callback_f_t.html#declaration", "<B>const</B> PK_ATTRIB_t live_attribs[], --- attribs on live_entity ", "PK Reference - PK_ATTDEF_merge_callback_f_t");
top.note("headers/pk_attdef_name_cb_f_t.html#declaration", " typedef <B>const</B> char *(*PK_ATTDEF_name_cb_f_t)", "PK Reference - PK_ATTDEF_name_cb_f_t");
top.note("headers/pk_attdef_receive_callback_f_t.html#declaration", "<B>const</B> PK_ATTRIB_t attribs[] --- attribs on entity ", "PK Reference - PK_ATTDEF_receive_callback_f_t");
top.note("headers/pk_attdef_register_callbacks.html#declaration", "<B>const</B> PK_ATTDEF_callback_fns_t *callbacks --- callback functions", "PK Reference - PK_ATTDEF_register_callbacks");
top.note("headers/pk_attdef_register_cb.html#declaration", "<B>const</B> PK_ATTDEF_callback_fns_t *callbacks, --- callback functions", "PK Reference - PK_ATTDEF_register_cb");
top.note("headers/pk_attdef_set_callback_flags.html#declaration", "<B>const</B> PK_ATTDEF_callback_flags_t *flags --- callback flags", "PK Reference - PK_ATTDEF_set_callback_flags");
top.note("headers/pk_attdef_set_group_closing.html#declaration", "<B>const</B> PK_ATTDEF_set_group_closing_o_t *options --- options", "PK Reference - PK_ATTDEF_set_group_closing");
top.note("headers/pk_attdef_split_callback_f_t.html#declaration", "<B>const</B> PK_ATTRIB_t attribs[], --- attribs on old_entity ", "PK Reference - PK_ATTDEF_split_callback_f_t");
top.note("headers/pk_attdef_transmit_callback_f_t.html#declaration", "<B>const</B> PK_ATTRIB_t attribs[] --- attribs on entity ", "PK Reference - PK_ATTDEF_transmit_callback_f_t");
top.note("headers/pk_attrib_ask_attdef.html#declaration", " PK_ATTDEF_t *<B>const</B> attdef --- attribute definition", "PK Reference - PK_ATTRIB_ask_attdef");
top.note("headers/pk_attrib_ask_axes.html#declaration", " int *<B>const</B> n_axes, --- number of axes (>=0)", "PK Reference - PK_ATTRIB_ask_axes");
top.note("headers/pk_attrib_ask_doubles.html#declaration", " int *<B>const</B> n_doubles, --- number of doubles (>=0)", "PK Reference - PK_ATTRIB_ask_doubles");
top.note("headers/pk_attrib_ask_ints.html#declaration", " int *<B>const</B> n_ints, --- number of ints (>= 0)", "PK Reference - PK_ATTRIB_ask_ints");
top.note("headers/pk_attrib_ask_named_axes.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_ask_named_axes");
top.note("headers/pk_attrib_ask_named_doubles.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_ask_named_doubles");
top.note("headers/pk_attrib_ask_named_ints.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_ask_named_ints");
top.note("headers/pk_attrib_ask_named_pointers.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_ask_named_pointers");
top.note("headers/pk_attrib_ask_named_string.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_ask_named_string");
top.note("headers/pk_attrib_ask_named_ustring.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_ask_named_ustring");
top.note("headers/pk_attrib_ask_named_vectors.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_ask_named_vectors");
top.note("headers/pk_attrib_ask_no_roll.html#declaration", "<B>const</B> PK_ATTRIB_t attribs[], --- attributes", "PK Reference - PK_ATTRIB_ask_no_roll");
top.note("headers/pk_attrib_ask_nth_axis.html#declaration", " PK_AXIS1_sf_t *<B>const</B> axis --- nth axis", "PK Reference - PK_ATTRIB_ask_nth_axis");
top.note("headers/pk_attrib_ask_nth_double.html#declaration", " double *<B>const</B> d --- nth double.", "PK Reference - PK_ATTRIB_ask_nth_double");
top.note("headers/pk_attrib_ask_nth_int.html#declaration", " int *<B>const</B> n --- nth integer", "PK Reference - PK_ATTRIB_ask_nth_int");
top.note("headers/pk_attrib_ask_nth_pointer.html#declaration", " PK_POINTER_t *<B>const</B> pointer --- nth pointer.", "PK Reference - PK_ATTRIB_ask_nth_pointer");
top.note("headers/pk_attrib_ask_nth_vector.html#declaration", " PK_VECTOR_t *<B>const</B> vector --- nth vector", "PK Reference - PK_ATTRIB_ask_nth_vector");
top.note("headers/pk_attrib_ask_owner.html#declaration", " PK_ENTITY_t *<B>const</B> owner --- entity which owns attribute", "PK Reference - PK_ATTRIB_ask_owner");
top.note("headers/pk_attrib_ask_pointers.html#declaration", " int *<B>const</B> n_pointers, --- number of pointers (>=0)", "PK Reference - PK_ATTRIB_ask_pointers");
top.note("headers/pk_attrib_ask_string.html#declaration", " char **<B>const</B> string --- pointer to character string", "PK Reference - PK_ATTRIB_ask_string");
top.note("headers/pk_attrib_ask_ustring.html#declaration", " PK_UCHAR_t **<B>const</B> string --- pointer to Unicode string", "PK Reference - PK_ATTRIB_ask_ustring");
top.note("headers/pk_attrib_ask_vectors.html#declaration", " int *<B>const</B> n_vectors, --- number of vectors (>= 0)", "PK Reference - PK_ATTRIB_ask_vectors");
top.note("headers/pk_attrib_cb_f_t.html#declaration", " <B>const</B> PK_ATTDEF_sf_2_t *attdef_sf, --- attribute definition standard", "PK Reference - PK_ATTRIB_cb_f_t");
top.note("headers/pk_attrib_create_empty.html#declaration", " PK_ATTRIB_t *<B>const</B> attrib --- created attribute", "PK Reference - PK_ATTRIB_create_empty");
top.note("headers/pk_attrib_field_values_t.html#declaration", " <B>const</B> int *ints;", "PK Reference - PK_ATTRIB_field_values_t");
top.note("headers/pk_attrib_reset_cb_f_t.html#declaration", " PK_ATTRIB_reset_cb_r_t *<B>const</B> result --- result", "PK Reference - PK_ATTRIB_reset_cb_f_t");
top.note("headers/pk_attrib_set_axes.html#declaration", "<B>const</B> PK_AXIS1_sf_t axes[] --- axes to set", "PK Reference - PK_ATTRIB_set_axes");
top.note("headers/pk_attrib_set_doubles.html#declaration", "<B>const</B> double doubles[] --- doubles to set", "PK Reference - PK_ATTRIB_set_doubles");
top.note("headers/pk_attrib_set_ints.html#declaration", "<B>const</B> int ints[] --- ints to set", "PK Reference - PK_ATTRIB_set_ints");
top.note("headers/pk_attrib_set_named_axes.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_set_named_axes");
top.note("headers/pk_attrib_set_named_doubles.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_set_named_doubles");
top.note("headers/pk_attrib_set_named_ints.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_set_named_ints");
top.note("headers/pk_attrib_set_named_pointers.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_set_named_pointers");
top.note("headers/pk_attrib_set_named_string.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_set_named_string");
top.note("headers/pk_attrib_set_named_ustring.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_set_named_ustring");
top.note("headers/pk_attrib_set_named_vectors.html#declaration", "<B>const</B> char *field_name, --- field name", "PK Reference - PK_ATTRIB_set_named_vectors");
top.note("headers/pk_attrib_set_no_roll.html#declaration", "<B>const</B> PK_ATTRIB_t attribs[], --- attributes", "PK Reference - PK_ATTRIB_set_no_roll");
top.note("headers/pk_attrib_set_pointers.html#declaration", "<B>const</B> PK_POINTER_t pointers[] --- pointers to set", "PK Reference - PK_ATTRIB_set_pointers");
top.note("headers/pk_attrib_set_string.html#declaration", "<B>const</B> char *string --- null-terminated string to set", "PK Reference - PK_ATTRIB_set_string");
top.note("headers/pk_attrib_set_ustring.html#declaration", "<B>const</B> PK_UCHAR_t *string --- null-terminated string to set", "PK Reference - PK_ATTRIB_set_ustring");
top.note("headers/pk_attrib_set_vectors.html#declaration", "<B>const</B> PK_VECTOR_t vectors[] --- vectors to set", "PK Reference - PK_ATTRIB_set_vectors");
top.note("headers/pk_bb_ask.html#declaration", " PK_BB_sf_t *<B>const</B> bb_sf --- bulletin board standard form", "PK Reference - PK_BB_ask");
top.note("headers/pk_bb_ask_status.html#declaration", " PK_BB_status_t *<B>const</B> status --- present status", "PK Reference - PK_BB_ask_status");
top.note("headers/pk_bb_create.html#declaration", " <B>const</B> PK_BB_sf_t *bb_sf, --- bulletin board standard form", "PK Reference - PK_BB_create");
top.note("headers/pk_bb_is.html#declaration", " PK_LOGICAL_t *<B>const</B> whether --- whether the received argument is a", "PK Reference - PK_BB_is");
top.note("headers/pk_bb_is_empty.html#declaration", " PK_LOGICAL_t *<B>const</B> is_empty --- true if the BB is off", "PK Reference - PK_BB_is_empty");
top.note("headers/pk_bb_output_events.html#declaration", " int *<B>const</B> n_entities, --- number of entities (>= 0)", "PK Reference - PK_BB_output_events");
top.note("headers/pk_bcurve_ask.html#declaration", " PK_BCURVE_sf_t *<B>const</B> bcurve_sf --- b-curve standard form", "PK Reference - PK_BCURVE_ask");
top.note("headers/pk_bcurve_ask_knots.html#declaration", "<B>const</B> PK_BCURVE_ask_knots_o_t *options, --- Option structure", "PK Reference - PK_BCURVE_ask_knots");
top.note("headers/pk_bcurve_ask_piecewise.html#declaration", " PK_BCURVE_piecewise_sf_t *<B>const</B> bcurve_piecewise_sf", "PK Reference - PK_BCURVE_ask_piecewise");
top.note("headers/pk_bcurve_ask_splinewise.html#declaration", " PK_BCURVE_splinewise_sf_t *<B>const</B> bcurve_splinewise_sf", "PK Reference - PK_BCURVE_ask_splinewise");
top.note("headers/pk_bcurve_clamp_knots.html#declaration", "<B>const</B> PK_BCURVE_clamp_knots_o_t *options --- options", "PK Reference - PK_BCURVE_clamp_knots");
top.note("headers/pk_bcurve_combine.html#declaration", "<B>const</B> PK_BCURVE_t bcurves[], --- bcurves", "PK Reference - PK_BCURVE_combine");
top.note("headers/pk_bcurve_create.html#declaration", " <B>const</B> PK_BCURVE_sf_t *bcurve_sf, --- b-curve standard form", "PK Reference - PK_BCURVE_create");
top.note("headers/pk_bcurve_create_by_fitting.html#declaration", " <B>const</B> PK_BCURVE_create_by_fitting_o_t *options, --- options for fitting", "PK Reference - PK_BCURVE_create_by_fitting");
top.note("headers/pk_bcurve_create_fitted.html#declaration", " <B>const</B> PK_BCURVE_create_fitted_o_t *options, --- options for fit", "PK Reference - PK_BCURVE_create_fitted");
top.note("headers/pk_bcurve_create_piecewise.html#declaration", " <B>const</B> PK_BCURVE_piecewise_sf_t *bcurve_piecewise_sf,", "PK Reference - PK_BCURVE_create_piecewise");
top.note("headers/pk_bcurve_create_spline.html#declaration", "<B>const</B> PK_VECTOR_t *positions, --- positions to spline", "PK Reference - PK_BCURVE_create_spline");
top.note("headers/pk_bcurve_create_spline_2.html#declaration", "<B>const</B> PK_VECTOR_t *positions, --- positions to spline", "PK Reference - PK_BCURVE_create_spline_2");
top.note("headers/pk_bcurve_create_spline_2_o_t.html#declaration", " <B>const</B> double *parameters; --- parameters for positions ", "PK Reference - PK_BCURVE_create_spline_2_o_t");
top.note("headers/pk_bcurve_create_spline_o_t.html#declaration", " <B>const</B> double *parameters; --- parameters for positions ", "PK Reference - PK_BCURVE_create_spline_o_t");
top.note("headers/pk_bcurve_create_splinewise.html#declaration", " <B>const</B> PK_BCURVE_splinewise_sf_t *bcurve_splinewise_sf,", "PK Reference - PK_BCURVE_create_splinewise");
top.note("headers/pk_bcurve_extend.html#declaration", "<B>const</B> PK_BCURVE_extend_o_t *options, --- options structure", "PK Reference - PK_BCURVE_extend");
top.note("headers/pk_bcurve_extend_r_f.html#declaration", " PK_BCURVE_extend_r_t *<B>const</B> loc", "PK Reference - PK_BCURVE_extend_r_f");
top.note("headers/pk_bcurve_find_g1_discontinuity.html#declaration", " int *<B>const</B> n_discs, --- number of discontinuities", "PK Reference - PK_BCURVE_find_g1_discontinuity");
top.note("headers/pk_bcurve_fit_eval_f_t.html#declaration", " PK_VECTOR_t *<B>const</B> point, --- sample point at parameter ", "PK Reference - PK_BCURVE_fit_eval_f_t");
top.note("headers/pk_bcurve_join.html#declaration", "<B>const</B> PK_BCURVE_t bcurves[], --- bcurves", "PK Reference - PK_BCURVE_join");
top.note("headers/pk_bcurve_lower_degree.html#declaration", "<B>const</B> PK_BCURVE_lower_degree_o_t *options --- options", "PK Reference - PK_BCURVE_lower_degree");
top.note("headers/pk_bcurve_make_bsurf_lofted.html#declaration", "<B>const</B> PK_BCURVE_t bcurves[], --- bcurves", "PK Reference - PK_BCURVE_make_bsurf_lofted");
top.note("headers/pk_bcurve_make_matched.html#declaration", "<B>const</B> PK_BCURVE_t bcurves[], --- unmatched bcurves", "PK Reference - PK_BCURVE_make_matched");
top.note("headers/pk_bcurve_raise_degree.html#declaration", "<B>const</B> PK_BCURVE_raise_degree_o_t *options --- options", "PK Reference - PK_BCURVE_raise_degree");
top.note("headers/pk_bcurve_remove_knots.html#declaration", "<B>const</B> PK_BCURVE_remove_knots_o_t *options, --- options", "PK Reference - PK_BCURVE_remove_knots");
top.note("headers/pk_bcurve_remove_knots_o_t.html#declaration", " <B>const</B> int *knot_indices; --- indices of knots to be", "PK Reference - PK_BCURVE_remove_knots_o_t");
top.note("headers/pk_bcurve_reparameterise.html#declaration", "<B>const</B> PK_BCURVE_reparameterise_o_t *options --- option structure", "PK Reference - PK_BCURVE_reparameterise");
top.note("headers/pk_bcurve_spin.html#declaration", "<B>const</B> PK_AXIS1_sf_t *axis, --- axis around which to spin", "PK Reference - PK_BCURVE_spin");
top.note("headers/pk_bcurve_spline_r_f.html#declaration", " PK_BCURVE_spline_r_t *<B>const</B> result", "PK Reference - PK_BCURVE_spline_r_f");
top.note("headers/pk_bcurve_sweep.html#declaration", " PK_BSURF_t *<B>const</B> bsurf --- resulting bsurf", "PK Reference - PK_BCURVE_sweep");
top.note("headers/pk_blend_cap_data_t.html#declaration", " <B>const</B> PK_ENTITY_t *caps; --- entities for capping blend (NULL)", "PK Reference - PK_blend_cap_data_t");
top.note("headers/pk_blend_constraint_t.html#declaration", " <B>const</B> PK_ENTITY_t *caps; --- entities for capping", "PK Reference - PK_blend_constraint_t");
top.note("headers/pk_blend_delete_cap_data_t.html#declaration", " <B>const</B> PK_FACE_t *blends; --- blend faces", "PK Reference - PK_blend_delete_cap_data_t");
top.note("headers/pk_blend_delete_unders_data_t.html#declaration", " <B>const</B> PK_FACE_t *blends; --- blend faces ( NULL )", "PK Reference - PK_blend_delete_unders_data_t");
top.note("headers/pk_blend_limit_data_t.html#declaration", " <B>const</B> PK_VECTOR_t *limit_points; --- limit points (NULL)", "PK Reference - PK_blend_limit_data_t");
top.note("headers/pk_blend_limit_patch_array_t.html#declaration", " <B>const</B> PK_blend_limit_patch_t *limit_topol_patch;", "PK Reference - PK_blend_limit_patch_array_t");
top.note("headers/pk_blend_rib_r_f.html#declaration", " PK_blend_rib_r_t *<B>const</B> ribs", "PK Reference - PK_blend_rib_r_f");
top.note("headers/pk_blend_setback_data_t.html#declaration", " <B>const</B> PK_EDGE_t * edges; --- edge (NULL)", "PK Reference - PK_blend_setback_data_t");
top.note("headers/pk_blend_setback_shape_data_t.html#declaration", " <B>const</B> PK_VERTEX_t *vertices; --- array of vertices at which", "PK Reference - PK_blend_setback_shape_data_t");
top.note("headers/pk_blend_vx_blend_data_t.html#declaration", " <B>const</B> PK_VERTEX_t *vertices; --- array of vertices to blend", "PK Reference - PK_blend_vx_blend_data_t");
top.note("headers/pk_blend_vx_order_data_t.html#declaration", " <B>const</B> PK_VERTEX_t *vertices; --- vertices (NULL)", "PK Reference - PK_blend_vx_order_data_t");
top.note("headers/pk_blend_y_blend_data_t.html#declaration", " <B>const</B> PK_VERTEX_t *vertices; --- array of vertices to blend", "PK Reference - PK_blend_y_blend_data_t");
top.note("headers/pk_blendsf_ask.html#declaration", " PK_BLENDSF_sf_t *<B>const</B> blendsf_sf --- standard form of blendsf", "PK Reference - PK_BLENDSF_ask");
top.note("headers/pk_body_add_to_compound.html#declaration", "<B>const</B> PK_BODY_t bodies[], --- bodies", "PK Reference - PK_BODY_add_to_compound");
top.note("headers/pk_body_apply_knit_pattern.html#declaration", " <B>const</B> PK_BODY_t body, --- target body", "PK Reference - PK_BODY_apply_knit_pattern");
top.note("headers/pk_body_ask_children.html#declaration", "<B>const</B> PK_BODY_ask_children_o_t *options, --- options", "PK Reference - PK_BODY_ask_children");
top.note("headers/pk_body_ask_components.html#declaration", " int *<B>const</B> n_components, --- number of components (>= 1)", "PK Reference - PK_BODY_ask_components");
top.note("headers/pk_body_ask_config.html#declaration", " PK_BODY_config_t *<B>const</B> body_config --- the configuration of the body", "PK Reference - PK_BODY_ask_config");
top.note("headers/pk_body_ask_curve_nmnl_state.html#declaration", " PK_BODY_curve_nmnl_t *<B>const</B> setting", "PK Reference - PK_BODY_ask_curve_nmnl_state");
top.note("headers/pk_body_ask_edges.html#declaration", " int *<B>const</B> n_edges, --- number of edges (>= 0)", "PK Reference - PK_BODY_ask_edges");
top.note("headers/pk_body_ask_faces.html#declaration", " int *<B>const</B> n_faces, --- number of faces (>= 0)", "PK Reference - PK_BODY_ask_faces");
top.note("headers/pk_body_ask_fins.html#declaration", " int *<B>const</B> n_fins, --- number of fins (>= 0)", "PK Reference - PK_BODY_ask_fins");
top.note("headers/pk_body_ask_first_edge.html#declaration", " PK_EDGE_t *<B>const</B> first_edge --- an edge (possibly PK_ENTITY_null)", "PK Reference - PK_BODY_ask_first_edge");
top.note("headers/pk_body_ask_first_face.html#declaration", " PK_FACE_t *<B>const</B> first_face --- a face (possibly PK_ENTITY_null)", "PK Reference - PK_BODY_ask_first_face");
top.note("headers/pk_body_ask_frames.html#declaration", " int *<B>const</B> n_frames, --- number of frames (>= 0)", "PK Reference - PK_BODY_ask_frames");
top.note("headers/pk_body_ask_loops.html#declaration", " int *<B>const</B> n_loops, --- number of loops (>= 0)", "PK Reference - PK_BODY_ask_loops");
top.note("headers/pk_body_ask_memory_usage.html#declaration", " size_t *<B>const</B> total", "PK Reference - PK_BODY_ask_memory_usage");
top.note("headers/pk_body_ask_parent.html#declaration", "<B>const</B> PK_BODY_ask_parent_o_t *options, --- options", "PK Reference - PK_BODY_ask_parent");
top.note("headers/pk_body_ask_regions.html#declaration", " int *<B>const</B> n_regions, --- number of regions (>= 1)", "PK Reference - PK_BODY_ask_regions");
top.note("headers/pk_body_ask_shells.html#declaration", " int *<B>const</B> n_shells, --- number of shells (>= 0)", "PK Reference - PK_BODY_ask_shells");
top.note("headers/pk_body_ask_topology.html#declaration", "<B>const</B> PK_BODY_ask_topology_o_t *options, --- options", "PK Reference - PK_BODY_ask_topology");
top.note("headers/pk_body_ask_type.html#declaration", " PK_BODY_type_t *<B>const</B> body_type --- the type of the body", "PK Reference - PK_BODY_ask_type");
top.note("headers/pk_body_ask_vertices.html#declaration", " int *<B>const</B> n_vertices, --- number of vertices (>= 0)", "PK Reference - PK_BODY_ask_vertices");
top.note("headers/pk_body_boolean.html#declaration", "<B>const</B> PK_BODY_t tools[], --- tool bodies", "PK Reference - PK_BODY_boolean");
top.note("headers/pk_body_boolean_2.html#declaration", "<B>const</B> PK_BODY_t tools[], --- tool bodies", "PK Reference - PK_BODY_boolean_2");
top.note("headers/pk_body_boolean_o_t.html#declaration", " <B>const</B> PK_boolean_config_o_t ", "PK Reference - PK_BODY_boolean_o_t");
top.note("headers/pk_body_check.html#declaration", "<B>const</B> PK_BODY_check_o_t *options, --- options structure", "PK Reference - PK_BODY_check");
top.note("headers/pk_body_contains_vector.html#declaration", " PK_enclosure_t *<B>const</B> enclosure, --- enclosure code", "PK Reference - PK_BODY_contains_vector");
top.note("headers/pk_body_copy_topology.html#declaration", "<B>const</B> PK_BODY_copy_topology_o_t *options, --- options structure", "PK Reference - PK_BODY_copy_topology");
top.note("headers/pk_body_create_minimum_topology.html#declaration", "<B>const</B> PK_CLASS_t classes[], --- class of each topol", "PK Reference - PK_BODY_create_minimum_topology");
top.note("headers/pk_body_create_sheet_circle.html#declaration", "<B>const</B> PK_AXIS2_sf_t *basis_set, --- position and orientation (may be", "PK Reference - PK_BODY_create_sheet_circle");
top.note("headers/pk_body_create_sheet_planar.html#declaration", "<B>const</B> PK_VECTOR_t vectors[], --- position vectors", "PK Reference - PK_BODY_create_sheet_planar");
top.note("headers/pk_body_create_sheet_planar_o_t.html#declaration", " <B>const</B> int *loops; --- loop numbers (NULL)", "PK Reference - PK_BODY_create_sheet_planar_o_t");
top.note("headers/pk_body_create_sheet_polygon.html#declaration", "<B>const</B> PK_AXIS2_sf_t *basis_set, --- position and orientation (may be", "PK Reference - PK_BODY_create_sheet_polygon");
top.note("headers/pk_body_create_sheet_rectangle.html#declaration", "<B>const</B> PK_AXIS2_sf_t *basis_set, --- position and orientation (may be", "PK Reference - PK_BODY_create_sheet_rectangle");
top.note("headers/pk_body_create_sheet_topology.html#declaration", "<B>const</B> PK_CLASS_t classes[], --- class of each topol", "PK Reference - PK_BODY_create_sheet_topology");
top.note("headers/pk_body_create_solid_block.html#declaration", "<B>const</B> PK_AXIS2_sf_t *basis_set, --- position and orientation (may be", "PK Reference - PK_BODY_create_solid_block");
top.note("headers/pk_body_create_solid_cone.html#declaration", "<B>const</B> PK_AXIS2_sf_t *basis_set, --- position and orientation (may be", "PK Reference - PK_BODY_create_solid_cone");
top.note("headers/pk_body_create_solid_cyl.html#declaration", "<B>const</B> PK_AXIS2_sf_t *basis_set, --- position and orientation (may be", "PK Reference - PK_BODY_create_solid_cyl");
top.note("headers/pk_body_create_solid_prism.html#declaration", "<B>const</B> PK_AXIS2_sf_t *basis_set, --- position and orientation (may be", "PK Reference - PK_BODY_create_solid_prism");
top.note("headers/pk_body_create_solid_sphere.html#declaration", "<B>const</B> PK_AXIS2_sf_t *basis_set, --- position and orientation (may be", "PK Reference - PK_BODY_create_solid_sphere");
top.note("headers/pk_body_create_solid_topology.html#declaration", "<B>const</B> PK_CLASS_t classes[], --- class of each topol", "PK Reference - PK_BODY_create_solid_topology");
top.note("headers/pk_body_create_solid_torus.html#declaration", "<B>const</B> PK_AXIS2_sf_t *basis_set, --- position and orientation (may be", "PK Reference - PK_BODY_create_solid_torus");
top.note("headers/pk_body_create_topology.html#declaration", "<B>const</B> PK_CLASS_t classes[], --- class of each topol", "PK Reference - PK_BODY_create_topology");
top.note("headers/pk_body_create_topology_2.html#declaration", "<B>const</B> PK_CLASS_t classes[], --- class of each topol", "PK Reference - PK_BODY_create_topology_2");
top.note("headers/pk_body_create_topology_2_r_f.html#declaration", " PK_BODY_create_topology_2_r_t *<B>const</B> creation --- structure to free", "PK Reference - PK_BODY_create_topology_2_r_f");
top.note("headers/pk_body_create_wire_topology.html#declaration", "<B>const</B> PK_CLASS_t classes[], --- class of each topol", "PK Reference - PK_BODY_create_wire_topology");
top.note("headers/pk_body_disjoin.html#declaration", " int *<B>const</B> n_bodies, --- number of disjoint bodies (>= 1)", "PK Reference - PK_BODY_disjoin");
top.note("headers/pk_body_embed_in_surf.html#declaration", " int *<B>const</B> n_edges, --- number of edges converted to SPCURVEs", "PK Reference - PK_BODY_embed_in_surf");
top.note("headers/pk_body_emboss.html#declaration", "<B>const</B> PK_BODY_emboss_o_t *options, --- options", "PK Reference - PK_BODY_emboss");
top.note("headers/pk_body_enlarge.html#declaration", "<B>const</B> PK_BODY_enlarge_o_t *options, --- options structure", "PK Reference - PK_BODY_enlarge");
top.note("headers/pk_body_enlarge_r_f.html#declaration", " PK_BODY_enlarge_r_t *<B>const</B> returns --- return information to free", "PK Reference - PK_BODY_enlarge_r_f");
top.note("headers/pk_body_extend.html#declaration", "<B>const</B> PK_EDGE_t *boundary_edges, --- boundary edges", "PK Reference - PK_BODY_extend");
top.note("headers/pk_body_extrude.html#declaration", "<B>const</B> PK_BODY_extrude_o_t *options, --- options structure", "PK Reference - PK_BODY_extrude");
top.note("headers/pk_body_fill_hole.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- boundary edges of hole", "PK Reference - PK_BODY_fill_hole");
top.note("headers/pk_body_fill_hole_o_t.html#declaration", " <B>const</B> PK_fill_hole_deriv_conds_t ", "PK Reference - PK_BODY_fill_hole_o_t");
top.note("headers/pk_body_find_extreme.html#declaration", "<B>const</B> PK_BODY_find_extreme_o_t *options, --- find extreme options", "PK Reference - PK_BODY_find_extreme");
top.note("headers/pk_body_find_facesets.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- bounding edges from body", "PK Reference - PK_BODY_find_facesets");
top.note("headers/pk_body_find_facesets_r_f.html#declaration", " PK_BODY_find_facesets_r_t *<B>const</B> facesets --- facesets to be deleted", "PK Reference - PK_BODY_find_facesets_r_f");
top.note("headers/pk_body_find_knit_pattern.html#declaration", "<B>const</B> PK_BODY_t bodies[], --- bodies between", "PK Reference - PK_BODY_find_knit_pattern");
top.note("headers/pk_body_find_laminar_edges.html#declaration", " int *<B>const</B> n_components, --- number of components (>= 0)", "PK Reference - PK_BODY_find_laminar_edges");
top.note("headers/pk_body_fix_blends.html#declaration", "<B>const</B> PK_BODY_fix_blends_o_t *options, --- options structure [PF]", "PK Reference - PK_BODY_fix_blends");
top.note("headers/pk_body_fix_blends_o_t.html#declaration", " <B>const</B> PK_TOPOL_array_t *limit_topols_unders;", "PK Reference - PK_BODY_fix_blends_o_t");
top.note("headers/pk_body_hollow.html#declaration", " int *<B>const</B> n_faces, --- number of faces", "PK Reference - PK_BODY_hollow");
top.note("headers/pk_body_hollow_2.html#declaration", "<B>const</B> PK_BODY_hollow_o_t *options, --- user options [PF]", "PK Reference - PK_BODY_hollow_2");
top.note("headers/pk_body_hollow_o_t.html#declaration", " <B>const</B> PK_FACE_t *pierce_faces; --- faces to be pierced (not", "PK Reference - PK_BODY_hollow_o_t");
top.note("headers/pk_body_identify_details.html#declaration", "<B>const</B> PK_detail_t details[], --- detail types", "PK Reference - PK_BODY_identify_details");
top.note("headers/pk_body_identify_facesets.html#declaration", "<B>const</B> PK_EDGE_t target_edges[], --- target edges", "PK Reference - PK_BODY_identify_facesets");
top.note("headers/pk_body_identify_general.html#declaration", "<B>const</B> PK_BODY_identify_general_o_t *options, --- options", "PK Reference - PK_BODY_identify_general");
top.note("headers/pk_body_imprint_body.html#declaration", "<B>const</B> PK_BODY_imprint_o_t *options, --- imprint options [PF]", "PK Reference - PK_BODY_imprint_body");
top.note("headers/pk_body_imprint_curve.html#declaration", " int *<B>const</B> n_new_edges, --- number of new edges", "PK Reference - PK_BODY_imprint_curve");
top.note("headers/pk_body_imprint_curves_normal.html#declaration", "<B>const</B> PK_CURVE_t curves[], --- curves", "PK Reference - PK_BODY_imprint_curves_normal");
top.note("headers/pk_body_imprint_curves_vector.html#declaration", "<B>const</B> PK_CURVE_t curves[], --- curves", "PK Reference - PK_BODY_imprint_curves_vector");
top.note("headers/pk_body_imprint_cus_normal.html#declaration", "<B>const</B> PK_CURVE_t curves[], --- curves", "PK Reference - PK_BODY_imprint_cus_normal");
top.note("headers/pk_body_imprint_cus_shadow.html#declaration", " <B>const</B> int n_bodies, --- number of bodies", "PK Reference - PK_BODY_imprint_cus_shadow");
top.note("headers/pk_body_imprint_cus_vec.html#declaration", "<B>const</B> PK_CURVE_t curves[], --- curves", "PK Reference - PK_BODY_imprint_cus_vec");
top.note("headers/pk_body_imprint_cus_vector.html#declaration", "<B>const</B> PK_CURVE_t curves[], --- curves", "PK Reference - PK_BODY_imprint_cus_vector");
top.note("headers/pk_body_imprint_faces.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces", "PK Reference - PK_BODY_imprint_faces");
top.note("headers/pk_body_imprint_faces_2.html#declaration", "<B>const</B> PK_FACE_t faces[], --- tool faces", "PK Reference - PK_BODY_imprint_faces_2");
top.note("headers/pk_body_imprint_faces_o_t.html#declaration", " <B>const</B> PK_boolean_match_o_t ", "PK Reference - PK_BODY_imprint_faces_o_t");
top.note("headers/pk_body_imprint_o_t.html#declaration", " <B>const</B> PK_boolean_match_o_t ", "PK Reference - PK_BODY_imprint_o_t");
top.note("headers/pk_body_imprint_plane.html#declaration", " int *<B>const</B> n_edges, --- number of edges imprinted", "PK Reference - PK_BODY_imprint_plane");
top.note("headers/pk_body_imprint_plane_2.html#declaration", "<B>const</B> PK_BODY_imprint_plane_o_t *options, --- options", "PK Reference - PK_BODY_imprint_plane_2");
top.note("headers/pk_body_intersect_bodies.html#declaration", "<B>const</B> PK_BODY_t tools[], --- Tool bodies", "PK Reference - PK_BODY_intersect_bodies");
top.note("headers/pk_body_is_cellular.html#declaration", "<B>const</B> PK_BODY_is_cellular_o_t *options, --- options", "PK Reference - PK_BODY_is_cellular");
top.note("headers/pk_body_is_cellular_r_f.html#declaration", " PK_BODY_is_cellular_r_t *<B>const</B> results", "PK Reference - PK_BODY_is_cellular_r_f");
top.note("headers/pk_body_knit.html#declaration", "<B>const</B> PK_TOPOL_t topols[], --- topols", "PK Reference - PK_BODY_knit");
top.note("headers/pk_body_loft_face_clamp_t.html#declaration", " <B>const</B> PK_FACE_t *faces; --- array of clamping faces (NULL)", "PK Reference - PK_BODY_loft_face_clamp_t");
top.note("headers/pk_body_loft_vector_clamp_t.html#declaration", " <B>const</B> PK_VECTOR_t *tangents; --- array of derivative vectors (NULL)", "PK Reference - PK_BODY_loft_vector_clamp_t");
top.note("headers/pk_body_make_compound.html#declaration", "<B>const</B> PK_BODY_t bodies[], --- bodies", "PK Reference - PK_BODY_make_compound");
top.note("headers/pk_body_make_curves_outline.html#declaration", " <B>const</B> int n_bodies, --- number of bodies", "PK Reference - PK_BODY_make_curves_outline");
top.note("headers/pk_body_make_facet_body.html#declaration", "<B>const</B> PK_BODY_make_facet_body_o_t *options,", "PK Reference - PK_BODY_make_facet_body");
top.note("headers/pk_body_make_lofted_body.html#declaration", "<B>const</B> PK_BODY_t profiles[], --- profiles to loft", "PK Reference - PK_BODY_make_lofted_body");
top.note("headers/pk_body_make_lofted_body_o_t.html#declaration", " <B>const</B> PK_BODY_t *guide_wires;", "PK Reference - PK_BODY_make_lofted_body_o_t");
top.note("headers/pk_body_make_manifold_bodies.html#declaration", " int *<B>const</B> n_components, --- number of manifold bodies", "PK Reference - PK_BODY_make_manifold_bodies");
top.note("headers/pk_body_make_patterned.html#declaration", "<B>const</B> PK_BODY_make_patterned_o_t *options, --- options", "PK Reference - PK_BODY_make_patterned");
top.note("headers/pk_body_make_patterned_r_f.html#declaration", " PK_BODY_make_patterned_r_t *<B>const</B> results", "PK Reference - PK_BODY_make_patterned_r_f");
top.note("headers/pk_body_make_persp_outline.html#declaration", " <B>const</B> int n_bodies, --- number of bodies", "PK Reference - PK_BODY_make_persp_outline");
top.note("headers/pk_body_make_persp_outline_r_f.html#declaration", " PK_BODY_make_persp_outline_r_t *<B>const</B> result", "PK Reference - PK_BODY_make_persp_outline_r_f");
top.note("headers/pk_body_make_section.html#declaration", "<B>const</B> PK_BODY_make_section_o_t *options, --- Sectioning options", "PK Reference - PK_BODY_make_section");
top.note("headers/pk_body_make_section_o_t.html#declaration", " <B>const</B> double *offsets; --- (NULL)", "PK Reference - PK_BODY_make_section_o_t");
top.note("headers/pk_body_make_section_r_f.html#declaration", " PK_BODY_make_section_r_t *<B>const</B> results --- section results to free", "PK Reference - PK_BODY_make_section_r_f");
top.note("headers/pk_body_make_section_with_surfs.html#declaration", "<B>const</B> PK_BODY_make_section_o_t *options, --- Sectioning options", "PK Reference - PK_BODY_make_section_with_surfs");
top.note("headers/pk_body_make_spun_outline.html#declaration", " <B>const</B> int n_bodies, --- number of bodies", "PK Reference - PK_BODY_make_spun_outline");
top.note("headers/pk_body_make_spun_outline_o_t.html#declaration", " <B>const</B> PK_FACE_t *exclude_faces; --- faces to exclude from outlining", "PK Reference - PK_BODY_make_spun_outline_o_t");
top.note("headers/pk_body_make_swept_body.html#declaration", " <B>const</B> PK_BODY_t profile, --- profile to sweep", "PK Reference - PK_BODY_make_swept_body");
top.note("headers/pk_body_make_swept_body_2.html#declaration", "<B>const</B> PK_BODY_t profiles[], --- profiles to sweep", "PK Reference - PK_BODY_make_swept_body_2");
top.note("headers/pk_body_make_swept_body_2_o_t.html#declaration", " <B>const</B> PK_VERTEX_t *ignorable_vertices;", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#declaration", " <B>const</B> PK_VERTEX_t *ignorable_vertices;", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_make_swept_tool.html#declaration", " <B>const</B> PK_BODY_t tool, --- tool to sweep", "PK Reference - PK_BODY_make_swept_tool");
top.note("headers/pk_body_make_swept_tool_o_t.html#declaration", " <B>const</B> PK_FACE_t *cap_faces; --- cap faces of the tool", "PK Reference - PK_BODY_make_swept_tool_o_t");
top.note("headers/pk_body_offset_2.html#declaration", "<B>const</B> PK_BODY_offset_o_t *options, --- options [PF]", "PK Reference - PK_BODY_offset_2");
top.note("headers/pk_body_offset_o_t.html#declaration", " <B>const</B> PK_FACE_t *offset_faces; --- faces to be offset by", "PK Reference - PK_BODY_offset_o_t");
top.note("headers/pk_body_offset_planar_wire.html#declaration", "<B>const</B> PK_BODY_offset_planar_wire_o_t *options, --- options structure", "PK Reference - PK_BODY_offset_planar_wire");
top.note("headers/pk_body_pick_topols.html#declaration", " <B>const</B> int n_bodies, --- number of bodies", "PK Reference - PK_BODY_pick_topols");
top.note("headers/pk_body_pick_topols_r_f.html#declaration", " PK_BODY_pick_topols_r_t *<B>const</B> picked", "PK Reference - PK_BODY_pick_topols_r_f");
top.note("headers/pk_body_remove_from_parents.html#declaration", "<B>const</B> PK_BODY_t children[], --- children", "PK Reference - PK_BODY_remove_from_parents");
top.note("headers/pk_body_repair_shells.html#declaration", "<B>const</B> PK_BODY_repair_shells_o_t *options, --- options structure", "PK Reference - PK_BODY_repair_shells");
top.note("headers/pk_body_section_o_t.html#declaration", " <B>const</B> PK_boolean_match_o_t ", "PK Reference - PK_BODY_section_o_t");
top.note("headers/pk_body_section_with_sheet.html#declaration", "<B>const</B> PK_BODY_section_o_t *options, --- Sectioning options", "PK Reference - PK_BODY_section_with_sheet");
top.note("headers/pk_body_section_with_sheet_2.html#declaration", "<B>const</B> PK_BODY_section_o_t *options, --- sectioning options", "PK Reference - PK_BODY_section_with_sheet_2");
top.note("headers/pk_body_section_with_surf.html#declaration", "<B>const</B> PK_BODY_section_o_t *options, --- Sectioning options", "PK Reference - PK_BODY_section_with_surf");
top.note("headers/pk_body_set_type.html#declaration", "<B>const</B> PK_BODY_set_type_o_t *options --- options structure", "PK Reference - PK_BODY_set_type");
top.note("headers/pk_body_sew_bodies.html#declaration", "<B>const</B> PK_BODY_t bodies[], --- bodies to sew", "PK Reference - PK_BODY_sew_bodies");
top.note("headers/pk_body_share_geom.html#declaration", " int *<B>const</B> n_geoms --- number of geometries removed", "PK Reference - PK_BODY_share_geom");
top.note("headers/pk_body_simplify_geom.html#declaration", " int *<B>const</B> n_geoms, --- number of geoms returned", "PK Reference - PK_BODY_simplify_geom");
top.note("headers/pk_body_spin.html#declaration", "<B>const</B> PK_AXIS1_sf_t *axis, --- spin axis", "PK Reference - PK_BODY_spin");
top.note("headers/pk_body_subtract_bodies.html#declaration", "<B>const</B> PK_BODY_t tools[], --- Tool bodies", "PK Reference - PK_BODY_subtract_bodies");
top.note("headers/pk_body_sweep.html#declaration", " int *<B>const</B> n_laterals, --- number of laterals", "PK Reference - PK_BODY_sweep");
top.note("headers/pk_body_sweep_tool_r_f.html#declaration", " PK_BODY_sweep_tool_r_t *<B>const</B> swept_body", "PK Reference - PK_BODY_sweep_tool_r_f");
top.note("headers/pk_body_taper.html#declaration", " <B>const</B> PK_BODY_t body, --- body to be tapered", "PK Reference - PK_BODY_taper");
top.note("headers/pk_body_taper_o_t.html#declaration", " <B>const</B> PK_taper_method_t *methods; --- non-default tapering", "PK Reference - PK_BODY_taper_o_t");
top.note("headers/pk_body_thicken.html#declaration", " int *<B>const</B> n_topols, --- number of topols", "PK Reference - PK_BODY_thicken");
top.note("headers/pk_body_thicken_2.html#declaration", "<B>const</B> PK_BODY_thicken_o_t *options, --- options", "PK Reference - PK_BODY_thicken_2");
top.note("headers/pk_body_thicken_3.html#declaration", "<B>const</B> PK_BODY_thicken_o_t *options, --- options [PF]", "PK Reference - PK_BODY_thicken_3");
top.note("headers/pk_body_thicken_o_t.html#declaration", " <B>const</B> PK_FACE_t *faces; --- faces without default offsets", "PK Reference - PK_BODY_thicken_o_t");
top.note("headers/pk_body_tracked_loft_r_f.html#declaration", " PK_BODY_tracked_loft_r_t *<B>const</B> lofted_body", "PK Reference - PK_BODY_tracked_loft_r_f");
top.note("headers/pk_body_tracked_sweep_2_r_f.html#declaration", " PK_BODY_tracked_sweep_2_r_t *<B>const</B> swept_body", "PK Reference - PK_BODY_tracked_sweep_2_r_f");
top.note("headers/pk_body_tracked_sweep_r_f.html#declaration", " PK_BODY_tracked_sweep_r_t *<B>const</B> profile", "PK Reference - PK_BODY_tracked_sweep_r_f");
top.note("headers/pk_body_transform.html#declaration", " int *<B>const</B> n_replaces, --- number of geoms replaced", "PK Reference - PK_BODY_transform");
top.note("headers/pk_body_transform_2.html#declaration", "<B>const</B> PK_BODY_transform_o_t *options, --- options", "PK Reference - PK_BODY_transform_2");
top.note("headers/pk_body_trim.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges", "PK Reference - PK_BODY_trim");
top.note("headers/pk_body_trim_gap_analysis.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges", "PK Reference - PK_BODY_trim_gap_analysis");
top.note("headers/pk_body_trim_neutral_sheets.html#declaration", "<B>const</B> PK_FACE_set_pair_t pairs[], --- array of pairs", "PK Reference - PK_BODY_trim_neutral_sheets");
top.note("headers/pk_body_trim_neutral_sheets_2.html#declaration", "<B>const</B> PK_FACE_set_pair_t pairs[], --- array of pairs", "PK Reference - PK_BODY_trim_neutral_sheets_2");
top.note("headers/pk_body_unite_bodies.html#declaration", "<B>const</B> PK_BODY_t tools[], --- Tool bodies", "PK Reference - PK_BODY_unite_bodies");
top.note("headers/pk_boolean_match_o_t.html#declaration", " <B>const</B> PK_boolean_match_region_o_t ", "PK Reference - PK_boolean_match_o_t");
top.note("headers/pk_boolean_r_f.html#declaration", " PK_boolean_r_t *<B>const</B> results --- boolean results to free", "PK Reference - PK_boolean_r_f");
top.note("headers/pk_boolean_region_select_o_t.html#declaration", " <B>const</B> PK_TOPOL_t *selectors; --- (NULL)", "PK Reference - PK_boolean_region_select_o_t");
top.note("headers/pk_boolean_select_topolset_o_t.html#declaration", " <B>const</B> PK_TOPOL_t *selectors; --- (NULL)", "PK Reference - PK_boolean_select_topolset_o_t");
top.note("headers/pk_bsurf_ask.html#declaration", " PK_BSURF_sf_t *<B>const</B> bsurf_sf --- b-surface standard form", "PK Reference - PK_BSURF_ask");
top.note("headers/pk_bsurf_ask_knots.html#declaration", "<B>const</B> PK_BSURF_ask_knots_o_t *options, --- Option structure", "PK Reference - PK_BSURF_ask_knots");
top.note("headers/pk_bsurf_ask_piecewise.html#declaration", " PK_BSURF_piecewise_sf_t *<B>const</B> bsurf_piecewise_sf --- b-surface standard form", "PK Reference - PK_BSURF_ask_piecewise");
top.note("headers/pk_bsurf_ask_splinewise.html#declaration", " PK_BSURF_splinewise_sf_t *<B>const</B> bsurf_splinewise_sf --- b-surface standard form", "PK Reference - PK_BSURF_ask_splinewise");
top.note("headers/pk_bsurf_clamp_knots.html#declaration", "<B>const</B> PK_BSURF_clamp_knots_o_t *options --- options", "PK Reference - PK_BSURF_clamp_knots");
top.note("headers/pk_bsurf_create.html#declaration", " <B>const</B> PK_BSURF_sf_t *bsurf_sf, --- b-surface standard form", "PK Reference - PK_BSURF_create");
top.note("headers/pk_bsurf_create_constrained.html#declaration", " <B>const</B> PK_BSURF_create_constrained_o_t *options, --- options", "PK Reference - PK_BSURF_create_constrained");
top.note("headers/pk_bsurf_create_constrained_o_t.html#declaration", " <B>const</B> PK_VECTOR_t *positions; --- position constraints (NULL)", "PK Reference - PK_BSURF_create_constrained_o_t");
top.note("headers/pk_bsurf_create_fitted.html#declaration", " <B>const</B> PK_BSURF_create_fitted_o_t *options, --- options for fit", "PK Reference - PK_BSURF_create_fitted");
top.note("headers/pk_bsurf_create_fitted_o_t.html#declaration", "<B>const</B> double *u_interpolation_parms; --- u parameters at which to", "PK Reference - PK_BSURF_create_fitted_o_t");
top.note("headers/pk_bsurf_create_piecewise.html#declaration", " <B>const</B> PK_BSURF_piecewise_sf_t *bsurf_piecewise_sf, --- b-surface standard form", "PK Reference - PK_BSURF_create_piecewise");
top.note("headers/pk_bsurf_create_splinewise.html#declaration", " <B>const</B> PK_BSURF_splinewise_sf_t *bsurf_splinewise_sf, --- bsurf standard form", "PK Reference - PK_BSURF_create_splinewise");
top.note("headers/pk_bsurf_find_g1_discontinuity.html#declaration", " int *<B>const</B> n_u_discs, --- number of U discontinuities", "PK Reference - PK_BSURF_find_g1_discontinuity");
top.note("headers/pk_bsurf_lower_degree.html#declaration", "<B>const</B> PK_BSURF_lower_degree_o_t *options --- options", "PK Reference - PK_BSURF_lower_degree");
top.note("headers/pk_bsurf_make_bcurve_u_isoparam.html#declaration", " <B>const</B> PK_BSURF_t bsurf, --- b-surface", "PK Reference - PK_BSURF_make_bcurve_u_isoparam");
top.note("headers/pk_bsurf_make_bcurve_v_isoparam.html#declaration", " <B>const</B> PK_BSURF_t bsurf, --- b-surface", "PK Reference - PK_BSURF_make_bcurve_v_isoparam");
top.note("headers/pk_bsurf_raise_degree.html#declaration", "<B>const</B> PK_BSURF_raise_degree_o_t *options --- options", "PK Reference - PK_BSURF_raise_degree");
top.note("headers/pk_bsurf_remove_knots.html#declaration", "<B>const</B> PK_BSURF_remove_knots_o_t *options, --- options", "PK Reference - PK_BSURF_remove_knots");
top.note("headers/pk_bsurf_remove_knots_o_t.html#declaration", " <B>const</B> int *knot_indices; --- indices of knots to be", "PK Reference - PK_BSURF_remove_knots_o_t");
top.note("headers/pk_bsurf_reparameterise.html#declaration", "<B>const</B> PK_BSURF_reparameterise_o_t *options --- option structure", "PK Reference - PK_BSURF_reparameterise");
top.note("headers/pk_change_edge_geom_data_t.html#declaration", " <B>const</B> PK_EDGE_array_t *edge_arrays; --- arrays of edges for which", "PK Reference - PK_change_edge_geom_data_t");
top.note("headers/pk_circle_ask.html#declaration", " PK_CIRCLE_sf_t *<B>const</B> circle_sf --- circle standard form", "PK Reference - PK_CIRCLE_ask");
top.note("headers/pk_circle_create.html#declaration", " <B>const</B> PK_CIRCLE_sf_t *circle_sf, --- circle standard form", "PK Reference - PK_CIRCLE_create");
top.note("headers/pk_class_ask_superclass.html#declaration", " PK_CLASS_t *<B>const</B> superclass --- immediate superclass of class", "PK Reference - PK_CLASS_ask_superclass");
top.note("headers/pk_class_is_subclass.html#declaration", " PK_LOGICAL_t *<B>const</B> is_subclass --- whether it was a subclass", "PK Reference - PK_CLASS_is_subclass");
top.note("headers/pk_cone_ask.html#declaration", " PK_CONE_sf_t *<B>const</B> cone_sf --- the standard form of the cone", "PK Reference - PK_CONE_ask");
top.note("headers/pk_cone_create.html#declaration", " <B>const</B> PK_CONE_sf_t *cone_sf, --- standard form of a cone", "PK Reference - PK_CONE_create");
top.note("headers/pk_cone_make_solid_body.html#declaration", " PK_BODY_t *<B>const</B> body --- solid body returned", "PK Reference - PK_CONE_make_solid_body");
top.note("headers/pk_curve_ask_edges.html#declaration", " int *<B>const</B> n_edges, --- number of edges (>= 0)", "PK Reference - PK_CURVE_ask_edges");
top.note("headers/pk_curve_ask_edges_nmnl.html#declaration", " int *<B>const</B> n_edges, --- number of edges (>= 0)", "PK Reference - PK_CURVE_ask_edges_nmnl");
top.note("headers/pk_curve_ask_fin.html#declaration", " PK_FIN_t *<B>const</B> fin --- owning fin (possibly PK_ENTITY_null)", "PK Reference - PK_CURVE_ask_fin");
top.note("headers/pk_curve_ask_interval.html#declaration", " PK_INTERVAL_t *<B>const</B> interval --- parametric bounds of the curve", "PK Reference - PK_CURVE_ask_interval");
top.note("headers/pk_curve_ask_param.html#declaration", " PK_PARAM_sf_t *<B>const</B> param --- standard form of parameterisation of curve", "PK Reference - PK_CURVE_ask_param");
top.note("headers/pk_curve_ask_parm_different.html#declaration", " PK_LOGICAL_t *<B>const</B> different --- true if pk and ki parametrisations", "PK Reference - PK_CURVE_ask_parm_different");
top.note("headers/pk_curve_ask_part.html#declaration", " PK_PART_t *<B>const</B> part --- owning part (possibly PK_ENTITY_null)", "PK Reference - PK_CURVE_ask_part");
top.note("headers/pk_curve_convert_parm_to_ki.html#declaration", " double *<B>const</B> ki_t --- ki parameter on curve", "PK Reference - PK_CURVE_convert_parm_to_ki");
top.note("headers/pk_curve_convert_parm_to_pk.html#declaration", " double *<B>const</B> pk_t --- pk parameter on curve", "PK Reference - PK_CURVE_convert_parm_to_pk");
top.note("headers/pk_curve_degens_f.html#declaration", " PK_CURVE_degens_t *<B>const</B> result", "PK Reference - PK_CURVE_degens_f");
top.note("headers/pk_curve_embed_in_surf.html#declaration", " int *<B>const</B> n_spcurves, --- no. spcurves returned", "PK Reference - PK_CURVE_embed_in_surf");
top.note("headers/pk_curve_embed_in_surf_2.html#declaration", "<B>const</B> PK_CURVE_embed_in_surf_o_t *options, --- options", "PK Reference - PK_CURVE_embed_in_surf_2");
top.note("headers/pk_curve_eval_curvature.html#declaration", " PK_VECTOR1_t *<B>const</B> tangent, --- tangent", "PK Reference - PK_CURVE_eval_curvature");
top.note("headers/pk_curve_eval_curvature_handed.html#declaration", " PK_VECTOR1_t *<B>const</B> tangent, --- tangent", "PK Reference - PK_CURVE_eval_curvature_handed");
top.note("headers/pk_curve_eval_with_tan_handed.html#declaration", " PK_VECTOR_t *<B>const</B> tangent --- curve tangent", "PK Reference - PK_CURVE_eval_with_tan_handed");
top.note("headers/pk_curve_eval_with_tangent.html#declaration", " PK_VECTOR_t *<B>const</B> tangent --- curve tangent", "PK Reference - PK_CURVE_eval_with_tangent");
top.note("headers/pk_curve_find_box.html#declaration", "<B>const</B> PK_CURVE_find_box_o_t *options, --- options structure", "PK Reference - PK_CURVE_find_box");
top.note("headers/pk_curve_find_degens.html#declaration", "<B>const</B> PK_CURVE_find_degens_o_t *options, --- options structure", "PK Reference - PK_CURVE_find_degens");
top.note("headers/pk_curve_find_discontinuity.html#declaration", "<B>const</B> PK_CURVE_find_discontinuity_o_t *options, --- option structure", "PK Reference - PK_CURVE_find_discontinuity");
top.note("headers/pk_curve_find_length.html#declaration", " double *<B>const</B> length, --- nominal arc length of curve", "PK Reference - PK_CURVE_find_length");
top.note("headers/pk_curve_find_min_radius.html#declaration", " int *<B>const</B> n_radii, --- number of radii returned", "PK Reference - PK_CURVE_find_min_radius");
top.note("headers/pk_curve_find_non_aligned_box.html#declaration", " PK_VECTOR_t *<B>const</B> centre, --- box centre", "PK Reference - PK_CURVE_find_non_aligned_box");
top.note("headers/pk_curve_find_self_int.html#declaration", "<B>const</B> PK_CURVE_find_self_int_o_t *options, --- options structure", "PK Reference - PK_CURVE_find_self_int");
top.note("headers/pk_curve_find_surfs_common.html#declaration", " int *<B>const</B> n_surfs, --- number of common surfaces", "PK Reference - PK_CURVE_find_surfs_common");
top.note("headers/pk_curve_find_vector_interval.html#declaration", " PK_INTERVAL_t *<B>const</B> interval --- parameter interval bounded by vectors", "PK Reference - PK_CURVE_find_vector_interval");
top.note("headers/pk_curve_find_vectors.html#declaration", "<B>const</B> PK_CURVE_find_vectors_o_t *options, --- options", "PK Reference - PK_CURVE_find_vectors");
top.note("headers/pk_curve_find_vectors_r_f.html#declaration", " PK_CURVE_find_vectors_r_t *<B>const</B> found_vectors --- structure to free", "PK Reference - PK_CURVE_find_vectors_r_f");
top.note("headers/pk_curve_fix_degens.html#declaration", "<B>const</B> PK_CURVE_degens_t *degens, --- degeneracies", "PK Reference - PK_CURVE_fix_degens");
top.note("headers/pk_curve_fix_degens_r_f.html#declaration", " PK_CURVE_fix_degens_r_t *<B>const</B> result", "PK Reference - PK_CURVE_fix_degens_r_f");
top.note("headers/pk_curve_fix_self_int.html#declaration", "<B>const</B> PK_CURVE_self_ints_t *self_ints, --- self intersections", "PK Reference - PK_CURVE_fix_self_int");
top.note("headers/pk_curve_fix_self_int_r_f.html#declaration", " PK_CURVE_fix_self_int_r_t *<B>const</B> result", "PK Reference - PK_CURVE_fix_self_int_r_f");
top.note("headers/pk_curve_general_eval_f_t.html#declaration", " double *<B>const</B> derivs --- point and derivatives", "PK Reference - PK_CURVE_general_eval_f_t");
top.note("headers/pk_curve_intersect_curve.html#declaration", "<B>const</B> PK_CURVE_intersect_curve_o_t *options, --- options structure", "PK Reference - PK_CURVE_intersect_curve");
top.note("headers/pk_curve_is_isoparam.html#declaration", "<B>const</B> PK_CURVE_is_isoparam_o_t *options, --- options structure", "PK Reference - PK_CURVE_is_isoparam");
top.note("headers/pk_curve_make_approx.html#declaration", "<B>const</B> PK_CURVE_make_approx_o_t *options, --- options", "PK Reference - PK_CURVE_make_approx");
top.note("headers/pk_curve_make_bcurve.html#declaration", " PK_BCURVE_t *<B>const</B> b_curve, --- created BCURVE", "PK Reference - PK_CURVE_make_bcurve");
top.note("headers/pk_curve_make_bcurve_2.html#declaration", "<B>const</B> PK_CURVE_make_bcurve_o_t *options, --- option structure [PF]", "PK Reference - PK_CURVE_make_bcurve_2");
top.note("headers/pk_curve_make_bcurve_array.html#declaration", "<B>const</B> PK_CURVE_make_bcurve_array_o_t *options, --- option structure [PF]", "PK Reference - PK_CURVE_make_bcurve_array");
top.note("headers/pk_curve_make_curve_reversed.html#declaration", " PK_CURVE_t *<B>const</B> reverse --- reversed curve", "PK Reference - PK_CURVE_make_curve_reversed");
top.note("headers/pk_curve_make_helical_surf.html#declaration", "<B>const</B> PK_AXIS1_sf_t *axis, --- axis", "PK Reference - PK_CURVE_make_helical_surf");
top.note("headers/pk_curve_make_spcurves.html#declaration", " int *<B>const</B> n_spcurves, --- no. spcurves produced", "PK Reference - PK_CURVE_make_spcurves");
top.note("headers/pk_curve_make_spcurves_2.html#declaration", "<B>const</B> PK_CURVE_make_spcurves_o_t *options, --- options structure", "PK Reference - PK_CURVE_make_spcurves_2");
top.note("headers/pk_curve_make_surf_isocline.html#declaration", " PK_SURF_t *<B>const</B> surf --- the isocline surface", "PK Reference - PK_CURVE_make_surf_isocline");
top.note("headers/pk_curve_make_wire_body.html#declaration", " PK_BODY_t *<B>const</B> body --- wire body returned", "PK Reference - PK_CURVE_make_wire_body");
top.note("headers/pk_curve_make_wire_body_2.html#declaration", "<B>const</B> PK_CURVE_t curves[], --- curves to create a wire", "PK Reference - PK_CURVE_make_wire_body_2");
top.note("headers/pk_curve_output_vectors.html#declaration", " int *<B>const</B> n_vectors, --- number of position vectors", "PK Reference - PK_CURVE_output_vectors");
top.note("headers/pk_curve_parameterise_vector.html#declaration", " double *<B>const</B> t --- parameter of position on curve", "PK Reference - PK_CURVE_parameterise_vector");
top.note("headers/pk_curve_project.html#declaration", "<B>const</B> PK_CURVE_t curves[], --- array of tool curves", "PK Reference - PK_CURVE_project");
top.note("headers/pk_curve_project_r_f.html#declaration", " PK_CURVE_project_r_t *<B>const</B> result", "PK Reference - PK_CURVE_project_r_f");
top.note("headers/pk_curve_self_ints_f.html#declaration", " PK_CURVE_self_ints_t *<B>const</B> result", "PK Reference - PK_CURVE_self_ints_f");
top.note("headers/pk_curve_spin.html#declaration", "<B>const</B> PK_AXIS1_sf_t *axis, --- axis around which to spin", "PK Reference - PK_CURVE_spin");
top.note("headers/pk_curve_spin_2.html#declaration", "<B>const</B> PK_AXIS1_sf_t *axis, --- axis around which to spin", "PK Reference - PK_CURVE_spin_2");
top.note("headers/pk_curve_sweep.html#declaration", " PK_SURF_t *<B>const</B> surf --- swept surface", "PK Reference - PK_CURVE_sweep");
top.note("headers/pk_cyl_ask.html#declaration", " PK_CYL_sf_t *<B>const</B> cylinder_sf --- the standard form of the cylinder", "PK Reference - PK_CYL_ask");
top.note("headers/pk_cyl_create.html#declaration", " <B>const</B> PK_CYL_sf_t *cylinder_sf, --- standard form of a cylinder", "PK Reference - PK_CYL_create");
top.note("headers/pk_cyl_make_solid_body.html#declaration", " PK_BODY_t *<B>const</B> body --- solid body returned", "PK Reference - PK_CYL_make_solid_body");
top.note("headers/pk_debug_behaviours_start.html#declaration", " <B>const</B> PK_DEBUG_behaviours_start_o_t *options --- options structure", "PK Reference - PK_DEBUG_behaviours_start");
top.note("headers/pk_debug_body_compare.html#declaration", "<B>const</B> PK_DEBUG_BODY_compare_o_t *options, --- options structure", "PK Reference - PK_DEBUG_BODY_compare");
top.note("headers/pk_debug_body_compare_r_f.html#declaration", " PK_DEBUG_BODY_compare_r_t *<B>const</B> results --- comparison results to free", "PK Reference - PK_DEBUG_BODY_compare_r_f");
top.note("headers/pk_debug_body_extract_data.html#declaration", " PK_DEBUG_data_t *<B>const</B> data --- saved data", "PK Reference - PK_DEBUG_BODY_extract_data");
top.note("headers/pk_debug_data_f.html#declaration", " PK_DEBUG_data_t *<B>const</B> data --- data to free", "PK Reference - PK_DEBUG_data_f");
top.note("headers/pk_debug_receive.html#declaration", " <B>const</B> char *key, --- key string", "PK Reference - PK_DEBUG_receive");
top.note("headers/pk_debug_report_comment.html#declaration", " <B>const</B> char *comment --- null-terminated string to set", "PK Reference - PK_DEBUG_report_comment");
top.note("headers/pk_debug_report_start.html#declaration", " <B>const</B> char *key, --- key string", "PK Reference - PK_DEBUG_report_start");
top.note("headers/pk_debug_session_check.html#declaration", " <B>const</B> PK_DEBUG_SESSION_check_o_t *options, --- options structure", "PK Reference - PK_DEBUG_SESSION_check");
top.note("headers/pk_debug_session_check_o_t.html#declaration", " <B>const</B> PK_PARTITION_t *partitions; --- list of partitions to check", "PK Reference - PK_DEBUG_SESSION_check_o_t");
top.note("headers/pk_debug_session_entry_cb_t.html#declaration", " typedef void (*PK_DEBUG_SESSION_entry_cb_t)(<B>const</B> char *, PK_POINTER_t );", "PK Reference - PK_DEBUG_SESSION_entry_cb_t");
top.note("headers/pk_debug_session_exit_cb_t.html#declaration", " typedef void (*PK_DEBUG_SESSION_exit_cb_t)(<B>const</B> char *, PK_POINTER_t );", "PK Reference - PK_DEBUG_SESSION_exit_cb_t");
top.note("headers/pk_debug_session_watch_fns.html#declaration", "<B>const</B> char *fns[], --- functions to watch", "PK Reference - PK_DEBUG_SESSION_watch_fns");
top.note("headers/pk_debug_shuffle_start.html#declaration", " <B>const</B> PK_DEBUG_shuffle_start_o_t *options --- options structure", "PK Reference - PK_DEBUG_shuffle_start");
top.note("headers/pk_debug_transmit.html#declaration", " <B>const</B> char *key, --- key string", "PK Reference - PK_DEBUG_transmit");
top.note("headers/pk_debug_try_error_handler.html#declaration", "<B>const</B> PK_DEBUG_try_error_handler_o_t *options --- options structure", "PK Reference - PK_DEBUG_try_error_handler");
top.note("headers/pk_delta_frustrum_t.html#declaration", " <B>const</B> char*);", "PK Reference - PK_DELTA_frustrum_t");
top.note("headers/pk_detail_hole_cb_f_t.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces in hole detail", "PK Reference - PK_detail_hole_cb_f_t");
top.note("headers/pk_edge_ask_blend.html#declaration", " PK_blend_type_t *<B>const</B> type, --- type of blend", "PK Reference - PK_EDGE_ask_blend");
top.note("headers/pk_edge_ask_body.html#declaration", " PK_BODY_t *<B>const</B> body --- owning body", "PK Reference - PK_EDGE_ask_body");
top.note("headers/pk_edge_ask_convexity.html#declaration", "<B>const</B> PK_EDGE_ask_convexity_o_t *options,", "PK Reference - PK_EDGE_ask_convexity");
top.note("headers/pk_edge_ask_curve.html#declaration", " PK_CURVE_t *<B>const</B> curve --- its curve (possibly PK_ENTITY_null)", "PK Reference - PK_EDGE_ask_curve");
top.note("headers/pk_edge_ask_curve_nmnl.html#declaration", " PK_CURVE_t *<B>const</B> curve --- its curve (possibly PK_ENTITY_null)", "PK Reference - PK_EDGE_ask_curve_nmnl");
top.note("headers/pk_edge_ask_faces.html#declaration", " int *<B>const</B> n_faces, --- number of faces (>= 0)", "PK Reference - PK_EDGE_ask_faces");
top.note("headers/pk_edge_ask_fins.html#declaration", " int *<B>const</B> n_fins, --- number of fins (>= 0)", "PK Reference - PK_EDGE_ask_fins");
top.note("headers/pk_edge_ask_first_fin.html#declaration", " PK_FIN_t *<B>const</B> first_fin --- the first fin (possibly PK_ENTITY_null)", "PK Reference - PK_EDGE_ask_first_fin");
top.note("headers/pk_edge_ask_geometry.html#declaration", " PK_CURVE_t *<B>const</B> curve, --- curve of edge (may be PK_ENTITY_null)", "PK Reference - PK_EDGE_ask_geometry");
top.note("headers/pk_edge_ask_geometry_nmnl.html#declaration", " PK_CURVE_t *<B>const</B> curve, --- curve of edge (may be PK_ENTITY_null)", "PK Reference - PK_EDGE_ask_geometry_nmnl");
top.note("headers/pk_edge_ask_next_in_body.html#declaration", " PK_EDGE_t *<B>const</B> next --- the next edge (possibly PK_ENTITY_null)", "PK Reference - PK_EDGE_ask_next_in_body");
top.note("headers/pk_edge_ask_oriented_curve.html#declaration", " PK_CURVE_t *<B>const</B> curve, --- the curve (possibly PK_ENTITY_null)", "PK Reference - PK_EDGE_ask_oriented_curve");
top.note("headers/pk_edge_ask_precision.html#declaration", " double *<B>const</B> precision --- precision", "PK Reference - PK_EDGE_ask_precision");
top.note("headers/pk_edge_ask_shells.html#declaration", " int *<B>const</B> n_shells, --- number of shells (>= 1)", "PK Reference - PK_EDGE_ask_shells");
top.note("headers/pk_edge_ask_type.html#declaration", " PK_EDGE_ask_type_t *<B>const</B> edge_types --- edge types structure", "PK Reference - PK_EDGE_ask_type");
top.note("headers/pk_edge_attach_curve_nmnl.html#declaration", "<B>const</B> PK_EDGE_attach_curve_nmnl_o_t *options --- option structure", "PK Reference - PK_EDGE_attach_curve_nmnl");
top.note("headers/pk_edge_attach_curves.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges to have curves attached", "PK Reference - PK_EDGE_attach_curves");
top.note("headers/pk_edge_attach_curves_2.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges to have curves attached", "PK Reference - PK_EDGE_attach_curves_2");
top.note("headers/pk_edge_attach_curves_o_t.html#declaration", " <B>const</B> PK_INTERVAL_t *intervals; --- parametric intervals of curves", "PK Reference - PK_EDGE_attach_curves_o_t");
top.note("headers/pk_edge_check.html#declaration", "<B>const</B> PK_EDGE_check_o_t *options, --- options structure", "PK Reference - PK_EDGE_check");
top.note("headers/pk_edge_check_blends.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges to have blends checked", "PK Reference - PK_EDGE_check_blends");
top.note("headers/pk_edge_contains_vector.html#declaration", " PK_TOPOL_t *<B>const</B> topol --- topology coincident with vector if any", "PK Reference - PK_EDGE_contains_vector");
top.note("headers/pk_edge_delete.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges to be deleted", "PK Reference - PK_EDGE_delete");
top.note("headers/pk_edge_delete_wireframe.html#declaration", "<B>const</B> PK_EDGE_t edges[] --- wireframe edges to delete", "PK Reference - PK_EDGE_delete_wireframe");
top.note("headers/pk_edge_euler_delete_make_loop.html#declaration", " PK_LOOP_t *<B>const</B> new_loop --- New loop created", "PK Reference - PK_EDGE_euler_delete_make_loop");
top.note("headers/pk_edge_euler_open_zip.html#declaration", " PK_VERTEX_t *<B>const</B> new_vertex, --- New vertex created", "PK Reference - PK_EDGE_euler_open_zip");
top.note("headers/pk_edge_euler_slit.html#declaration", " PK_FACE_t *<B>const</B> new_face, --- New face created by slit", "PK Reference - PK_EDGE_euler_slit");
top.note("headers/pk_edge_euler_split.html#declaration", " PK_VERTEX_t *<B>const</B> new_vertex, --- New vertex create by split", "PK Reference - PK_EDGE_euler_split");
top.note("headers/pk_edge_find_blend_topol.html#declaration", " int *<B>const</B> n_edges, --- number of affected edges", "PK Reference - PK_EDGE_find_blend_topol");
top.note("headers/pk_edge_find_deviation.html#declaration", " int *<B>const</B> n_distances, --- number of distances returned", "PK Reference - PK_EDGE_find_deviation");
top.note("headers/pk_edge_find_deviation_2.html#declaration", "<B>const</B> PK_EDGE_find_deviation_o_t *options, --- Option structure", "PK Reference - PK_EDGE_find_deviation_2");
top.note("headers/pk_edge_find_deviation_r_f.html#declaration", " PK_EDGE_find_deviation_r_t *<B>const</B> results", "PK Reference - PK_EDGE_find_deviation_r_f");
top.note("headers/pk_edge_find_end_tangents.html#declaration", " PK_VECTOR_t *<B>const</B> start, --- start position of edge", "PK Reference - PK_EDGE_find_end_tangents");
top.note("headers/pk_edge_find_extreme.html#declaration", " PK_VECTOR_t *<B>const</B> extreme, --- position of extreme point", "PK Reference - PK_EDGE_find_extreme");
top.note("headers/pk_edge_find_g1_edges.html#declaration", " int *<B>const</B> n_edges, --- number of edges (>= 1)", "PK Reference - PK_EDGE_find_g1_edges");
top.note("headers/pk_edge_find_interval.html#declaration", " PK_INTERVAL_t *<B>const</B> t_int", "PK Reference - PK_EDGE_find_interval");
top.note("headers/pk_edge_imprint_point.html#declaration", " PK_VERTEX_t *<B>const</B> new_vertex, --- new vertex", "PK Reference - PK_EDGE_imprint_point");
top.note("headers/pk_edge_is_planar.html#declaration", " PK_LOGICAL_t *<B>const</B> is_planar, --- whether edge is planar", "PK Reference - PK_EDGE_is_planar");
top.note("headers/pk_edge_is_smooth.html#declaration", " PK_LOGICAL_t *<B>const</B> is_smooth --- whether the edge is smooth", "PK Reference - PK_EDGE_is_smooth");
top.note("headers/pk_edge_make_curve.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edge chain to make curve", "PK Reference - PK_EDGE_make_curve");
top.note("headers/pk_edge_make_faces_from_wire.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- initial wireframe edges", "PK Reference - PK_EDGE_make_faces_from_wire");
top.note("headers/pk_edge_make_wire_body.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges", "PK Reference - PK_EDGE_make_wire_body");
top.note("headers/pk_edge_offset_on_body.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges", "PK Reference - PK_EDGE_offset_on_body");
top.note("headers/pk_edge_offset_on_body_r_f.html#declaration", " PK_EDGE_offset_on_body_r_t *<B>const</B> results", "PK Reference - PK_EDGE_offset_on_body_r_f");
top.note("headers/pk_edge_optimise.html#declaration", "<B>const</B> PK_EDGE_optimise_o_t *options, --- option structure", "PK Reference - PK_EDGE_optimise");
top.note("headers/pk_edge_remove_to_bodies.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges", "PK Reference - PK_EDGE_remove_to_bodies");
top.note("headers/pk_edge_repair.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges", "PK Reference - PK_EDGE_repair");
top.note("headers/pk_edge_reset_precision.html#declaration", " PK_reset_prec_t *<B>const</B> result", "PK Reference - PK_EDGE_reset_precision");
top.note("headers/pk_edge_reset_precision_2.html#declaration", "<B>const</B> PK_EDGE_reset_precision_o_t *options, --- options", "PK Reference - PK_EDGE_reset_precision_2");
top.note("headers/pk_edge_reverse_2.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges to be reversed", "PK Reference - PK_EDGE_reverse_2");
top.note("headers/pk_edge_set_blend_chain.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges to be blended", "PK Reference - PK_EDGE_set_blend_chain");
top.note("headers/pk_edge_set_blend_chamfer.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges to have", "PK Reference - PK_EDGE_set_blend_chamfer");
top.note("headers/pk_edge_set_blend_constant.html#declaration", "<B>const</B> PK_EDGE_t edges[], --- edges to have", "PK Reference - PK_EDGE_set_blend_constant");
top.note("headers/pk_edge_set_blend_variable.html#declaration", "<B>const</B> PK_EDGE_set_blend_variable_o_t *options, --- options structure", "PK Reference - PK_EDGE_set_blend_variable");
top.note("headers/pk_edge_set_precision.html#declaration", " int *<B>const</B> n_new_edges, --- number of new edges", "PK Reference - PK_EDGE_set_precision");
top.note("headers/pk_edge_set_precision_2.html#declaration", "<B>const</B> PK_EDGE_set_precision_o_t *options, --- options", "PK Reference - PK_EDGE_set_precision_2");
top.note("headers/pk_edge_split_at_param.html#declaration", " PK_VERTEX_t *<B>const</B> new_vertex, --- new vertex", "PK Reference - PK_EDGE_split_at_param");
top.note("headers/pk_ellipse_ask.html#declaration", " PK_ELLIPSE_sf_t *<B>const</B> ellipse_sf --- ellipse standard form", "PK Reference - PK_ELLIPSE_ask");
top.note("headers/pk_ellipse_create.html#declaration", " <B>const</B> PK_ELLIPSE_sf_t *ellipse_sf, --- ellipse standard form", "PK Reference - PK_ELLIPSE_create");
top.note("headers/pk_emboss_sidewall_data_t.html#declaration", " <B>const</B> PK_EDGE_t *multi_taper_edges;", "PK Reference - PK_emboss_sidewall_data_t");
top.note("headers/pk_entity_ask_attribs.html#declaration", " int *<B>const</B> n_attribs, --- number of attributes (>=0)", "PK Reference - PK_ENTITY_ask_attribs");
top.note("headers/pk_entity_ask_class.html#declaration", " PK_CLASS_t *<B>const</B> class --- class of entity", "PK Reference - PK_ENTITY_ask_class");
top.note("headers/pk_entity_ask_description.html#declaration", "<B>const</B> PK_ENTITY_ask_description_o_t *options, --- options structure", "PK Reference - PK_ENTITY_ask_description");
top.note("headers/pk_entity_ask_first_attrib.html#declaration", " PK_ATTRIB_t *<B>const</B> attrib --- an attribute on entity of given", "PK Reference - PK_ENTITY_ask_first_attrib");
top.note("headers/pk_entity_ask_identifier.html#declaration", " int *<B>const</B> identifier --- identifier of entity (possibly 0)", "PK Reference - PK_ENTITY_ask_identifier");
top.note("headers/pk_entity_ask_owning_groups.html#declaration", " int *<B>const</B> n_groups, --- number of groups (>=0)", "PK Reference - PK_ENTITY_ask_owning_groups");
top.note("headers/pk_entity_ask_owning_groups_2.html#declaration", "<B>const</B> PK_ENTITY_ask_owning_groups_o_t *options, --- options", "PK Reference - PK_ENTITY_ask_owning_groups_2");
top.note("headers/pk_entity_ask_partition.html#declaration", " PK_PARTITION_t *<B>const</B> partition --- partition of entity", "PK Reference - PK_ENTITY_ask_partition");
top.note("headers/pk_entity_ask_user_field.html#declaration", " int *<B>const</B> user_field --- user_field values", "PK Reference - PK_ENTITY_ask_user_field");
top.note("headers/pk_entity_check_attribs.html#declaration", "<B>const</B> PK_ENTITY_check_attribs_o_t *options, --- options structure", "PK Reference - PK_ENTITY_check_attribs");
top.note("headers/pk_entity_copy.html#declaration", " PK_ENTITY_t *<B>const</B> entity_copy --- copy of given entity", "PK Reference - PK_ENTITY_copy");
top.note("headers/pk_entity_copy_2.html#declaration", "<B>const</B> PK_ENTITY_copy_o_t *options, --- options structure", "PK Reference - PK_ENTITY_copy_2");
top.note("headers/pk_entity_delete.html#declaration", "<B>const</B> PK_ENTITY_t *entities --- entities to be deleted", "PK Reference - PK_ENTITY_delete");
top.note("headers/pk_entity_delete_attribs.html#declaration", " int *<B>const</B> n_deleted --- number of attributes deleted (>=0)", "PK Reference - PK_ENTITY_delete_attribs");
top.note("headers/pk_entity_find_reparam.html#declaration", "<B>const</B> PK_ENTITY_find_reparam_o_t *options, --- find reparam options", "PK Reference - PK_ENTITY_find_reparam");
top.note("headers/pk_entity_find_reparam_r_f.html#declaration", " PK_ENTITY_find_reparam_r_t *<B>const</B> results --- structure to free", "PK Reference - PK_ENTITY_find_reparam_r_f");
top.note("headers/pk_entity_is.html#declaration", " PK_LOGICAL_t *<B>const</B> is_entity --- whether it is an entity", "PK Reference - PK_ENTITY_is");
top.note("headers/pk_entity_is_curve.html#declaration", " PK_LOGICAL_t *<B>const</B> is_curve --- whether entity is a curve", "PK Reference - PK_ENTITY_is_curve");
top.note("headers/pk_entity_is_geom.html#declaration", " PK_LOGICAL_t *<B>const</B> is_geom --- whether entity is geometry", "PK Reference - PK_ENTITY_is_geom");
top.note("headers/pk_entity_is_part.html#declaration", " PK_LOGICAL_t *<B>const</B> is_part --- whether entity is a part", "PK Reference - PK_ENTITY_is_part");
top.note("headers/pk_entity_is_surf.html#declaration", " PK_LOGICAL_t *<B>const</B> is_surf --- whether entity is a surface", "PK Reference - PK_ENTITY_is_surf");
top.note("headers/pk_entity_is_topol.html#declaration", " PK_LOGICAL_t *<B>const</B> is_topol --- whether entity is topology", "PK Reference - PK_ENTITY_is_topol");
top.note("headers/pk_entity_may_own_attdef.html#declaration", " PK_LOGICAL_t *<B>const</B> whether", "PK Reference - PK_ENTITY_may_own_attdef");
top.note("headers/pk_entity_range.html#declaration", "<B>const</B> PK_ENTITY_t entities_1[], --- first entity array", "PK Reference - PK_ENTITY_range");
top.note("headers/pk_entity_range_o_t.html#declaration", " <B>const</B> PK_range_guess_t *guesses_1; --- guesses for the first entity", "PK Reference - PK_ENTITY_range_o_t");
top.note("headers/pk_entity_range_r_f.html#declaration", " PK_ENTITY_range_r_t *<B>const</B> result --- result information to free", "PK Reference - PK_ENTITY_range_r_f");
top.note("headers/pk_entity_range_vector.html#declaration", "<B>const</B> PK_ENTITY_t entities[], --- entity array", "PK Reference - PK_ENTITY_range_vector");
top.note("headers/pk_entity_range_vector_o_t.html#declaration", " <B>const</B> PK_range_guess_t *guesses; --- guesses for end on entities", "PK Reference - PK_ENTITY_range_vector_o_t");
top.note("headers/pk_entity_range_vector_r_f.html#declaration", " PK_ENTITY_range_vector_r_t *<B>const</B> result --- result information to free", "PK Reference - PK_ENTITY_range_vector_r_f");
top.note("headers/pk_entity_set_user_field.html#declaration", "<B>const</B> int *user_field --- user_field values", "PK Reference - PK_ENTITY_set_user_field");
top.note("headers/pk_entity_track_r_f.html#declaration", " PK_ENTITY_track_r_t *<B>const</B> tracking --- tracking information to free", "PK Reference - PK_ENTITY_track_r_f");
top.note("headers/pk_error_ask_callbacks.html#declaration", " PK_ERROR_frustrum_t *<B>const</B> frustrum --- session error handler", "PK Reference - PK_ERROR_ask_callbacks");
top.note("headers/pk_error_ask_last.html#declaration", " PK_LOGICAL_t *<B>const</B> was_error, --- whether there was an error", "PK Reference - PK_ERROR_ask_last");
top.note("headers/pk_error_clear_last.html#declaration", " PK_LOGICAL_t *<B>const</B> was_error --- whether there was an error to", "PK Reference - PK_ERROR_clear_last");
top.note("headers/pk_error_reraise.html#declaration", " PK_LOGICAL_t *<B>const</B> was_error --- whether there was an error to", "PK Reference - PK_ERROR_reraise");
top.note("headers/pk_expr_sf_t.html#declaration", " <B>const</B> char *root_expr; --- root expression definition (NULL)", "PK Reference - PK_EXPR_sf_t");
top.note("headers/pk_extend_side_data_t.html#declaration", " <B>const</B> PK_VERTEX_t *vertices; --- terminal vertices of the", "PK Reference - PK_extend_side_data_t");
top.note("headers/pk_face_ask_body.html#declaration", " PK_BODY_t *<B>const</B> body --- owning body", "PK Reference - PK_FACE_ask_body");
top.note("headers/pk_face_ask_edges.html#declaration", " int *<B>const</B> n_edges, --- number of edges (>= 0)", "PK Reference - PK_FACE_ask_edges");
top.note("headers/pk_face_ask_faces_adjacent.html#declaration", "<B>const</B> PK_FACE_t faces[], --- array of faces", "PK Reference - PK_FACE_ask_faces_adjacent");
top.note("headers/pk_face_ask_first_loop.html#declaration", " PK_LOOP_t *<B>const</B> first_loop --- the first loop (possibly PK_ENTITY_null)", "PK Reference - PK_FACE_ask_first_loop");
top.note("headers/pk_face_ask_loops.html#declaration", " int *<B>const</B> n_loops, --- number of loops (>= 0)", "PK Reference - PK_FACE_ask_loops");
top.note("headers/pk_face_ask_next_in_body.html#declaration", " PK_FACE_t *<B>const</B> next --- the next face (possibly PK_ENTITY_null)", "PK Reference - PK_FACE_ask_next_in_body");
top.note("headers/pk_face_ask_oriented_surf.html#declaration", " PK_SURF_t *<B>const</B> surf, --- the surface (possibly PK_ENTITY_null)", "PK Reference - PK_FACE_ask_oriented_surf");
top.note("headers/pk_face_ask_surf.html#declaration", " PK_SURF_t *<B>const</B> surf --- its surface (possibly PK_ENTITY_null)", "PK Reference - PK_FACE_ask_surf");
top.note("headers/pk_face_ask_type.html#declaration", "<B>const</B> PK_FACE_ask_type_o_t *options, --- options", "PK Reference - PK_FACE_ask_type");
top.note("headers/pk_face_ask_type_r_f.html#declaration", " PK_FACE_ask_type_r_t *<B>const</B> results", "PK Reference - PK_FACE_ask_type_r_f");
top.note("headers/pk_face_ask_vertices.html#declaration", " int *<B>const</B> n_vertices, --- number of vertices (>= 0)", "PK Reference - PK_FACE_ask_vertices");
top.note("headers/pk_face_attach_surf_fitting.html#declaration", " PK_local_check_t *<B>const</B> local_check_result --- result of local check", "PK Reference - PK_FACE_attach_surf_fitting");
top.note("headers/pk_face_attach_surfs.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces to have surfaces attached", "PK Reference - PK_FACE_attach_surfs");
top.note("headers/pk_face_boolean.html#declaration", "<B>const</B> PK_FACE_t targets[], --- target faces", "PK Reference - PK_FACE_boolean");
top.note("headers/pk_face_boolean_2.html#declaration", "<B>const</B> PK_FACE_t targets[], --- target faces", "PK Reference - PK_FACE_boolean_2");
top.note("headers/pk_face_boolean_o_t.html#declaration", " <B>const</B> PK_boolean_config_o_t ", "PK Reference - PK_FACE_boolean_o_t");
top.note("headers/pk_face_change.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces to change", "PK Reference - PK_FACE_change");
top.note("headers/pk_face_change_blend_o_t.html#declaration", " <B>const</B> PK_ENTITY_t *unders; --- faces used to define the", "PK Reference - PK_FACE_change_blend_o_t");
top.note("headers/pk_face_change_data_taper_t.html#declaration", " <B>const</B> PK_ENTITY_t *references; --- taper reference entities", "PK Reference - PK_FACE_change_data_taper_t");
top.note("headers/pk_face_change_deform_eval_f_t.html#declaration", " PK_VECTOR_t *<B>const</B> deformed_position --- deformed position", "PK Reference - PK_FACE_change_deform_eval_f_t");
top.note("headers/pk_face_change_deform_o_t.html#declaration", " <B>const</B> PK_EDGE_t *matched_edges; --- matched edges (NULL)", "PK Reference - PK_FACE_change_deform_o_t");
top.note("headers/pk_face_change_opts_t.html#declaration", " <B>const</B> PK_FACE_change_offset_o_t *offset; --- offset specific options", "PK Reference - PK_FACE_change_opts_t");
top.note("headers/pk_face_change_taper_o_t.html#declaration", " <B>const</B> PK_ENTITY_t *parting_edges; --- parting body step edges (NULL)", "PK Reference - PK_FACE_change_taper_o_t");
top.note("headers/pk_face_change_transform_o_t.html#declaration", " <B>const</B> PK_LOOP_t *base_loops; --- boundary loops of the faces", "PK Reference - PK_FACE_change_transform_o_t");
top.note("headers/pk_face_check.html#declaration", "<B>const</B> PK_FACE_check_o_t *options, --- options structure", "PK Reference - PK_FACE_check");
top.note("headers/pk_face_check_pair.html#declaration", "<B>const</B> PK_FACE_check_pair_o_t *options, --- options structure", "PK Reference - PK_FACE_check_pair");
top.note("headers/pk_face_classify_details.html#declaration", "<B>const</B> PK_FACE_classify_details_o_t *options, --- options structure", "PK Reference - PK_FACE_classify_details");
top.note("headers/pk_face_classify_details_o_t.html#declaration", " <B>const</B> PK_FACE_details_hole_o_t *hole; --- hole options ( NULL )", "PK Reference - PK_FACE_classify_details_o_t");
top.note("headers/pk_face_classify_details_r_f.html#declaration", " PK_FACE_classify_details_r_t *<B>const</B> results", "PK Reference - PK_FACE_classify_details_r_f");
top.note("headers/pk_face_close_gaps.html#declaration", "<B>const</B> PK_FACE_close_gaps_o_t *options, --- options on how to close", "PK Reference - PK_FACE_close_gaps");
top.note("headers/pk_face_contains_vectors.html#declaration", "<B>const</B> PK_FACE_contains_vectors_o_t *options,", "PK Reference - PK_FACE_contains_vectors");
top.note("headers/pk_face_cover.html#declaration", "<B>const</B> PK_FACE_t faces[], --- target faces to cover", "PK Reference - PK_FACE_cover");
top.note("headers/pk_face_delete.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces", "PK Reference - PK_FACE_delete");
top.note("headers/pk_face_delete_2.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces to delete", "PK Reference - PK_FACE_delete_2");
top.note("headers/pk_face_delete_blends.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces to delete", "PK Reference - PK_FACE_delete_blends");
top.note("headers/pk_face_delete_facesets.html#declaration", "<B>const</B> PK_FACE_delete_facesets_o_t *options, --- options structure", "PK Reference - PK_FACE_delete_facesets");
top.note("headers/pk_face_delete_from_gen_body.html#declaration", "<B>const</B> PK_FACE_t faces[] --- faces to delete", "PK Reference - PK_FACE_delete_from_gen_body");
top.note("headers/pk_face_delete_from_sheet.html#declaration", "<B>const</B> PK_FACE_t faces[], --- array of faces", "PK Reference - PK_FACE_delete_from_sheet");
top.note("headers/pk_face_emboss.html#declaration", "<B>const</B> PK_FACE_t faces[], --- target faces upon which the", "PK Reference - PK_FACE_emboss");
top.note("headers/pk_face_euler_make_loop.html#declaration", " PK_LOOP_t *<B>const</B> new_loop --- New loop created", "PK Reference - PK_FACE_euler_make_loop");
top.note("headers/pk_face_euler_make_ring_face.html#declaration", " PK_FACE_t *<B>const</B> new_face --- New face created", "PK Reference - PK_FACE_euler_make_ring_face");
top.note("headers/pk_face_euler_make_ring_loop.html#declaration", " PK_LOOP_t *<B>const</B> new_loop --- One of the two loops created", "PK Reference - PK_FACE_euler_make_ring_loop");
top.note("headers/pk_face_find_blend_unders.html#declaration", "<B>const</B> PK_FACE_find_blend_unders_o_t *options, --- options", "PK Reference - PK_FACE_find_blend_unders");
top.note("headers/pk_face_find_blend_unders_r_f.html#declaration", " PK_FACE_find_blend_unders_r_t *<B>const</B> under_returns", "PK Reference - PK_FACE_find_blend_unders_r_f");
top.note("headers/pk_face_find_edges_common.html#declaration", " int *<B>const</B> n_edges, --- number of common edges", "PK Reference - PK_FACE_find_edges_common");
top.note("headers/pk_face_find_extreme.html#declaration", " PK_VECTOR_t *<B>const</B> extreme, --- position of extreme point", "PK Reference - PK_FACE_find_extreme");
top.note("headers/pk_face_find_interior_vec.html#declaration", "<B>const</B> PK_FACE_find_interior_vec_o_t *options, --- options structure", "PK Reference - PK_FACE_find_interior_vec");
top.note("headers/pk_face_find_outer_loop.html#declaration", "<B>const</B> PK_FACE_find_outer_loop_o_t *options, --- provided options", "PK Reference - PK_FACE_find_outer_loop");
top.note("headers/pk_face_find_uvbox.html#declaration", " PK_UVBOX_t *<B>const</B> uvbox --- uvbox containing face", "PK Reference - PK_FACE_find_uvbox");
top.note("headers/pk_face_fix_mesh_defects.html#declaration", "<B>const</B> PK_FACE_t faces[], --- array of faces to process", "PK Reference - PK_FACE_fix_mesh_defects");
top.note("headers/pk_face_fix_mesh_defects_r_f.html#declaration", " PK_FACE_fix_mesh_defects_r_t *<B>const</B> results", "PK Reference - PK_FACE_fix_mesh_defects_r_f");
top.note("headers/pk_face_grow_cb_f_t.html#declaration", "<B>const</B> PK_FACE_t faces1[], --- first set of clashing faces", "PK Reference - PK_FACE_grow_cb_f_t");
top.note("headers/pk_face_hollow.html#declaration", " PK_FACE_t *<B>const</B> new_faces --- new faces", "PK Reference - PK_FACE_hollow");
top.note("headers/pk_face_hollow_2.html#declaration", " int *<B>const</B> n_new_faces,", "PK Reference - PK_FACE_hollow_2");
top.note("headers/pk_face_hollow_3.html#declaration", "<B>const</B> PK_FACE_hollow_o_t *options, --- options [PF]", "PK Reference - PK_FACE_hollow_3");
top.note("headers/pk_face_identify_blends.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces", "PK Reference - PK_FACE_identify_blends");
top.note("headers/pk_face_identify_blends_r_f.html#declaration", " PK_FACE_identify_blends_r_t *<B>const</B> blend_returns", "PK Reference - PK_FACE_identify_blends_r_f");
top.note("headers/pk_face_imprint_curve.html#declaration", " int *<B>const</B> n_new_edges, --- number of new edges", "PK Reference - PK_FACE_imprint_curve");
top.note("headers/pk_face_imprint_curves_2.html#declaration", "<B>const</B> PK_CURVE_t curves[], --- curves", "PK Reference - PK_FACE_imprint_curves_2");
top.note("headers/pk_face_imprint_curves_isocline.html#declaration", "<B>const</B> PK_FACE_t rec_faces[], --- received faces", "PK Reference - PK_FACE_imprint_curves_isocline");
top.note("headers/pk_face_imprint_cus_isoclin.html#declaration", "<B>const</B> PK_FACE_t rec_faces[],--- received faces", "PK Reference - PK_FACE_imprint_cus_isoclin");
top.note("headers/pk_face_imprint_cus_normal.html#declaration", "<B>const</B> PK_FACE_t targets[], --- array of faces", "PK Reference - PK_FACE_imprint_cus_normal");
top.note("headers/pk_face_imprint_cus_vec.html#declaration", "<B>const</B> PK_FACE_t targets[], --- array of faces", "PK Reference - PK_FACE_imprint_cus_vec");
top.note("headers/pk_face_imprint_cus_vector.html#declaration", "<B>const</B> PK_FACE_t targets[], --- array of faces", "PK Reference - PK_FACE_imprint_cus_vector");
top.note("headers/pk_face_imprint_faces.html#declaration", "<B>const</B> PK_FACE_t targets[], --- target faces", "PK Reference - PK_FACE_imprint_faces");
top.note("headers/pk_face_imprint_faces_2.html#declaration", "<B>const</B> PK_FACE_t targets[], --- target faces", "PK Reference - PK_FACE_imprint_faces_2");
top.note("headers/pk_face_imprint_faces_o_t.html#declaration", " <B>const</B> PK_boolean_match_o_t ", "PK Reference - PK_FACE_imprint_faces_o_t");
top.note("headers/pk_face_imprint_o_t.html#declaration", " <B>const</B> PK_boolean_match_o_t ", "PK Reference - PK_FACE_imprint_o_t");
top.note("headers/pk_face_imprint_point.html#declaration", " PK_VERTEX_t *<B>const</B> new_vertex --- new vertex", "PK Reference - PK_FACE_imprint_point");
top.note("headers/pk_face_inst_tools_r_f.html#declaration", " PK_FACE_inst_tools_r_t *<B>const</B> results", "PK Reference - PK_FACE_inst_tools_r_f");
top.note("headers/pk_face_install_surfs_isocline.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces to be drafted", "PK Reference - PK_FACE_install_surfs_isocline");
top.note("headers/pk_face_instance_bodies.html#declaration", "<B>const</B> PK_FACE_t target_faces[], --- target faces", "PK Reference - PK_FACE_instance_bodies");
top.note("headers/pk_face_instance_bodies_o_t.html#declaration", " <B>const</B> PK_boolean_config_o_t ", "PK Reference - PK_FACE_instance_bodies_o_t");
top.note("headers/pk_face_instance_tools.html#declaration", "<B>const</B> PK_FACE_t target_faces[], --- target faces", "PK Reference - PK_FACE_instance_tools");
top.note("headers/pk_face_intersect_curve.html#declaration", " int *<B>const</B> n_vectors, --- number of intersections", "PK Reference - PK_FACE_intersect_curve");
top.note("headers/pk_face_intersect_face.html#declaration", "<B>const</B> PK_FACE_intersect_face_o_t *options, --- options structure [PF]", "PK Reference - PK_FACE_intersect_face");
top.note("headers/pk_face_intersect_surf.html#declaration", "<B>const</B> PK_FACE_intersect_surf_o_t *options, --- options structure [PF]", "PK Reference - PK_FACE_intersect_surf");
top.note("headers/pk_face_is_coincident.html#declaration", "<B>const</B> PK_FACE_is_coincident_o_t *options, --- option structure", "PK Reference - PK_FACE_is_coincident");
top.note("headers/pk_face_is_periodic.html#declaration", " PK_PARAM_periodic_t *<B>const</B> periodic_u, --- periodicity in u", "PK Reference - PK_FACE_is_periodic");
top.note("headers/pk_face_is_uvbox.html#declaration", " PK_LOGICAL_t *<B>const</B> is_uvbox, --- whether face is parametric rectangle", "PK Reference - PK_FACE_is_uvbox");
top.note("headers/pk_face_make_3_face_blend.html#declaration", "<B>const</B> PK_FACE_t left_wall_faces[], --- left wall faces", "PK Reference - PK_FACE_make_3_face_blend");
top.note("headers/pk_face_make_3_face_blend_o_t.html#declaration", " <B>const</B> PK_ENTITY_t *limits; --- entities limiting the blend", "PK Reference - PK_FACE_make_3_face_blend_o_t");
top.note("headers/pk_face_make_3_face_blend_r_f.html#declaration", " PK_FACE_make_3_face_blend_r_t *<B>const</B> results", "PK Reference - PK_FACE_make_3_face_blend_r_f");
top.note("headers/pk_face_make_blend.html#declaration", "<B>const</B> PK_FACE_t left_wall_faces[], --- faces in left wall", "PK Reference - PK_FACE_make_blend");
top.note("headers/pk_face_make_neutral_sheet.html#declaration", " PK_BODY_t *<B>const</B> neutral_sheet --- neutral sheet", "PK Reference - PK_FACE_make_neutral_sheet");
top.note("headers/pk_face_make_neutral_sheet_2.html#declaration", "<B>const</B> PK_FACE_t left_faces[], --- left faces", "PK Reference - PK_FACE_make_neutral_sheet_2");
top.note("headers/pk_face_make_neutral_sheet_o_t.html#declaration", " <B>const</B> PK_neutral_method_t ", "PK Reference - PK_FACE_make_neutral_sheet_o_t");
top.note("headers/pk_face_make_sect_with_sfs.html#declaration", "<B>const</B> PK_FACE_make_sect_with_sfs_o_t *options, --- Sectioning options", "PK Reference - PK_FACE_make_sect_with_sfs");
top.note("headers/pk_face_make_sect_with_sfs_r_f.html#declaration", " PK_FACE_make_sect_with_sfs_r_t *<B>const</B> results --- section results to free", "PK Reference - PK_FACE_make_sect_with_sfs_r_f");
top.note("headers/pk_face_make_sheet_bodies.html#declaration", "<B>const</B> PK_FACE_t faces[], --- array of faces", "PK Reference - PK_FACE_make_sheet_bodies");
top.note("headers/pk_face_make_sheet_body.html#declaration", "<B>const</B> PK_FACE_t faces[], --- array of faces", "PK Reference - PK_FACE_make_sheet_body");
top.note("headers/pk_face_make_solid_bodies.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces", "PK Reference - PK_FACE_make_solid_bodies");
top.note("headers/pk_face_offset.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces to offset", "PK Reference - PK_FACE_offset");
top.note("headers/pk_face_offset_2.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces to offset", "PK Reference - PK_FACE_offset_2");
top.note("headers/pk_face_output_surf_trimmed.html#declaration", "<B>const</B> PK_FACE_output_surf_trimmed_o_t *options, --- options structure", "PK Reference - PK_FACE_output_surf_trimmed");
top.note("headers/pk_face_pattern.html#declaration", "<B>const</B> PK_FACE_t pattern_faces[], --- pattern faces", "PK Reference - PK_FACE_pattern");
top.note("headers/pk_face_pattern_2.html#declaration", "<B>const</B> PK_FACE_t pattern_faces[], --- pattern faces", "PK Reference - PK_FACE_pattern_2");
top.note("headers/pk_face_pattern_2_r_f.html#declaration", " PK_FACE_pattern_2_r_t *<B>const</B> pattern_results --- status and tracking info", "PK Reference - PK_FACE_pattern_2_r_f");
top.note("headers/pk_face_pattern_r_f.html#declaration", " PK_FACE_pattern_r_t *<B>const</B> pattern_results --- status and tracking info", "PK Reference - PK_FACE_pattern_r_f");
top.note("headers/pk_face_remove_to_solid_bodies.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces", "PK Reference - PK_FACE_remove_to_solid_bodies");
top.note("headers/pk_face_repair.html#declaration", "<B>const</B> PK_FACE_repair_o_t *options, --- options structure", "PK Reference - PK_FACE_repair");
top.note("headers/pk_face_reparameterise_surf.html#declaration", "<B>const</B> PK_FACE_reparameterise_surf_o_t *options, --- options", "PK Reference - PK_FACE_reparameterise_surf");
top.note("headers/pk_face_reparameterise_surf_r_f.html#declaration", " PK_FACE_reparameterise_surf_r_t *<B>const</B> results", "PK Reference - PK_FACE_reparameterise_surf_r_f");
top.note("headers/pk_face_replace_surfs.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces", "PK Reference - PK_FACE_replace_surfs");
top.note("headers/pk_face_replace_surfs_2.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces", "PK Reference - PK_FACE_replace_surfs_2");
top.note("headers/pk_face_replace_surfs_3.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces", "PK Reference - PK_FACE_replace_surfs_3");
top.note("headers/pk_face_replace_with_sheet.html#declaration", "<B>const</B> PK_FACE_t faces[], --- target faces to replace", "PK Reference - PK_FACE_replace_with_sheet");
top.note("headers/pk_face_reverse.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces", "PK Reference - PK_FACE_reverse");
top.note("headers/pk_face_section_o_t.html#declaration", " <B>const</B> PK_boolean_config_o_t ", "PK Reference - PK_FACE_section_o_t");
top.note("headers/pk_face_section_with_sheet.html#declaration", "<B>const</B> PK_FACE_t targets[], --- Target faces", "PK Reference - PK_FACE_section_with_sheet");
top.note("headers/pk_face_section_with_sheet_2.html#declaration", "<B>const</B> PK_FACE_t targets[], --- target faces", "PK Reference - PK_FACE_section_with_sheet_2");
top.note("headers/pk_face_set_approx.html#declaration", "<B>const</B> PK_FACE_t faces[] --- faces for which approximations are", "PK Reference - PK_FACE_set_approx");
top.note("headers/pk_face_simplify_geom.html#declaration", "<B>const</B> PK_FACE_simplify_geom_o_t *options, --- options", "PK Reference - PK_FACE_simplify_geom");
top.note("headers/pk_face_spin.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces", "PK Reference - PK_FACE_spin");
top.note("headers/pk_face_split_at_param.html#declaration", "<B>const</B> PK_FACE_split_at_param_o_t *options, --- options", "PK Reference - PK_FACE_split_at_param");
top.note("headers/pk_face_sweep.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces", "PK Reference - PK_FACE_sweep");
top.note("headers/pk_face_taper.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces to be drafted", "PK Reference - PK_FACE_taper");
top.note("headers/pk_face_taper_o_t.html#declaration", " <B>const</B> PK_FACE_t *taper_faces; --- faces which are tapered with", "PK Reference - PK_FACE_taper_o_t");
top.note("headers/pk_face_transform.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces", "PK Reference - PK_FACE_transform");
top.note("headers/pk_face_transform_2.html#declaration", "<B>const</B> PK_FACE_t faces[], --- faces to transform", "PK Reference - PK_FACE_transform_2");
top.note("headers/pk_face_trim_cb_f_t.html#declaration", "<B>const</B> PK_FACE_t faces1[], --- first set of clashing faces", "PK Reference - PK_FACE_trim_cb_f_t");
top.note("headers/pk_face_unset_approx.html#declaration", "<B>const</B> PK_FACE_t faces[] --- faces to clear of approximations", "PK Reference - PK_FACE_unset_approx");
top.note("headers/pk_fcurve_ask.html#declaration", " PK_FCURVE_sf_t *<B>const</B> fcurve_sf --- standard form of fcurve", "PK Reference - PK_FCURVE_ask");
top.note("headers/pk_fcurve_create.html#declaration", " <B>const</B> PK_FCURVE_sf_t *fcurve_sf, --- standard form of fcurve", "PK Reference - PK_FCURVE_create");
top.note("headers/pk_ffclos_f_t.html#declaration", " <B>const</B> int *guise,", "PK Reference - PK_FFCLOS_f_t");
top.note("headers/pk_ffoprb_f_t.html#declaration", " <B>const</B> int *guise,", "PK Reference - PK_FFOPRB_f_t");
top.note("headers/pk_ffoprd_f_t.html#declaration", " <B>const</B> int *guise,", "PK Reference - PK_FFOPRD_f_t");
top.note("headers/pk_ffopwr_f_t.html#declaration", " <B>const</B> int *guise,", "PK Reference - PK_FFOPWR_f_t");
top.note("headers/pk_ffread_f_t.html#declaration", " <B>const</B> int *guise,", "PK Reference - PK_FFREAD_f_t");
top.note("headers/pk_ffseek_f_t.html#declaration", " <B>const</B> int *guise,", "PK Reference - PK_FFSEEK_f_t");
top.note("headers/pk_ffskxt_f_t.html#declaration", " <B>const</B> int guise,", "PK Reference - PK_FFSKXT_f_t");
top.note("headers/pk_fftell_f_t.html#declaration", " <B>const</B> int *guise,", "PK Reference - PK_FFTELL_f_t");
top.note("headers/pk_ffwrit_f_t.html#declaration", " <B>const</B> int *guise,", "PK Reference - PK_FFWRIT_f_t");
top.note("headers/pk_fgcrcu_f_t.html#declaration", " <B>const</B> char *key,", "PK Reference - PK_FGCRCU_f_t");
top.note("headers/pk_fgcrsu_f_t.html#declaration", " <B>const</B> char *key,", "PK Reference - PK_FGCRSU_f_t");
top.note("headers/pk_field_name_t.html#declaration", " <B>const</B> char *name;", "PK Reference - PK_field_name_t");
top.note("headers/pk_fin_ask_body.html#declaration", " PK_BODY_t *<B>const</B> body --- owning body", "PK Reference - PK_FIN_ask_body");
top.note("headers/pk_fin_ask_curve.html#declaration", " PK_CURVE_t *<B>const</B> curve --- its curve (possibly PK_ENTITY_null)", "PK Reference - PK_FIN_ask_curve");
top.note("headers/pk_fin_ask_edge.html#declaration", " PK_EDGE_t *<B>const</B> edge --- owning edge", "PK Reference - PK_FIN_ask_edge");
top.note("headers/pk_fin_ask_face.html#declaration", " PK_FACE_t *<B>const</B> face --- owning face", "PK Reference - PK_FIN_ask_face");
top.note("headers/pk_fin_ask_geometry.html#declaration", " PK_CURVE_t *<B>const</B> curve, --- curve of fin (may be PK_ENTITY_null)", "PK Reference - PK_FIN_ask_geometry");
top.note("headers/pk_fin_ask_loop.html#declaration", " PK_LOOP_t *<B>const</B> loop --- owning loop", "PK Reference - PK_FIN_ask_loop");
top.note("headers/pk_fin_ask_next_in_loop.html#declaration", " PK_FIN_t *<B>const</B> next --- the next fin around the loop", "PK Reference - PK_FIN_ask_next_in_loop");
top.note("headers/pk_fin_ask_next_of_edge.html#declaration", " PK_FIN_t *<B>const</B> next --- the next fin around the edge", "PK Reference - PK_FIN_ask_next_of_edge");
top.note("headers/pk_fin_ask_oriented_curve.html#declaration", " PK_CURVE_t *<B>const</B> curve, --- the curve (possibly PK_ENTITY_null)", "PK Reference - PK_FIN_ask_oriented_curve");
top.note("headers/pk_fin_ask_previous_in_loop.html#declaration", " PK_FIN_t *<B>const</B> previous --- the previous fin around the loop", "PK Reference - PK_FIN_ask_previous_in_loop");
top.note("headers/pk_fin_ask_previous_of_edge.html#declaration", " PK_FIN_t *<B>const</B> previous --- the previous fin around the edge", "PK Reference - PK_FIN_ask_previous_of_edge");
top.note("headers/pk_fin_ask_type.html#declaration", " PK_FIN_type_t *<B>const</B> fin_type --- the type of the fin", "PK Reference - PK_FIN_ask_type");
top.note("headers/pk_fin_attach_curves.html#declaration", "<B>const</B> PK_FIN_t fins[], --- fins to have curves attached", "PK Reference - PK_FIN_attach_curves");
top.note("headers/pk_fin_euler_glue.html#declaration", "<B>const</B> PK_FIN_t fins[], --- fins to glue", "PK Reference - PK_FIN_euler_glue");
top.note("headers/pk_fin_find_curve_parameter.html#declaration", " double *<B>const</B> t --- t parameter on curve attached to", "PK Reference - PK_FIN_find_curve_parameter");
top.note("headers/pk_fin_find_interval.html#declaration", " PK_INTERVAL_t *<B>const</B> t_int --- interval", "PK Reference - PK_FIN_find_interval");
top.note("headers/pk_fin_find_mtopols.html#declaration", "<B>const</B> PK_FIN_find_mtopols_o_t *options, --- options structure", "PK Reference - PK_FIN_find_mtopols");
top.note("headers/pk_fin_find_surf_parameters.html#declaration", " PK_UV_t *<B>const</B> parms --- u,v parameters on surface attached to", "PK Reference - PK_FIN_find_surf_parameters");
top.note("headers/pk_fin_find_uvbox.html#declaration", " PK_UVBOX_t *<B>const</B> uvbox --- uvbox containing fin", "PK Reference - PK_FIN_find_uvbox");
top.note("headers/pk_fin_is_positive.html#declaration", " PK_LOGICAL_t *<B>const</B> is_positive --- whether fin is positive or negative", "PK Reference - PK_FIN_is_positive");
top.note("headers/pk_frame_ask_body.html#declaration", " PK_BODY_t *<B>const</B> body --- body", "PK Reference - PK_FRAME_ask_body");
top.note("headers/pk_frame_ask_geometry.html#declaration", "<B>const</B> PK_FRAME_ask_geometry_o_t *options, --- options structure", "PK Reference - PK_FRAME_ask_geometry");
top.note("headers/pk_frame_ask_geometry_r_f.html#declaration", " PK_FRAME_ask_geometry_r_t *<B>const</B> result", "PK Reference - PK_FRAME_ask_geometry_r_f");
top.note("headers/pk_frame_ask_owner.html#declaration", "<B>const</B> PK_FRAME_ask_owner_o_t *options, --- options structure", "PK Reference - PK_FRAME_ask_owner");
top.note("headers/pk_frame_ask_owner_r_f.html#declaration", " PK_FRAME_ask_owner_r_t *<B>const</B> result", "PK Reference - PK_FRAME_ask_owner_r_f");
top.note("headers/pk_frame_ask_sense.html#declaration", " PK_LOGICAL_t *<B>const</B> sense --- sense", "PK Reference - PK_FRAME_ask_sense");
top.note("headers/pk_frame_reverse.html#declaration", "<B>const</B> PK_FRAME_reverse_o_t *options, --- options structure", "PK Reference - PK_FRAME_reverse");
top.note("headers/pk_frame_reverse_r_f.html#declaration", " PK_FRAME_reverse_r_t *<B>const</B> result", "PK Reference - PK_FRAME_reverse_r_f");
top.note("headers/pk_fsurf_ask.html#declaration", " PK_FSURF_sf_t *<B>const</B> fsurf_sf --- standard form of fsurf", "PK Reference - PK_FSURF_ask");
top.note("headers/pk_fsurf_create.html#declaration", " <B>const</B> PK_FSURF_sf_t *fsurf_sf, --- standard form of fsurf", "PK Reference - PK_FSURF_create");
top.note("headers/pk_function_find.html#declaration", "<B>const</B> char *<B>const</B> function_names[], --- function names", "PK Reference - PK_FUNCTION_find");
top.note("headers/pk_geom_ask_dependents.html#declaration", " int *<B>const</B> n_dependents, --- number of dependents (>= 0)", "PK Reference - PK_GEOM_ask_dependents");
top.note("headers/pk_geom_ask_geom_category.html#declaration", "<B>const</B> PK_GEOM_ask_geom_category_o_t *options, --- options", "PK Reference - PK_GEOM_ask_geom_category");
top.note("headers/pk_geom_ask_geom_owners.html#declaration", " int *<B>const</B> n_owners, --- number of geometric owners (>= 0)", "PK Reference - PK_GEOM_ask_geom_owners");
top.note("headers/pk_geom_check.html#declaration", "<B>const</B> PK_GEOM_check_o_t *options, --- options structure", "PK Reference - PK_GEOM_check");
top.note("headers/pk_geom_copy.html#declaration", "<B>const</B> PK_GEOM_t geoms[],", "PK Reference - PK_GEOM_copy");
top.note("headers/pk_geom_copy_r_f.html#declaration", " PK_GEOM_copy_r_t *<B>const</B> copies --- structure to free", "PK Reference - PK_GEOM_copy_r_f");
top.note("headers/pk_geom_enlarge.html#declaration", "<B>const</B> PK_GEOM_t geoms[], --- geometries to be enlarged", "PK Reference - PK_GEOM_enlarge");
top.note("headers/pk_geom_enlarge_r_f.html#declaration", " PK_GEOM_enlarge_r_t *<B>const</B> result --- result information to free", "PK Reference - PK_GEOM_enlarge_r_f");
top.note("headers/pk_geom_is_coincident.html#declaration", " PK_LOGICAL_t *<B>const</B> is_coincident --- whether coincident", "PK Reference - PK_GEOM_is_coincident");
top.note("headers/pk_geom_range.html#declaration", "<B>const</B> PK_GEOM_range_o_t *options, --- options structure [PF]", "PK Reference - PK_GEOM_range");
top.note("headers/pk_geom_range_array.html#declaration", "<B>const</B> PK_GEOM_t geoms_1[], --- first geometrical array", "PK Reference - PK_GEOM_range_array");
top.note("headers/pk_geom_range_array_vector.html#declaration", "<B>const</B> PK_GEOM_t geoms[], --- geometrical array", "PK Reference - PK_GEOM_range_array_vector");
top.note("headers/pk_geom_range_local.html#declaration", "<B>const</B> PK_GEOM_range_local_o_t *options, --- options structure", "PK Reference - PK_GEOM_range_local");
top.note("headers/pk_geom_range_local_vector.html#declaration", "<B>const</B> PK_GEOM_range_local_vector_o_t *options, --- options structure", "PK Reference - PK_GEOM_range_local_vector");
top.note("headers/pk_geom_range_vector.html#declaration", "<B>const</B> PK_GEOM_range_vector_o_t *options, --- options structure [PF]", "PK Reference - PK_GEOM_range_vector");
top.note("headers/pk_geom_range_vector_many.html#declaration", "<B>const</B> PK_VECTOR_t vectors[], --- position array", "PK Reference - PK_GEOM_range_vector_many");
top.note("headers/pk_geom_render.html#declaration", "<B>const</B> PK_GEOM_t geoms[], --- geometric entities to be rendered", "PK Reference - PK_GEOM_render");
top.note("headers/pk_geom_render_line.html#declaration", " <B>const</B> int n_geoms, --- number of entities to be", "PK Reference - PK_GEOM_render_line");
top.note("headers/pk_geom_transform.html#declaration", " PK_GEOM_t *<B>const</B> out_geom, --- transformed entity", "PK Reference - PK_GEOM_transform");
top.note("headers/pk_geom_transform_2.html#declaration", "<B>const</B> PK_GEOM_t in_geoms[], --- geometric entities to be", "PK Reference - PK_GEOM_transform_2");
top.note("headers/pk_goclpx_f_t.html#declaration", " <B>const</B> int *nreals,", "PK Reference - PK_GOCLPX_f_t");
top.note("headers/pk_goclsg_f_t.html#declaration", " <B>const</B> int *segtyp,", "PK Reference - PK_GOCLSG_f_t");
top.note("headers/pk_gooppx_f_t.html#declaration", " <B>const</B> int *nreals,", "PK Reference - PK_GOOPPX_f_t");
top.note("headers/pk_goopsg_f_t.html#declaration", " <B>const</B> int *segtyp,", "PK Reference - PK_GOOPSG_f_t");
top.note("headers/pk_gopixl_f_t.html#declaration", " <B>const</B> int *npixels,", "PK Reference - PK_GOPIXL_f_t");
top.note("headers/pk_gosgmt_f_t.html#declaration", " <B>const</B> int *segtyp,", "PK Reference - PK_GOSGMT_f_t");
top.note("headers/pk_group_add_entities.html#declaration", "<B>const</B> PK_ENTITY_t entities[] --- entities", "PK Reference - PK_GROUP_add_entities");
top.note("headers/pk_group_ask_closure.html#declaration", "<B>const</B> PK_GROUP_ask_closure_o_t *options, --- options", "PK Reference - PK_GROUP_ask_closure");
top.note("headers/pk_group_ask_controls.html#declaration", "<B>const</B> PK_GROUP_ask_controls_o_t *options, --- options", "PK Reference - PK_GROUP_ask_controls");
top.note("headers/pk_group_ask_controls_r_f.html#declaration", " PK_GROUP_ask_controls_r_t *<B>const</B> controls --- controls to be freed", "PK Reference - PK_GROUP_ask_controls_r_f");
top.note("headers/pk_group_ask_entities.html#declaration", " int *<B>const</B> n_entities, --- number of entities (>=0)", "PK Reference - PK_GROUP_ask_entities");
top.note("headers/pk_group_ask_entity_class.html#declaration", " PK_CLASS_t *<B>const</B> entity_class --- class of entity allowed in the", "PK Reference - PK_GROUP_ask_entity_class");
top.note("headers/pk_group_ask_entity_label.html#declaration", " int *<B>const</B> entity_label --- label of the entity in the", "PK Reference - PK_GROUP_ask_entity_label");
top.note("headers/pk_group_ask_part.html#declaration", " PK_PART_t *<B>const</B> part --- the part containing this group", "PK Reference - PK_GROUP_ask_part");
top.note("headers/pk_group_contains_entity.html#declaration", " PK_LOGICAL_t *<B>const</B> is_contained --- is the entity contained in the", "PK Reference - PK_GROUP_contains_entity");
top.note("headers/pk_group_create_from_entities.html#declaration", "<B>const</B> PK_ENTITY_t entities[], --- entities", "PK Reference - PK_GROUP_create_from_entities");
top.note("headers/pk_group_create_from_entities_2.html#declaration", "<B>const</B> PK_ENTITY_t entities[], --- entities", "PK Reference - PK_GROUP_create_from_entities_2");
top.note("headers/pk_group_create_from_ents_o_t.html#declaration", " <B>const</B> int *labelled_entities;", "PK Reference - PK_GROUP_create_from_ents_o_t");
top.note("headers/pk_group_find_entities.html#declaration", "<B>const</B> PK_GROUP_find_entities_o_t *options, --- find options", "PK Reference - PK_GROUP_find_entities");
top.note("headers/pk_group_merge_entities.html#declaration", "<B>const</B> PK_ENTITY_t entities[], --- entities", "PK Reference - PK_GROUP_merge_entities");
top.note("headers/pk_group_remove_entities.html#declaration", "<B>const</B> PK_ENTITY_t entities[], --- entities", "PK Reference - PK_GROUP_remove_entities");
top.note("headers/pk_identify_details_r_f.html#declaration", " PK_identify_details_r_t *<B>const</B> facesets", "PK Reference - PK_identify_details_r_f");
top.note("headers/pk_identify_facesets_r_f.html#declaration", " PK_identify_facesets_r_t *<B>const</B> facesets", "PK Reference - PK_identify_facesets_r_f");
top.note("headers/pk_identify_general_r_f.html#declaration", " PK_identify_general_r_t *<B>const</B> topol", "PK Reference - PK_identify_general_r_f");
top.note("headers/pk_imprint_r_f.html#declaration", " PK_imprint_r_t *<B>const</B> results", "PK Reference - PK_imprint_r_f");
top.note("headers/pk_instance_ask.html#declaration", " PK_INSTANCE_sf_t *<B>const</B> instance_sf --- the standard form of the instance", "PK Reference - PK_INSTANCE_ask");
top.note("headers/pk_instance_create.html#declaration", " <B>const</B> PK_INSTANCE_sf_t *instance_sf, --- standard form of an instance", "PK Reference - PK_INSTANCE_create");
top.note("headers/pk_lattice_ask_connectivity.html#declaration", "<B>const</B> PK_LATTICE_ask_connectivity_o_t *options, --- options", "PK Reference - PK_LATTICE_ask_connectivity");
top.note("headers/pk_lattice_ask_connectivity_r_f.html#declaration", " PK_LATTICE_ask_connectivity_r_t *<B>const</B> results", "PK Reference - PK_LATTICE_ask_connectivity_r_f");
top.note("headers/pk_lattice_ask_n_lballs.html#declaration", "<B>const</B> PK_LATTICE_ask_n_lballs_o_t *options, --- options structure", "PK Reference - PK_LATTICE_ask_n_lballs");
top.note("headers/pk_lattice_ask_n_lballs_r_f.html#declaration", " PK_LATTICE_ask_n_lballs_r_t *<B>const</B> result", "PK Reference - PK_LATTICE_ask_n_lballs_r_f");
top.note("headers/pk_lattice_ask_n_lrods.html#declaration", "<B>const</B> PK_LATTICE_ask_n_lrods_o_t *options, --- options structure", "PK Reference - PK_LATTICE_ask_n_lrods");
top.note("headers/pk_lattice_ask_n_lrods_r_f.html#declaration", " PK_LATTICE_ask_n_lrods_r_t *<B>const</B> result", "PK Reference - PK_LATTICE_ask_n_lrods_r_f");
top.note("headers/pk_lattice_ask_part.html#declaration", " PK_PART_t *<B>const</B> part --- owning part (possibly PK_ENTITY_null)", "PK Reference - PK_LATTICE_ask_part");
top.note("headers/pk_lattice_ask_regions.html#declaration", "<B>const</B> PK_LATTICE_ask_regions_o_t *options, --- options structure", "PK Reference - PK_LATTICE_ask_regions");
top.note("headers/pk_lattice_ask_regions_r_f.html#declaration", " PK_LATTICE_ask_regions_r_t *<B>const</B> result", "PK Reference - PK_LATTICE_ask_regions_r_f");
top.note("headers/pk_lattice_clip.html#declaration", "<B>const</B> PK_LATTICE_clip_o_t *options, --- options structure", "PK Reference - PK_LATTICE_clip");
top.note("headers/pk_lattice_clip_o_t.html#declaration", " <B>const</B> PK_ENTITY_t *clip_entities; --- entities with which to clip", "PK Reference - PK_LATTICE_clip_o_t");
top.note("headers/pk_lattice_clip_r_f.html#declaration", " PK_LATTICE_clip_r_t *<B>const</B> result", "PK Reference - PK_LATTICE_clip_r_f");
top.note("headers/pk_lattice_combine.html#declaration", "<B>const</B> PK_LATTICE_combine_o_t *options, --- options", "PK Reference - PK_LATTICE_combine");
top.note("headers/pk_lattice_combine_r_f.html#declaration", " PK_LATTICE_combine_r_t *<B>const</B> results", "PK Reference - PK_LATTICE_combine_r_f");
top.note("headers/pk_lattice_create_by_graph.html#declaration", "<B>const</B> PK_POINTER_t context, --- data returned to", "PK Reference - PK_LATTICE_create_by_graph");
top.note("headers/pk_lattice_create_by_graph_r_f.html#declaration", " PK_LATTICE_create_by_graph_r_t *<B>const</B> result", "PK Reference - PK_LATTICE_create_by_graph_r_f");
top.note("headers/pk_lattice_disjoin.html#declaration", "<B>const</B> PK_LATTICE_disjoin_o_t *options, --- options", "PK Reference - PK_LATTICE_disjoin");
top.note("headers/pk_lattice_disjoin_r_f.html#declaration", " PK_LATTICE_disjoin_r_t *<B>const</B> results", "PK Reference - PK_LATTICE_disjoin_r_f");
top.note("headers/pk_lattice_find_box.html#declaration", "<B>const</B> PK_LATTICE_find_box_o_t *options, --- option structure", "PK Reference - PK_LATTICE_find_box");
top.note("headers/pk_lattice_find_box_r_f.html#declaration", " PK_LATTICE_find_box_r_t *<B>const</B> results", "PK Reference - PK_LATTICE_find_box_r_f");
top.note("headers/pk_lattice_find_nabox.html#declaration", "<B>const</B> PK_LATTICE_find_nabox_o_t *options, --- option structure", "PK Reference - PK_LATTICE_find_nabox");
top.note("headers/pk_lattice_find_nabox_r_f.html#declaration", " PK_LATTICE_find_nabox_r_t *<B>const</B> results", "PK Reference - PK_LATTICE_find_nabox_r_f");
top.note("headers/pk_lattice_graph_cb_f_t.html#declaration", " PK_LATTICE_graph_data_t *<B>const</B> graph_data, --- block of lattice data", "PK Reference - PK_LATTICE_graph_cb_f_t");
top.note("headers/pk_lattice_graph_f.html#declaration", " <B>const</B> PK_LATTICE_graph_data_t *graph_data --- Block of lattice data to", "PK Reference - PK_LATTICE_graph_f");
top.note("headers/pk_lattice_make_bodies.html#declaration", "<B>const</B> PK_LATTICE_make_bodies_o_t *options, --- options structure", "PK Reference - PK_LATTICE_make_bodies");
top.note("headers/pk_lattice_make_bodies_r_f.html#declaration", " PK_LATTICE_make_bodies_r_t *<B>const</B> result", "PK Reference - PK_LATTICE_make_bodies_r_f");
top.note("headers/pk_lattice_make_patterned.html#declaration", "<B>const</B> PK_LATTICE_make_patterned_o_t *options, --- options", "PK Reference - PK_LATTICE_make_patterned");
top.note("headers/pk_lattice_make_patterned_r_f.html#declaration", " PK_LATTICE_make_patterned_r_t *<B>const</B> results", "PK Reference - PK_LATTICE_make_patterned_r_f");
top.note("headers/pk_lball_ask_blend.html#declaration", "<B>const</B> PK_LBALL_ask_blend_o_t *options, --- options structure", "PK Reference - PK_LBALL_ask_blend");
top.note("headers/pk_lball_ask_blend_r_f.html#declaration", " PK_LBALL_ask_blend_r_t *<B>const</B> result", "PK Reference - PK_LBALL_ask_blend_r_f");
top.note("headers/pk_lball_ask_lballs_adj.html#declaration", "<B>const</B> PK_LBALL_ask_lballs_adj_o_t *options, --- options structure", "PK Reference - PK_LBALL_ask_lballs_adj");
top.note("headers/pk_lball_ask_lballs_adj_r_f.html#declaration", " PK_LBALL_ask_lballs_adj_r_t *<B>const</B> result", "PK Reference - PK_LBALL_ask_lballs_adj_r_f");
top.note("headers/pk_lball_ask_lrods.html#declaration", "<B>const</B> PK_LBALL_ask_lrods_o_t *options, --- options structure", "PK Reference - PK_LBALL_ask_lrods");
top.note("headers/pk_lball_ask_lrods_r_f.html#declaration", " PK_LBALL_ask_lrods_r_t *<B>const</B> result", "PK Reference - PK_LBALL_ask_lrods_r_f");
top.note("headers/pk_lball_ask_position.html#declaration", "<B>const</B> PK_LBALL_ask_position_o_t *options, --- options structure", "PK Reference - PK_LBALL_ask_position");
top.note("headers/pk_lball_ask_position_r_f.html#declaration", " PK_LBALL_ask_position_r_t *<B>const</B> result", "PK Reference - PK_LBALL_ask_position_r_f");
top.note("headers/pk_lball_ask_radius.html#declaration", "<B>const</B> PK_LBALL_ask_radius_o_t *options, --- options structure", "PK Reference - PK_LBALL_ask_radius");
top.note("headers/pk_lball_ask_radius_r_f.html#declaration", " PK_LBALL_ask_radius_r_t *<B>const</B> result", "PK Reference - PK_LBALL_ask_radius_r_f");
top.note("headers/pk_lball_cb_f_t.html#declaration", " <B>const</B> PK_LBALL_t lball, --- lball", "PK Reference - PK_LBALL_cb_f_t");
top.note("headers/pk_line_ask.html#declaration", " PK_LINE_sf_t *<B>const</B> line_sf --- line standard form", "PK Reference - PK_LINE_ask");
top.note("headers/pk_line_create.html#declaration", " <B>const</B> PK_LINE_sf_t *line_sf, --- line standard form", "PK Reference - PK_LINE_create");
top.note("headers/pk_loop_ask_body.html#declaration", " PK_BODY_t *<B>const</B> body --- owning body", "PK Reference - PK_LOOP_ask_body");
top.note("headers/pk_loop_ask_edges.html#declaration", " int *<B>const</B> n_edges, --- number of edges (>= 0)", "PK Reference - PK_LOOP_ask_edges");
top.note("headers/pk_loop_ask_face.html#declaration", " PK_FACE_t *<B>const</B> face --- owning face", "PK Reference - PK_LOOP_ask_face");
top.note("headers/pk_loop_ask_fins.html#declaration", " int *<B>const</B> n_fins, --- number of fins (>= 0)", "PK Reference - PK_LOOP_ask_fins");
top.note("headers/pk_loop_ask_first_fin.html#declaration", " PK_FIN_t *<B>const</B> first_fin --- the first fin (possibly PK_ENTITY_null)", "PK Reference - PK_LOOP_ask_first_fin");
top.note("headers/pk_loop_ask_next_in_face.html#declaration", " PK_LOOP_t *<B>const</B> next --- the next loop (possibly PK_ENTITY_null)", "PK Reference - PK_LOOP_ask_next_in_face");
top.note("headers/pk_loop_ask_type.html#declaration", " PK_LOOP_type_t *<B>const</B> loop_type --- the type of the loop", "PK Reference - PK_LOOP_ask_type");
top.note("headers/pk_loop_ask_vertices.html#declaration", " int *<B>const</B> n_vertices, --- number of vertices (>= 0)", "PK Reference - PK_LOOP_ask_vertices");
top.note("headers/pk_loop_close_gaps.html#declaration", "<B>const</B> PK_LOOP_close_gaps_o_t *options, --- options on how to close", "PK Reference - PK_LOOP_close_gaps");
top.note("headers/pk_loop_delete_from_sheet_body.html#declaration", "<B>const</B> PK_LOOP_t loops[] --- loops to be deleted", "PK Reference - PK_LOOP_delete_from_sheet_body");
top.note("headers/pk_loop_euler_create_edge.html#declaration", " PK_VERTEX_t *<B>const</B> new_vertex, --- New vertex created", "PK Reference - PK_LOOP_euler_create_edge");
top.note("headers/pk_loop_euler_delete_make_edge.html#declaration", " PK_EDGE_t *<B>const</B> new_edge", "PK Reference - PK_LOOP_euler_delete_make_edge");
top.note("headers/pk_loop_euler_make_edge.html#declaration", " PK_VERTEX_t *<B>const</B> new_vertex, --- New vertex created", "PK Reference - PK_LOOP_euler_make_edge");
top.note("headers/pk_loop_euler_make_edge_face.html#declaration", " PK_FACE_t *<B>const</B> new_face, --- New face created", "PK Reference - PK_LOOP_euler_make_edge_face");
top.note("headers/pk_loop_euler_make_edge_loop.html#declaration", " PK_LOOP_t *<B>const</B> new_loop --- New loop created", "PK Reference - PK_LOOP_euler_make_edge_loop");
top.note("headers/pk_loop_is_isolated.html#declaration", " PK_LOGICAL_t *<B>const</B> is_isolated --- whether loop is isolated or not", "PK Reference - PK_LOOP_is_isolated");
top.note("headers/pk_lrod_ask_geometry.html#declaration", "<B>const</B> PK_LROD_ask_geometry_o_t *options, --- options structure", "PK Reference - PK_LROD_ask_geometry");
top.note("headers/pk_lrod_ask_geometry_r_f.html#declaration", " PK_LROD_ask_geometry_r_t *<B>const</B> result", "PK Reference - PK_LROD_ask_geometry_r_f");
top.note("headers/pk_lrod_ask_lballs.html#declaration", "<B>const</B> PK_LROD_ask_lballs_o_t *options, --- options structure", "PK Reference - PK_LROD_ask_lballs");
top.note("headers/pk_lrod_ask_lballs_r_f.html#declaration", " PK_LROD_ask_lballs_r_t *<B>const</B> result", "PK Reference - PK_LROD_ask_lballs_r_f");
top.note("headers/pk_lrod_cb_f_t.html#declaration", " <B>const</B> PK_LROD_t lrod, --- lrod", "PK Reference - PK_LROD_cb_f_t");
top.note("headers/pk_ltopol_ask_box.html#declaration", "<B>const</B> PK_LTOPOL_ask_box_o_t *options, --- options structure", "PK Reference - PK_LTOPOL_ask_box");
top.note("headers/pk_ltopol_ask_box_r_f.html#declaration", " PK_LTOPOL_ask_box_r_t *<B>const</B> result", "PK Reference - PK_LTOPOL_ask_box_r_f");
top.note("headers/pk_ltopol_ask_class.html#declaration", "<B>const</B> PK_LTOPOL_ask_class_o_t *options, --- options structure", "PK Reference - PK_LTOPOL_ask_class");
top.note("headers/pk_ltopol_ask_class_r_f.html#declaration", " PK_LTOPOL_ask_class_r_t *<B>const</B> result", "PK Reference - PK_LTOPOL_ask_class_r_f");
top.note("headers/pk_ltopol_is.html#declaration", "<B>const</B> PK_LTOPOL_is_o_t *options, --- options structure", "PK Reference - PK_LTOPOL_is");
top.note("headers/pk_ltopol_is_r_f.html#declaration", " PK_LTOPOL_is_r_t *<B>const</B> result", "PK Reference - PK_LTOPOL_is_r_f");
top.note("headers/pk_mark_ask_following.html#declaration", " PK_MARK_t *<B>const</B> following --- its following mark", "PK Reference - PK_MARK_ask_following");
top.note("headers/pk_mark_ask_forward.html#declaration", " PK_LOGICAL_t *<B>const</B> is_enabled --- whether roll forward is enabled", "PK Reference - PK_MARK_ask_forward");
top.note("headers/pk_mark_ask_frustrum.html#declaration", " PK_MARK_frustrum_t *<B>const</B> frustrum --- frustrum functions", "PK Reference - PK_MARK_ask_frustrum");
top.note("headers/pk_mark_ask_pmarks.html#declaration", " int *<B>const</B> n_pmarks, --- number of pmarks of mark", "PK Reference - PK_MARK_ask_pmarks");
top.note("headers/pk_mark_ask_preceding.html#declaration", " PK_MARK_t *<B>const</B> preceding --- its preceding mark", "PK Reference - PK_MARK_ask_preceding");
top.note("headers/pk_mark_ask_state.html#declaration", " PK_MARK_t *<B>const</B> current, --- current (or immediately previous) mark", "PK Reference - PK_MARK_ask_state");
top.note("headers/pk_mark_create.html#declaration", " PK_MARK_t *<B>const</B> mark --- created mark", "PK Reference - PK_MARK_create");
top.note("headers/pk_mark_frustrum_t.html#declaration", "typedef PK_ERROR_code_t (*PK_MARK_write_f_t)( PK_MARK_t , int, <B>const</B> char*);", "PK Reference - PK_MARK_frustrum_t");
top.note("headers/pk_mark_goto_2.html#declaration", "<B>const</B> PK_MARK_goto_o_t *options, --- options structure", "PK Reference - PK_MARK_goto_2");
top.note("headers/pk_mark_is.html#declaration", " PK_LOGICAL_t *<B>const</B> is_mark --- whether it is a mark", "PK Reference - PK_MARK_is");
top.note("headers/pk_mark_is_on.html#declaration", " PK_LOGICAL_t *<B>const</B> is_on --- whether non-partitioned rollback active", "PK Reference - PK_MARK_is_on");
top.note("headers/pk_mark_start.html#declaration", "<B>const</B> PK_MARK_start_o_t *options --- options structure", "PK Reference - PK_MARK_start");
top.note("headers/pk_memory_alloc.html#declaration", " void **<B>const</B> pointer --- allocated memory (possibly NULL)", "PK Reference - PK_MEMORY_alloc");
top.note("headers/pk_memory_ask_block_size.html#declaration", " size_t *<B>const</B> size --- default block size", "PK Reference - PK_MEMORY_ask_block_size");
top.note("headers/pk_memory_ask_callbacks.html#declaration", " PK_MEMORY_frustrum_t *<B>const</B> frustrum --- current memory handlers", "PK Reference - PK_MEMORY_ask_callbacks");
top.note("headers/pk_memory_block_f.html#declaration", " PK_MEMORY_block_t *<B>const</B> block", "PK Reference - PK_MEMORY_block_f");
top.note("headers/pk_memory_block_t.html#declaration", " <B>const</B> char *bytes;", "PK Reference - PK_MEMORY_block_t");
top.note("headers/pk_mesh_ask_n_mfacets.html#declaration", " int *<B>const</B> n_mfacets --- number of mfacets", "PK Reference - PK_MESH_ask_n_mfacets");
top.note("headers/pk_mesh_ask_n_mvertices.html#declaration", " int *<B>const</B> n_mvertices --- number of mvertices", "PK Reference - PK_MESH_ask_n_mvertices");
top.note("headers/pk_mesh_ask_normal_type.html#declaration", "<B>const</B> PK_MESH_ask_normal_type_o_t *options, --- options structure", "PK Reference - PK_MESH_ask_normal_type");
top.note("headers/pk_mesh_create_from_facets.html#declaration", "<B>const</B> PK_POINTER_t context, --- data returned to reader", "PK Reference - PK_MESH_create_from_facets");
top.note("headers/pk_mesh_defect_array_f.html#declaration", " PK_MESH_defect_array_t *<B>const</B> array --- structure to free", "PK Reference - PK_MESH_defect_array_f");
top.note("headers/pk_mesh_defect_details_f.html#declaration", " PK_MESH_defect_details_t *<B>const</B> defects --- structure to free", "PK Reference - PK_MESH_defect_details_f");
top.note("headers/pk_mesh_discard_normals.html#declaration", "<B>const</B> PK_MESH_discard_normals_o_t *options --- option structure", "PK Reference - PK_MESH_discard_normals");
top.note("headers/pk_mesh_eval_with_mtopol.html#declaration", "<B>const</B> PK_MESH_eval_with_mtopol_o_t *options, --- option structure", "PK Reference - PK_MESH_eval_with_mtopol");
top.note("headers/pk_mesh_facet_cb_f_t.html#declaration", " PK_MESH_facet_t * <B>const</B> facets, --- block of mesh data", "PK Reference - PK_MESH_facet_cb_f_t");
top.note("headers/pk_mesh_facet_f.html#declaration", " <B>const</B> PK_MESH_facet_t * facets --- Block of mesh data", "PK Reference - PK_MESH_facet_f");
top.note("headers/pk_mesh_fill_holes.html#declaration", "<B>const</B> PK_MESH_fill_holes_o_t *options, --- option structure", "PK Reference - PK_MESH_fill_holes");
top.note("headers/pk_mesh_find_defects.html#declaration", "<B>const</B> PK_MESH_find_defects_o_t *options, --- options structure", "PK Reference - PK_MESH_find_defects");
top.note("headers/pk_mesh_find_laminar_mfins.html#declaration", "<B>const</B> PK_MESH_find_laminar_mfins_o_t *options, --- option structure", "PK Reference - PK_MESH_find_laminar_mfins");
top.note("headers/pk_mesh_find_laminar_mfins_r_f.html#declaration", " PK_MESH_find_laminar_mfins_r_t *<B>const</B> result --- result structure", "PK Reference - PK_MESH_find_laminar_mfins_r_f");
top.note("headers/pk_mesh_find_sharp_mfins.html#declaration", "<B>const</B> PK_MESH_find_sharp_mfins_o_t *options, --- options", "PK Reference - PK_MESH_find_sharp_mfins");
top.note("headers/pk_mesh_find_sharp_mvxs.html#declaration", "<B>const</B> PK_MESH_find_sharp_mvxs_o_t *options, --- options", "PK Reference - PK_MESH_find_sharp_mvxs");
top.note("headers/pk_mesh_fix_defects.html#declaration", "<B>const</B> PK_MESH_fix_defects_o_t *options, --- options structure", "PK Reference - PK_MESH_fix_defects");
top.note("headers/pk_mesh_has_unique_normals.html#declaration", "<B>const</B> PK_MESH_has_unique_normals_o_t *options, --- options structure", "PK Reference - PK_MESH_has_unique_normals");
top.note("headers/pk_mesh_imprint_vectors.html#declaration", "<B>const</B> PK_VECTOR_t *vectors, --- vectors", "PK Reference - PK_MESH_imprint_vectors");
top.note("headers/pk_mesh_imprint_vectors_r_f.html#declaration", " PK_MESH_imprint_vectors_r_t *<B>const</B> result --- results structure to free", "PK Reference - PK_MESH_imprint_vectors_r_f");
top.note("headers/pk_mesh_is_loaded.html#declaration", "<B>const</B> PK_MESH_is_loaded_o_t *options, --- options structure", "PK Reference - PK_MESH_is_loaded");
top.note("headers/pk_mesh_is_loaded_r_f.html#declaration", " PK_MESH_is_loaded_r_t *<B>const</B> result", "PK Reference - PK_MESH_is_loaded_r_f");
top.note("headers/pk_mesh_make_bodies.html#declaration", "<B>const</B> PK_MESH_make_bodies_o_t *options, --- option structure", "PK Reference - PK_MESH_make_bodies");
top.note("headers/pk_mesh_make_surf_trimmed.html#declaration", "<B>const</B> PK_MESH_make_surf_trimmed_o_t *options, --- option structure", "PK Reference - PK_MESH_make_surf_trimmed");
top.note("headers/pk_mesh_store_normals.html#declaration", "<B>const</B> PK_MESH_store_normals_o_t *options --- option structure", "PK Reference - PK_MESH_store_normals");
top.note("headers/pk_mfacet_ask_mfacet_adjacent.html#declaration", " PK_MFACET_t *<B>const</B> mfacet_adjacent --- adjacent mfacet", "PK Reference - PK_MFACET_ask_mfacet_adjacent");
top.note("headers/pk_mfacet_ask_mfin.html#declaration", " PK_MFIN_t *<B>const</B> mfin --- the mfin ", "PK Reference - PK_MFACET_ask_mfin");
top.note("headers/pk_mfacet_ask_mvx_normals.html#declaration", "<B>const</B> PK_MFACET_ask_mvx_normals_o_t *options, --- options", "PK Reference - PK_MFACET_ask_mvx_normals");
top.note("headers/pk_mfacet_ask_normal.html#declaration", " PK_VECTOR1_t *<B>const</B> normal ---the normal vector of the mfacet", "PK Reference - PK_MFACET_ask_normal");
top.note("headers/pk_mfacet_cb_f_t.html#declaration", " <B>const</B> PK_MFACET_t mfacet, --- mfacet", "PK Reference - PK_MFACET_cb_f_t");
top.note("headers/pk_mfacet_find_perimeters.html#declaration", "<B>const</B> PK_MFACET_t mfacets[], --- the mfacets", "PK Reference - PK_MFACET_find_perimeters");
top.note("headers/pk_mfacet_find_perimeters_r_f.html#declaration", " PK_MFACET_find_perimeters_r_t *<B>const</B> result --- result structure", "PK Reference - PK_MFACET_find_perimeters_r_f");
top.note("headers/pk_mfacet_parameterise_vec.html#declaration", "<B>const</B> PK_MFACET_parameterise_vec_o_t *options, --- options", "PK Reference - PK_MFACET_parameterise_vec");
top.note("headers/pk_mfin_ask_mfacet.html#declaration", " PK_MFACET_t *<B>const</B> mfacet --- the mfacet containing mfin ", "PK Reference - PK_MFIN_ask_mfacet");
top.note("headers/pk_mfin_ask_mfin_adjacent.html#declaration", " PK_MFIN_t *<B>const</B> mfin_adjacent --- adjacent mfin", "PK Reference - PK_MFIN_ask_mfin_adjacent");
top.note("headers/pk_mfin_ask_mfin_index.html#declaration", " PK_MFIN_index_t *<B>const</B> mfin_index --- the index of the mfin within", "PK Reference - PK_MFIN_ask_mfin_index");
top.note("headers/pk_mfin_ask_mvertex.html#declaration", " PK_MVERTEX_t *<B>const</B> mvertex --- The mvertex towards which mfin points", "PK Reference - PK_MFIN_ask_mvertex");
top.note("headers/pk_mfin_ask_mvx_curvature.html#declaration", "<B>const</B> PK_MFIN_ask_mvx_curvature_o_t *options, --- options", "PK Reference - PK_MFIN_ask_mvx_curvature");
top.note("headers/pk_mfin_ask_mvx_normal.html#declaration", "<B>const</B> PK_MFIN_ask_mvx_normal_o_t *options, --- options", "PK Reference - PK_MFIN_ask_mvx_normal");
top.note("headers/pk_mfin_ask_next_in_mfacet.html#declaration", " PK_MFIN_t *<B>const</B> next_mfin --- the next mfin in the same", "PK Reference - PK_MFIN_ask_next_in_mfacet");
top.note("headers/pk_mfin_ask_next_of_mvertex.html#declaration", " PK_MFIN_t *<B>const</B> next_mfin ---the next mfin around the mvertex", "PK Reference - PK_MFIN_ask_next_of_mvertex");
top.note("headers/pk_mfin_ask_previous_in_mfacet.html#declaration", " PK_MFIN_t *<B>const</B> previous_mfin --- the previous mfin in the same", "PK Reference - PK_MFIN_ask_previous_in_mfacet");
top.note("headers/pk_mfin_ask_previous_of_mvertex.html#declaration", " PK_MFIN_t *<B>const</B> previous_mfin --- the previous mfin around the mvertex", "PK Reference - PK_MFIN_ask_previous_of_mvertex");
top.note("headers/pk_mfin_is_laminar.html#declaration", " PK_LOGICAL_t *<B>const</B> is_laminar --- whether the mfin is laminar", "PK Reference - PK_MFIN_is_laminar");
top.note("headers/pk_mfin_is_same_mfacet.html#declaration", " PK_LOGICAL_t * <B>const</B> is_same_mfacet --- whether the two mfins belong to", "PK Reference - PK_MFIN_is_same_mfacet");
top.note("headers/pk_mfin_is_sharp.html#declaration", "<B>const</B> PK_MFIN_is_sharp_o_t *options, --- options", "PK Reference - PK_MFIN_is_sharp");
top.note("headers/pk_mtopol_ask_box.html#declaration", " PK_BOX_t *<B>const</B> bounding_box --- a bounding box for the mtopol", "PK Reference - PK_MTOPOL_ask_box");
top.note("headers/pk_mtopol_ask_class.html#declaration", " PK_CLASS_t *<B>const</B> class", "PK Reference - PK_MTOPOL_ask_class");
top.note("headers/pk_mtopol_make_meshes.html#declaration", "<B>const</B> PK_MTOPOL_t mtopols[], --- the mtopols", "PK Reference - PK_MTOPOL_make_meshes");
top.note("headers/pk_mtopol_make_meshes_o_t.html#declaration", " <B>const</B> PK_FACE_t *faces; --- faces (NULL)", "PK Reference - PK_MTOPOL_make_meshes_o_t");
top.note("headers/pk_mtopol_map_r_f.html#declaration", " PK_MTOPOL_map_r_t *<B>const</B> mapping --- mapping information to free", "PK Reference - PK_MTOPOL_map_r_f");
top.note("headers/pk_mtopol_select_cb_f_t.html#declaration", " <B>const</B> PK_MTOPOL_t mtopol, --- mfacet or mfin", "PK Reference - PK_MTOPOL_select_cb_f_t");
top.note("headers/pk_mvertex_ask_mfacets.html#declaration", " int *<B>const</B> n_mfacets, --- the number of mfacets ", "PK Reference - PK_MVERTEX_ask_mfacets");
top.note("headers/pk_mvertex_ask_mfin.html#declaration", " PK_MFIN_t *<B>const</B> mfin --- an mfin which points towards mvertex", "PK Reference - PK_MVERTEX_ask_mfin");
top.note("headers/pk_mvertex_ask_mvertices_ring.html#declaration", " int *<B>const</B> n_mvertices_ring, --- the number of mvertices", "PK Reference - PK_MVERTEX_ask_mvertices_ring");
top.note("headers/pk_mvertex_ask_normals.html#declaration", "<B>const</B> PK_MVERTEX_ask_normals_o_t *options, --- options structure", "PK Reference - PK_MVERTEX_ask_normals");
top.note("headers/pk_mvertex_ask_position.html#declaration", " PK_VECTOR_t *<B>const</B> position --- position", "PK Reference - PK_MVERTEX_ask_position");
top.note("headers/pk_mvertex_cb_f_t.html#declaration", " <B>const</B> PK_MVERTEX_t mvertex, --- mvertex", "PK Reference - PK_MVERTEX_cb_f_t");
top.note("headers/pk_mvertex_is_laminar.html#declaration", " PK_LOGICAL_t *<B>const</B> is_laminar --- whether mvertex is on the laminar", "PK Reference - PK_MVERTEX_is_laminar");
top.note("headers/pk_mvertex_set_positions.html#declaration", "<B>const</B> PK_MVERTEX_t mvertices[], --- the mvertices", "PK Reference - PK_MVERTEX_set_positions");
top.note("headers/pk_offset_ask.html#declaration", " PK_OFFSET_sf_t *<B>const</B> offset_sf --- sf for an offset surface", "PK Reference - PK_OFFSET_ask");
top.note("headers/pk_offset_create.html#declaration", " <B>const</B> PK_OFFSET_sf_t *offset_sf, --- offset surf standard form", "PK Reference - PK_OFFSET_create");
top.note("headers/pk_part_add_geoms.html#declaration", "<B>const</B> PK_GEOM_t geoms[] --- geoms to be added to", "PK Reference - PK_PART_add_geoms");
top.note("headers/pk_part_ask_all_attdefs.html#declaration", " int *<B>const</B> n_attdefs, --- number of attdefs (>= 0)", "PK Reference - PK_PART_ask_all_attdefs");
top.note("headers/pk_part_ask_all_attribs.html#declaration", " int *<B>const</B> n_attribs, --- number of attributes (>= 0)", "PK Reference - PK_PART_ask_all_attribs");
top.note("headers/pk_part_ask_attribs_cb.html#declaration", "<B>const</B> PK_PART_ask_attribs_cb_o_t *options, --- options", "PK Reference - PK_PART_ask_attribs_cb");
top.note("headers/pk_part_ask_con_lattices.html#declaration", " int *<B>const</B> n_con_lattices, --- number of construction lattices (>=0)", "PK Reference - PK_PART_ask_con_lattices");
top.note("headers/pk_part_ask_construction_curves.html#declaration", " int *<B>const</B> n_con_curves, --- number of construction curves (>=0)", "PK Reference - PK_PART_ask_construction_curves");
top.note("headers/pk_part_ask_construction_points.html#declaration", " int *<B>const</B> n_con_points, --- number of construction points (>=0)", "PK Reference - PK_PART_ask_construction_points");
top.note("headers/pk_part_ask_construction_surfs.html#declaration", " int *<B>const</B> n_con_surfs, --- number of construction surfaces (>=0)", "PK Reference - PK_PART_ask_construction_surfs");
top.note("headers/pk_part_ask_geoms.html#declaration", " int *<B>const</B> n_geoms, --- number of geoms (>=0)", "PK Reference - PK_PART_ask_geoms");
top.note("headers/pk_part_ask_groups.html#declaration", " int *<B>const</B> n_groups, --- number of groups (>=0)", "PK Reference - PK_PART_ask_groups");
top.note("headers/pk_part_ask_groups_2.html#declaration", "<B>const</B> PK_PART_ask_groups_o_t *options, --- options", "PK Reference - PK_PART_ask_groups_2");
top.note("headers/pk_part_ask_ref_instances.html#declaration", " int *<B>const</B> n_instances, --- number of instances (>=0)", "PK Reference - PK_PART_ask_ref_instances");
top.note("headers/pk_part_delete_attribs.html#declaration", "<B>const</B> PK_ATTDEF_t attdefs[], --- attribute definitions", "PK Reference - PK_PART_delete_attribs");
top.note("headers/pk_part_find_entity_by_ident.html#declaration", " PK_ENTITY_t *<B>const</B> entity --- entity (may be PK_ENTITY_null)", "PK Reference - PK_PART_find_entity_by_ident");
top.note("headers/pk_part_receive.html#declaration", " <B>const</B> char *key, --- key string", "PK Reference - PK_PART_receive");
top.note("headers/pk_part_receive_b.html#declaration", "<B>const</B> PK_PART_receive_o_t *options, --- receive options", "PK Reference - PK_PART_receive_b");
top.note("headers/pk_part_receive_meshes.html#declaration", "<B>const</B> PK_PART_t parts[], --- parts", "PK Reference - PK_PART_receive_meshes");
top.note("headers/pk_part_receive_o_t.html#declaration", " <B>const</B> int *part_indices;", "PK Reference - PK_PART_receive_o_t");
top.note("headers/pk_part_receive_u.html#declaration", " <B>const</B> PK_UCHAR_t *key, --- key string", "PK Reference - PK_PART_receive_u");
top.note("headers/pk_part_receive_version.html#declaration", " <B>const</B> char *key, --- key string", "PK Reference - PK_PART_receive_version");
top.note("headers/pk_part_receive_version_b.html#declaration", " PK_SESSION_kernel_version_t *<B>const</B> version --- version", "PK Reference - PK_PART_receive_version_b");
top.note("headers/pk_part_receive_version_u.html#declaration", " <B>const</B> PK_UCHAR_t *key, --- key string", "PK Reference - PK_PART_receive_version_u");
top.note("headers/pk_part_rectify_identifiers.html#declaration", " int *<B>const</B> n_entities, --- number of entities with changed idents", "PK Reference - PK_PART_rectify_identifiers");
top.note("headers/pk_part_remove_geoms.html#declaration", "<B>const</B> PK_GEOM_t geoms[], --- geoms to be removed from", "PK Reference - PK_PART_remove_geoms");
top.note("headers/pk_part_transmit.html#declaration", "<B>const</B> PK_PART_t *parts, --- parts", "PK Reference - PK_PART_transmit");
top.note("headers/pk_part_transmit_b.html#declaration", "<B>const</B> PK_PART_t *parts, --- parts", "PK Reference - PK_PART_transmit_b");
top.note("headers/pk_part_transmit_u.html#declaration", "<B>const</B> PK_PART_t *parts, --- parts", "PK Reference - PK_PART_transmit_u");
top.note("headers/pk_partition_advance_pmark.html#declaration", "<B>const</B> PK_PARTITION_advance_pmark_o_t *options, --- advance pmark options", "PK Reference - PK_PARTITION_advance_pmark");
top.note("headers/pk_partition_ask.html#declaration", "<B>const</B> PK_PARTITION_ask_o_t *options, --- options", "PK Reference - PK_PARTITION_ask");
top.note("headers/pk_partition_ask_appitems.html#declaration", " int *<B>const</B> n_appitems, --- number of appitems (>= 0)", "PK Reference - PK_PARTITION_ask_appitems");
top.note("headers/pk_partition_ask_assemblies.html#declaration", " int *<B>const</B> n_assemblies, --- number of assemblies (>= 0)", "PK Reference - PK_PARTITION_ask_assemblies");
top.note("headers/pk_partition_ask_bodies.html#declaration", " int *<B>const</B> n_bodies, --- number of bodies (>= 0)", "PK Reference - PK_PARTITION_ask_bodies");
top.note("headers/pk_partition_ask_cloning.html#declaration", "<B>const</B> PK_PARTITION_ask_cloning_o_t *options, --- options", "PK Reference - PK_PARTITION_ask_cloning");
top.note("headers/pk_partition_ask_facet_geom.html#declaration", "<B>const</B> PK_PARTITION_ask_facet_geom_o_t *options, --- option structure", "PK Reference - PK_PARTITION_ask_facet_geom");
top.note("headers/pk_partition_ask_geoms.html#declaration", " int *<B>const</B> n_geoms, --- number of geoms (>= 0)", "PK Reference - PK_PARTITION_ask_geoms");
top.note("headers/pk_partition_ask_initial_pmark.html#declaration", " PK_PMARK_t *<B>const</B> pmark --- initial partition mark", "PK Reference - PK_PARTITION_ask_initial_pmark");
top.note("headers/pk_partition_ask_ki_lists.html#declaration", " int *<B>const</B> n_lists, --- number of lists (>= 0)", "PK Reference - PK_PARTITION_ask_ki_lists");
top.note("headers/pk_partition_ask_pmark.html#declaration", " PK_PMARK_t *<B>const</B> pmark, --- current pmark", "PK Reference - PK_PARTITION_ask_pmark");
top.note("headers/pk_partition_ask_pmark_size.html#declaration", " int *<B>const</B> n_bytes --- size of pmark file", "PK Reference - PK_PARTITION_ask_pmark_size");
top.note("headers/pk_partition_ask_pmarks.html#declaration", " int *<B>const</B> n_pmarks, --- number of pmarks (>= 1)", "PK Reference - PK_PARTITION_ask_pmarks");
top.note("headers/pk_partition_ask_pmarks_2.html#declaration", "<B>const</B> PK_PARTITION_ask_pmarks_2_o_t *options, --- options", "PK Reference - PK_PARTITION_ask_pmarks_2");
top.note("headers/pk_partition_ask_pmarks_2_r_f.html#declaration", " PK_PARTITION_ask_pmarks_2_r_t *<B>const</B> results", "PK Reference - PK_PARTITION_ask_pmarks_2_r_f");
top.note("headers/pk_partition_ask_r_f.html#declaration", " PK_PARTITION_ask_r_t *<B>const</B> results", "PK Reference - PK_PARTITION_ask_r_f");
top.note("headers/pk_partition_ask_transfs.html#declaration", " int *<B>const</B> n_transfs, --- number of transforms (>= 0)", "PK Reference - PK_PARTITION_ask_transfs");
top.note("headers/pk_partition_ask_type.html#declaration", " PK_PARTITION_type_t *<B>const</B> partition_type --- type of partition", "PK Reference - PK_PARTITION_ask_type");
top.note("headers/pk_partition_clone_pmark.html#declaration", "<B>const</B> PK_PARTITION_clone_pmark_o_t *options, --- options", "PK Reference - PK_PARTITION_clone_pmark");
top.note("headers/pk_partition_copy.html#declaration", "<B>const</B> PK_PARTITION_copy_o_t *options, --- copy options", "PK Reference - PK_PARTITION_copy");
top.note("headers/pk_partition_create.html#declaration", " <B>const</B> PK_PARTITION_create_o_t *options, --- options", "PK Reference - PK_PARTITION_create");
top.note("headers/pk_partition_create_empty.html#declaration", " PK_PARTITION_t *<B>const</B> partition --- new partition", "PK Reference - PK_PARTITION_create_empty");
top.note("headers/pk_partition_create_r_f.html#declaration", " PK_PARTITION_create_r_t *<B>const</B> results", "PK Reference - PK_PARTITION_create_r_f");
top.note("headers/pk_partition_delete.html#declaration", "<B>const</B> PK_PARTITION_delete_o_t *options --- deletion options", "PK Reference - PK_PARTITION_delete");
top.note("headers/pk_partition_find_pmark_by_id.html#declaration", " PK_PMARK_t *<B>const</B> pmark --- pmark (may be PK_PMARK_null)", "PK Reference - PK_PARTITION_find_pmark_by_id");
top.note("headers/pk_partition_goto_guard.html#declaration", "<B>const</B> PK_PARTITION_goto_guard_o_t *options, --- options structure", "PK Reference - PK_PARTITION_goto_guard");
top.note("headers/pk_partition_goto_guard_r_f.html#declaration", " PK_PARTITION_goto_guard_r_t *<B>const</B> returns", "PK Reference - PK_PARTITION_goto_guard_r_f");
top.note("headers/pk_partition_has_guard.html#declaration", " PK_LOGICAL_t *<B>const</B> has_guard, --- whether partition has a guard", "PK Reference - PK_PARTITION_has_guard");
top.note("headers/pk_partition_has_lattices.html#declaration", "<B>const</B> PK_PARTITION_has_lattices_o_t *options, --- options", "PK Reference - PK_PARTITION_has_lattices");
top.note("headers/pk_partition_has_lattices_r_f.html#declaration", " PK_PARTITION_has_lattices_r_t *<B>const</B> results", "PK Reference - PK_PARTITION_has_lattices_r_f");
top.note("headers/pk_partition_is.html#declaration", " PK_LOGICAL_t *<B>const</B> is_partition --- whether it is a partition", "PK Reference - PK_PARTITION_is");
top.note("headers/pk_partition_is_clone.html#declaration", "<B>const</B> PK_PARTITION_is_clone_o_t *options, --- options", "PK Reference - PK_PARTITION_is_clone");
top.note("headers/pk_partition_make_pmark.html#declaration", " PK_PMARK_t *<B>const</B> pmark --- partition mark", "PK Reference - PK_PARTITION_make_pmark");
top.note("headers/pk_partition_make_pmark_2.html#declaration", "<B>const</B> PK_PARTITION_make_pmark_o_t *options,", "PK Reference - PK_PARTITION_make_pmark_2");
top.note("headers/pk_partition_merge.html#declaration", "<B>const</B> PK_PARTITION_t partitions[], --- partitions", "PK Reference - PK_PARTITION_merge");
top.note("headers/pk_partition_receive.html#declaration", " <B>const</B> char *key, --- key string", "PK Reference - PK_PARTITION_receive");
top.note("headers/pk_partition_receive_b.html#declaration", "<B>const</B> PK_PARTITION_receive_o_t *options, --- receive options", "PK Reference - PK_PARTITION_receive_b");
top.note("headers/pk_partition_receive_deltas_2.html#declaration", "<B>const</B> PK_PARTITION_receive_deltas_o_t *options --- receive options", "PK Reference - PK_PARTITION_receive_deltas_2");
top.note("headers/pk_partition_receive_meshes.html#declaration", "<B>const</B> PK_PARTITION_receive_meshes_o_t *options, --- options structure", "PK Reference - PK_PARTITION_receive_meshes");
top.note("headers/pk_partition_receive_o_t.html#declaration", " <B>const</B> PK_MEMORY_block_t *deltas_block;", "PK Reference - PK_PARTITION_receive_o_t");
top.note("headers/pk_partition_receive_u.html#declaration", " <B>const</B> PK_UCHAR_t *key, --- key string", "PK Reference - PK_PARTITION_receive_u");
top.note("headers/pk_partition_receive_version.html#declaration", " <B>const</B> char *key, --- key string", "PK Reference - PK_PARTITION_receive_version");
top.note("headers/pk_partition_receive_version_b.html#declaration", " PK_SESSION_kernel_version_t *<B>const</B> version --- version", "PK Reference - PK_PARTITION_receive_version_b");
top.note("headers/pk_partition_receive_version_u.html#declaration", " <B>const</B> PK_UCHAR_t *key, --- key string", "PK Reference - PK_PARTITION_receive_version_u");
top.note("headers/pk_partition_reset_attribs.html#declaration", "<B>const</B> PK_ATTDEF_t attdefs[], --- attdefs to consider", "PK Reference - PK_PARTITION_reset_attribs");
top.note("headers/pk_partition_set_guard.html#declaration", "<B>const</B> PK_PARTITION_set_guard_o_t *options, --- options structure", "PK Reference - PK_PARTITION_set_guard");
top.note("headers/pk_partition_set_guard_r_f.html#declaration", " PK_PARTITION_set_guard_r_t *<B>const</B> returns", "PK Reference - PK_PARTITION_set_guard_r_f");
top.note("headers/pk_partition_start_cloning.html#declaration", "<B>const</B> PK_PARTITION_start_cloning_o_t *options --- options", "PK Reference - PK_PARTITION_start_cloning");
top.note("headers/pk_partition_stop_cloning.html#declaration", "<B>const</B> PK_PARTITION_stop_cloning_o_t *options --- options", "PK Reference - PK_PARTITION_stop_cloning");
top.note("headers/pk_partition_transmit.html#declaration", "<B>const</B> char *key, --- key string", "PK Reference - PK_PARTITION_transmit");
top.note("headers/pk_partition_transmit_b.html#declaration", "<B>const</B> PK_PARTITION_transmit_o_t *options, --- transmit options", "PK Reference - PK_PARTITION_transmit_b");
top.note("headers/pk_partition_transmit_delta.html#declaration", "<B>const</B> PK_PARTITION_transmit_delta_o_t *options --- transmit options", "PK Reference - PK_PARTITION_transmit_delta");
top.note("headers/pk_partition_transmit_u.html#declaration", "<B>const</B> PK_UCHAR_t *key, --- key string", "PK Reference - PK_PARTITION_transmit_u");
top.note("headers/pk_pattern_cb_f_t.html#declaration", "<B>const</B> PK_VECTOR_t receive_positions[],", "PK Reference - PK_pattern_cb_f_t");
top.note("headers/pk_pattern_face_map_t.html#declaration", " <B>const</B> PK_LOOP_t *base_loops; --- boundary loops defining the", "PK Reference - PK_pattern_face_map_t");
top.note("headers/pk_plane_ask.html#declaration", " PK_PLANE_sf_t *<B>const</B> plane_sf --- the standard form of the plane", "PK Reference - PK_PLANE_ask");
top.note("headers/pk_plane_create.html#declaration", " <B>const</B> PK_PLANE_sf_t *plane_sf, --- standard form of a plane", "PK Reference - PK_PLANE_create");
top.note("headers/pk_pline_ask.html#declaration", " PK_PLINE_sf_t *<B>const</B> pline_sf --- polyline standard form", "PK Reference - PK_PLINE_ask");
top.note("headers/pk_pline_create.html#declaration", " <B>const</B> PK_PLINE_sf_t *pline_sf, --- polyline standard form", "PK Reference - PK_PLINE_create");
top.note("headers/pk_pmark_ask_entities.html#declaration", "<B>const</B> PK_PMARK_ask_entities_o_t *options, --- options structure", "PK Reference - PK_PMARK_ask_entities");
top.note("headers/pk_pmark_ask_following.html#declaration", " int *<B>const</B> n_following, --- number of following pmarks", "PK Reference - PK_PMARK_ask_following");
top.note("headers/pk_pmark_ask_identifier.html#declaration", " int *<B>const</B> identifier --- identifier of pmark", "PK Reference - PK_PMARK_ask_identifier");
top.note("headers/pk_pmark_ask_marks.html#declaration", " int *<B>const</B> n_marks, --- number of marks of pmark", "PK Reference - PK_PMARK_ask_marks");
top.note("headers/pk_pmark_ask_partition.html#declaration", " PK_PARTITION_t *<B>const</B> partition --- the partition of the pmark", "PK Reference - PK_PMARK_ask_partition");
top.note("headers/pk_pmark_ask_preceding.html#declaration", " PK_PMARK_t *<B>const</B> preceding --- preceding pmark", "PK Reference - PK_PMARK_ask_preceding");
top.note("headers/pk_pmark_delete.html#declaration", "<B>const</B> PK_PMARK_t *pmarks, --- pmark array", "PK Reference - PK_PMARK_delete");
top.note("headers/pk_pmark_goto.html#declaration", " int *<B>const</B> n_new, --- number of entities created", "PK Reference - PK_PMARK_goto");
top.note("headers/pk_pmark_goto_2.html#declaration", "<B>const</B> PK_PMARK_goto_o_t *options, --- options structure", "PK Reference - PK_PMARK_goto_2");
top.note("headers/pk_pmark_is.html#declaration", " PK_LOGICAL_t *<B>const</B> is_pmark --- whether it is a pmark", "PK Reference - PK_PMARK_is");
top.note("headers/pk_pmark_is_used_by_mark.html#declaration", " PK_LOGICAL_t *<B>const</B> is_used --- whether it is used by a", "PK Reference - PK_PMARK_is_used_by_mark");
top.note("headers/pk_point_ask.html#declaration", " PK_POINT_sf_t *<B>const</B> point_sf --- point standard form", "PK Reference - PK_POINT_ask");
top.note("headers/pk_point_ask_part.html#declaration", " PK_PART_t *<B>const</B> part --- owning part (possibly PK_ENTITY_null)", "PK Reference - PK_POINT_ask_part");
top.note("headers/pk_point_ask_vertex.html#declaration", " PK_VERTEX_t *<B>const</B> vertex --- owning vertex (possibly PK_ENTITY_null)", "PK Reference - PK_POINT_ask_vertex");
top.note("headers/pk_point_create.html#declaration", " <B>const</B> PK_POINT_sf_t *point_sf, --- point standard form", "PK Reference - PK_POINT_create");
top.note("headers/pk_point_make_helical_curve.html#declaration", "<B>const</B> PK_AXIS1_sf_t *axis, --- axis", "PK Reference - PK_POINT_make_helical_curve");
top.note("headers/pk_point_make_minimum_body.html#declaration", " PK_BODY_t *<B>const</B> body --- created body", "PK Reference - PK_POINT_make_minimum_body");
top.note("headers/pk_region_ask_body.html#declaration", " PK_BODY_t *<B>const</B> body --- owning body", "PK Reference - PK_REGION_ask_body");
top.note("headers/pk_region_ask_lattices.html#declaration", "<B>const</B> PK_REGION_ask_lattices_o_t *options, --- options structure", "PK Reference - PK_REGION_ask_lattices");
top.note("headers/pk_region_ask_lattices_r_f.html#declaration", " PK_REGION_ask_lattices_r_t *<B>const</B> result", "PK Reference - PK_REGION_ask_lattices_r_f");
top.note("headers/pk_region_ask_shells.html#declaration", " int *<B>const</B> n_shells, --- number of shells (>= 0)", "PK Reference - PK_REGION_ask_shells");
top.note("headers/pk_region_ask_type.html#declaration", "<B>const</B> PK_REGION_ask_type_o_t *options, --- options", "PK Reference - PK_REGION_ask_type");
top.note("headers/pk_region_ask_type_r_f.html#declaration", " PK_REGION_ask_type_r_t *<B>const</B> results", "PK Reference - PK_REGION_ask_type_r_f");
top.note("headers/pk_region_embed_lattices.html#declaration", "<B>const</B> PK_LATTICE_t lattices[], --- lattices to embed", "PK Reference - PK_REGION_embed_lattices");
top.note("headers/pk_region_embed_lattices_o_t.html#declaration", " <B>const</B> PK_ATTDEF_t *attdefs; --- List of attdefs specifying set", "PK Reference - PK_REGION_embed_lattices_o_t");
top.note("headers/pk_region_embed_lattices_r_f.html#declaration", " PK_REGION_embed_lattices_r_t *<B>const</B> result", "PK Reference - PK_REGION_embed_lattices_r_f");
top.note("headers/pk_region_imprint_curve.html#declaration", " int *<B>const</B> n_new_edges, --- number of new edges", "PK Reference - PK_REGION_imprint_curve");
top.note("headers/pk_region_imprint_point.html#declaration", " PK_VERTEX_t *<B>const</B> new_vertex --- new vertex", "PK Reference - PK_REGION_imprint_point");
top.note("headers/pk_region_is_solid.html#declaration", " PK_LOGICAL_t *<B>const</B> is_solid --- whether region is solid or void", "PK Reference - PK_REGION_is_solid");
top.note("headers/pk_region_remove_lattice.html#declaration", "<B>const</B> PK_REGION_remove_lattice_o_t *options, --- options structure", "PK Reference - PK_REGION_remove_lattice");
top.note("headers/pk_region_remove_lattice_o_t.html#declaration", " <B>const</B> PK_ATTDEF_t *attdefs; --- List of attdefs specifying set", "PK Reference - PK_REGION_remove_lattice_o_t");
top.note("headers/pk_region_remove_lattice_r_f.html#declaration", " PK_REGION_remove_lattice_r_t *<B>const</B> result", "PK Reference - PK_REGION_remove_lattice_r_f");
top.note("headers/pk_replace_edge_data_t.html#declaration", " <B>const</B> PK_EDGE_t *edges; --- edges to have curves replaced", "PK Reference - PK_replace_edge_data_t");
top.note("headers/pk_replace_help_points_t.html#declaration", " <B>const</B> PK_TOPOL_t *topologies; --- topologies needing help points (NULL)", "PK Reference - PK_replace_help_points_t");
top.note("headers/pk_replace_patch_data_t.html#declaration", " <B>const</B> PK_FACE_t *tool_patches; --- the tool faces to replace", "PK Reference - PK_replace_patch_data_t");
top.note("headers/pk_replace_variation_data_t.html#declaration", " <B>const</B> PK_FACE_t *variation_faces; --- faces to have surfaces replaced", "PK Reference - PK_replace_variation_data_t");
top.note("headers/pk_replace_vertex_data_t.html#declaration", " <B>const</B> PK_VERTEX_t *vertices; --- vertices to have positions", "PK Reference - PK_replace_vertex_data_t");
top.note("headers/pk_report_add_records.html#declaration", "<B>const</B> PK_REPORT_record_t report_records[] --- report records", "PK Reference - PK_REPORT_add_records");
top.note("headers/pk_report_ask.html#declaration", " PK_REPORT_r_t *<B>const</B> report_r --- report data", "PK Reference - PK_REPORT_ask");
top.note("headers/pk_report_create.html#declaration", " <B>const</B> char *name, --- name of report", "PK Reference - PK_REPORT_create");
top.note("headers/pk_report_find.html#declaration", " <B>const</B> char *name, --- name of report", "PK Reference - PK_REPORT_find");
top.note("headers/pk_report_is_open.html#declaration", " PK_LOGICAL_t *<B>const</B> is_open --- whether report is open or closed", "PK Reference - PK_REPORT_is_open");
top.note("headers/pk_report_r_f.html#declaration", " PK_REPORT_r_t *<B>const</B> report_r --- report return type", "PK Reference - PK_REPORT_r_f");
top.note("headers/pk_report_set_function.html#declaration", "<B>const</B> char *function", "PK Reference - PK_REPORT_set_function");
top.note("headers/pk_section_2_r_f.html#declaration", " PK_section_2_r_t *<B>const</B> results --- section results to free", "PK Reference - PK_section_2_r_f");
top.note("headers/pk_section_r_f.html#declaration", " PK_section_r_t *<B>const</B> results --- section results to free", "PK Reference - PK_section_r_f");
top.note("headers/pk_session_applio_t.html#declaration", " int (*open_rd) (int keylen, <B>const</B> char* key, int *strid);", "PK Reference - PK_SESSION_applio_t");
top.note("headers/pk_session_ask_angle_precision.html#declaration", " double *<B>const</B> precision --- precision", "PK Reference - PK_SESSION_ask_angle_precision");
top.note("headers/pk_session_ask_applio.html#declaration", " PK_SESSION_applio_t *<B>const</B> res", "PK Reference - PK_SESSION_ask_applio");
top.note("headers/pk_session_ask_applio_2.html#declaration", " PK_SESSION_applio_t *<B>const</B> res", "PK Reference - PK_SESSION_ask_applio_2");
top.note("headers/pk_session_ask_attdefs.html#declaration", " <B>const</B> PK_SESSION_ask_attdefs_o_t *options, --- options", "PK Reference - PK_SESSION_ask_attdefs");
top.note("headers/pk_session_ask_behaviour.html#declaration", " <B>const</B> PK_SESSION_ask_behaviour_o_t *options, --- option structure", "PK Reference - PK_SESSION_ask_behaviour");
top.note("headers/pk_session_ask_binding.html#declaration", " PK_SESSION_binding_t *<B>const</B> answer", "PK Reference - PK_SESSION_ask_binding");
top.note("headers/pk_session_ask_cellular_guise.html#declaration", " PK_cellular_guise_t *<B>const</B> cellular_guise --- the cellular guise", "PK Reference - PK_SESSION_ask_cellular_guise");
top.note("headers/pk_session_ask_check_arguments.html#declaration", " PK_LOGICAL_t *<B>const</B> whether --- whether argument checking is enabled", "PK Reference - PK_SESSION_ask_check_arguments");
top.note("headers/pk_session_ask_check_continuity.html#declaration", " PK_LOGICAL_t *<B>const</B> whether --- whether continuity checking is enabled", "PK Reference - PK_SESSION_ask_check_continuity");
top.note("headers/pk_session_ask_check_self_int.html#declaration", " PK_LOGICAL_t *<B>const</B> whether --- whether self intersection checking is enabled", "PK Reference - PK_SESSION_ask_check_self_int");
top.note("headers/pk_session_ask_close_knots.html#declaration", " PK_LOGICAL_t *<B>const</B> whether --- whether close knots are allowed", "PK Reference - PK_SESSION_ask_close_knots");
top.note("headers/pk_session_ask_curr_partition.html#declaration", " PK_PARTITION_t *<B>const</B> partition --- current partition", "PK Reference - PK_SESSION_ask_curr_partition");
top.note("headers/pk_session_ask_err_reports.html#declaration", " <B>const</B> PK_SESSION_ask_err_reports_o_t *options, --- options structure", "PK Reference - PK_SESSION_ask_err_reports");
top.note("headers/pk_session_ask_facet_geometry.html#declaration", " PK_facet_geometry_t *<B>const</B> facet_geometry --- whether facet_geometry is enabled", "PK Reference - PK_SESSION_ask_facet_geometry");
top.note("headers/pk_session_ask_fru_2.html#declaration", " <B>const</B> PK_SESSION_ask_fru_o_t *options", "PK Reference - PK_SESSION_ask_fru_2");
top.note("headers/pk_session_ask_frustrum.html#declaration", " PK_SESSION_frustrum_t *<B>const</B> res", "PK Reference - PK_SESSION_ask_frustrum");
top.note("headers/pk_session_ask_function.html#declaration", " <B>const</B> char **<B>const</B> fn_name --- function name string", "PK Reference - PK_SESSION_ask_function");
top.note("headers/pk_session_ask_general_topology.html#declaration", " PK_LOGICAL_t *<B>const</B> whether --- whether generalised topology is enabled", "PK Reference - PK_SESSION_ask_general_topology");
top.note("headers/pk_session_ask_indexio.html#declaration", " PK_SESSION_indexio_t *<B>const</B> res", "PK Reference - PK_SESSION_ask_indexio");
top.note("headers/pk_session_ask_journalling.html#declaration", " PK_LOGICAL_t *<B>const</B> whether --- whether journalling is enabled", "PK Reference - PK_SESSION_ask_journalling");
top.note("headers/pk_session_ask_kernel_version.html#declaration", " PK_SESSION_kernel_version_t *<B>const</B> info", "PK Reference - PK_SESSION_ask_kernel_version");
top.note("headers/pk_session_ask_latest_behaviour.html#declaration", " PK_SESSION_behaviour_t *<B>const</B> latest_behaviour --- latest behaviour", "PK Reference - PK_SESSION_ask_latest_behaviour");
top.note("headers/pk_session_ask_mark.html#declaration", " PK_MARK_t *<B>const</B> mark, --- current session mark (possibly PK_MARK_null)", "PK Reference - PK_SESSION_ask_mark");
top.note("headers/pk_session_ask_max_threads.html#declaration", " <B>const</B> PK_SESSION_ask_max_threads_o_t *options,", "PK Reference - PK_SESSION_ask_max_threads");
top.note("headers/pk_session_ask_memory_usage.html#declaration", " size_t *<B>const</B> total, --- total amount of memory", "PK Reference - PK_SESSION_ask_memory_usage");
top.note("headers/pk_session_ask_mesh_angle.html#declaration", " double *<B>const</B> mesh_angle --- mesh angle", "PK Reference - PK_SESSION_ask_mesh_angle");
top.note("headers/pk_session_ask_partitions.html#declaration", " int *<B>const</B> n_partitions, --- number of partitions (>= 0)", "PK Reference - PK_SESSION_ask_partitions");
top.note("headers/pk_session_ask_parts.html#declaration", " int *<B>const</B> n_parts, --- number of parts (>= 0)", "PK Reference - PK_SESSION_ask_parts");
top.note("headers/pk_session_ask_precision.html#declaration", " double *<B>const</B> precision --- required precision", "PK Reference - PK_SESSION_ask_precision");
top.note("headers/pk_session_ask_rebuild_history.html#declaration", " PK_int_array_t *<B>const</B> rebuild_history --- rebuild history", "PK Reference - PK_SESSION_ask_rebuild_history");
top.note("headers/pk_session_ask_schema_version.html#declaration", " PK_SESSION_schema_version_t *<B>const</B> info", "PK Reference - PK_SESSION_ask_schema_version");
top.note("headers/pk_session_ask_smp.html#declaration", " PK_SESSION_smp_r_t *<B>const</B> results --- SMP return structure", "PK Reference - PK_SESSION_ask_smp");
top.note("headers/pk_session_ask_smp_stacksize.html#declaration", " size_t *<B>const</B> size", "PK Reference - PK_SESSION_ask_smp_stacksize");
top.note("headers/pk_session_ask_swept_spun_surfs.html#declaration", " PK_LOGICAL_t *<B>const</B> whether --- whether swept/spun surfaces enabled", "PK Reference - PK_SESSION_ask_swept_spun_surfs");
top.note("headers/pk_session_ask_tag_highest.html#declaration", " int *<B>const</B> highest_tag --- value of highest tag allocated", "PK Reference - PK_SESSION_ask_tag_highest");
top.note("headers/pk_session_ask_tag_limit.html#declaration", " int *<B>const</B> limit --- tag value limit", "PK Reference - PK_SESSION_ask_tag_limit");
top.note("headers/pk_session_ask_tags_remaining.html#declaration", " int *<B>const</B> tags_remaining --- number of available unused tags", "PK Reference - PK_SESSION_ask_tags_remaining");
top.note("headers/pk_session_ask_unicode.html#declaration", " PK_LOGICAL_t *<B>const</B> whether", "PK Reference - PK_SESSION_ask_unicode");
top.note("headers/pk_session_ask_user_field_len.html#declaration", " int *<B>const</B> user_field_length --- user field length", "PK Reference - PK_SESSION_ask_user_field_len");
top.note("headers/pk_session_comment.html#declaration", " <B>const</B> char *comment --- null-terminated string to set", "PK Reference - PK_SESSION_comment");
top.note("headers/pk_session_indexio_t.html#declaration", " int (*ffoprd)(int guise, <B>const</B> char name[], void *context);", "PK Reference - PK_SESSION_indexio_t");
top.note("headers/pk_session_is_in_kernel.html#declaration", " PK_LOGICAL_t *<B>const</B> is_in_kernel, --- whether called from within the kernel", "PK Reference - PK_SESSION_is_in_kernel");
top.note("headers/pk_session_is_in_kernel_2.html#declaration", " PK_LOGICAL_t *<B>const</B> is_in_kernel, --- whether called from within the kernel", "PK Reference - PK_SESSION_is_in_kernel_2");
top.note("headers/pk_session_is_roll_forward_on.html#declaration", " PK_LOGICAL_t *<B>const</B> roll_forward_on --- roll forward interface parameter", "PK Reference - PK_SESSION_is_roll_forward_on");
top.note("headers/pk_session_is_rollback_on.html#declaration", " PK_LOGICAL_t *<B>const</B> rollback_on --- true if rollback is on", "PK Reference - PK_SESSION_is_rollback_on");
top.note("headers/pk_session_receive.html#declaration", " <B>const</B> char *key, --- key string", "PK Reference - PK_SESSION_receive");
top.note("headers/pk_session_receive_u.html#declaration", " <B>const</B> PK_UCHAR_t *key, --- key string", "PK Reference - PK_SESSION_receive_u");
top.note("headers/pk_session_receive_version.html#declaration", " <B>const</B> char *key, --- key string", "PK Reference - PK_SESSION_receive_version");
top.note("headers/pk_session_receive_version_u.html#declaration", " <B>const</B> PK_UCHAR_t *key, --- key string", "PK Reference - PK_SESSION_receive_version_u");
top.note("headers/pk_session_register_applio.html#declaration", " <B>const</B> PK_SESSION_applio_t *new --- functions to register (may be", "PK Reference - PK_SESSION_register_applio");
top.note("headers/pk_session_register_applio_2.html#declaration", " <B>const</B> PK_SESSION_applio_t *new --- functions to register (may be", "PK Reference - PK_SESSION_register_applio_2");
top.note("headers/pk_session_register_fru_2.html#declaration", " <B>const</B> PK_SESSION_register_fru_o_t *options", "PK Reference - PK_SESSION_register_fru_2");
top.note("headers/pk_session_register_frustrum.html#declaration", " <B>const</B> PK_SESSION_frustrum_t *new", "PK Reference - PK_SESSION_register_frustrum");
top.note("headers/pk_session_register_indexio.html#declaration", " <B>const</B> PK_SESSION_indexio_t *new", "PK Reference - PK_SESSION_register_indexio");
top.note("headers/pk_session_set_behaviour.html#declaration", "<B>const</B> PK_SESSION_set_behaviour_o_t *options, --- option structure", "PK Reference - PK_SESSION_set_behaviour");
top.note("headers/pk_session_set_err_reports.html#declaration", "<B>const</B> PK_SESSION_set_err_reports_o_t *options --- options structure", "PK Reference - PK_SESSION_set_err_reports");
top.note("headers/pk_session_set_rebuild_history.html#declaration", " PK_int_array_t *<B>const</B> set_history, --- the rebuild history now set", "PK Reference - PK_SESSION_set_rebuild_history");
top.note("headers/pk_session_set_smp.html#declaration", " <B>const</B> PK_SESSION_smp_o_t *options --- SMP options", "PK Reference - PK_SESSION_set_smp");
top.note("headers/pk_session_start.html#declaration", " <B>const</B> PK_SESSION_start_o_t *options", "PK Reference - PK_SESSION_start");
top.note("headers/pk_session_transmit.html#declaration", " <B>const</B> char *key, --- key string", "PK Reference - PK_SESSION_transmit");
top.note("headers/pk_session_transmit_u.html#declaration", " <B>const</B> PK_UCHAR_t *key, --- key string", "PK Reference - PK_SESSION_transmit_u");
top.note("headers/pk_session_watch_tags.html#declaration", "<B>const</B> int tags[], --- tags to watch", "PK Reference - PK_SESSION_watch_tags");
top.note("headers/pk_shell_ask_acorn_vertex.html#declaration", " PK_VERTEX_t *<B>const</B> vertex --- its acorn vertex (or PK_ENTITY_null)", "PK Reference - PK_SHELL_ask_acorn_vertex");
top.note("headers/pk_shell_ask_body.html#declaration", " PK_BODY_t *<B>const</B> body --- owning body", "PK Reference - PK_SHELL_ask_body");
top.note("headers/pk_shell_ask_oriented_faces.html#declaration", " int *<B>const</B> n_faces, --- number of faces (>= 0)", "PK Reference - PK_SHELL_ask_oriented_faces");
top.note("headers/pk_shell_ask_region.html#declaration", " PK_REGION_t *<B>const</B> region --- owning region", "PK Reference - PK_SHELL_ask_region");
top.note("headers/pk_shell_ask_type.html#declaration", " PK_SHELL_type_t *<B>const</B> shell_type --- the type of the shell", "PK Reference - PK_SHELL_ask_type");
top.note("headers/pk_shell_ask_wireframe_edges.html#declaration", " int *<B>const</B> n_edges, --- number of wireframe edges (>= 0)", "PK Reference - PK_SHELL_ask_wireframe_edges");
top.note("headers/pk_shell_find_sign.html#declaration", " PK_SHELL_sign_t *<B>const</B> shell_sign --- the sign of the shell", "PK Reference - PK_SHELL_find_sign");
top.note("headers/pk_spcurve_ask.html#declaration", " PK_SPCURVE_sf_t *<B>const</B> spcurve_sf --- sf for an spcurve", "PK Reference - PK_SPCURVE_ask");
top.note("headers/pk_spcurve_create.html#declaration", " <B>const</B> PK_SPCURVE_sf_t *spcurve_sf, --- spcurve standard form", "PK Reference - PK_SPCURVE_create");
top.note("headers/pk_sphere_ask.html#declaration", " PK_SPHERE_sf_t *<B>const</B> sphere_sf --- sphere standard form", "PK Reference - PK_SPHERE_ask");
top.note("headers/pk_sphere_create.html#declaration", " <B>const</B> PK_SPHERE_sf_t *sphere_sf, --- sphere standard form", "PK Reference - PK_SPHERE_create");
top.note("headers/pk_sphere_make_solid_body.html#declaration", " PK_BODY_t *<B>const</B> body --- body", "PK Reference - PK_SPHERE_make_solid_body");
top.note("headers/pk_spun_ask.html#declaration", " PK_SPUN_sf_t *<B>const</B> spun_sf --- sf for an spun surface", "PK Reference - PK_SPUN_ask");
top.note("headers/pk_spun_create.html#declaration", " <B>const</B> PK_SPUN_sf_t *spun_sf, --- spun surf standard form", "PK Reference - PK_SPUN_create");
top.note("headers/pk_surf_ask_faces.html#declaration", " int *<B>const</B> n_faces, --- number of faces (>= 0)", "PK Reference - PK_SURF_ask_faces");
top.note("headers/pk_surf_ask_part.html#declaration", " PK_PART_t *<B>const</B> part --- owning part (possibly PK_ENTITY_null)", "PK Reference - PK_SURF_ask_part");
top.note("headers/pk_surf_ask_uvbox.html#declaration", " PK_UVBOX_t *<B>const</B> uvbox --- parametric bounds of the surf", "PK Reference - PK_SURF_ask_uvbox");
top.note("headers/pk_surf_create_blend.html#declaration", "<B>const</B> PK_SURF_create_blend_o_t *options,", "PK Reference - PK_SURF_create_blend");
top.note("headers/pk_surf_degens_f.html#declaration", " PK_SURF_degens_t *<B>const</B> result", "PK Reference - PK_SURF_degens_f");
top.note("headers/pk_surf_eval_curvature.html#declaration", " PK_VECTOR1_t *<B>const</B> normal, --- surface normal", "PK Reference - PK_SURF_eval_curvature");
top.note("headers/pk_surf_eval_curvature_handed.html#declaration", " PK_VECTOR1_t *<B>const</B> normal, --- surface normal", "PK Reference - PK_SURF_eval_curvature_handed");
top.note("headers/pk_surf_eval_grid.html#declaration", "<B>const</B> double u[], --- u parameters", "PK Reference - PK_SURF_eval_grid");
top.note("headers/pk_surf_eval_with_normal.html#declaration", " PK_VECTOR_t *<B>const</B> normal --- surface normal", "PK Reference - PK_SURF_eval_with_normal");
top.note("headers/pk_surf_eval_with_normal_handed.html#declaration", " PK_VECTOR_t *<B>const</B> normal --- surface normal", "PK Reference - PK_SURF_eval_with_normal_handed");
top.note("headers/pk_surf_extend.html#declaration", "<B>const</B> PK_SURF_extend_o_t *options, --- options structure [PF]", "PK Reference - PK_SURF_extend");
top.note("headers/pk_surf_find_box.html#declaration", "<B>const</B> PK_SURF_find_box_o_t *options, --- options structure", "PK Reference - PK_SURF_find_box");
top.note("headers/pk_surf_find_curves_common.html#declaration", " int *<B>const</B> n_curves, --- number of common curves", "PK Reference - PK_SURF_find_curves_common");
top.note("headers/pk_surf_find_degens.html#declaration", "<B>const</B> PK_SURF_find_degens_o_t *options, --- options structure", "PK Reference - PK_SURF_find_degens");
top.note("headers/pk_surf_find_discontinuity.html#declaration", "<B>const</B> PK_SURF_find_discontinuity_o_t *options, --- options", "PK Reference - PK_SURF_find_discontinuity");
top.note("headers/pk_surf_find_min_radii.html#declaration", " int *<B>const</B> n_radii, --- number of radii returned", "PK Reference - PK_SURF_find_min_radii");
top.note("headers/pk_surf_find_non_aligned_box.html#declaration", " PK_VECTOR_t *<B>const</B> centre, --- box centre", "PK Reference - PK_SURF_find_non_aligned_box");
top.note("headers/pk_surf_find_self_int.html#declaration", "<B>const</B> PK_SURF_find_self_int_o_t *options, --- options structure", "PK Reference - PK_SURF_find_self_int");
top.note("headers/pk_surf_find_vectors.html#declaration", "<B>const</B> PK_SURF_find_vectors_o_t *options, --- options [PF]", "PK Reference - PK_SURF_find_vectors");
top.note("headers/pk_surf_find_vectors_r_f.html#declaration", " PK_SURF_find_vectors_r_t *<B>const</B> found_vectors --- structure to free", "PK Reference - PK_SURF_find_vectors_r_f");
top.note("headers/pk_surf_fix_degens.html#declaration", "<B>const</B> PK_SURF_degens_t *degens, --- degeneracies", "PK Reference - PK_SURF_fix_degens");
top.note("headers/pk_surf_fix_degens_o_t.html#declaration", " <B>const</B> PK_VECTOR1_t *normals; --- normals of the degeneracies", "PK Reference - PK_SURF_fix_degens_o_t");
top.note("headers/pk_surf_fix_self_int.html#declaration", "<B>const</B> PK_SURF_self_ints_t *self_ints, --- self intersections", "PK Reference - PK_SURF_fix_self_int");
top.note("headers/pk_surf_fix_self_int_r_f.html#declaration", " PK_SURF_fix_self_int_r_t *<B>const</B> result", "PK Reference - PK_SURF_fix_self_int_r_f");
top.note("headers/pk_surf_general_eval_f_t.html#declaration", " double *<B>const</B> p --- point and derivatives", "PK Reference - PK_SURF_general_eval_f_t");
top.note("headers/pk_surf_intersect_curve.html#declaration", "<B>const</B> PK_SURF_intersect_curve_o_t *options, --- options structure", "PK Reference - PK_SURF_intersect_curve");
top.note("headers/pk_surf_intersect_surf.html#declaration", "<B>const</B> PK_SURF_intersect_surf_o_t *options, --- options structure [PF]", "PK Reference - PK_SURF_intersect_surf");
top.note("headers/pk_surf_make_bsurf.html#declaration", " PK_BSURF_t *<B>const</B> b_surf, --- created BSURF", "PK Reference - PK_SURF_make_bsurf");
top.note("headers/pk_surf_make_bsurf_2.html#declaration", "<B>const</B> PK_SURF_make_bsurf_o_t *options, --- options", "PK Reference - PK_SURF_make_bsurf_2");
top.note("headers/pk_surf_make_bsurf_array.html#declaration", "<B>const</B> PK_SURF_make_bsurf_array_o_t *options, --- options", "PK Reference - PK_SURF_make_bsurf_array");
top.note("headers/pk_surf_make_curve_isoparam.html#declaration", "<B>const</B> PK_SURF_make_curve_isoparam_o_t *options, --- option structure", "PK Reference - PK_SURF_make_curve_isoparam");
top.note("headers/pk_surf_make_curve_u_isoparam.html#declaration", " <B>const</B> PK_SURF_t surf, --- surface", "PK Reference - PK_SURF_make_curve_u_isoparam");
top.note("headers/pk_surf_make_curve_v_isoparam.html#declaration", " <B>const</B> PK_SURF_t surf, --- surface", "PK Reference - PK_SURF_make_curve_v_isoparam");
top.note("headers/pk_surf_make_curves_isocline.html#declaration", " int *<B>const</B> n_curves, --- number of isocline curves (>= 0)", "PK Reference - PK_SURF_make_curves_isocline");
top.note("headers/pk_surf_make_cus_isocline.html#declaration", "<B>const</B> PK_SURF_make_cus_isocline_o_t *options,", "PK Reference - PK_SURF_make_cus_isocline");
top.note("headers/pk_surf_make_sheet_body.html#declaration", " PK_BODY_t *<B>const</B> body --- sheet body returned", "PK Reference - PK_SURF_make_sheet_body");
top.note("headers/pk_surf_make_sheet_trimmed.html#declaration", "<B>const</B> PK_SURF_make_sheet_trimmed_o_t *options, --- options structure", "PK Reference - PK_SURF_make_sheet_trimmed");
top.note("headers/pk_surf_offset.html#declaration", " PK_SURF_t *<B>const</B> surf --- surface returned", "PK Reference - PK_SURF_offset");
top.note("headers/pk_surf_parameterise_vector.html#declaration", " PK_UV_t *<B>const</B> uv --- parameters of position on surf", "PK Reference - PK_SURF_parameterise_vector");
top.note("headers/pk_surf_self_ints_f.html#declaration", " PK_SURF_self_ints_t *<B>const</B> result", "PK Reference - PK_SURF_self_ints_f");
top.note("headers/pk_sweep_face_clamp_t.html#declaration", " <B>const</B> PK_EDGE_t *edges; --- array of clamped profile edges", "PK Reference - PK_sweep_face_clamp_t");
top.note("headers/pk_sweep_guide_clamp_dirn_t.html#declaration", " <B>const</B> PK_VECTOR1_t *directions; --- the direction of each clamp", "PK Reference - PK_sweep_guide_clamp_dirn_t");
top.note("headers/pk_swept_ask.html#declaration", " PK_SWEPT_sf_t *<B>const</B> swept_sf --- sf for a swept surface", "PK Reference - PK_SWEPT_ask");
top.note("headers/pk_swept_create.html#declaration", " <B>const</B> PK_SWEPT_sf_t *swept_sf, --- swept surf standard form", "PK Reference - PK_SWEPT_create");
top.note("headers/pk_thread_ask_err_reports.html#declaration", " <B>const</B> PK_THREAD_ask_err_reports_o_t *options, --- options structure", "PK Reference - PK_THREAD_ask_err_reports");
top.note("headers/pk_thread_ask_error_cbs.html#declaration", " PK_ERROR_frustrum_t *<B>const</B> frustrum --- thread error handler", "PK Reference - PK_THREAD_ask_error_cbs");
top.note("headers/pk_thread_ask_exclusion.html#declaration", " PK_THREAD_exclusion_t *<B>const</B> exclusion, --- type of thread exclusion", "PK Reference - PK_THREAD_ask_exclusion");
top.note("headers/pk_thread_ask_function.html#declaration", " <B>const</B> char **<B>const</B> fn_name, --- function name string (may be NULL)", "PK Reference - PK_THREAD_ask_function");
top.note("headers/pk_thread_ask_function_run.html#declaration", "<B>const</B> PK_FUNCTION_t functions[], --- functions", "PK Reference - PK_THREAD_ask_function_run");
top.note("headers/pk_thread_ask_id.html#declaration", " PK_THREAD_id_t *<B>const</B> thread_id, --- ID of calling thread", "PK Reference - PK_THREAD_ask_id");
top.note("headers/pk_thread_ask_last_error.html#declaration", " PK_LOGICAL_t *<B>const</B> was_error, --- whether there was an error", "PK Reference - PK_THREAD_ask_last_error");
top.note("headers/pk_thread_ask_local_level.html#declaration", " <B>const</B> PK_THREAD_ask_local_level_o_t *options, --- options structure", "PK Reference - PK_THREAD_ask_local_level");
top.note("headers/pk_thread_ask_memory_cbs.html#declaration", " PK_MEMORY_frustrum_t *<B>const</B> frustrum --- thread memory handlers", "PK Reference - PK_THREAD_ask_memory_cbs");
top.note("headers/pk_thread_ask_partitions.html#declaration", " <B>const</B> PK_THREAD_ask_partitions_o_t *options,", "PK Reference - PK_THREAD_ask_partitions");
top.note("headers/pk_thread_chain_start.html#declaration", "<B>const</B> PK_THREAD_chain_start_o_t *options", "PK Reference - PK_THREAD_chain_start");
top.note("headers/pk_thread_chain_stop.html#declaration", " <B>const</B> PK_THREAD_chain_stop_o_t *options", "PK Reference - PK_THREAD_chain_stop");
top.note("headers/pk_thread_clear_exclusion.html#declaration", " PK_THREAD_exclusion_t *<B>const</B> exclusion, --- type of thread exclusion", "PK Reference - PK_THREAD_clear_exclusion");
top.note("headers/pk_thread_clear_last_error.html#declaration", " PK_LOGICAL_t *<B>const</B> was_error --- whether there was an error to", "PK Reference - PK_THREAD_clear_last_error");
top.note("headers/pk_thread_is_in_chain.html#declaration", " PK_THREAD_chain_type_t *<B>const</B> type,", "PK Reference - PK_THREAD_is_in_chain");
top.note("headers/pk_thread_is_in_kernel.html#declaration", " PK_LOGICAL_t *<B>const</B> is_in_kernel, --- whether called from within the kernel", "PK Reference - PK_THREAD_is_in_kernel");
top.note("headers/pk_thread_lock_partitions.html#declaration", "<B>const</B> PK_PARTITION_t partitions[],", "PK Reference - PK_THREAD_lock_partitions");
top.note("headers/pk_thread_lock_partitions_r_f.html#declaration", " PK_THREAD_lock_partitions_r_t *<B>const</B> results --- lock results to free", "PK Reference - PK_THREAD_lock_partitions_r_f");
top.note("headers/pk_thread_set_err_reports.html#declaration", "<B>const</B> PK_THREAD_set_err_reports_o_t *options --- options structure", "PK Reference - PK_THREAD_set_err_reports");
top.note("headers/pk_thread_set_function_run.html#declaration", "<B>const</B> PK_FUNCTION_t functions[], --- functions", "PK Reference - PK_THREAD_set_function_run");
top.note("headers/pk_thread_set_id.html#declaration", "<B>const</B> PK_THREAD_set_id_o_t *options, --- options structure", "PK Reference - PK_THREAD_set_id");
top.note("headers/pk_thread_set_id_r_f.html#declaration", " PK_THREAD_set_id_r_t *<B>const</B> result --- result information to free", "PK Reference - PK_THREAD_set_id_r_f");
top.note("headers/pk_thread_unlock_partitions.html#declaration", " <B>const</B> PK_THREAD_unlock_partitions_o_t *options,", "PK Reference - PK_THREAD_unlock_partitions");
top.note("headers/pk_topol_ask_entities_by_attdef.html#declaration", " int *<B>const</B> n_entities, --- number of entities ( >= 0", "PK Reference - PK_TOPOL_ask_entities_by_attdef");
top.note("headers/pk_topol_categorise_geom.html#declaration", "<B>const</B> PK_TOPOL_categorise_geom_o_t *options, --- option structure", "PK Reference - PK_TOPOL_categorise_geom");
top.note("headers/pk_topol_clash.html#declaration", " <B>const</B> int n_targets, --- Number of target topologies", "PK Reference - PK_TOPOL_clash");
top.note("headers/pk_topol_delete_redundant_2.html#declaration", "<B>const</B> PK_TOPOL_t topols[], --- array of topols", "PK Reference - PK_TOPOL_delete_redundant_2");
top.note("headers/pk_topol_delete_redundant_2_o_t.html#declaration", "<B>const</B> PK_TOPOL_t *protected_topols; --- protected topology array", "PK Reference - PK_TOPOL_delete_redundant_2_o_t");
top.note("headers/pk_topol_eval_mass_props.html#declaration", "<B>const</B> PK_TOPOL_t topols[], --- topological entities array", "PK Reference - PK_TOPOL_eval_mass_props");
top.note("headers/pk_topol_eval_mass_props_o_t.html#declaration", " <B>const</B> PK_TRANSF_t *transfs; --- array of transformations (NULL)", "PK Reference - PK_TOPOL_eval_mass_props_o_t");
top.note("headers/pk_topol_facet.html#declaration", " <B>const</B> int n_topols, --- number of entities", "PK Reference - PK_TOPOL_facet");
top.note("headers/pk_topol_facet_2.html#declaration", " <B>const</B> int n_topols, --- number of entities", "PK Reference - PK_TOPOL_facet_2");
top.note("headers/pk_topol_facet_2_r_f.html#declaration", " PK_TOPOL_facet_2_r_t *<B>const</B> tables --- facet tables to free", "PK Reference - PK_TOPOL_facet_2_r_f");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#declaration", " <B>const</B> PK_NABOX_sf_t ", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#declaration", " <B>const</B> PK_NABOX_sf_t ", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_facet_r_f.html#declaration", " PK_TOPOL_facet_r_t *<B>const</B> tables --- facet tables to free", "PK Reference - PK_TOPOL_facet_r_f");
top.note("headers/pk_topol_facet_tables_cb_f_t.html#declaration", " PK_TOPOL_facet_2_r_t *<B>const</B> tables, --- returned facet tables", "PK Reference - PK_TOPOL_facet_tables_cb_f_t");
top.note("headers/pk_topol_find_box.html#declaration", " PK_BOX_t *<B>const</B> box --- box containing entity", "PK Reference - PK_TOPOL_find_box");
top.note("headers/pk_topol_find_box_2.html#declaration", "<B>const</B> PK_TOPOL_t topols[], --- topologies to be boxed", "PK Reference - PK_TOPOL_find_box_2");
top.note("headers/pk_topol_find_box_2_r_f.html#declaration", " PK_TOPOL_find_box_2_r_t *<B>const</B> result", "PK Reference - PK_TOPOL_find_box_2_r_f");
top.note("headers/pk_topol_find_frames.html#declaration", "<B>const</B> PK_TOPOL_find_frames_o_t *options, --- options", "PK Reference - PK_TOPOL_find_frames");
top.note("headers/pk_topol_find_frames_r_f.html#declaration", " PK_TOPOL_find_frames_r_t *<B>const</B> results", "PK Reference - PK_TOPOL_find_frames_r_f");
top.note("headers/pk_topol_find_nabox.html#declaration", "<B>const</B> PK_TOPOL_t topols[], --- entities to be boxed", "PK Reference - PK_TOPOL_find_nabox");
top.note("headers/pk_topol_identify_redundant.html#declaration", "<B>const</B> PK_TOPOL_t topols[], --- array of topols", "PK Reference - PK_TOPOL_identify_redundant");
top.note("headers/pk_topol_imprint_frames.html#declaration", "<B>const</B> PK_TOPOL_imprint_frames_o_t *options, --- options", "PK Reference - PK_TOPOL_imprint_frames");
top.note("headers/pk_topol_imprint_frames_r_f.html#declaration", " PK_TOPOL_imprint_frames_r_t *<B>const</B> results", "PK Reference - PK_TOPOL_imprint_frames_r_f");
top.note("headers/pk_topol_local_r_f.html#declaration", " PK_TOPOL_local_r_t *<B>const</B> loc", "PK Reference - PK_TOPOL_local_r_f");
top.note("headers/pk_topol_make_facet_topol.html#declaration", "<B>const</B> PK_TOPOL_make_facet_topol_o_t *options, --- Options structure", "PK Reference - PK_TOPOL_make_facet_topol");
top.note("headers/pk_topol_make_general_body.html#declaration", "<B>const</B> PK_TOPOL_t topols[], --- array of topologies", "PK Reference - PK_TOPOL_make_general_body");
top.note("headers/pk_topol_make_new.html#declaration", "<B>const</B> PK_TOPOL_make_new_o_t *options, --- options structure", "PK Reference - PK_TOPOL_make_new");
top.note("headers/pk_topol_range.html#declaration", "<B>const</B> PK_TOPOL_range_o_t *options, --- options structure [PF]", "PK Reference - PK_TOPOL_range");
top.note("headers/pk_topol_range_array.html#declaration", "<B>const</B> PK_TOPOL_t topols_1[], --- first topological array", "PK Reference - PK_TOPOL_range_array");
top.note("headers/pk_topol_range_array_vector.html#declaration", "<B>const</B> PK_TOPOL_t topols[], --- topological array", "PK Reference - PK_TOPOL_range_array_vector");
top.note("headers/pk_topol_range_geom.html#declaration", "<B>const</B> PK_TOPOL_range_geom_o_t *options, --- option structure [PF]", "PK Reference - PK_TOPOL_range_geom");
top.note("headers/pk_topol_range_geom_array.html#declaration", "<B>const</B> PK_TOPOL_t topols[], --- topological array", "PK Reference - PK_TOPOL_range_geom_array");
top.note("headers/pk_topol_range_local.html#declaration", "<B>const</B> PK_TOPOL_range_local_o_t *options, --- options structure", "PK Reference - PK_TOPOL_range_local");
top.note("headers/pk_topol_range_local_vector.html#declaration", "<B>const</B> PK_TOPOL_range_local_vector_o_t *options, --- options structure", "PK Reference - PK_TOPOL_range_local_vector");
top.note("headers/pk_topol_range_vector.html#declaration", "<B>const</B> PK_TOPOL_range_vector_o_t *options, --- options structure [PF]", "PK Reference - PK_TOPOL_range_vector");
top.note("headers/pk_topol_remove_body_component.html#declaration", " <B>const</B> PK_TOPOL_t topol, --- a topological entity in required", "PK Reference - PK_TOPOL_remove_body_component");
top.note("headers/pk_topol_render_facet.html#declaration", " <B>const</B> int n_topols, --- number of entities", "PK Reference - PK_TOPOL_render_facet");
top.note("headers/pk_topol_render_line.html#declaration", " <B>const</B> int n_topols, --- number of entities", "PK Reference - PK_TOPOL_render_line");
top.note("headers/pk_topol_render_line_o_t.html#declaration", " <B>const</B> int *overlap_indices1;", "PK Reference - PK_TOPOL_render_line_o_t");
top.note("headers/pk_topol_render_volume.html#declaration", "<B>const</B> PK_TOPOL_t topols[], --- topols to be rendered", "PK Reference - PK_TOPOL_render_volume");
top.note("headers/pk_topol_render_volume_o_t.html#declaration", " <B>const</B> PK_BODY_t *bodies_with_scales; --- a scale factor is", "PK Reference - PK_TOPOL_render_volume_o_t");
top.note("headers/pk_topol_render_volume_r_f.html#declaration", " PK_TOPOL_render_volume_r_t *<B>const</B> results", "PK Reference - PK_TOPOL_render_volume_r_f");
top.note("headers/pk_topol_track_r_f.html#declaration", " PK_TOPOL_track_r_t *<B>const</B> tracking --- tracking information to free", "PK Reference - PK_TOPOL_track_r_f");
top.note("headers/pk_torus_ask.html#declaration", " PK_TORUS_sf_t *<B>const</B> torus_sf --- torus standard form", "PK Reference - PK_TORUS_ask");
top.note("headers/pk_torus_create.html#declaration", " <B>const</B> PK_TORUS_sf_t *torus_sf, --- torus standard form", "PK Reference - PK_TORUS_create");
top.note("headers/pk_torus_make_solid_body.html#declaration", " PK_BODY_t *<B>const</B> body --- solid body", "PK Reference - PK_TORUS_make_solid_body");
top.note("headers/pk_transf_ask.html#declaration", " PK_TRANSF_sf_t *<B>const</B> transf_sf --- transf standard form", "PK Reference - PK_TRANSF_ask");
top.note("headers/pk_transf_check.html#declaration", "<B>const</B> PK_TRANSF_check_o_t *options, --- options structure", "PK Reference - PK_TRANSF_check");
top.note("headers/pk_transf_classify.html#declaration", "<B>const</B> PK_TRANSF_classify_o_t *options, --- options structure", "PK Reference - PK_TRANSF_classify");
top.note("headers/pk_transf_classify_r_f.html#declaration", " PK_TRANSF_classify_r_t *<B>const</B> result", "PK Reference - PK_TRANSF_classify_r_f");
top.note("headers/pk_transf_create.html#declaration", " <B>const</B> PK_TRANSF_sf_t *transf_sf, --- transf standard form", "PK Reference - PK_TRANSF_create");
top.note("headers/pk_transf_create_equal_scale.html#declaration", " PK_TRANSF_t *<B>const</B> transf --- equal scaling transformation", "PK Reference - PK_TRANSF_create_equal_scale");
top.note("headers/pk_transf_create_reflection.html#declaration", " PK_TRANSF_t *<B>const</B> transf --- reflection transformation", "PK Reference - PK_TRANSF_create_reflection");
top.note("headers/pk_transf_create_rotation.html#declaration", " PK_TRANSF_t *<B>const</B> transf --- rotation transformation", "PK Reference - PK_TRANSF_create_rotation");
top.note("headers/pk_transf_create_translation.html#declaration", " PK_TRANSF_t *<B>const</B> transf --- translation transformation", "PK Reference - PK_TRANSF_create_translation");
top.note("headers/pk_transf_create_view.html#declaration", "<B>const</B> PK_TRANSF_create_view_o_t *options, --- option structure", "PK Reference - PK_TRANSF_create_view");
top.note("headers/pk_transf_enlarge.html#declaration", "<B>const</B> PK_TRANSF_enlarge_o_t *options, --- options", "PK Reference - PK_TRANSF_enlarge");
top.note("headers/pk_transf_enlarge_r_f.html#declaration", " PK_TRANSF_enlarge_r_t *<B>const</B> results", "PK Reference - PK_TRANSF_enlarge_r_f");
top.note("headers/pk_transf_is_equal.html#declaration", " PK_LOGICAL_t *<B>const</B> is_equal --- whether transformations are equal", "PK Reference - PK_TRANSF_is_equal");
top.note("headers/pk_transf_transform.html#declaration", " PK_TRANSF_t *<B>const</B> transf_out", "PK Reference - PK_TRANSF_transform");
top.note("headers/pk_transf_transform_2.html#declaration", "<B>const</B> PK_TRANSF_transform_o_t *options, --- options", "PK Reference - PK_TRANSF_transform_2");
top.note("headers/pk_transf_transform_r_f.html#declaration", " PK_TRANSF_transform_r_t *<B>const</B> results", "PK Reference - PK_TRANSF_transform_r_f");
top.note("headers/pk_trcurve_ask.html#declaration", " PK_TRCURVE_sf_t *<B>const</B> trcurve_sf --- trcurve standard form", "PK Reference - PK_TRCURVE_ask");
top.note("headers/pk_ucoprd_f_t.html#declaration", " <B>const</B> int guise,", "PK Reference - PK_UCOPRD_f_t");
top.note("headers/pk_ucopwr_f_t.html#declaration", " <B>const</B> int guise,", "PK Reference - PK_UCOPWR_f_t");
top.note("headers/pk_vector_is_equal.html#declaration", " PK_LOGICAL_t *<B>const</B> is_equal", "PK Reference - PK_VECTOR_is_equal");
top.note("headers/pk_vector_is_parallel.html#declaration", " PK_LOGICAL_t *<B>const</B> is_parallel", "PK Reference - PK_VECTOR_is_parallel");
top.note("headers/pk_vector_is_zero.html#declaration", " PK_LOGICAL_t *<B>const</B> is_zero", "PK Reference - PK_VECTOR_is_zero");
top.note("headers/pk_vector_make_lsq_plane.html#declaration", "<B>const</B> PK_VECTOR_t *positions, --- positions to fit to", "PK Reference - PK_VECTOR_make_lsq_plane");
top.note("headers/pk_vector_make_view_transf.html#declaration", " PK_TRANSF_t *<B>const</B> transf --- viewing transformation", "PK Reference - PK_VECTOR_make_view_transf");
top.note("headers/pk_vector_normalise.html#declaration", " PK_VECTOR1_t *<B>const</B> uvec --- unit-magnitude result, or {0,0,0}", "PK Reference - PK_VECTOR_normalise");
top.note("headers/pk_vector_perpendicular.html#declaration", " PK_VECTOR1_t *<B>const</B> perpendicular_vector --- vector address", "PK Reference - PK_VECTOR_perpendicular");
top.note("headers/pk_vector_transform.html#declaration", " PK_VECTOR_t *<B>const</B> ptrans --- new position", "PK Reference - PK_VECTOR_transform");
top.note("headers/pk_vector_transform_direction.html#declaration", " PK_VECTOR1_t *<B>const</B> direction_trans --- new direction", "PK Reference - PK_VECTOR_transform_direction");
top.note("headers/pk_vertex_ask_body.html#declaration", " PK_BODY_t *<B>const</B> body --- owning body", "PK Reference - PK_VERTEX_ask_body");
top.note("headers/pk_vertex_ask_faces.html#declaration", " int *<B>const</B> n_faces, --- number of faces (>= 0)", "PK Reference - PK_VERTEX_ask_faces");
top.note("headers/pk_vertex_ask_isolated_loops.html#declaration", " int *<B>const</B> n_loops, --- number of isolated loops (>= 0)", "PK Reference - PK_VERTEX_ask_isolated_loops");
top.note("headers/pk_vertex_ask_oriented_edges.html#declaration", " int *<B>const</B> n_edges, --- number of edges (>= 0)", "PK Reference - PK_VERTEX_ask_oriented_edges");
top.note("headers/pk_vertex_ask_point.html#declaration", " PK_POINT_t *<B>const</B> point --- its point (possibly PK_ENTITY_null)", "PK Reference - PK_VERTEX_ask_point");
top.note("headers/pk_vertex_ask_precision.html#declaration", " double *<B>const</B> precision --- precision", "PK Reference - PK_VERTEX_ask_precision");
top.note("headers/pk_vertex_ask_shells.html#declaration", " int *<B>const</B> n_shells, --- number of shells (>= 1)", "PK Reference - PK_VERTEX_ask_shells");
top.note("headers/pk_vertex_ask_type.html#declaration", " PK_VERTEX_type_t *<B>const</B> vertex_type --- the type of the vertex", "PK Reference - PK_VERTEX_ask_type");
top.note("headers/pk_vertex_attach_points.html#declaration", "<B>const</B> PK_VERTEX_t vertices[], --- vertices to have points attached", "PK Reference - PK_VERTEX_attach_points");
top.note("headers/pk_vertex_delete_acorn.html#declaration", "<B>const</B> PK_VERTEX_t vertices[] --- acorn vertices to delete", "PK Reference - PK_VERTEX_delete_acorn");
top.note("headers/pk_vertex_euler_split.html#declaration", " PK_VERTEX_t *<B>const</B> new_vertex, --- New vertex created", "PK Reference - PK_VERTEX_euler_split");
top.note("headers/pk_vertex_make_blend.html#declaration", " PK_EDGE_t *<B>const</B> edge, --- new edge", "PK Reference - PK_VERTEX_make_blend");
top.note("headers/pk_vertex_optimise.html#declaration", "<B>const</B> PK_VERTEX_optimise_o_t *options, --- option structure", "PK Reference - PK_VERTEX_optimise");
top.note("headers/pk_vertex_remove_edge.html#declaration", " PK_VERTEX_t *<B>const</B> new_vertex --- new vertex", "PK Reference - PK_VERTEX_remove_edge");
top.note("headers/pk_vertex_spin.html#declaration", "<B>const</B> PK_AXIS1_sf_t *axis, --- spin axis", "PK Reference - PK_VERTEX_spin");
top.note("headers/pk_vertex_sweep.html#declaration", " PK_EDGE_t *<B>const</B> lateral, --- new edge", "PK Reference - PK_VERTEX_sweep");
top.note("chapters/kd_chap.05.html#50475010_pgfId-280942", " int *<B>const</B> n_things --- number of things", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274100", " <B>const</B> char ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274273", " <B>const</B> char ", "FG Manual - FG Module Interface Functions");
top.note("chapters/fr_chap.06.html#50462725_pgfId-276111", " static void write_xml_header( file_p file_ptr, <B>const</B> char* pd2hdr, int pd2len, ", "Reporting Faults to Parasolid - Updating The Frustrum");
top.note("chapters/fr_chap.06.html#50462725_pgfId-276541", " void OpenWriteFrustrumFile( <B>const</B> int* guise, <B>const</B> int* format, ", "Reporting Faults to Parasolid - Updating The Frustrum");
top.note("chapters/fr_chap.06.html#50462725_pgfId-276720", " <B>const</B> char* name, ", "Reporting Faults to Parasolid - Updating The Frustrum");
top.note("chapters/fr_chap.06.html#50462725_pgfId-276542", " <B>const</B> int* namlen, <B>const</B> char* pd2hdr, <B>const</B> int *pd2len,", "Reporting Faults to Parasolid - Updating The Frustrum");
top.note("chapters/fr_chap.06.html#50462725_pgfId-275648", " void WriteToFrustrumFile( <B>const</B> int* guise, <B>const</B> int* strid, <B>const</B> int* nchars,", "Reporting Faults to Parasolid - Updating The Frustrum");
top.note("chapters/fr_chap.06.html#50462725_pgfId-275649", " <B>const</B> char* buffer, int* ifail) ", "Reporting Faults to Parasolid - Updating The Frustrum");
top.display();
//-->
</SCRIPT>
</HEAD>
<BODY bgcolor=#FFFFFF link=#0F3A68 vlink=#878787 alink=#FF7600 leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
</BODY>
</HTML>
