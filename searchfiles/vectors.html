<HTML>
<HEAD>
<LINK REL=STYLESHEET HREF=../ps_doc.css CHARSET=ISO-8859-1 TYPE=text/css>
<SCRIPT LANGUAGE="JavaScript">
<!--

top.note("chapters/fd_chap.018.html#50409799_pgfId-610407", " the coefficient <B>vectors</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-610819", " the coefficient <B>vectors</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-608962", " the twist <B>vectors</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-608396", " the knot <B>vectors</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-310162", " capital letters denote <B>vectors</B> ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311062", "Y are unit <B>vectors</B> such that ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311140", "Y are unit <B>vectors</B> where ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311189", " X and Y are unit <B>vectors</B> such that ", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-311404", "Y(u) are unit <B>vectors</B> such that ", "Functional Description - Geometry");
top.note("chapters/fd_chap.019.html#50409800_pgfId-294812", " be created from B-spline control points and knot <B>vectors</B> using PK_BCURVE_create and PK_BSURF_create respectively. Both rational and", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-299476", " the splined surface, so to clamp this boundary, <B>vectors</B> representing the first derivatives with respect to the", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300706", " <B>vectors</B>, together with the normals of those position <B>vectors</B>.", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-302240", " is the union of all the curve knot <B>vectors</B> by the addition of corresponding knot points on", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-302754", " clamp the surface with a list of derivative <B>vectors</B> ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-302761", " Twist <B>vectors</B> at either of the corners of a clamped", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.022.html#50409803_pgfId-396508", " can be applied to geometry, bodies, assemblies, instances, <B>vectors</B> and faces. ", "Functional Description - Transformations");
top.note("chapters/fd_chap.028.html#50409808_pgfId-380861", " interval of a curve bounded by two position <B>vectors</B> lying on the curve ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-309851", " Do the points represented by the given <B>vectors</B> or parameters lie inside, outside or on the", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-309884", " Tests whether two <B>vectors</B> are equal within the current session precision. ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-309892", " Tests whether two <B>vectors</B> are parallel within the current session angle precision.", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310448", " 27.6.12 Finding position <B>vectors</B> along a curve ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310449", " You can find position <B>vectors</B> along a curve subject to measurements in 3-space", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310458", " to the distance along the curve. See Finding <B>vectors</B> using distance along the curve for more information.", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310465", " a plane orthogonal to the chord. See Finding <B>vectors</B> using distance along the chord for more information.", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310472", " ratio of distances along the curve. See Finding <B>vectors</B> using the ratio of distances along the curve", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310479", " chord as measured using a ratio. See Finding <B>vectors</B> using ratio of distances along chord length for", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310486", " the supplied two chords ratio measurement. See Finding <B>vectors</B> using ratios of two chords for more information.", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310492", " 27.6.12.1 Finding <B>vectors</B> using distance along the curve ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310528", " Figure 27-6 Finding <B>vectors</B> using distance along the curve ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310534", " 27.6.12.2 Finding <B>vectors</B> using distance along the chord ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310570", " Figure 27-7 Finding <B>vectors</B> using distance along the chord ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310574", " is used as an input measurement, multiple position <B>vectors</B> are returned once they lie on the curve", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310576", " 27.6.12.3 Finding <B>vectors</B> using the ratio of distances along the curve", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310612", " Figure 27-8 Finding <B>vectors</B> using the ratio of distances along the curve", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310618", " 27.6.12.4 Finding <B>vectors</B> using ratio of distances along chord length ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310654", " Figure 27-9 Finding <B>vectors</B> using ratio of distances along chord length ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310655", " length B as an input measurement, multiple position <B>vectors</B> are returned once they lie on the curve", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310660", " 27.6.12.5 Finding <B>vectors</B> using ratios of two chords ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310696", " Figure 27-10 Finding <B>vectors</B> using ratio of two chords ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310697", " two chords as an input measurement, all position <B>vectors</B> that lie on the curve between the start", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310738", " 27.6.13 Finding position <B>vectors</B> along a surface ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-579514", " You can find the position <B>vectors</B> on a given surface using PK_SURF_find_vectors . This", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-593417", " Figure 27-11 Finding position <B>vectors</B> along a curved surface ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-575591", " For more information, see Section 27.6.12, Finding position <B>vectors</B> along a curve . Default: PK_measure_chord_ratio_c . ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.030.html#50409810_pgfId-413908", " you to calculate distances between an array of <B>vectors</B> and either a single topology or a single", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.042.html#50409824_pgfId-534251", " You can supply separate pairs of tangent <B>vectors</B> and vertices for each vertex you want to", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295984", " Pairs of tangent <B>vectors</B> and vertices on the profile adjacent to the", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-295986", " of the adjacent profile, and the remaining tangent <B>vectors</B> are applied in order along the adjacent profile.", "Functional Description - Lofting");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394075", " An optional array of help points (<B>vectors</B>) which, when combined with the corresponding face in", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394238", " An array of <B>vectors</B>, which when combined with an appropriate topological entity", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.077.html#50409864_pgfId-603495", " option), lets you specify a list of <B>vectors</B> along the blend chain at which to apply", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-603672", " blend, you should therefore specify at least two <B>vectors</B> in ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-604783", " in which case you can just add additional <B>vectors</B> to the ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298446", " case of overlap limits, the value of these <B>vectors</B> is ignored, but they must be present so", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.082.html#50409869_pgfId-305565", " an array of <B>vectors</B> associated with the fault ", "Functional Description - Interpreting Face-Face Blending Error Codes");
top.note("chapters/fd_chap.084.html#50409872_pgfId-311823", " so that they match one-to-one with those position <B>vectors</B>. Such models will always be watertight (i.e.there are", "Functional Description - Overview Of Convergent Modeling");
top.note("chapters/fd_chap.085.html#50409873_pgfId-509671", " Imprint an array of <B>vectors</B> on to a mesh ", "Functional Description - Facet Model Structure");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343025", " option takes an array of position <B>vectors</B>, and for each position vector specified, PK_MESH_find_laminar_mfins returns", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.093.html#50409882_pgfId-310247", " outputs position <B>vectors</B> along a curve ", "Functional Description - Exporting Data");
top.note("chapters/fd_chap.109.html#50409900_pgfId-313209", " option. This takes an array of unit <B>vectors</B>, each unit vector defining a different view direction.", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.111.html#50409902_pgfId-297837", " Face normal values are returned as normalized <B>vectors</B>, pointing away from the originating face. ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-519356", " singularity, the principal directions are returned as zero <B>vectors</B> and the principal curvatures are returned as zero.", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294775", "rotation matrix may be considered as the column <B>vectors</B>: ", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287059", " B.2.2 Knot <B>vectors</B> ", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-324677", "(degree+1) knots higher. The control <B>vectors</B> are the coefficients applied to these basis functions", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287396", " is segmented, and for B-spline surfaces the knot <B>vectors</B> control how a surface is divided into patches.", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287402", " Note: Both knot <B>vectors</B> must have coincident end knots for the surface", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275422", " When the supplied curves have different knot <B>vectors</B>, amalgamation of the curves will create the same", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275426", " The largest angle allowed between two direction <B>vectors</B> that Parasolid regards as parallel. ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275427", " When Parasolid compares two direction <B>vectors</B> they are considered to be parallel if the", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275841", " It is represented by an array of position <B>vectors</B> and values representing its degree, end and tangency", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-204836", " comparing <B>vectors</B> 323 ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-205842", " <B>vectors</B> 323 ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-207626", " knot <B>vectors</B> 1666 ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.130.html#50409969_pgfId-210545", " <B>vectors</B> ", "Functional Description - ZGlossary");
top.note("chapters/ov_chap.08.html#50442268_pgfId-377100", " (in the form of control points and knot <B>vectors</B>), and Parasolid can create B-curves and B-surfaces directly", "Overview of Parasolid - B-Spline Curves and Surfaces");
top.note("chapters/p2_chap.03.html#sec_b_1_1", " PK_PARAM_twist_no_c 18530 twist <B>vectors</B> not supplied ", "PK Reference - PK token Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.05.html#sec_d_1_app", " the <B>vectors</B> because there was a \"cluster\" of <B>vectors</B> which could not be resolved into a single", "PK Reference - PK token Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.07.html#sec_f_1_2", " PK_ERROR_coincident_points 977 PK_PLINE_create repeated consecutive position <B>vectors</B>", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_4", " PK_ERROR_vectors_are_parallel 5024 PK_VECTOR_perpendicular If the <B>vectors</B> are parallel", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.09.html#sec_h_1_1", " PK_ERROR_bad_knots 978 PK_BCURVE_make_bsurf_lofted_o_t curve knot <B>vectors</B> are incompatible,", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_2", " PK_ERROR_coincident_points 977 PK_PLINE_create repeated consecutive position <B>vectors</B>", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_4", " PK_ERROR_vectors_are_parallel 5024 PK_VECTOR_perpendicular If the <B>vectors</B> are parallel", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.10.html#sec_i_1_1", " PK_BCURVE_make_bsurf_lofted_o_t 978 PK_ERROR_bad_knots curve knot <B>vectors</B> are incompatible,", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_3", " PK_PLINE_create 977 PK_ERROR_coincident_points repeated consecutive position <B>vectors</B>", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_4", " PK_VECTOR_perpendicular 5024 PK_ERROR_vectors_are_parallel If the <B>vectors</B> are parallel", "PK Reference - PK Error Codes (Functional)");
top.note("headers/pk_attrib_ask_named_vectors.html#declaration", " int *const n_vectors, --- number of <B>vectors</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_named_vectors");
top.note("headers/pk_attrib_ask_named_vectors.html#description", " This function returns the array of <B>vectors</B> from field field_name ", "PK Reference - PK_ATTRIB_ask_named_vectors");
top.note("headers/pk_attrib_ask_named_vectors.html#documentation", "The output array <B>vectors</B> is optional. If it is set to NULL,", "PK Reference - PK_ATTRIB_ask_named_vectors");
top.note("headers/pk_attrib_ask_vectors.html#declaration", " int *const n_vectors, --- number of <B>vectors</B> (>= 0)", "PK Reference - PK_ATTRIB_ask_vectors");
top.note("headers/pk_attrib_ask_vectors.html#description", " This function returns the array of <B>vectors</B> from field field_no ", "PK Reference - PK_ATTRIB_ask_vectors");
top.note("headers/pk_attrib_ask_vectors.html#documentation", "The output array <B>vectors</B> is optional. If it is set to NULL,", "PK Reference - PK_ATTRIB_ask_vectors");
top.note("headers/pk_attrib_field_values_t.html#declaration", " const PK_VECTOR_t *<B>vectors</B>;", "PK Reference - PK_ATTRIB_field_values_t");
top.note("headers/pk_attrib_set_named_vectors.html#declaration", "int n_vectors, --- number of <B>vectors</B> (>=0)", "PK Reference - PK_ATTRIB_set_named_vectors");
top.note("headers/pk_attrib_set_named_vectors.html#description", " This function copies <B>vectors</B> into field field_name of the given", "PK Reference - PK_ATTRIB_set_named_vectors");
top.note("headers/pk_attrib_set_vectors.html#declaration", "int n_vectors, --- number of <B>vectors</B> (>=0)", "PK Reference - PK_ATTRIB_set_vectors");
top.note("headers/pk_attrib_set_vectors.html#description", " This function copies <B>vectors</B> into field number field_no of the given", "PK Reference - PK_ATTRIB_set_vectors");
top.note("headers/pk_bcurve_make_bsurf_lofted.html#documentation", " PK_PARAM_end_clamped_vector_c derivative <B>vectors</B> are supplied across the", "PK Reference - PK_BCURVE_make_bsurf_lofted");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#declaration", " PK_LOGICAL_t amalgamate; --- whether to amalgamate knot <B>vectors</B>", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#errors", " PK_ERROR_bad_knots curve knot <B>vectors</B> are incompatible,", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#documentation", " this is set to PK_LOGICAL_true then the knot <B>vectors</B>", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_make_matched.html#errors", " PK_ERROR_bad_knots invalid knot <B>vectors</B>", "PK Reference - PK_BCURVE_make_matched");
top.note("headers/pk_bcurve_piecewise_sf_t.html#declaration", " double *coeffs; --- Coefficient <B>vectors</B>", "PK Reference - PK_BCURVE_piecewise_sf_t");
top.note("headers/pk_bcurve_piecewise_sf_t.html#documentation", "coeffs Contains ( degree +1)* n_segments <B>vectors</B> of dimension dim .", "PK Reference - PK_BCURVE_piecewise_sf_t");
top.note("headers/pk_bcurve_splinewise_sf_t.html#errors", " degree < 2 and supplied clamping <B>vectors</B>", "PK Reference - PK_BCURVE_splinewise_sf_t");
top.note("headers/pk_bcurve_splinewise_sf_t.html#documentation", " magnitude is significant, and supplying <B>vectors</B> which are too", "PK Reference - PK_BCURVE_splinewise_sf_t");
top.note("headers/pk_blendsf_sf_t.html#documentation", " - X(u) and Y(u) are unit <B>vectors</B> such that dC(u)/du, X(u) and Y(u) form", "PK Reference - PK_BLENDSF_sf_t");
top.note("headers/pk_body_create_sheet_planar.html#declaration", " --- <B>vectors</B>", "PK Reference - PK_BODY_create_sheet_planar");
top.note("headers/pk_body_create_sheet_planar.html#documentation", "position <B>vectors</B> given clockwise (when viewed in the direction of", "PK Reference - PK_BODY_create_sheet_planar");
top.note("headers/pk_body_create_sheet_planar_o_t.html#documentation", " field is NULL (the default) then all the <B>vectors</B> ", "PK Reference - PK_BODY_create_sheet_planar_o_t");
top.note("headers/pk_body_loft_vector_clamp_t.html#declaration", " int n_tangents; --- number of derivative <B>vectors</B> (0)", "PK Reference - PK_BODY_loft_vector_clamp_t");
top.note("headers/pk_body_loft_vector_clamp_t.html#description", " This structure holds an array of derivative <B>vectors</B> and an optional array", "PK Reference - PK_BODY_loft_vector_clamp_t");
top.note("headers/pk_body_loft_vector_clamp_t.html#documentation", " the tangents do not have to be unit <B>vectors</B>,", "PK Reference - PK_BODY_loft_vector_clamp_t");
top.note("headers/pk_body_pick_topols_o_t.html#documentation", "the unscaled ray, such that the intersect <B>vectors</B> will always lie on ray .", "PK Reference - PK_BODY_pick_topols_o_t");
top.note("headers/pk_boolean_region_select_o_t.html#documentation", " n_help_points The number of help points (<B>vectors</B>) supplied.", "PK Reference - PK_boolean_region_select_o_t");
top.note("headers/pk_boolean_select_topolset_o_t.html#documentation", " help_points Help points (<B>vectors</B>) which, when combined with the", "PK Reference - PK_boolean_select_topolset_o_t");
top.note("headers/pk_bsurf_piecewise_sf_t.html#declaration", " double *coeffs; --- Coefficient <B>vectors</B>", "PK Reference - PK_BSURF_piecewise_sf_t");
top.note("headers/pk_bsurf_piecewise_sf_t.html#documentation", " <B>vectors</B> of dimension dim .", "PK Reference - PK_BSURF_piecewise_sf_t");
top.note("headers/pk_bsurf_splinewise_sf_t.html#documentation", " significant, and supplying <B>vectors</B> which are too large may", "PK Reference - PK_BSURF_splinewise_sf_t");
top.note("headers/pk_curve_find_non_aligned_box.html#documentation", "orthonormal set of three axis <B>vectors</B>, and three doubles giving the width of", "PK Reference - PK_CURVE_find_non_aligned_box");
top.note("headers/pk_curve_find_vector_interval.html#declaration", " PK_INTERVAL_t *const interval --- parameter interval bounded by <B>vectors</B>", "PK Reference - PK_CURVE_find_vector_interval");
top.note("headers/pk_curve_find_vector_interval.html#description", "position <B>vectors</B> lying on the curve.", "PK Reference - PK_CURVE_find_vector_interval");
top.note("headers/pk_curve_find_vector_interval.html#documentation", "The position <B>vectors</B> must lie on the curve within SESSION precision.", "PK Reference - PK_CURVE_find_vector_interval");
top.note("headers/pk_curve_find_vectors.html#description", " This function returns position <B>vectors</B> on the supplied curve given measurements", "PK Reference - PK_CURVE_find_vectors");
top.note("headers/pk_curve_find_vectors.html#documentation", "function will return position <B>vectors</B> on the required part of the curve. The", "PK Reference - PK_CURVE_find_vectors");
top.note("headers/pk_curve_find_vectors_o_t.html#documentation", " allows the caller to control how the position <B>vectors</B>", "PK Reference - PK_CURVE_find_vectors_o_t");
top.note("headers/pk_curve_find_vectors_r_t.html#declaration", " PK_VECTOR_t *<B>vectors</B>;", "PK Reference - PK_CURVE_find_vectors_r_t");
top.note("headers/pk_curve_find_vectors_r_t.html#documentation", " returned in <B>vectors</B> and parms respectively. Only position <B>vectors</B>", "PK Reference - PK_CURVE_find_vectors_r_t");
top.note("headers/pk_curve_intersect_curve.html#declaration", " PK_VECTOR_t **const <B>vectors</B>, --- positions of intersections", "PK Reference - PK_CURVE_intersect_curve");
top.note("headers/pk_curve_intersect_curve.html#documentation", "It returns an array of intersection <B>vectors</B> <B>vectors</B> , arrays of parameters", "PK Reference - PK_CURVE_intersect_curve");
top.note("headers/pk_curve_make_wire_body_2.html#documentation", "of the curve must be periodic (see Knot <B>Vectors</B> ).", "PK Reference - PK_CURVE_make_wire_body_2");
top.note("headers/pk_curve_output_vectors.html#declaration", " int *const n_vectors, --- number of position <B>vectors</B>", "PK Reference - PK_CURVE_output_vectors");
top.note("headers/pk_curve_output_vectors.html#description", " This function outputs position <B>vectors</B> along a curve.", "PK Reference - PK_CURVE_output_vectors");
top.note("headers/pk_curve_output_vectors.html#documentation", "of position <B>vectors</B> is controlled by curve_chord_tol, curve_chord_ang and", "PK Reference - PK_CURVE_output_vectors");
top.note("headers/pk_edge_set_blend_variable.html#documentation", " <B>vectors</B> of the data points on the edge at", "PK Reference - PK_EDGE_set_blend_variable");
top.note("headers/pk_entity_range_vector.html#declaration", "const PK_VECTOR_t <B>vectors</B>[], --- position array", "PK Reference - PK_ENTITY_range_vector");
top.note("headers/pk_entity_range_vector.html#documentation", " of entities entities and the array of positions <B>vectors</B> .", "PK Reference - PK_ENTITY_range_vector");
top.note("headers/pk_entity_range_vector_o_t.html#documentation", " for the positions provided in <B>vectors</B> .", "PK Reference - PK_ENTITY_range_vector_o_t");
top.note("headers/pk_face_contains_vectors.html#declaration", " --- <B>vectors</B>", "PK Reference - PK_FACE_contains_vectors");
top.note("headers/pk_face_contains_vectors.html#description", " determines whether the points represented by the given <B>vectors</B>", "PK Reference - PK_FACE_contains_vectors");
top.note("headers/pk_face_contains_vectors.html#documentation", " reasons, it is assumed by default that position <B>vectors</B> lie", "PK Reference - PK_FACE_contains_vectors");
top.note("headers/pk_face_contains_vectors_o_t.html#declaration", " PK_VECTOR_t *<B>vectors</B>; --- xyz positions (NULL)", "PK Reference - PK_FACE_contains_vectors_o_t");
top.note("headers/pk_face_contains_vectors_o_t.html#documentation", "the face, or as position <B>vectors</B> in 3D space, or both.", "PK Reference - PK_FACE_contains_vectors_o_t");
top.note("headers/pk_face_intersect_curve.html#declaration", " PK_VECTOR_t **const <B>vectors</B>, --- positions of intersections", "PK Reference - PK_FACE_intersect_curve");
top.note("headers/pk_face_intersect_curve.html#documentation", " face. It returns an array of intersection <B>vectors</B> <B>vectors</B> ,", "PK Reference - PK_FACE_intersect_curve");
top.note("headers/pk_face_intersect_face.html#declaration", " PK_VECTOR_t **const <B>vectors</B>, --- posns of point intersections", "PK Reference - PK_FACE_intersect_face");
top.note("headers/pk_face_intersect_face.html#documentation", " face_1 and face_2 ), returning intersection points ( <B>vectors</B> )", "PK Reference - PK_FACE_intersect_face");
top.note("headers/pk_face_intersect_surf.html#declaration", " PK_VECTOR_t **const <B>vectors</B>, --- posns of point intersections", "PK Reference - PK_FACE_intersect_surf");
top.note("headers/pk_face_intersect_surf.html#documentation", " surface ( surface ), returning intersection points ( <B>vectors</B> )", "PK Reference - PK_FACE_intersect_surf");
top.note("headers/pk_face_make_3_face_blend_r_t.html#documentation", " n_points the number of <B>vectors</B> returned", "PK Reference - PK_FACE_make_3_face_blend_r_t");
top.note("headers/pk_fxf_error_t.html#documentation", " n_points the number of <B>vectors</B> associated with the fault", "PK Reference - PK_fxf_error_t");
top.note("headers/pk_geom_range_vector_many.html#declaration", "const PK_VECTOR_t <B>vectors</B>[], --- position array", "PK Reference - PK_GEOM_range_vector_many");
top.note("headers/pk_geom_range_vector_many.html#documentation", " separation between the geom and one of the <B>vectors</B> ", "PK Reference - PK_GEOM_range_vector_many");
top.note("headers/pk_geom_range_vector_many_o_t.html#documentation", " for the positions provided in <B>vectors</B> .", "PK Reference - PK_GEOM_range_vector_many_o_t");
top.note("headers/pk_goopsg_f_t.html#documentation", " space box of the body: given as two <B>vectors</B>:", "PK Reference - PK_GOOPSG_f_t");
top.note("headers/pk_gosgmt_f_t.html#documentation", " geom holds ngeom <B>vectors</B> of dimension 3. These are the", "PK Reference - PK_GOSGMT_f_t");
top.note("headers/pk_imprint_vecs_t.html#documentation", "A status value to be returned when imprinting <B>vectors</B> on a mesh.", "PK Reference - PK_imprint_vecs_t");
top.note("headers/pk_mesh_imprint_vectors.html#declaration", "int n_vectors, --- number of <B>vectors</B>", "PK Reference - PK_MESH_imprint_vectors");
top.note("headers/pk_mesh_imprint_vectors.html#description", " This function imprints an array of <B>vectors</B> onto a mesh.", "PK Reference - PK_MESH_imprint_vectors");
top.note("headers/pk_mesh_imprint_vectors.html#documentation", " copy of the given mesh with the given <B>vectors</B> ", "PK Reference - PK_MESH_imprint_vectors");
top.note("headers/pk_mesh_imprint_vectors_o_t.html#declaration", " PK_UV_t *parameters; --- UV parameter of <B>vectors</B> on the", "PK Reference - PK_MESH_imprint_vectors_o_t");
top.note("headers/pk_mesh_imprint_vectors_o_t.html#documentation", " to the array of <B>vectors</B> . Supplying parameters may", "PK Reference - PK_MESH_imprint_vectors_o_t");
top.note("headers/pk_mesh_imprint_vectors_r_t.html#declaration", "int n_error_indices; --- number of <B>vectors</B> not on the", "PK Reference - PK_MESH_imprint_vectors_r_t");
top.note("headers/pk_mesh_imprint_vectors_r_t.html#description", " This structure is returned after attempting to imprint <B>vectors</B> on a mesh. It", "PK Reference - PK_MESH_imprint_vectors_r_t");
top.note("headers/pk_mesh_imprint_vectors_r_t.html#documentation", " status : Token indicating whether the <B>vectors</B> were successfully", "PK Reference - PK_MESH_imprint_vectors_r_t");
top.note("headers/pk_mesh_make_surf_trimmed_o_t.html#declaration", " --- when fitting to the normal <B>vectors</B>", "PK Reference - PK_MESH_make_surf_trimmed_o_t");
top.note("headers/pk_mfacet_ask_positions.html#description", " This function returns the position <B>vectors</B> at the mvertices of mfacet .", "PK Reference - PK_MFACET_ask_positions");
top.note("headers/pk_nabox_sf_t.html#documentation", "axes (normalised direction <B>vectors</B>) and a set of x, y, z intervals.", "PK Reference - PK_NABOX_sf_t");
top.note("headers/pk_param_twist_t.html#documentation", "This datatype is used to specify whether twist <B>vectors</B> are supplied", "PK Reference - PK_PARAM_twist_t");
top.note("headers/pk_pline_create.html#errors", " PK_ERROR_coincident_points repeated consecutive position <B>vectors</B>", "PK Reference - PK_PLINE_create");
top.note("headers/pk_pline_sf_t.html#documentation", " positions This is an array of <B>vectors</B> that contains the positions of", "PK Reference - PK_PLINE_sf_t");
top.note("headers/pk_report_3_t.html#documentation", "- an array of <B>vectors</B> specifying a 3-space location for each discontinuity.", "PK Reference - PK_REPORT_3_t");
top.note("headers/pk_skewbox_sf_t.html#documentation", "non-orthogonal axes (normalised direction <B>vectors</B>) and a set of i, j, k", "PK Reference - PK_SKEWBOX_sf_t");
top.note("headers/pk_surf_eval.html#documentation", "contains 12 <B>vectors</B>:-", "PK Reference - PK_SURF_eval");
top.note("headers/pk_surf_find_min_radii.html#declaration", " PK_VECTOR_t positions[2], --- position <B>vectors</B> where minima occur", "PK Reference - PK_SURF_find_min_radii");
top.note("headers/pk_surf_find_non_aligned_box.html#documentation", "orthonormal set of three axis <B>vectors</B>, and three doubles giving the width of", "PK Reference - PK_SURF_find_non_aligned_box");
top.note("headers/pk_surf_find_vectors.html#description", " The function will return position <B>vectors</B> on the supplied surface between the", "PK Reference - PK_SURF_find_vectors");
top.note("headers/pk_surf_find_vectors.html#documentation", "The returned position <B>vectors</B> satisfy (up to tolerance ) the conditions", "PK Reference - PK_SURF_find_vectors");
top.note("headers/pk_surf_find_vectors_o_t.html#documentation", " allows the caller to control how the position <B>vectors</B>", "PK Reference - PK_SURF_find_vectors_o_t");
top.note("headers/pk_surf_find_vectors_r_t.html#declaration", " PK_VECTOR_t *<B>vectors</B>;", "PK Reference - PK_SURF_find_vectors_r_t");
top.note("headers/pk_surf_find_vectors_r_t.html#documentation", " parameters are returned in <B>vectors</B> and uv_parms respectively.", "PK Reference - PK_SURF_find_vectors_r_t");
top.note("headers/pk_surf_intersect_curve.html#declaration", " PK_VECTOR_t **const <B>vectors</B>, --- positions of intersections", "PK Reference - PK_SURF_intersect_curve");
top.note("headers/pk_surf_intersect_curve.html#documentation", " n_vectors is returned as zero and <B>vectors</B> is returned as null.", "PK Reference - PK_SURF_intersect_curve");
top.note("headers/pk_surf_intersect_surf.html#declaration", " PK_VECTOR_t **const <B>vectors</B>, --- posns of point intersections", "PK Reference - PK_SURF_intersect_surf");
top.note("headers/pk_surf_intersect_surf.html#documentation", " surf_1 and surf_2 ), returning intersection points ( <B>vectors</B> )", "PK Reference - PK_SURF_intersect_surf");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#documentation", " rotation submatrix R defines an orthonormal set of <B>vectors</B> H, V, D", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#documentation", " rotation submatrix R defines an orthonormal set of <B>vectors</B> H, V, D", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_transf_create_view.html#documentation", "axis, these <B>vectors</B> will be parallel to the other two principal", "PK Reference - PK_TRANSF_create_view");
top.note("headers/pk_transf_sf_t.html#documentation", " matrix (M) operates as a post-multiplier on row <B>vectors</B> containing", "PK Reference - PK_TRANSF_sf_t");
top.note("headers/pk_vector_is_equal.html#description", " This function tests whether the two <B>vectors</B> are equal within the current", "PK Reference - PK_VECTOR_is_equal");
top.note("headers/pk_vector_is_parallel.html#description", " This function tests whether the two <B>vectors</B> are parallel within the", "PK Reference - PK_VECTOR_is_parallel");
top.note("headers/pk_vector_is_parallel.html#documentation", "The two <B>vectors</B> v1 , v2 are parallel if their cross", "PK Reference - PK_VECTOR_is_parallel");
top.note("headers/pk_vector_make_view_transf.html#documentation", "axis, these <B>vectors</B> will be parallel to the other two principal", "PK Reference - PK_VECTOR_make_view_transf");
top.note("headers/pk_vector_perpendicular.html#errors", "PK_ERROR_vectors_are_parallel If the <B>vectors</B> are parallel", "PK Reference - PK_VECTOR_perpendicular");
top.note("headers/pk_vector_perpendicular.html#documentation", "This function accepts two <B>vectors</B>, the first of which must be normalised, and", "PK Reference - PK_VECTOR_perpendicular");
top.note("chapters/di_chap.03.html#50511935_pgfId-274206", " round brackets enclose a list of doubles (e.g. <B>vectors</B>) ", "Downward Interfaces - File Handling");
top.note("chapters/di_chap.05.html#50511937_pgfId-274533", " ngeom = the number of 3D <B>vectors</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275037", " holds the visibility transition points, i.e. the <B>vectors</B> in model space where the edge changes visibility", "Downward Interfaces - Graphical Output");
top.note("chapters/kd_chap.04.html#50475012_pgfId-273861", " a point and a direction are recorded. These <B>vectors</B> are written to the journal file and are", "KID Manual - Object-Oriented KID");
top.note("chapters/kd_chap.05.html#50475010_pgfId-281321", " ( <B>vectors</B> . (( 0 0 0 ) ( 0", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.05.html#50475010_pgfId-280882", " > (setq *<B>vectors</B> ((0 0 0)(10 0 0)(0 10 0)))", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.05.html#50475010_pgfId-280883", " (cons <B>vectors</B> ((0 0 0)(10 0 0)(0 10 0)))", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.05.html#50475010_pgfId-280904", " (list <B>vectors</B> ((0 0 0)(10 0 0)(0 10 0)))", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.05.html#50475010_pgfId-280905", " (cons <B>vectors</B> ((0 0 0)(10 0 0)(0 10 0)))", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.06.html#50475013_pgfId-273948", " Simple geometric properties such as points, <B>vectors</B>, curves and surfaces can also be created from", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.10.html#50475015_pgfId-273952", " The function box returns two <B>vectors</B> defining the extremes of a minimal rectangular box", "KID Manual - Enquiries");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274727", " array should be considered as an array of <B>vectors</B> each of which is stored in 3 successive", "FG Manual - Implementing an FG System");
top.note("chapters/wn_chap.02.html#50466820_pgfId-7753940", " when calculating distances between topology and arrays of <B>vectors</B> ", "What's New in Parasolid - What&#8217;s New in Parasolid V36.0");
top.note("chapters/wn_chap.02.html#50466820_pgfId-7753876", " could only supply a single geometry with multiple <B>vectors</B>. ", "What's New in Parasolid - What&#8217;s New in Parasolid V36.0");
top.display();
//-->
</SCRIPT>
</HEAD>
<BODY bgcolor=#FFFFFF link=#0F3A68 vlink=#878787 alink=#FF7600 leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
</BODY>
</HTML>
