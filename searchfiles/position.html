<HTML>
<HEAD>
<LINK REL=STYLESHEET HREF=../ps_doc.css CHARSET=ISO-8859-1 TYPE=text/css>
<SCRIPT LANGUAGE="JavaScript">
<!--

top.note("chapters/fd_chap.011.html#50409791_pgfId-312308", "<B>position</B> ", "Functional Description - Tracking And Labelling");
top.note("chapters/fd_chap.016.html#50409797_pgfId-295034", " The <B>position</B> of the new body is based on the", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-295047", " is part of a model may have any <B>position</B> and orientation in the world coordinate system. PK_CIRCLE_ask", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-295050", "location - <B>position</B> of local coordinate system origin in world coordinates", "Functional Description - Body Types");
top.note("chapters/fd_chap.016.html#50409797_pgfId-295328", " Figure 15-6 Entity <B>position</B> after sweeping or partially spinning a sheet body", "Functional Description - Body Types");
top.note("chapters/fd_chap.017.html#50409798_pgfId-310994", " SP-curves attached to the edge, and computes the <B>position</B> of the new curve by finding the intersection", "Functional Description - Session And Local Precision");
top.note("chapters/fd_chap.018.html#50409799_pgfId-309981", " a cartesian <B>position</B>. PK_ERROR_bad_position is returned if the <B>position</B> is outside the size box. See PK_POINT_sf_t for", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-500769", " at the uv parameter gives the corresponding 3-space <B>position</B> on the SP-curve. See Section 92.1.5, Concept of", "Functional Description - Geometry");
top.note("chapters/fd_chap.018.html#50409799_pgfId-299494", " angle about the axis, measured from the initial <B>position</B> of the profile curve. ", "Functional Description - Geometry");
top.note("chapters/fd_chap.019.html#50409800_pgfId-296088", " (except that the curve or surface must be <B>position</B> (G0) continuous across adjacent segments or patches). The", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-298584", " In addition to controlling parameter information at each <B>position</B>, you can define the parameter range for the", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-298720", " curve lies further along that axis, i.e. the <B>position</B> is the local extremum of the curve. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300706", " <B>position</B> vectors, together with the normals of those <B>position</B>", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300717", " <B>position</B> constraints for PK_BSURF_create_constrained . Each <B>position</B> in this array denotes a point in the", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300737", " should be used for the first <B>position</B> supplied in ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300743", " The B-surface matches <B>position</B> constraints to within the supplied ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-302775", " up a badly-parameterised curve without changing the curves <B>position</B> in 3-space, as shown in ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-302916", " Note: A <B>position</B> on a surface where any surface tangent makes", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-314515", " functions, only the curve and surface parameterisation is changed. <B>Position</B> and shape is preserved. ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.021.html#50409802_pgfId-526217", " will be relocated to this <B>position</B> and, through a mapping of the ", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-336217", " Queries the <B>position</B> of the given lball ", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.022.html#50409803_pgfId-411584", " example in factory design when deciding where to <B>position</B> objects (such as machinery) around the factory. Each", "Functional Description - Transformations");
top.note("chapters/fd_chap.024.html#50409622_pgfId-457964", " associating them with a large transformation that may <B>position</B> them outside of the size box. See Section", "Functional Description - Distant and Multi-scale Modelling");
top.note("chapters/fd_chap.024.html#50409622_pgfId-476057", " is in factory design when deciding where to <B>position</B> objects (such as machinery) around the factory. Each", "Functional Description - Distant and Multi-scale Modelling");
top.note("chapters/fd_chap.024.html#50409622_pgfId-478141", " in this terrain data where it needs to <B>position</B> a bridge. ", "Functional Description - Distant and Multi-scale Modelling");
top.note("chapters/fd_chap.024.html#50409622_pgfId-478188", " techniques to manoeuvre the bridge into the correct <B>position</B> creating a transform at standard scale. ", "Functional Description - Distant and Multi-scale Modelling");
top.note("chapters/fd_chap.026.html#50409768_pgfId-332434", " the vector (0.1, 0.0, 0.0) to the variable <B>position</B>, which should also be a vector. ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386218", " <B>position</B> + c_offset_dist * pkx_normal(c_surf, sbx_projection) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386264", " <B>position</B> would be a vector variable defined by the", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386721", " ( PK_ENTITY_t entity, vector <B>position</B>) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-376260", " ( PK_ENTITY_t entity, vector <B>position</B>, bool ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-381801", " is set to false (the default), then the <B>position</B> is a three space point, which must lie", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386700", " ( PK_GEOM_t geom, vector <B>position</B>) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-386702", " are returned as the vector (u, v, 0).The <B>position</B> must lie on the curve or surface. ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-388410", " ( PK_ENTITY_t entity, vector <B>position</B>, bool ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-388452", " an edge, fin or curve, at the supplied <B>position</B> The entity may be an edge, fin or", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-379182", " <B>position</B> + 0.1*pkx_normal(face, <B>position</B>) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-379184", " the direction of the face normal at the <B>position</B> ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-379481", " <B>position</B> + c_offset_dist * pkx_normal(c_s0, sbx_projection) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-379485", " pkx_closest_position(c_s0, <B>position</B>) ", "Functional Description - Expressions");
top.note("chapters/fd_chap.026.html#50409768_pgfId-378074", " the closest point on the surface to the <B>position</B>. In this example, c_s0 and c_offset_dist are supplied", "Functional Description - Expressions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-306679", " uv parameters that represent the location of the <B>position</B> in the surface of the face, The returned", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-380764", " values for these two arguments, together with the <B>position</B> of the parameter pair, determines the direction from", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-380861", " parameter interval of a curve bounded by two <B>position</B> vectors lying on the curve ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310084", " A 3-space <B>position</B> where the self-intersection occurs. ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310094", " more parametric intervals or regions occupy the same <B>position</B> in space. ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310106", " A 3-space <B>position</B> where the degeneracy occurs, if it occupies a", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310111", " A 3-space <B>position</B>, or else the middle point if the degeneracy", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310448", " 27.6.12 Finding <B>position</B> vectors along a curve ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310449", " You can find <B>position</B> vectors along a curve subject to measurements in", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310458", " A <B>position</B> vector corresponding to the distance along the curve.", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310465", " All <B>position</B> vectors that lie at the intersections of the", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310472", " A <B>position</B> vector that corresponds to the ratio of distances", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310479", " All <B>position</B> vectors that lie at the intersections of the", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310486", " All <B>position</B> vectors on the curve that satisfies the supplied", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310529", " along the curve as an input measurement, one <B>position</B> vector is returned as shown in ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310574", " A is used as an input measurement, multiple <B>position</B> vectors are returned once they lie on the", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310613", " curve is used as an input measurement, one <B>position</B> vector is returned as shown in ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310655", " chord length B as an input measurement, multiple <B>position</B> vectors are returned once they lie on the", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310697", " of two chords as an input measurement, all <B>position</B> vectors that lie on the curve between the", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-310738", " 27.6.13 Finding <B>position</B> vectors along a surface ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-579514", " You can find the <B>position</B> vectors on a given surface using PK_SURF_find_vectors .", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-593417", " Figure 27-11 Finding <B>position</B> vectors along a curved surface ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-575591", " represent. For more information, see Section 27.6.12, Finding <B>position</B> vectors along a curve . Default: PK_measure_chord_ratio_c .", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-576638", " Whether a <B>position</B> vector is supplied to help find the path", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-581605", " A <B>position</B> vector to help find the path curve. ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.029.html#50409809_pgfId-294750", " density function at a given <B>position</B> with the <B>position</B> vector itself over the whole amount being considered.", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.029.html#50409809_pgfId-295328", " density function at a given <B>position</B> with the <B>position</B> vector itself over the whole volume being considered.", "Functional Description - Mass Properties");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296601", " any entity or group of entities and a <B>position</B> or array of positions. ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296928", " functions to find the minimum distance between a <B>position</B> or array of positions and an entity or", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-296946", " an array of positions, one distance for each geometry/<B>position</B> pairing. ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297054", " maximum distance between a topological entity and a <B>position</B>, as described in Section 29.6, Local minimum distance", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297061", " that you believe is close to an end <B>position</B> of the minimum or maximum distance on that", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-414137", " provide an array of estimates, one for each <B>position</B> supplied to the function. The option name is", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297139", " PK_range_guess_vector_c : a <B>position</B> ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297150", " Note: You should not supply both parameter and <B>position</B> estimates within a single PK_range_guess_t structure. ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297175", " <B>position</B> on the single entity received by the vector", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297177", " The details for each end <B>position</B> are contained in a PK_range_end_t structure. A description", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-377967", " for each minimum distance calculated (and hence each <B>position</B> received by the function). Consequently, the returned fields", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-378244", " The details for each end <B>position</B> that describes where the ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297217", " minimum distance between a geometrical entity and a <B>position</B> ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.030.html#50409810_pgfId-297224", " maximum distance between a topological entity and a <B>position</B> ", "Functional Description - Calculating Minimum And Maximum Distance ");
top.note("chapters/fd_chap.032.html#50409812_pgfId-295508", " edges that share common vertices touch at a <B>position</B> other than at those vertices. ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-296055", "<B>position</B> ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-296108", " <B>Position</B> vector field out of range ", "Functional Description - Checking");
top.note("chapters/fd_chap.032.html#50409812_pgfId-296111", " A <B>position</B> vector field is out of range (usually outside", "Functional Description - Checking");
top.note("chapters/fd_chap.038.html#50409820_pgfId-532273", " For PK_BODY_make_persp_outline , you must specify an eye <B>position</B> to use for the outlines as shown in", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.040.html#50409822_pgfId-294898", " You can also control the size and <B>position</B> of a single profile as it moves along", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-297381", " You can control the size or <B>position</B> of a single profile as it moves along", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-297394", " Describes how the size or <B>position</B> of the profile should vary as it moves", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-297525", " Vary the <B>position</B> of the profile with respect to the path", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-300342", " different trimmed results are possible, depending on the <B>position</B> of the ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.041.html#50409823_pgfId-299946", " the resultant body can vary depending on the <B>position</B> of the ", "Functional Description - Sweeping Tool Bodies Along a Path");
top.note("chapters/fd_chap.041.html#50409823_pgfId-300198", " path and will be swept from its initial <B>position</B> if the following conditions are met: ", "Functional Description - Sweeping Tool Bodies Along a Path");
top.note("chapters/fd_chap.042.html#50409824_pgfId-534254", " controls the <B>position</B> of each clamp. If set to NULL, all", "Functional Description - Lofting");
top.note("chapters/fd_chap.043.html#50409825_pgfId-351459", " The view direction used to calculate the <B>position</B> of the imprinted curves. ", "Functional Description - Shadow Curves");
top.note("chapters/fd_chap.044.html#50409826_pgfId-297639", " of an emboss feature is determined by the <B>position</B> of the end cap. ", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.048.html#50409831_pgfId-419069", " sheet boundaries are shared. Parasolid is in no <B>position</B> to judge the relative merits of two equally", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.049.html#50409832_pgfId-358705", " parameter that describes the exact <B>position</B> of the resulting neutral sheets between the ", "Functional Description - Mid-Surface Generation");
top.note("chapters/fd_chap.052.html#50409836_pgfId-1099563", " specifies the <B>position</B> for the source of rays needed to define", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.056.html#50409840_pgfId-294769", " (either translations or rotations). Each transform determines the <B>position</B> of one instance that is the result of", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.057.html#50409620_pgfId-524364", " option takes effect at the <B>position</B> where the clip entity intersects the axis of", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-633463", " clipping operation are merged with other lballs whose <B>position</B>, radius and ", "Functional Description - Sectioning");
top.note("chapters/fd_chap.064.html#50409850_pgfId-327949", " from each changed face, or from the resultant <B>position</B> of an optional supplied reference face. This operation", "Functional Description -  Overview of Editing Models");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296952", " a through-hole is placed at the end whose <B>position</B> has the largest Z component. For horizontal though", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-368308", " The origin (i.e. the <B>position</B> and orientation) of the hole detail described as", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.068.html#50409854_pgfId-1394602", " to a single reference entity in the corresponding <B>position</B> in the ", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.068.html#50409854_pgfId-1395229", " <B>position</B> ", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.068.html#50409854_pgfId-296760", "<B>position</B> ", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.068.html#50409854_pgfId-296773", " that are orthogonal to the draw direction. The <B>position</B> of the laminar edges of the tapered face", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.068.html#50409854_pgfId-297047", " Figure 67-19 Controlling the <B>position</B> of laminar edges in tapered faces ", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.071.html#50409857_pgfId-363103", " of the patch using an array of point (<B>position</B>) data. ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-363105", " Section 70.3.6, Using point (<B>position</B>) data to control the shape of the patch", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-363173", " 70.3.6 Using point (<B>position</B>) data to control the shape of the patch", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.071.html#50409857_pgfId-296050", " patch that contains a sharp point at the <B>position</B> of the supporting body. ", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.074.html#50409860_pgfId-302161", " from each changed face, or from the resultant <B>position</B> of an optional supplied reference face. A positive", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-302585", " ), then this is measured from the resultant <B>position</B> of the supplied reference face. ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-677594", " to a single reference entity in the corresponding <B>position</B> in the ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-303326", " <B>position</B> ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-303328", " An input <B>position</B> on the specified ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-303337", " available, the corresponding surface parameters for the supplied <B>position</B> may be supplied in ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-303386", " returns the corresponding deformed <B>position</B> using the ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-316928", " this face, rather than relative to the current <B>position</B> of the offset face, thereby creating a dependent", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-304015", " <B>position</B> ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-304019", " Control the <B>position</B> of laminar edges on tapered faces. See Section", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.077.html#50409864_pgfId-1054646", " The shape of the blend is linear with <B>position</B> continuity. ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-756635", " Note: The <B>position</B> of user-specified ranges may be automatically adjusted to", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-618517", " be used twice in this case (i.e. a <B>position</B> may be repeated) so long as the following", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-713846", " the blend spine and contact points at a <B>position</B> on the blend chain ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-603347", " list of blend rho parameters, one for each <B>position</B> in the blend chain specified in ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-738895", " Parasolid choosing blend parameters at a G1 discontinuous <B>position</B> ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-1193445", " . The effect of these arguments on the <B>position</B> and size of the chamfer is shown in", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298442", " limits, the point does not define the starting <B>position</B> of the limit: the blend automatically stops short", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.079.html#50409866_pgfId-468239", " succeed, and blends which fail because of the <B>position</B> of the master faces. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-298276", " are orthogonal to the parameter spine. The absolute <B>position</B> of the parameter spine in 3-space need not", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-298759", " boundary of the blend lies, and hence the <B>position</B> of the contact points on each cross-sectional plane.", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-299602", " of one boundary, and let Parasolid calculate the <B>position</B> of the other boundary. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-299603", " the standard blend size controls to define the <B>position</B> of the other boundary, as described in Section", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-299610", " You can define the <B>position</B> of both boundaries, and let Parasolid calculate the", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-305613", " This is an indication of the <B>position</B> of the depth point along the chord between", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-894126", " the curve contains two parameters that set the <B>position</B> of the depth point as follows: ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-895648", " a curvature continuous blend also depends on the <B>position</B> of the parameter spine (see Section 78.3.1 )", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-306122", " PK_blend_xs_shape_chamfer_c - chamfer cross-section, with <B>position</B> continuity. See Section 78.5.2 ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311311", " also supply a help point to identify a <B>position</B> at which to generate a blend rib. See", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311338", " Alternatively, this can represent the <B>position</B> at which you want to generate a blend", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311471", " at a specific <B>position</B>, identified using a help point ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311492", " Where possible, produce a single rib at a <B>position</B> that corresponds to the supplied ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311540", " parameters. Each member of the array represents the <B>position</B> of the corresponding rib on the parameter spine", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-313178", " Section 78.4 told you how to define the <B>position</B> of the contact points between a blend and", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.080.html#50409867_pgfId-295168", " planes that are used to determine the exact <B>position</B> where the blended surface touches the blend walls.", "Functional Description - Three-Face Blending");
top.note("chapters/fd_chap.084.html#50409872_pgfId-311823", " polyline, so that they match one-to-one with those <B>position</B> vectors. Such models will always be watertight (i.e.there", "Functional Description - Overview Of Convergent Modeling");
top.note("chapters/fd_chap.084.html#50409872_pgfId-311851", " facets where facets also share a single common <B>position</B> at a single vertex with more than two", "Functional Description - Overview Of Convergent Modeling");
top.note("chapters/fd_chap.085.html#50409873_pgfId-443569", " mfacet and the mtopol at a given uv <B>position</B> in a mesh. ", "Functional Description - Facet Model Structure");
top.note("chapters/fd_chap.085.html#50409873_pgfId-443615", " Finds the mesh parameterisation of a <B>position</B> on a given mfacet. ", "Functional Description - Facet Model Structure");
top.note("chapters/fd_chap.085.html#50409873_pgfId-412826", " Returns the <B>position</B> at the given mvertex. ", "Functional Description - Facet Model Structure");
top.note("chapters/fd_chap.088.html#50409876_pgfId-339926", " types of defects found, the entities affected and <B>position</B> and parameter information. ", "Functional Description - Checking and Repairing Mesh Data");
top.note("chapters/fd_chap.088.html#50409876_pgfId-341837", " have slits (laminar mfins that occupy the same <B>position</B>). ", "Functional Description - Checking and Repairing Mesh Data");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343304", " An array of <B>position</B> data to help locate chains of mfins to", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343025", " an array of <B>position</B> vectors, and for each <B>position</B> vector specified, PK_MESH_find_laminar_mfins returns the closest chain of", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.090.html#50409878_pgfId-339102", " same functions you would use to find your <B>position</B> in a classic B-rep surface. ", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.090.html#50409878_pgfId-352953", " mfacet and any mfin or mvertex at the <B>position</B> evaluated. ", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.090.html#50409878_pgfId-352957", " Calculates the mesh UV-parameters of a <B>position</B> known to lie in a given mfacet. If", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.090.html#50409878_pgfId-365227", " Returns the averaged normal at a given <B>position</B> on the mesh. ", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.093.html#50409882_pgfId-310247", " outputs <B>position</B> vectors along a curve ", "Functional Description - Exporting Data");
top.note("chapters/fd_chap.096.html#50409886_pgfId-294762", " coordinate (<B>position</B> vector) ", "Functional Description - Attribute Definitions");
top.note("chapters/fd_chap.096.html#50409886_pgfId-294924", " Attribute is independent of the entitys <B>position</B> and size ", "Functional Description - Attribute Definitions");
top.note("chapters/fd_chap.096.html#50409886_pgfId-294930", " size of entity but is independent of its <B>position</B> ", "Functional Description - Attribute Definitions");
top.note("chapters/fd_chap.096.html#50409886_pgfId-294936", " Attribute is dependent on both the size and <B>position</B> of the entity ", "Functional Description - Attribute Definitions");
top.note("chapters/fd_chap.096.html#50409886_pgfId-294957", " 1, attribute is independent of physical size and <B>position</B> for the entity to which it is attached.", "Functional Description - Attribute Definitions");
top.note("chapters/fd_chap.107.html#50409898_pgfId-304598", " by a loop of edges which indicates the <B>position</B> of the boundary between the small feature and", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-304629", " features are ignored. This is determined by the <B>position</B> of the boundary between the small feature and", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-304390", " with each visibility transition point corresponding to its <B>position</B> along the polyline. ", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-294903", " which allows the application to control the relative <B>position</B> of hatch lines on a face. This option", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-294904", " option specifies that Parasolid should choose the start <B>position</B> for hatching. ", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-303921", " Add the integer value corresponding to the <B>position</B> in the ", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.107.html#50409898_pgfId-303942", " you want to render transparent, according to the <B>position</B> of those occurrences in the ", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.109.html#50409900_pgfId-1100131", " features are ignored. This is determined by the <B>position</B> of the boundary between the small feature and", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.111.html#50409902_pgfId-294788", " and curvatures) that is derived from the corresponding <B>position</B> in the original model. ", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-298684", " this context, dominant refers to the edge whose <B>position</B> stays the same when the spike is zipped", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.111.html#50409902_pgfId-424287", " are associated with a model edge but whose <B>position</B> does not lie on the geometry of that", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294731", " Parasolid specifies the viewing data (<B>position</B>, direction and type) for rendering and faceting functions", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294768", " specified view direction and, optionally, a specific eye <B>position</B> from which to view a model with a", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.112.html#50409903_pgfId-294810", " is a vector that represents the <B>position</B> from which the part is viewed along the", "Functional Description - Parasolid View Matrices");
top.note("chapters/fd_chap.116.html#50409908_pgfId-295124", " Must fit at least one <B>position</B> to a tolerance, or set ", "Functional Description - Symmetric Multi-Processing In Parasolid");
top.note("chapters/fd_chap.124.html#50409918_pgfId-387141", " these classes are independent of the size and <B>position</B> of the entity to which they are attached.", "Functional Description - System Attribute Definitions");
top.note("chapters/fd_chap.124.html#50409918_pgfId-285690", " <B>position</B> vector ", "Functional Description - System Attribute Definitions");
top.note("chapters/fd_chap.124.html#50409918_pgfId-378346", " a face by submitting multiple normal, pitch, and <B>position</B> data in the form of sets of 7", "Functional Description - System Attribute Definitions");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287022", " function which is defined to have continuity of <B>position</B> and of ( ", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.125.html#50409919_pgfId-287435", " You achieve continuity of <B>position</B> between adjacent patches with Bezier end conditions by", "Functional Description - The Mathematical Form Of B-Geometry");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275506", " G0 - the curve has continuous <B>position</B>, i.e. it is a single piece with no", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275510", " G0 - the surface has continuous <B>position</B>, i.e. it is a single piece with no", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275563", "Periodic: the <B>position</B> and derivatives at both ends are the same", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275640", " the part to place it in the required <B>position</B> within the assembly. ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-299994", " A term used to describe transformations that can <B>position</B> an entity outside of the size box while", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275683", " in a convenient coordinate system and shows its <B>position</B> and orientation within the world coordinate system. ", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275829", " <B>Position</B> on a surface where the normal is not defined.", "Functional Description - ZGlossary");
top.note("chapters/fd_chap.128.html#50409922_pgfId-275841", " constraints. It is represented by an array of <B>position</B> vectors and values representing its degree, end and", "Functional Description - ZGlossary");
top.note("chapters/ov_chap.04.html#50442254_pgfId-648857", " example in designing factories when deciding where to <B>position</B> objects (such as machinery) around the factory. Each", "Overview of Parasolid - Model Structure");
top.note("chapters/ov_chap.06.html#50442273_pgfId-845512", " extending adjacent offset faces to determine the new <B>position</B> of the edge, Parasolid can optionally round off", "Overview of Parasolid - Local Operations");
top.note("chapters/ov_chap.06.html#50442273_pgfId-1485220", " The last illustration in the image, shows how <B>position</B> data can be used to aid Parasolid in", "Overview of Parasolid - Local Operations");
top.note("chapters/ov_chap.11.html#50442244_pgfId-728458", " of the blend walls. You can determine the <B>position</B> of these contact points in two ways: ", "Overview of Parasolid - Blending");
top.note("chapters/ov_chap.11.html#50442244_pgfId-282093", " of the blend and let Parasolid calculate the <B>position</B> of the contact points ", "Overview of Parasolid - Blending");
top.note("chapters/ov_chap.11.html#50442244_pgfId-285075", " of one boundary and let Parasolid calculate the <B>position</B> of the other boundary. ", "Overview of Parasolid - Blending");
top.note("chapters/ov_chap.11.html#50442244_pgfId-285079", " the standard blend size controls to define the <B>position</B> of the other boundary. ", "Overview of Parasolid - Blending");
top.note("chapters/ov_chap.11.html#50442244_pgfId-285083", " You define the <B>position</B> of both boundaries and let Parasolid fit the", "Overview of Parasolid - Blending");
top.note("chapters/p2_chap.03.html#sec_b_1_1", " 5801 attribute is independent of physical size and <B>position</B> of entity to which it is attached (e.g.", "PK Reference - PK token Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.05.html#sec_d_1_app", " 5801 attribute is independent of physical size and <B>position</B> of entity to which it is attached (e.g.", "PK Reference - PK token Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.07.html#sec_f_1_2", " PK_ERROR_system_error 900 PK_SURF_parameterise_vector Parameters for the given <B>position</B>", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_4", " <B>position</B> indicated by its corresponding entry", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.09.html#sec_h_1_1", " <B>position</B> indicated by its corresponding entry", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_2", " the <B>position</B> vectors. Returned only", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_3", " PK_ERROR_not_on_mfacet 5234 PK_MFACET_parameterise_vec the <B>position</B> supplied does not lie on the", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_4", " PK_ERROR_system_error 900 PK_SURF_parameterise_vector Parameters for the given <B>position</B>", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.10.html#sec_i_1_1", " PK_BCURVE_create_spline 911 PK_ERROR_bad_position a <B>position</B> is outside size box (MILD)", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_2", " <B>position</B> indicated by its corresponding entry", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_3", " PK_MESH_create_from_facets 5241 PK_ERROR_facet_invalid_input <B>Position</B> or normal is not a valid", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_4", " the <B>position</B> vectors. Returned only", "PK Reference - PK Error Codes (Functional)");
top.note("headers/pk_appitem_ask.html#documentation", " (see PK_APPITEM_create ) is returned in the corresponding <B>position</B> in", "PK Reference - PK_APPITEM_ask");
top.note("headers/pk_appitem_create.html#documentation", "the corresponding <B>position</B> in appitems .", "PK Reference - PK_APPITEM_create");
top.note("headers/pk_assembly_check_o_t.html#documentation", " state | entity_1 | entity_2 | <B>position</B> ", "PK Reference - PK_ASSEMBLY_check_o_t");
top.note("headers/pk_attdef_class_t.html#documentation", " and <B>position</B> of entity to which it is", "PK Reference - PK_ATTDEF_class_t");
top.note("headers/pk_attdef_sf_2_t.html#documentation", " and <B>position</B> of entity to which it is", "PK Reference - PK_ATTDEF_sf_2_t");
top.note("headers/pk_attdef_sf_t.html#documentation", " and <B>position</B> of entity to which it is", "PK Reference - PK_ATTDEF_sf_t");
top.note("headers/pk_bcurve_clamp_t.html#documentation", " Furthermore, if a supplied <B>position</B> p is such", "PK Reference - PK_BCURVE_clamp_t");
top.note("headers/pk_bcurve_create_spline.html#errors", " PK_ERROR_bad_position a <B>position</B> is outside size box (MILD)", "PK Reference - PK_BCURVE_create_spline");
top.note("headers/pk_bcurve_create_spline_2.html#errors", " PK_ERROR_bad_position a <B>position</B> is outside size box; or two or", "PK Reference - PK_BCURVE_create_spline_2");
top.note("headers/pk_bcurve_create_spline_2_o_t.html#declaration", " --- <B>position</B> ", "PK Reference - PK_BCURVE_create_spline_2_o_t");
top.note("headers/pk_bcurve_create_spline_2_o_t.html#documentation", " <B>position</B> in positions that has the parameter given by", "PK Reference - PK_BCURVE_create_spline_2_o_t");
top.note("headers/pk_bcurve_create_spline_o_t.html#documentation", " of the <B>position</B> in positions that has the parameter", "PK Reference - PK_BCURVE_create_spline_o_t");
top.note("headers/pk_bcurve_make_bsurf_lofted.html#documentation", "curves. Otherwise the surface is, in general, only <B>position</B> continuous", "PK Reference - PK_BCURVE_make_bsurf_lofted");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#declaration", " PK_VECTOR_t v_degen_vector; --- <B>position</B> vector of point degeneracy", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#documentation", " then a degenerate <B>position</B> vector is supplied in", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_overdefined_t.html#documentation", " is used to determine the behaviour when the <B>position</B>, parameter", "PK Reference - PK_BCURVE_overdefined_t");
top.note("headers/pk_bcurve_spline_t.html#documentation", " PK_BCURVE_spline_overdefined_c The <B>position</B>, parameter and derivative", "PK Reference - PK_BCURVE_spline_t");
top.note("headers/pk_blend_edge_shape_t.html#documentation", " PK_blend_xs_shape_conic_c , if the two ranges at each <B>position</B> are equal and", "PK Reference - PK_blend_edge_shape_t");
top.note("headers/pk_blend_limit_data_t.html#documentation", " <B>position</B> of the limits of the blend. If the", "PK Reference - PK_blend_limit_data_t");
top.note("headers/pk_blend_xs_shape_t.html#documentation", "PK_blend_xs_shape_chamfer_c shape is linear, with <B>position</B> continuity", "PK Reference - PK_blend_xs_shape_t");
top.note("headers/pk_body_check_o_t.html#documentation", " state | entity_1 | <B>position</B> ", "PK Reference - PK_BODY_check_o_t");
top.note("headers/pk_body_contains_vector.html#declaration", " PK_VECTOR_t vector, --- the <B>position</B> vector", "PK Reference - PK_BODY_contains_vector");
top.note("headers/pk_body_contains_vector.html#description", "<B>position</B> vector lies inside, outside, or on the boundary", "PK Reference - PK_BODY_contains_vector");
top.note("headers/pk_body_create_sheet_circle.html#declaration", "const PK_AXIS2_sf_t *basis_set, --- <B>position</B> and orientation (may be NULL)", "PK Reference - PK_BODY_create_sheet_circle");
top.note("headers/pk_body_create_sheet_planar.html#declaration", " int n_vectors, --- number of <B>position</B>", "PK Reference - PK_BODY_create_sheet_planar");
top.note("headers/pk_body_create_sheet_planar.html#documentation", "<B>position</B> vectors given clockwise (when viewed in the direction", "PK Reference - PK_BODY_create_sheet_planar");
top.note("headers/pk_body_create_sheet_planar_o_t.html#documentation", "given <B>position</B> vectors form a single loop which is the", "PK Reference - PK_BODY_create_sheet_planar_o_t");
top.note("headers/pk_body_create_sheet_polygon.html#declaration", "const PK_AXIS2_sf_t *basis_set, --- <B>position</B> and orientation (may be NULL)", "PK Reference - PK_BODY_create_sheet_polygon");
top.note("headers/pk_body_create_sheet_rectangle.html#declaration", "const PK_AXIS2_sf_t *basis_set, --- <B>position</B> and orientation (may be NULL)", "PK Reference - PK_BODY_create_sheet_rectangle");
top.note("headers/pk_body_create_solid_block.html#declaration", "const PK_AXIS2_sf_t *basis_set, --- <B>position</B> and orientation (may be NULL)", "PK Reference - PK_BODY_create_solid_block");
top.note("headers/pk_body_create_solid_cone.html#declaration", "const PK_AXIS2_sf_t *basis_set, --- <B>position</B> and orientation (may be NULL)", "PK Reference - PK_BODY_create_solid_cone");
top.note("headers/pk_body_create_solid_cyl.html#declaration", "const PK_AXIS2_sf_t *basis_set, --- <B>position</B> and orientation (may be NULL)", "PK Reference - PK_BODY_create_solid_cyl");
top.note("headers/pk_body_create_solid_prism.html#declaration", "const PK_AXIS2_sf_t *basis_set, --- <B>position</B> and orientation (may be NULL)", "PK Reference - PK_BODY_create_solid_prism");
top.note("headers/pk_body_create_solid_sphere.html#declaration", "const PK_AXIS2_sf_t *basis_set, --- <B>position</B> and orientation (may be NULL)", "PK Reference - PK_BODY_create_solid_sphere");
top.note("headers/pk_body_create_solid_torus.html#declaration", "const PK_AXIS2_sf_t *basis_set, --- <B>position</B> and orientation (may be NULL)", "PK Reference - PK_BODY_create_solid_torus");
top.note("headers/pk_body_emboss.html#errors", " PK_ERROR_bad_position The <B>position</B> of endcap relative to the", "PK Reference - PK_BODY_emboss");
top.note("headers/pk_body_fault_t.html#documentation", " array but not at the first <B>position</B>", "PK Reference - PK_BODY_fault_t");
top.note("headers/pk_body_find_extreme.html#declaration", " PK_VECTOR_t *const extreme, --- <B>position</B> of extreme point", "PK Reference - PK_BODY_find_extreme");
top.note("headers/pk_body_imprint_curve.html#documentation", " The <B>position</B> of the point of the single vertex of", "PK Reference - PK_BODY_imprint_curve");
top.note("headers/pk_body_imprint_cus_shadow.html#documentation", "in the <B>position</B> where shadows would have been cast had the", "PK Reference - PK_BODY_imprint_cus_shadow");
top.note("headers/pk_body_make_curves_outline_o_t.html#declaration", " PK_VECTOR_t project_position;--- <B>position</B> of plane if projecting", "PK Reference - PK_BODY_make_curves_outline_o_t");
top.note("headers/pk_body_make_curves_outline_o_t.html#documentation", " project_position The <B>position</B> of the plane in the view direction.", "PK Reference - PK_BODY_make_curves_outline_o_t");
top.note("headers/pk_body_make_facet_body_o_t.html#documentation", " a <B>position</B> on a mesh to the surface of the", "PK Reference - PK_BODY_make_facet_body_o_t");
top.note("headers/pk_body_make_persp_outline.html#declaration", "const PK_VECTOR_t eye_position, --- eye <B>position</B>", "PK Reference - PK_BODY_make_persp_outline");
top.note("headers/pk_body_make_section_o_t.html#documentation", " tool surface in its original <B>position</B> when", "PK Reference - PK_BODY_make_section_o_t");
top.note("headers/pk_body_make_spun_outline_o_t.html#declaration", " PK_VECTOR_t project_position; --- <B>position</B> of plane if projecting", "PK Reference - PK_BODY_make_spun_outline_o_t");
top.note("headers/pk_body_make_spun_outline_o_t.html#documentation", " project_position The <B>position</B> of the plane through the spin axis.", "PK Reference - PK_BODY_make_spun_outline_o_t");
top.note("headers/pk_body_make_swept_body.html#documentation", " corresponding to the profiles <B>position</B> will be created, unless the", "PK Reference - PK_BODY_make_swept_body");
top.note("headers/pk_body_make_swept_body_2.html#documentation", " guide wire is supplied: In this case the <B>position</B> of the sweep is", "PK Reference - PK_BODY_make_swept_body_2");
top.note("headers/pk_body_make_swept_body_2_o_t.html#documentation", " scale_point A <B>position</B> vector indicating the defining point for a", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#documentation", " scale_point A <B>position</B> vector indicating the defining point for a", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_make_swept_tool_o_t.html#documentation", " <B>position</B> of the sweep. In this case, the location", "PK Reference - PK_BODY_make_swept_tool_o_t");
top.note("headers/pk_body_offset_o_t.html#documentation", " <B>position</B> of the new vertex is trimmed back along", "PK Reference - PK_BODY_offset_o_t");
top.note("headers/pk_body_pick_topols_o_t.html#documentation", "(the radial distance) and records the <B>position</B> on the ray (the hit point)", "PK Reference - PK_BODY_pick_topols_o_t");
top.note("headers/pk_body_sweep_alignment_t.html#documentation", " the path <B>position</B>, and perpendicular to", "PK Reference - PK_BODY_sweep_alignment_t");
top.note("headers/pk_body_sweep_scale_type_t.html#documentation", " PK_BODY_sweep_scale_posn_c Scale the relative <B>position</B> of the profile", "PK Reference - PK_BODY_sweep_scale_type_t");
top.note("headers/pk_body_thicken_o_t.html#documentation", " to split into two vertices. The default <B>position</B> of the", "PK Reference - PK_BODY_thicken_o_t");
top.note("headers/pk_body_trim_neutral_sheets.html#documentation", "will correspond to the pair in the same <B>position</B> in the input array.", "PK Reference - PK_BODY_trim_neutral_sheets");
top.note("headers/pk_body_trim_neutral_sheets_2.html#documentation", "will correspond to the pair in the same <B>position</B> in the input array.", "PK Reference - PK_BODY_trim_neutral_sheets_2");
top.note("headers/pk_bsurf_constrained_fault_t.html#documentation", " <B>position</B> constraints.", "PK Reference - PK_BSURF_constrained_fault_t");
top.note("headers/pk_bsurf_create_constrained.html#errors", " PK_ERROR_bad_position A <B>position</B> is repeated in positions , and", "PK Reference - PK_BSURF_create_constrained");
top.note("headers/pk_bsurf_create_constrained_o_t.html#declaration", " int n_positions; --- number of <B>position</B> constraints", "PK Reference - PK_BSURF_create_constrained_o_t");
top.note("headers/pk_bsurf_create_constrained_o_t.html#documentation", " n_positions The number of <B>position</B> constraints. (0)", "PK Reference - PK_BSURF_create_constrained_o_t");
top.note("headers/pk_check_fault_t.html#declaration", " PK_VECTOR_t <B>position</B>; --- <B>position</B> within faulty geometry or the", "PK Reference - PK_check_fault_t");
top.note("headers/pk_check_fault_t.html#documentation", "contain an entity_2 and/or a <B>position</B> . This depends upon the state as", "PK Reference - PK_check_fault_t");
top.note("headers/pk_check_state_t.html#documentation", " PK_ATTRIB_state_p_vector_oor_c a <B>position</B> vector field is out of range", "PK Reference - PK_check_state_t");
top.note("headers/pk_curve_degen_t.html#declaration", " PK_VECTOR_t <B>position</B>;", "PK Reference - PK_CURVE_degen_t");
top.note("headers/pk_curve_degen_t.html#documentation", " have_position If set to PK_LOGICAL_true, then a three-space <B>position</B> is", "PK Reference - PK_CURVE_degen_t");
top.note("headers/pk_curve_eval.html#documentation", " if the function could evaluate at least the <B>position</B>, but is", "PK Reference - PK_CURVE_eval");
top.note("headers/pk_curve_eval_curvature.html#declaration", "double t, --- parametric <B>position</B> on curve", "PK Reference - PK_CURVE_eval_curvature");
top.note("headers/pk_curve_eval_curvature_handed.html#declaration", "double t, --- parametric <B>position</B> on curve", "PK Reference - PK_CURVE_eval_curvature_handed");
top.note("headers/pk_curve_find_min_radius.html#declaration", " PK_VECTOR_t *const <B>position</B>, --- <B>position</B> vector where minimum occurs", "PK Reference - PK_CURVE_find_min_radius");
top.note("headers/pk_curve_find_min_radius.html#description", "<B>position</B> and parameter.", "PK Reference - PK_CURVE_find_min_radius");
top.note("headers/pk_curve_find_min_radius.html#documentation", " 2: A <B>position</B> vector indicating where on the curve the minimum", "PK Reference - PK_CURVE_find_min_radius");
top.note("headers/pk_curve_find_vector_interval.html#declaration", " PK_VECTOR_t vector_1, --- first <B>position</B> vector", "PK Reference - PK_CURVE_find_vector_interval");
top.note("headers/pk_curve_find_vector_interval.html#description", "<B>position</B> vectors lying on the curve.", "PK Reference - PK_CURVE_find_vector_interval");
top.note("headers/pk_curve_find_vector_interval.html#documentation", "The <B>position</B> vectors must lie on the curve within SESSION", "PK Reference - PK_CURVE_find_vector_interval");
top.note("headers/pk_curve_find_vectors.html#description", " This function returns <B>position</B> vectors on the supplied curve given measurements", "PK Reference - PK_CURVE_find_vectors");
top.note("headers/pk_curve_find_vectors.html#documentation", "function will return <B>position</B> vectors on the required part of the curve.", "PK Reference - PK_CURVE_find_vectors");
top.note("headers/pk_curve_find_vectors_o_t.html#documentation", " structure allows the caller to control how the <B>position</B> vectors", "PK Reference - PK_CURVE_find_vectors_o_t");
top.note("headers/pk_curve_find_vectors_r_t.html#documentation", "If PK_CURVE_find_vectors successfully determines a <B>position</B> vector", "PK Reference - PK_CURVE_find_vectors_r_t");
top.note("headers/pk_curve_make_helical_surf.html#documentation", "The turns argument need not include <B>position</B> 0.0 - the supplied curve, but", "PK Reference - PK_CURVE_make_helical_surf");
top.note("headers/pk_curve_make_wire_body_2.html#documentation", "meet at a particular <B>position</B> (though check must be set to PK_LOGICAL_false", "PK Reference - PK_CURVE_make_wire_body_2");
top.note("headers/pk_curve_make_wire_body_o_t.html#documentation", " with an array of integers, indicating the <B>position</B> in", "PK Reference - PK_CURVE_make_wire_body_o_t");
top.note("headers/pk_curve_output_vectors.html#declaration", " int *const n_vectors, --- number of <B>position</B> vectors", "PK Reference - PK_CURVE_output_vectors");
top.note("headers/pk_curve_output_vectors.html#description", " This function outputs <B>position</B> vectors along a curve.", "PK Reference - PK_CURVE_output_vectors");
top.note("headers/pk_curve_output_vectors.html#documentation", "of <B>position</B> vectors is controlled by curve_chord_tol, curve_chord_ang and", "PK Reference - PK_CURVE_output_vectors");
top.note("headers/pk_curve_parameterise_vector.html#declaration", " PK_VECTOR_t <B>position</B>, --- <B>position</B> on curve", "PK Reference - PK_CURVE_parameterise_vector");
top.note("headers/pk_curve_project_o_t.html#declaration", " PK_VECTOR_t eye_position; --- <B>position</B> for perspective", "PK Reference - PK_CURVE_project_o_t");
top.note("headers/pk_curve_project_o_t.html#documentation", " specifies the <B>position</B> for the source of rays needed to", "PK Reference - PK_CURVE_project_o_t");
top.note("headers/pk_curve_self_int_t.html#documentation", " <B>position</B> will be returned.", "PK Reference - PK_CURVE_self_int_t");
top.note("headers/pk_detail_def_hole_t.html#declaration", " PK_AXIS2_sf_t origin; --- holes <B>position</B> and orientation", "PK Reference - PK_detail_def_hole_t");
top.note("headers/pk_detail_def_hole_t.html#documentation", " origin this defines the <B>position</B> and orientation of the hole.", "PK Reference - PK_detail_def_hole_t");
top.note("headers/pk_edge_contains_vector.html#declaration", " PK_VECTOR_t vector, --- the <B>position</B> vector", "PK Reference - PK_EDGE_contains_vector");
top.note("headers/pk_edge_contains_vector.html#description", " This function determines whether the given <B>position</B> vector coincides with", "PK Reference - PK_EDGE_contains_vector");
top.note("headers/pk_edge_find_deviation.html#documentation", "give a <B>position</B> on each edge and the measured distance between", "PK Reference - PK_EDGE_find_deviation");
top.note("headers/pk_edge_find_end_tangents.html#declaration", " PK_VECTOR_t *const start, --- start <B>position</B> of edge", "PK Reference - PK_EDGE_find_end_tangents");
top.note("headers/pk_edge_find_end_tangents.html#documentation", " are directed along the edge from the start <B>position</B> to the end", "PK Reference - PK_EDGE_find_end_tangents");
top.note("headers/pk_edge_find_extreme.html#declaration", " PK_VECTOR_t *const extreme, --- <B>position</B> of extreme point", "PK Reference - PK_EDGE_find_extreme");
top.note("headers/pk_edge_set_blend_chain.html#errors", " <B>position</B> indicated by its corresponding entry", "PK Reference - PK_EDGE_set_blend_chain");
top.note("headers/pk_edge_set_blend_chain_o_t.html#documentation", " chain. If the edge chain is open, one <B>position</B> should be at", "PK Reference - PK_EDGE_set_blend_chain_o_t");
top.note("headers/pk_edge_set_blend_variable.html#documentation", " an array of length n_ranges , consisting of <B>position</B>", "PK Reference - PK_EDGE_set_blend_variable");
top.note("headers/pk_edge_split_at_param.html#documentation", " raised. Also if the parameter evaluates to a <B>position</B> coincident", "PK Reference - PK_EDGE_split_at_param");
top.note("headers/pk_entity_check_attribs.html#documentation", "be the owning entity of this attribute. <B>position</B> is unused.", "PK Reference - PK_ENTITY_check_attribs");
top.note("headers/pk_entity_range_end_t.html#declaration", " PK_VECTOR_t vector; --- end <B>position</B> (0.0, 0.0, 0.0)", "PK Reference - PK_ENTITY_range_end_t");
top.note("headers/pk_entity_range_end_t.html#documentation", " index : this represents the <B>position</B> of the entity in the", "PK Reference - PK_ENTITY_range_end_t");
top.note("headers/pk_entity_range_o_t.html#documentation", " PK_range_guess_vector_c : <B>position</B> guess", "PK Reference - PK_ENTITY_range_o_t");
top.note("headers/pk_entity_range_vector.html#declaration", "const PK_VECTOR_t vectors[], --- <B>position</B> array", "PK Reference - PK_ENTITY_range_vector");
top.note("headers/pk_entity_range_vector_o_t.html#documentation", " PK_range_guess_vector_c : <B>position</B> guess.", "PK Reference - PK_ENTITY_range_vector_o_t");
top.note("headers/pk_entity_range_vector_r_t.html#declaration", " PK_ENTITY_range_end_t *ends; --- end <B>position</B> array", "PK Reference - PK_ENTITY_range_vector_r_t");
top.note("headers/pk_face_change_data_offset_t.html#documentation", " <B>position</B> of each face. Otherwise it is measured from", "PK Reference - PK_FACE_change_data_offset_t");
top.note("headers/pk_face_change_deform_eval_f_t.html#declaration", " PK_VECTOR_t <B>position</B>, --- input <B>position</B>", "PK Reference - PK_FACE_change_deform_eval_f_t");
top.note("headers/pk_face_change_deform_eval_f_t.html#documentation", " be deformed. The function will receive an input <B>position</B> located on", "PK Reference - PK_FACE_change_deform_eval_f_t");
top.note("headers/pk_face_change_deform_o_t.html#documentation", " <B>position</B> (vector) - An input <B>position</B> located on the", "PK Reference - PK_FACE_change_deform_o_t");
top.note("headers/pk_face_change_taper_o_t.html#declaration", " PK_taper_laminar_edge_t <B>position</B>; --- defines how to process", "PK Reference - PK_FACE_change_taper_o_t");
top.note("headers/pk_face_change_taper_o_t.html#documentation", " <B>position</B> Specifies how to process laminar edge boundaries.", "PK Reference - PK_FACE_change_taper_o_t");
top.note("headers/pk_face_change_type_t.html#documentation", " corresponding <B>position</B> on the deformed", "PK Reference - PK_FACE_change_type_t");
top.note("headers/pk_face_check_pair.html#documentation", "state | entity_1 | entity_2 | <B>position</B>", "PK Reference - PK_FACE_check_pair");
top.note("headers/pk_face_contains_vectors.html#documentation", " performance reasons, it is assumed by default that <B>position</B> vectors lie", "PK Reference - PK_FACE_contains_vectors");
top.note("headers/pk_face_contains_vectors_o_t.html#declaration", " PK_LOGICAL_t is_on_surf; --- whether <B>position</B> vector is assumed", "PK Reference - PK_FACE_contains_vectors_o_t");
top.note("headers/pk_face_contains_vectors_o_t.html#documentation", "the face, or as <B>position</B> vectors in 3D space, or both.", "PK Reference - PK_FACE_contains_vectors_o_t");
top.note("headers/pk_face_emboss.html#errors", " PK_ERROR_bad_position The <B>position</B> of endcap relative to the", "PK Reference - PK_FACE_emboss");
top.note("headers/pk_face_find_extreme.html#declaration", " PK_VECTOR_t *const extreme, --- <B>position</B> of extreme point", "PK Reference - PK_FACE_find_extreme");
top.note("headers/pk_face_instance_tools.html#documentation", "adjusted according to its <B>position</B> on the incline, by a suitable transform.", "PK Reference - PK_FACE_instance_tools");
top.note("headers/pk_face_is_coincident.html#documentation", "<B>position</B> vector is returned in point indicating where the", "PK Reference - PK_FACE_is_coincident");
top.note("headers/pk_face_offset_o_t.html#documentation", " <B>position</B> of the new vertex is trimmed back along", "PK Reference - PK_FACE_offset_o_t");
top.note("headers/pk_face_pattern.html#documentation", "by the application to help determine the transformed <B>position</B> of the pattern", "PK Reference - PK_FACE_pattern");
top.note("headers/pk_face_pattern_2.html#documentation", "by the application to help determine the transformed <B>position</B> of the pattern", "PK Reference - PK_FACE_pattern_2");
top.note("headers/pk_face_taper_o_t.html#declaration", " PK_taper_laminar_edge_t <B>position</B>; --- defines how to process", "PK Reference - PK_FACE_taper_o_t");
top.note("headers/pk_face_taper_o_t.html#documentation", " <B>position</B> Specifies how to process laminar edge boundaries.", "PK Reference - PK_FACE_taper_o_t");
top.note("headers/pk_ffread_f_t.html#documentation", " function reads from file (starting at the current <B>position</B> of the file", "PK Reference - PK_FFREAD_f_t");
top.note("headers/pk_ffskxt_f_t.html#documentation", " relative to the <B>position</B> immediately after FFOPRD or FFOPWR. Subsequent", "PK Reference - PK_FFSKXT_f_t");
top.note("headers/pk_ffwrit_f_t.html#documentation", " current <B>position</B> of the file pointer. The file pointer is", "PK Reference - PK_FFWRIT_f_t");
top.note("headers/pk_fgevcu_f_t.html#documentation", "Parasolid. The function should be capable of supplying <B>position</B> and up", "PK Reference - PK_FGEVCU_f_t");
top.note("headers/pk_fgevsu_f_t.html#documentation", "Parasolid. The function should be capable of supplying <B>position</B> and up", "PK Reference - PK_FGEVSU_f_t");
top.note("headers/pk_fin_euler_glue.html#documentation", "may appear at any <B>position</B> in fins as fins is treated as a", "PK Reference - PK_FIN_euler_glue");
top.note("headers/pk_geom_check_o_t.html#documentation", " <B>Position</B> : a vector (t,0,0) where the parameter t", "PK Reference - PK_GEOM_check_o_t");
top.note("headers/pk_geom_is_coincident.html#description", "occupy the same <B>position</B>(s) in space.", "PK Reference - PK_GEOM_is_coincident");
top.note("headers/pk_geom_is_coincident.html#documentation", "<B>position</B>(s) in space, is_coincident will be returned as PK_LOGICAL_true,", "PK Reference - PK_GEOM_is_coincident");
top.note("headers/pk_geom_range.html#documentation", " vector : the end <B>position</B> on entity .", "PK Reference - PK_GEOM_range");
top.note("headers/pk_geom_range_array.html#documentation", " vector : the end <B>position</B> on entity .", "PK Reference - PK_GEOM_range_array");
top.note("headers/pk_geom_range_array_vector.html#declaration", " PK_VECTOR_t vector, --- <B>position</B> vector", "PK Reference - PK_GEOM_range_array_vector");
top.note("headers/pk_geom_range_array_vector.html#documentation", "the array of geometrical entities geoms and the <B>position</B> vector vector .", "PK Reference - PK_GEOM_range_array_vector");
top.note("headers/pk_geom_range_local.html#documentation", " vector : the end <B>position</B> on entity .", "PK Reference - PK_GEOM_range_local");
top.note("headers/pk_geom_range_local_vector.html#declaration", " PK_VECTOR_t vector, --- <B>position</B> vector", "PK Reference - PK_GEOM_range_local_vector");
top.note("headers/pk_geom_range_local_vector.html#documentation", "the geometrical entity geom and a <B>position</B> vector vector .", "PK Reference - PK_GEOM_range_local_vector");
top.note("headers/pk_geom_range_o_t.html#documentation", " PK_range_guess_vector_c : <B>position</B> guess", "PK Reference - PK_GEOM_range_o_t");
top.note("headers/pk_geom_range_vector.html#declaration", " PK_VECTOR_t vector, --- <B>position</B> vector", "PK Reference - PK_GEOM_range_vector");
top.note("headers/pk_geom_range_vector.html#documentation", "geometrical entity geom and a <B>position</B> vector vector .", "PK Reference - PK_GEOM_range_vector");
top.note("headers/pk_geom_range_vector_many.html#declaration", "const PK_VECTOR_t vectors[], --- <B>position</B> array", "PK Reference - PK_GEOM_range_vector_many");
top.note("headers/pk_geom_range_vector_many.html#documentation", " vector the end <B>position</B> on entity .", "PK Reference - PK_GEOM_range_vector_many");
top.note("headers/pk_geom_range_vector_many_o_t.html#documentation", " PK_range_guess_vector_c : <B>position</B> guess.", "PK Reference - PK_GEOM_range_vector_many_o_t");
top.note("headers/pk_geom_range_vector_o_t.html#documentation", " PK_range_guess_vector_c : <B>position</B> guess", "PK Reference - PK_GEOM_range_vector_o_t");
top.note("headers/pk_gooppx_f_t.html#documentation", " `rvals[0] } - image space <B>position</B> of top left of picture = (Xmin, Ymin)", "PK Reference - PK_GOOPPX_f_t");
top.note("headers/pk_gosgmt_f_t.html#documentation", " the vector <B>position</B> of the transition points in model space.", "PK Reference - PK_GOSGMT_f_t");
top.note("headers/pk_group_create_from_ents_o_t.html#documentation", " label is specified in the corresponding <B>position</B> in", "PK Reference - PK_GROUP_create_from_ents_o_t");
top.note("headers/pk_lattice_make_bodies_o_t.html#documentation", " This value controls the maximum distance from a <B>position</B>", "PK Reference - PK_LATTICE_make_bodies_o_t");
top.note("headers/pk_lball_ask_position.html#description", " This function returns the <B>position</B> of the given lball .", "PK Reference - PK_LBALL_ask_position");
top.note("headers/pk_lball_ask_position_o_t.html#description", " Holds optional controls for querying the <B>position</B> of an lball.", "PK Reference - PK_LBALL_ask_position_o_t");
top.note("headers/pk_lball_ask_position_r_t.html#declaration", " PK_VECTOR_t <B>position</B>; --- <B>position</B> of lball", "PK Reference - PK_LBALL_ask_position_r_t");
top.note("headers/pk_lball_ask_position_r_t.html#description", " A structure packaging the <B>position</B> of the lball.", "PK Reference - PK_LBALL_ask_position_r_t");
top.note("headers/pk_lball_ask_position_r_t.html#documentation", " <B>position</B> The <B>position</B> of the lball.", "PK Reference - PK_LBALL_ask_position_r_t");
top.note("headers/pk_mesh_create_from_facets.html#errors", " PK_ERROR_facet_invalid_input <B>Position</B> or normal is not a valid", "PK Reference - PK_MESH_create_from_facets");
top.note("headers/pk_mesh_eval_with_mtopol.html#declaration", " PK_VECTOR_t *const <B>position</B>, --- <B>position</B> returned", "PK Reference - PK_MESH_eval_with_mtopol");
top.note("headers/pk_mesh_eval_with_mtopol.html#description", " function evaluates the mesh at the given uv <B>position</B> and returns the", "PK Reference - PK_MESH_eval_with_mtopol");
top.note("headers/pk_mesh_eval_with_mtopol.html#documentation", "If the <B>position</B> is inside an mfacet both the mfacet and", "PK Reference - PK_MESH_eval_with_mtopol");
top.note("headers/pk_mesh_eval_with_mtopol_o_t.html#documentation", " mfacet returned for <B>position</B> s on more than one mfacet will be", "PK Reference - PK_MESH_eval_with_mtopol_o_t");
top.note("headers/pk_mesh_find_laminar_mfins_o_t.html#documentation", " the closest component to each help <B>position</B> will be", "PK Reference - PK_MESH_find_laminar_mfins_o_t");
top.note("headers/pk_mesh_find_laminar_mfins_r_t.html#declaration", " --- the index of the help <B>position</B>", "PK Reference - PK_MESH_find_laminar_mfins_r_t");
top.note("headers/pk_mesh_find_laminar_mfins_r_t.html#documentation", " the index of the help <B>position</B> closest to that component.", "PK Reference - PK_MESH_find_laminar_mfins_r_t");
top.note("headers/pk_mfacet_ask_positions.html#description", " This function returns the <B>position</B> vectors at the mvertices of mfacet .", "PK Reference - PK_MFACET_ask_positions");
top.note("headers/pk_mfacet_ask_positions.html#documentation", "`positions[0] is the <B>position</B> vector at the mvertex pointed to by the", "PK Reference - PK_MFACET_ask_positions");
top.note("headers/pk_mfacet_parameterise_vec.html#declaration", " PK_VECTOR_t <B>position</B>, --- <B>position</B> on the mfacet", "PK Reference - PK_MFACET_parameterise_vec");
top.note("headers/pk_mfacet_parameterise_vec.html#description", " This function finds the mesh parameterisation of a <B>position</B> known to be on a", "PK Reference - PK_MFACET_parameterise_vec");
top.note("headers/pk_mfacet_parameterise_vec.html#errors", " PK_ERROR_not_on_mfacet the <B>position</B> supplied does not lie on the", "PK Reference - PK_MFACET_parameterise_vec");
top.note("headers/pk_mvertex_ask_position.html#declaration", " PK_VECTOR_t *const <B>position</B> --- <B>position</B>", "PK Reference - PK_MVERTEX_ask_position");
top.note("headers/pk_mvertex_ask_position.html#description", " This function returns the <B>position</B> at the given mvertex .", "PK Reference - PK_MVERTEX_ask_position");
top.note("headers/pk_mvertex_set_positions.html#description", " This function sets the <B>position</B> of each given mvertex.", "PK Reference - PK_MVERTEX_set_positions");
top.note("headers/pk_mvertex_set_positions.html#documentation", " mvertices has its <B>position</B> set to be the <B>position</B> vector in", "PK Reference - PK_MVERTEX_set_positions");
top.note("headers/pk_param_degen_t.html#documentation", " PK_PARAM_degen_vector_c degenerate <B>position</B> vector beyond end", "PK Reference - PK_PARAM_degen_t");
top.note("headers/pk_part_receive_meshes.html#errors", " PK_ERROR_facet_invalid_input <B>Position</B> or normal is not a valid", "PK Reference - PK_PART_receive_meshes");
top.note("headers/pk_partition_receive_meshes.html#errors", " PK_ERROR_facet_invalid_input <B>Position</B> or normal is not a valid", "PK Reference - PK_PARTITION_receive_meshes");
top.note("headers/pk_pline_create.html#errors", " PK_ERROR_coincident_points repeated consecutive <B>position</B> vectors", "PK Reference - PK_PLINE_create");
top.note("headers/pk_pline_sf_t.html#documentation", " parameterisation. The <B>position</B> vector which would close", "PK Reference - PK_PLINE_sf_t");
top.note("headers/pk_point_make_helical_curve.html#documentation", "The turns argument need not include <B>position</B> 0.0 - the supplied point, but", "PK Reference - PK_POINT_make_helical_curve");
top.note("headers/pk_point_sf_t.html#declaration", " PK_VECTOR_t <B>position</B>; --- cartesian <B>position</B>", "PK Reference - PK_POINT_sf_t");
top.note("headers/pk_point_sf_t.html#errors", "PK_ERROR_bad_position <B>position</B> must be inside size box", "PK Reference - PK_POINT_sf_t");
top.note("headers/pk_range_1_r_t.html#declaration", " double distance; --- separation between entity and <B>position</B>", "PK Reference - PK_range_1_r_t");
top.note("headers/pk_range_end_t.html#declaration", " PK_VECTOR_t vector; --- end <B>position</B> (0.0, 0.0, 0.0)", "PK Reference - PK_range_end_t");
top.note("headers/pk_range_guess_t.html#declaration", " PK_VECTOR_t vector; --- end <B>position</B> (0.0, 0.0, 0.0)", "PK Reference - PK_range_guess_t");
top.note("headers/pk_range_guess_t.html#description", " is used to provide an estimate of the <B>position</B> of an end of a", "PK Reference - PK_range_guess_t");
top.note("headers/pk_range_guess_t.html#documentation", " or face then an estimate of the end <B>position</B>", "PK Reference - PK_range_guess_t");
top.note("headers/pk_range_guess_type_t.html#documentation", " PK_range_guess_vector_c <B>position</B> guess provided", "PK Reference - PK_range_guess_type_t");
top.note("headers/pk_region_imprint_curve.html#documentation", " The <B>position</B> of the point of the single vertex of", "PK Reference - PK_REGION_imprint_curve");
top.note("headers/pk_replace_vertex_data_t.html#description", "structure. It contains the vertex <B>position</B> replacement data.", "PK Reference - PK_replace_vertex_data_t");
top.note("headers/pk_report_3_t.html#documentation", " array[0], array[1], array[2] - the components of a <B>position</B> vector on the", "PK Reference - PK_REPORT_3_t");
top.note("headers/pk_self_int_type_t.html#documentation", " occupy the same <B>position</B> in space.", "PK Reference - PK_self_int_type_t");
top.note("headers/pk_session_indexio_t.html#documentation", " routine reads from file (starting at the current <B>position</B>", "PK Reference - PK_SESSION_indexio_t");
top.note("headers/pk_spline_method_t.html#documentation", "This datatype indicates the default behaviour of each <B>position</B> in", "PK Reference - PK_spline_method_t");
top.note("headers/pk_surf_degen_t.html#declaration", " PK_VECTOR_t <B>position</B>;", "PK Reference - PK_SURF_degen_t");
top.note("headers/pk_surf_degen_t.html#documentation", " have_position Whether the degenerate region occupies a single <B>position</B> in", "PK Reference - PK_SURF_degen_t");
top.note("headers/pk_surf_eval_curvature.html#declaration", " PK_UV_t uv, --- parametric <B>position</B>", "PK Reference - PK_SURF_eval_curvature");
top.note("headers/pk_surf_eval_curvature_handed.html#declaration", " PK_UV_t uv, --- parametric <B>position</B>", "PK Reference - PK_SURF_eval_curvature_handed");
top.note("headers/pk_surf_eval_curvature_handed.html#documentation", "<B>position</B> on the surface patch indicated by an additional", "PK Reference - PK_SURF_eval_curvature_handed");
top.note("headers/pk_surf_eval_handed.html#documentation", "at the given parameter <B>position</B> (shown as *), where straight lines represent", "PK Reference - PK_SURF_eval_handed");
top.note("headers/pk_surf_eval_with_normal.html#documentation", "<B>position</B> corresponding to uv by averaging the normals of", "PK Reference - PK_SURF_eval_with_normal");
top.note("headers/pk_surf_eval_with_normal_handed.html#documentation", " the surface has a discontinuity at the parameter <B>position</B>, these arguments", "PK Reference - PK_SURF_eval_with_normal_handed");
top.note("headers/pk_surf_find_min_radii.html#declaration", " PK_VECTOR_t positions[2], --- <B>position</B> vectors where minima occur", "PK Reference - PK_SURF_find_min_radii");
top.note("headers/pk_surf_find_min_radii.html#description", " within the supplied uv_box , along with its <B>position</B> and u-v", "PK Reference - PK_SURF_find_min_radii");
top.note("headers/pk_surf_find_min_radii.html#documentation", " 2: A <B>position</B> vector indicating where on the surface the minimum", "PK Reference - PK_SURF_find_min_radii");
top.note("headers/pk_surf_find_vectors.html#description", " The function will return <B>position</B> vectors on the supplied surface between the", "PK Reference - PK_SURF_find_vectors");
top.note("headers/pk_surf_find_vectors.html#errors", " the <B>position</B> vectors. Returned only", "PK Reference - PK_SURF_find_vectors");
top.note("headers/pk_surf_find_vectors.html#documentation", "The returned <B>position</B> vectors satisfy (up to tolerance ) the conditions", "PK Reference - PK_SURF_find_vectors");
top.note("headers/pk_surf_find_vectors_o_t.html#declaration", " PK_VECTOR_t help_point; --- help <B>position</B> vector", "PK Reference - PK_SURF_find_vectors_o_t");
top.note("headers/pk_surf_find_vectors_o_t.html#documentation", " structure allows the caller to control how the <B>position</B> vectors", "PK Reference - PK_SURF_find_vectors_o_t");
top.note("headers/pk_surf_find_vectors_r_t.html#documentation", "If PK_SURF_find_vectors successfully determines a <B>position</B> vector", "PK Reference - PK_SURF_find_vectors_r_t");
top.note("headers/pk_surf_general_eval_f_t.html#documentation", "at the given parameter <B>position</B> (shown as #), where straight lines represent", "PK Reference - PK_SURF_general_eval_f_t");
top.note("headers/pk_surf_make_sheet_trimmed.html#documentation", " supply them. The <B>position</B> of the vertex is deemed to be the", "PK Reference - PK_SURF_make_sheet_trimmed");
top.note("headers/pk_surf_parameterise_vector.html#declaration", " PK_VECTOR_t <B>position</B>, --- <B>position</B> on surf", "PK Reference - PK_SURF_parameterise_vector");
top.note("headers/pk_surf_parameterise_vector.html#errors", " PK_ERROR_not_on_surface Given <B>position</B> is not on or lies", "PK Reference - PK_SURF_parameterise_vector");
top.note("headers/pk_surf_self_int_t.html#documentation", " only one <B>position</B> will be returned.", "PK Reference - PK_SURF_self_int_t");
top.note("headers/pk_thread_ask_function.html#documentation", "<B>position</B> in the call stack starting at 0 for", "PK Reference - PK_THREAD_ask_function");
top.note("headers/pk_topol_facet_choice_o_t.html#documentation", "topology matching option) which meet at the same <B>position</B> will refer to", "PK Reference - PK_TOPOL_facet_choice_o_t");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#declaration", " --- <B>position</B> on a facet to the surface", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#documentation", " body will all be refacetted in their transformed <B>position</B>", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#declaration", " --- <B>position</B> on a facet to the surface", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#documentation", " body will all be refacetted in their transformed <B>position</B>", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_fctab_error_facet_t.html#documentation", " accurate face normal value at the <B>position</B>", "PK Reference - PK_TOPOL_fctab_error_facet_t");
top.note("headers/pk_topol_fctab_error_object_t.html#documentation", " accurate surface normal value at the <B>position</B>", "PK Reference - PK_TOPOL_fctab_error_object_t");
top.note("headers/pk_topol_fctab_vertex_point_t.html#documentation", "<B>position</B> will refer to the same vertex_point index.", "PK Reference - PK_TOPOL_fctab_vertex_point_t");
top.note("headers/pk_topol_range.html#documentation", " and the end <B>position</B> is found on a vertex then entity ", "PK Reference - PK_TOPOL_range");
top.note("headers/pk_topol_range_array.html#documentation", " and the end <B>position</B> is found on a vertex then entity ", "PK Reference - PK_TOPOL_range_array");
top.note("headers/pk_topol_range_array_vector.html#declaration", " PK_VECTOR_t vector, --- <B>position</B> vector", "PK Reference - PK_TOPOL_range_array_vector");
top.note("headers/pk_topol_range_array_vector.html#documentation", "the array of topological entities topols and the <B>position</B> vector vector .", "PK Reference - PK_TOPOL_range_array_vector");
top.note("headers/pk_topol_range_geom.html#documentation", " and the end <B>position</B> is found on a vertex then entity ", "PK Reference - PK_TOPOL_range_geom");
top.note("headers/pk_topol_range_geom_array.html#documentation", " and the end <B>position</B> is found on a vertex then entity ", "PK Reference - PK_TOPOL_range_geom_array");
top.note("headers/pk_topol_range_geom_o_t.html#documentation", " PK_range_guess_vector_c : <B>position</B> guess", "PK Reference - PK_TOPOL_range_geom_o_t");
top.note("headers/pk_topol_range_local.html#documentation", " and the end <B>position</B> is found on a vertex then entity ", "PK Reference - PK_TOPOL_range_local");
top.note("headers/pk_topol_range_local_vector.html#declaration", " PK_VECTOR_t vector, --- <B>position</B> vector", "PK Reference - PK_TOPOL_range_local_vector");
top.note("headers/pk_topol_range_local_vector.html#documentation", "the topological entity topol and the <B>position</B> vector vector .", "PK Reference - PK_TOPOL_range_local_vector");
top.note("headers/pk_topol_range_o_t.html#documentation", " PK_range_guess_vector_c : <B>position</B> guess", "PK Reference - PK_TOPOL_range_o_t");
top.note("headers/pk_topol_range_vector.html#declaration", " PK_VECTOR_t vector, --- <B>position</B>", "PK Reference - PK_TOPOL_range_vector");
top.note("headers/pk_topol_range_vector.html#documentation", "the <B>position</B> vector vector .", "PK Reference - PK_TOPOL_range_vector");
top.note("headers/pk_topol_range_vector_o_t.html#documentation", " PK_range_guess_vector_c : <B>position</B> guess", "PK Reference - PK_TOPOL_range_vector_o_t");
top.note("headers/pk_topol_render_line_o_t.html#documentation", "third and fifth <B>position</B> of the array topols, then transparent_indices will", "PK Reference - PK_TOPOL_render_line_o_t");
top.note("headers/pk_topol_t.html#documentation", " PK_VERTEX_t : a vertex which is a single <B>position</B> in 3D space", "PK Reference - PK_TOPOL_t");
top.note("headers/pk_transf_check.html#documentation", "state | entity_1 | entity_2 | <B>position</B>", "PK Reference - PK_TRANSF_check");
top.note("headers/pk_transf_create_reflection.html#declaration", " PK_VECTOR_t <B>position</B>, --- <B>position</B> on plane", "PK Reference - PK_TRANSF_create_reflection");
top.note("headers/pk_transf_create_reflection.html#documentation", "in the plane defined by the given <B>position</B> and normal .", "PK Reference - PK_TRANSF_create_reflection");
top.note("headers/pk_transf_create_rotation.html#declaration", " PK_VECTOR_t <B>position</B>, --- <B>position</B> on axis", "PK Reference - PK_TRANSF_create_rotation");
top.note("headers/pk_transf_create_view.html#documentation", "<B>position</B> from which to view the part along the", "PK Reference - PK_TRANSF_create_view");
top.note("headers/pk_transf_create_view_o_t.html#declaration", " PK_VECTOR_t eye_position; --- perspective eye <B>position</B>", "PK Reference - PK_TRANSF_create_view_o_t");
top.note("headers/pk_transf_create_view_o_t.html#documentation", " eye_position The eye <B>position</B> representing the centre of", "PK Reference - PK_TRANSF_create_view_o_t");
top.note("headers/pk_uv_t.html#description", " This structure represents a <B>position</B> in a surfaces parameter space.", "PK Reference - PK_UV_t");
top.note("headers/pk_vector_make_lsq_plane.html#description", "<B>position</B> vectors.", "PK Reference - PK_VECTOR_make_lsq_plane");
top.note("headers/pk_vector_make_lsq_plane_o_t.html#description", "fitting to a set of <B>position</B> vectors.", "PK Reference - PK_VECTOR_make_lsq_plane_o_t");
top.note("headers/pk_vector_transform.html#declaration", " PK_VECTOR_t *const ptrans --- new <B>position</B>", "PK Reference - PK_VECTOR_transform");
top.note("headers/pk_vector_transform.html#description", " This function applies the given transform to the <B>position</B> vector and", "PK Reference - PK_VECTOR_transform");
top.note("headers/pk_vector_transform.html#errors", " transform and <B>position</B> p is such that the <B>position</B>", "PK Reference - PK_VECTOR_transform");
top.note("headers/pk_vertex_optimise.html#description", " tolerant vertex, this function attempts to modify the <B>position</B> of", "PK Reference - PK_VERTEX_optimise");
top.note("headers/pk_vertex_optimise.html#documentation", "PK_VERTEX_optimise_success_c indicates that the vertex <B>position</B> has been", "PK Reference - PK_VERTEX_optimise");
top.note("headers/pk_vertex_optimise_result_t.html#documentation", " maximum deviation. The <B>position</B> of the", "PK Reference - PK_VERTEX_optimise_result_t");
top.note("headers/pk_vertex_t.html#description", " represents a VERTEX. A vertex is a single <B>position</B> in 3D space.", "PK Reference - PK_VERTEX_t");
top.note("chapters/di_chap.05.html#50511937_pgfId-275195", " sets of four values, defining both the vector <B>position</B> of the change in visibility and its parameter", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275196", " geom[0...2] vector <B>position</B> of first change in visibility ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275198", " geom[i...i+2] nth vector <B>position</B>, where i = 4(n-1) ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.05.html#50511937_pgfId-275232", " The <B>position</B> ", "Downward Interfaces - Graphical Output");
top.note("chapters/di_chap.09.html#50511941_pgfId-286040", " be written to the array, but the file <B>position</B> should be advanced. ", "Downward Interfaces - PK_DELTA Functions");
top.note("chapters/di_chap.12.html#50511944_pgfId-290271", " from the open file starting at the current <B>position</B> of the file pointer. ", "Downward Interfaces - Indexed I/O Functions");
top.note("chapters/kd_chap.04.html#50475012_pgfId-273846", " operations on itself to modify its shape or <B>position</B> in space. ", "KID Manual - Object-Oriented KID");
top.note("chapters/kd_chap.06.html#50475013_pgfId-273891", " top and bottom, which can be used to <B>position</B> further primitives. ", "KID Manual - Creation of Primitives");
top.note("chapters/kd_chap.15.html#50475034_pgfId-273900", " is invoked with just one argument ( the <B>position</B> vector of the eye point in model space),", "KID Manual - Picking");
top.note("chapters/kd_chap.17.html#50475020_pgfId-291470", " parameters at <B>position</B> ", "KID Manual - KID Class Structure");
top.note("chapters/kd_chap.17.html#50475020_pgfId-291482", " <B>position</B> at parameters ", "KID Manual - KID Class Structure");
top.note("chapters/kd_chap.17.html#50475020_pgfId-291530", " parameter at <B>position</B> ", "KID Manual - KID Class Structure");
top.note("chapters/kd_chap.17.html#50475020_pgfId-291542", " <B>position</B> at parameter ", "KID Manual - KID Class Structure");
top.note("chapters/fg_chap.02.html#50462725_pgfId-273853", " able to supply (via the FG module interface) <B>position</B> and derivatives at specific parameter values. ", "FG Manual - Introduction and Summary");
top.note("chapters/fg_chap.02.html#50462725_pgfId-273855", " and be able to supply <B>position</B>, first and second derivatives over this interval. ", "FG Manual - Introduction and Summary");
top.note("chapters/fg_chap.02.html#50462725_pgfId-273860", " and must be able to supply <B>position</B>, first and all second derivatives over this region.", "FG Manual - Introduction and Summary");
top.note("chapters/fg_chap.02.html#50462725_pgfId-273891", " They are also passed details of the specific <B>position</B> and derivatives required and an array in which", "FG Manual - Introduction and Summary");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274713", " Parameter <B>position</B> (u, v). Parasolid ensures that only parameter values", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274715", " for the evaluator to return its results. Each <B>position</B> or derivative is stored in three elements of", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-282519", " is requested and n points to the correct <B>position</B> in the results array. More details on these", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.03.html#50462724_pgfId-274732", " array in row order. For example, counting from <B>position</B> 0 (in Fortran add 1 to these positions):", "FG Manual - Implementing an FG System");
top.note("chapters/fg_chap.05.html#50462729_pgfId-274057", " tangent vector, and to be C1 continuous if <B>position</B> and first derivative are both continuous. ", "FG Manual - Geometric Restrictions");
top.note("chapters/fg_chap.05.html#50462729_pgfId-274058", " normal vector, and to be C1 continuous if <B>position</B> and first derivatives are all continuous. C1 continuity", "FG Manual - Geometric Restrictions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274550", " Parasolid. The function should be capable of supplying <B>position</B> and up to second derivatives for a foreign", "FG Manual - FG Module Interface Functions");
top.note("chapters/fg_chap.06.html#50462723_pgfId-274721", " Parasolid. The function should be capable of supplying <B>position</B> and up to second derivatives for a foreign", "FG Manual - FG Module Interface Functions");
top.display();
//-->
</SCRIPT>
</HEAD>
<BODY bgcolor=#FFFFFF link=#0F3A68 vlink=#878787 alink=#FF7600 leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
</BODY>
</HTML>
