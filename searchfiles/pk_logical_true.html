<HTML>
<HEAD>
<LINK REL=STYLESHEET HREF=../ps_doc.css CHARSET=ISO-8859-1 TYPE=text/css>
<SCRIPT LANGUAGE="JavaScript">
<!--

top.note("chapters/fd_chap.003.html#50409782_pgfId-298415", " #define <B>PK_LOGICAL_true</B> 1 ", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.003.html#50409782_pgfId-449420", " is set to <B>PK_LOGICAL_true</B>, then PK_ENTITY_copy_2 returns a ", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.003.html#50409782_pgfId-449431", " is set to <B>PK_LOGICAL_true</B>, tracking information is recorded for all entity classes.", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.003.html#50409782_pgfId-449433", " options to <B>PK_LOGICAL_true</B> to copy or record the information relevant for that", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.012.html#50409792_pgfId-294873", " already been written. Therefore this function can only return <B>PK_LOGICAL_true</B> if called from within a callback or frustrum function", "Functional Description - Using Reports");
top.note("chapters/fd_chap.013.html#50409793_pgfId-295057", " a struct named PK.LOGICAL_t in C#. The associated values <B>PK_LOGICAL_true</B> and PK_LOGICAL_false become struct members PK.LOGICAL_t.@true and PK.LOGICAL_t.@false, where", "Functional Description - Calling Parasolid From .NET Code");
top.note("chapters/fd_chap.015.html#50409796_pgfId-295986", " respect to the surface normal. If this flag is <B>PK_LOGICAL_true</B>, then the face normal is parallel to the", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-296102", " by the edge/fin orientation flag. If this flag is <B>PK_LOGICAL_true</B>, then the direction of the edge or fin", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-884398", " is set to <B>PK_LOGICAL_true</B> then a 3-space box will be used to trim", "Functional Description - Model Structure");
top.note("chapters/fd_chap.015.html#50409796_pgfId-882036", " is set to <B>PK_LOGICAL_true</B> then a 3-space box will be used to trim", "Functional Description - Model Structure");
top.note("chapters/fd_chap.016.html#50409797_pgfId-297719", " is PK_LOGICAL_false. If set to <B>PK_LOGICAL_true</B>, then information about shared geometry is recorded in", "Functional Description - Body Types");
top.note("chapters/fd_chap.019.html#50409800_pgfId-1112018", " <B>PK_LOGICAL_true</B>, then ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-1112030", " <B>PK_LOGICAL_true</B>, then ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-298534", " must be <B>PK_LOGICAL_true</B>, and a tolerance must be supplied in ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-298811", " to <B>PK_LOGICAL_true</B>, and supply a suitable ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.019.html#50409800_pgfId-300496", " <B>PK_LOGICAL_true</B> (the default). For every parameter ", "Functional Description - B-Curves And B-Surfaces");
top.note("chapters/fd_chap.021.html#50409802_pgfId-357327", " is <B>PK_LOGICAL_true</B>, ", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-435076", " Defaults: <B>PK_LOGICAL_true</B>, (0, 0) ", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-435110", " Defaults: <B>PK_LOGICAL_true</B>, (0, 0) ", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-435137", " Defaults: <B>PK_LOGICAL_true</B>, (0, 0) ", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-547407", " If the associated sense of the embedded lattice is <B>PK_LOGICAL_true</B> (i.e. the lattice contains solid material), the region will", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-547548", " and the associated sense of the embedded lattice is <B>PK_LOGICAL_true</B>, the region density is copied to a new", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-459885", " <B>PK_LOGICAL_true</B>, the interior volume of the lattice is considered", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.021.html#50409802_pgfId-576097", " and a solid lattice (with a frame sense of <B>PK_LOGICAL_true</B>) embedded in a void region. ", "Functional Description - Lattice Geometry");
top.note("chapters/fd_chap.022.html#50409803_pgfId-373778", " array. If this is <B>PK_LOGICAL_true</B>, then: ", "Functional Description - Transformations");
top.note("chapters/fd_chap.022.html#50409803_pgfId-373784", " transformed exactly, or to within the specified tolerance. If <B>PK_LOGICAL_true</B>, then PK_GEOM_transform_2 returns an ", "Functional Description - Transformations");
top.note("chapters/fd_chap.028.html#50409808_pgfId-582985", " <B>PK_LOGICAL_true</B>, the chord between ", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.028.html#50409808_pgfId-579506", " option to <B>PK_LOGICAL_true</B>, thereby allowing PK_SURF_find_vectors to use the nearest path", "Functional Description - Enquiry And Output Functions");
top.note("chapters/fd_chap.031.html#50409811_pgfId-294933", " If <B>PK_LOGICAL_true</B>, find all the clashes between the two topologies.", "Functional Description - Clash Detection Of Bodies");
top.note("chapters/fd_chap.031.html#50409811_pgfId-294937", " If <B>PK_LOGICAL_true</B>, classify each clash between the two topologies, and", "Functional Description - Clash Detection Of Bodies");
top.note("chapters/fd_chap.031.html#50409811_pgfId-294945", " to <B>PK_LOGICAL_true</B>, you can supply an array of transforms to", "Functional Description - Clash Detection Of Bodies");
top.note("chapters/fd_chap.031.html#50409811_pgfId-294956", " is <B>PK_LOGICAL_true</B>, PK_TOPOL_clash returns information that classifies each type of", "Functional Description - Clash Detection Of Bodies");
top.note("chapters/fd_chap.032.html#50409812_pgfId-295230", " option is <B>PK_LOGICAL_true</B>, then any sub-entities of the given entity are", "Functional Description - Checking");
top.note("chapters/fd_chap.035.html#50409816_pgfId-361094", " to <B>PK_LOGICAL_true</B> and ", "Functional Description - Controlling Redundant Topology");
top.note("chapters/fd_chap.038.html#50409820_pgfId-308951", " is <B>PK_LOGICAL_true</B>, Parasolid creates a single body that contains all", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.038.html#50409820_pgfId-308956", " is PK_LOGICAL_false: you should only set it to <B>PK_LOGICAL_true</B> if ", "Functional Description - Creating Profiles");
top.note("chapters/fd_chap.039.html#50409821_pgfId-295057", "<B>PK_LOGICAL_true</B> The bound lies on the same side of the profile as the path (the default). ", "Functional Description - Creating Extruded Bodies");
top.note("chapters/fd_chap.039.html#50409821_pgfId-295077", "<B>PK_LOGICAL_true</B>: Use the nearest intersection for this bound (the default). ", "Functional Description - Creating Extruded Bodies");
top.note("chapters/fd_chap.039.html#50409821_pgfId-508160", " option is set to <B>PK_LOGICAL_true</B>, and the angle between adjacent polyline segments, when", "Functional Description - Creating Extruded Bodies");
top.note("chapters/fd_chap.039.html#50409821_pgfId-295583", " is <B>PK_LOGICAL_true</B>, divisions are numbered from the profile outwards, so", "Functional Description - Creating Extruded Bodies");
top.note("chapters/fd_chap.040.html#50409822_pgfId-298409", " to topology created by the sweep are minimised. Default: <B>PK_LOGICAL_true</B>. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-298410", " to <B>PK_LOGICAL_true</B> whenever possible. ", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-298414", " is <B>PK_LOGICAL_true</B>, rational B-surfaces may be used in the resulting", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-300322", " if <B>PK_LOGICAL_true</B>, then the swept body is trimmed so that", "Functional Description - Sweeping");
top.note("chapters/fd_chap.040.html#50409822_pgfId-300342", " is <B>PK_LOGICAL_true</B>, two different trimmed results are possible, depending on", "Functional Description - Sweeping");
top.note("chapters/fd_chap.041.html#50409823_pgfId-325560", " B-surfaces may be used in the resulting body. Default: <B>PK_LOGICAL_true</B> ", "Functional Description - Sweeping Tool Bodies Along a Path");
top.note("chapters/fd_chap.041.html#50409823_pgfId-325582", " a lock direction for the sweep. If set to <B>PK_LOGICAL_true</B>, the sweep direction and the orientation of the", "Functional Description - Sweeping Tool Bodies Along a Path");
top.note("chapters/fd_chap.041.html#50409823_pgfId-538291", " is <B>PK_LOGICAL_true</B>: ", "Functional Description - Sweeping Tool Bodies Along a Path");
top.note("chapters/fd_chap.042.html#50409824_pgfId-296920", " option to <B>PK_LOGICAL_true</B>, then the topology from any construction profiles is", "Functional Description - Lofting");
top.note("chapters/fd_chap.042.html#50409824_pgfId-297146", " is <B>PK_LOGICAL_true</B>, PK_BODY_make_lofted_body returns extra tracking information for edges that", "Functional Description - Lofting");
top.note("chapters/fd_chap.044.html#50409826_pgfId-296932", ". If <B>PK_LOGICAL_true</B>, side faces are created from the laminar edges", "Functional Description - Creating Emboss Features");
top.note("chapters/fd_chap.046.html#50409829_pgfId-294912", " Whether to repair self-intersecting bodies. If this is <B>PK_LOGICAL_true</B>, any edge pairs that still intersect after offsetting,", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-358540", " general wire bodies can be created. If this is <B>PK_LOGICAL_true</B> and general topology is enabled ( PK_SESSION_set_general_topology ), a", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295298", " If <B>PK_LOGICAL_true</B>, then curves that have dependent geometry (e.g. sp-curves,", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295305", " If <B>PK_LOGICAL_true</B>, then any nominal geometry specified on a received", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.046.html#50409829_pgfId-295307", " If this is <B>PK_LOGICAL_true</B>, and ", "Functional Description - Wire Modeling");
top.note("chapters/fd_chap.047.html#50409830_pgfId-467491", " Default: <B>PK_LOGICAL_true</B> ", "Functional Description - Sheet Modeling");
top.note("chapters/fd_chap.047.html#50409830_pgfId-296736", " <B>PK_LOGICAL_true</B>: keep any face sets which have a face", "Functional Description - Sheet Modeling");
top.note("chapters/fd_chap.048.html#50409831_pgfId-295192", " If set to <B>PK_LOGICAL_true</B> this option enables PK_BODY_sew_bodies to return several disjoint composite", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-295200", " If set to <B>PK_LOGICAL_true</B>, PK_BODY_sew_bodies assumes that the input data is intended", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.048.html#50409831_pgfId-360912", " <B>PK_LOGICAL_true</B> ", "Functional Description - Sewing and Knitting");
top.note("chapters/fd_chap.049.html#50409832_pgfId-358843", " for the operation before a sheet is generated. If <B>PK_LOGICAL_true</B>, a neutral sheet is created. If PK_LOGICAL_false, no", "Functional Description - Mid-Surface Generation");
top.note("chapters/fd_chap.049.html#50409832_pgfId-396887", " is set to <B>PK_LOGICAL_true</B>, a neutral sheet is created. With the option", "Functional Description - Mid-Surface Generation");
top.note("chapters/fd_chap.049.html#50409832_pgfId-358988", " is <B>PK_LOGICAL_true</B>, then ", "Functional Description - Mid-Surface Generation");
top.note("chapters/fd_chap.049.html#50409832_pgfId-359173", " However, we recommend that you set this option to <B>PK_LOGICAL_true</B> when dealing with new models. ", "Functional Description - Mid-Surface Generation");
top.note("chapters/fd_chap.050.html#50409833_pgfId-296344", " <B>PK_LOGICAL_true</B> ", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-296350", " Note: When modify is <B>PK_LOGICAL_true</B>, the configuration of boundary edges and vertices depends", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-296385", ": <B>PK_LOGICAL_true</B> ", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-296397", ": <B>PK_LOGICAL_true</B> ", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-296972", " in an invalid surface, then setting this option to <B>PK_LOGICAL_true</B> attempts to extend the surface as far as possible,", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.050.html#50409833_pgfId-297047", " is <B>PK_LOGICAL_true</B>, then the surface is extended as far as", "Functional Description - Extending Sheets And Surfaces");
top.note("chapters/fd_chap.052.html#50409836_pgfId-362511", " option (Default: <B>PK_LOGICAL_true</B>). ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-944966", " option. When set to <B>PK_LOGICAL_true</B>, the parameter intervals on the input curves that", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-711892", " is <B>PK_LOGICAL_true</B>, ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-526849", " is <B>PK_LOGICAL_true</B>). ", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-631937", " If <B>PK_LOGICAL_true</B>, then any curves that are coincident with the", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.052.html#50409836_pgfId-296292", " If <B>PK_LOGICAL_true</B>, edges and vertices imprinted on the body are", "Functional Description - Imprinting and Curve Projection");
top.note("chapters/fd_chap.053.html#50409837_pgfId-491650", " <B>PK_LOGICAL_true</B>: The target edge survives, unless both (a) the", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394613", " and sectioning operations, this field can be set to <B>PK_LOGICAL_true</B> if ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394617", " For imprinting operations, this field must be set to <B>PK_LOGICAL_true</B> if ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-394621", " Note: This field should only be set to <B>PK_LOGICAL_true</B> if ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-395333", " is <B>PK_LOGICAL_true</B>, the boundaries of the ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.053.html#50409837_pgfId-938574", " option to <B>PK_LOGICAL_true</B> and have general topology enabled in the session. ", "Functional Description - Introduction to Booleans");
top.note("chapters/fd_chap.055.html#50409839_pgfId-294952", " is <B>PK_LOGICAL_true</B>), this represents the highest dimension of topology that", "Functional Description - General Booleans");
top.note("chapters/fd_chap.055.html#50409839_pgfId-294959", " is <B>PK_LOGICAL_true</B>), this represents the highest dimension of topology that", "Functional Description - General Booleans");
top.note("chapters/fd_chap.055.html#50409839_pgfId-294969", " is <B>PK_LOGICAL_true</B> then the part of the tool that lies internal", "Functional Description - General Booleans");
top.note("chapters/fd_chap.055.html#50409839_pgfId-295024", " <B>PK_LOGICAL_true</B> ", "Functional Description - General Booleans");
top.note("chapters/fd_chap.055.html#50409839_pgfId-295030", " <B>PK_LOGICAL_true</B> ", "Functional Description - General Booleans");
top.note("chapters/fd_chap.055.html#50409839_pgfId-295032", " <B>PK_LOGICAL_true</B> ", "Functional Description - General Booleans");
top.note("chapters/fd_chap.055.html#50409839_pgfId-295038", " <B>PK_LOGICAL_true</B> ", "Functional Description - General Booleans");
top.note("chapters/fd_chap.056.html#50409840_pgfId-294903", " to <B>PK_LOGICAL_true</B> in PK_FACE_instance_tools . ", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-294956", " If <B>PK_LOGICAL_true</B>, when two coincident faces are combined in the", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-294970", " <B>PK_LOGICAL_true</B>: The target edge survives, unless both (a) the", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-295076", " optimal performance in PK_FACE_instance_bodies , this option should be <B>PK_LOGICAL_true</B>, and any tools supplied must not intersect with", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.056.html#50409840_pgfId-298422", " option. If this field is <B>PK_LOGICAL_true</B>, PK_FACE_instance_tools returns tracking information. This tracking information includes:", "Functional Description - Instancing And Patterning ");
top.note("chapters/fd_chap.057.html#50409620_pgfId-294818", " <B>PK_LOGICAL_true</B>: The target edge survives, unless both ", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-296168", " If <B>PK_LOGICAL_true</B>, a tool body that is disjoint after the", "Functional Description - Sectioning");
top.note("chapters/fd_chap.057.html#50409620_pgfId-296183", " field (described below) in the options structure to <B>PK_LOGICAL_true</B>; this will enable Parasolid to use additional target", "Functional Description - Sectioning");
top.note("chapters/fd_chap.060.html#50409845_pgfId-294802", " bodies as part of the operation. Setting this to <B>PK_LOGICAL_true</B> can sometimes produce results that might otherwise fail or", "Functional Description - Offsetting");
top.note("chapters/fd_chap.060.html#50409845_pgfId-294908", " is set to <B>PK_LOGICAL_true</B>, information regarding the faces that have been repaired", "Functional Description - Offsetting");
top.note("chapters/fd_chap.060.html#50409845_pgfId-516220", " is set to <B>PK_LOGICAL_true</B>, then information about any repairs that have been", "Functional Description - Offsetting");
top.note("chapters/fd_chap.065.html#50409851_pgfId-301090", " that are created by the operation. If this is <B>PK_LOGICAL_true</B>, then checking results are returned in a report", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.065.html#50409851_pgfId-301833", " Note: You cannot set this option to <B>PK_LOGICAL_true</B> if ", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.065.html#50409851_pgfId-321847", " If <B>PK_LOGICAL_true</B>, PK_FACE_delete_facesets returns a disjoint body if deleting face", "Functional Description - Deleting Entities ");
top.note("chapters/fd_chap.066.html#50409852_pgfId-295085", " option is <B>PK_LOGICAL_true</B>, you can return alternate facesets in a body.", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296277", " to <B>PK_LOGICAL_true</B> and specify the largest angle across which you want", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296338", " is <B>PK_LOGICAL_true</B>, then the radius of each blend returned by", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296339", " is <B>PK_LOGICAL_true</B>, then the convexity of each blend returned by", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-296987", " is <B>PK_LOGICAL_true</B>, ", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.066.html#50409852_pgfId-368315", " is <B>PK_LOGICAL_true</B>, this contains a profile for the hole. This", "Functional Description - Identifying And Simplifying Model Details");
top.note("chapters/fd_chap.068.html#50409854_pgfId-1395156", " Default: <B>PK_LOGICAL_true</B> ", "Functional Description - Face Tapering");
top.note("chapters/fd_chap.069.html#50409855_pgfId-1417383", " is set to <B>PK_LOGICAL_true</B> ", "Functional Description - Body Tapering");
top.note("chapters/fd_chap.070.html#50409856_pgfId-311024", " is <B>PK_LOGICAL_true</B>, then the supplied ", "Functional Description - Patching");
top.note("chapters/fd_chap.071.html#50409857_pgfId-295657", " or not. The default value for this option is <B>PK_LOGICAL_true</B>, and this is the setting you should use", "Functional Description - Filling Holes In A Body");
top.note("chapters/fd_chap.073.html#50409859_pgfId-316686", ": Whether disjoint bodies can be produced. (Default: <B>PK_LOGICAL_true</B>) ", "Functional Description - Creating New Bodies From Existing Entities");
top.note("chapters/fd_chap.073.html#50409859_pgfId-317846", " is <B>PK_LOGICAL_true</B>, and therefore only 2 bodies are returned; one", "Functional Description - Creating New Bodies From Existing Entities");
top.note("chapters/fd_chap.074.html#50409860_pgfId-436820", " <B>PK_LOGICAL_true</B> - the face normal with ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-305851", " If <B>PK_LOGICAL_true</B>, the supplied ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-464384", " If this is <B>PK_LOGICAL_true</B>, then any new faces created by the call", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-784052", " Default: <B>PK_LOGICAL_true</B> ", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-464389", " <B>PK_LOGICAL_true</B> - if the body is split as a result", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.074.html#50409860_pgfId-464501", " that were extended during the operation. If this is <B>PK_LOGICAL_true</B>, then the Parasolid report stream contains a record", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.077.html#50409864_pgfId-624903", " is <B>PK_LOGICAL_true</B> or PK_LOGICAL_false. ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296102", " is <B>PK_LOGICAL_true</B>, and all other values are left at their", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296341", " option to <B>PK_LOGICAL_true</B>, ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296586", " option. Setting this to <B>PK_LOGICAL_true</B> projects the edges that form the notch normally onto", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296918", " If <B>PK_LOGICAL_true</B>, then vertex blending is switched on. The default", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.077.html#50409864_pgfId-296928", " is <B>PK_LOGICAL_true</B>, and all other values are left at their", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.079.html#50409866_pgfId-307445", " is <B>PK_LOGICAL_true</B>, then the blend is trimmed only once for", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-308303", " to <B>PK_LOGICAL_true</B> implies that the area behind the corresponding capping face", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-308891", " must be set to <B>PK_LOGICAL_true</B> in this example. In ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-309647", " to <B>PK_LOGICAL_true</B> and specify the largest angle across which you want", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-310556", " is <B>PK_LOGICAL_true</B>, the blend is extended along all the faces", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.079.html#50409866_pgfId-311333", " The default is PK_LOGICAL_false. This must be set to <B>PK_LOGICAL_true</B> for any help point to be used. ", "Functional Description - Face-Face Blending");
top.note("chapters/fd_chap.084.html#50409872_pgfId-526952", " is <B>PK_LOGICAL_true</B>, all parts containing facet geometry are returned. ", "Functional Description - Overview Of Convergent Modeling");
top.note("chapters/fd_chap.084.html#50409872_pgfId-526963", " is <B>PK_LOGICAL_true</B>, all orphan meshes and polylines are returned. ", "Functional Description - Overview Of Convergent Modeling");
top.note("chapters/fd_chap.086.html#50409874_pgfId-479008", " is <B>PK_LOGICAL_true</B> and ", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-479557", " is <B>PK_LOGICAL_true</B> and ", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-489418", " is <B>PK_LOGICAL_true</B> and ", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-490856", " option to <B>PK_LOGICAL_true</B>. When set to <B>PK_LOGICAL_true</B>, the meshes created will have the same normals", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-477940", " is <B>PK_LOGICAL_true</B> and ", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-477978", " is <B>PK_LOGICAL_true</B> and ", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-477982", " is <B>PK_LOGICAL_true</B> and ", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-477983", " is <B>PK_LOGICAL_true</B> and ", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-337988", " If <B>PK_LOGICAL_true</B>, the result is a single body which may", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-336173", " Default: <B>PK_LOGICAL_true</B> ", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-392116", " <B>PK_LOGICAL_true</B>, a single mesh which may contain disjoint components", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-373685", " is <B>PK_LOGICAL_true</B>, the value of ", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.086.html#50409874_pgfId-373717", " is <B>PK_LOGICAL_true</B>, this option must be set to a positive", "Functional Description - Converting Between Facet and Classic Geometry");
top.note("chapters/fd_chap.087.html#50409875_pgfId-343456", " is_relative_index:<B>PK_LOGICAL_true</B> ", "Functional Description - Creating PSM Data From Foreign Facet Data");
top.note("chapters/fd_chap.087.html#50409875_pgfId-339924", " is_relative_index:<B>PK_LOGICAL_true</B> ", "Functional Description - Creating PSM Data From Foreign Facet Data");
top.note("chapters/fd_chap.087.html#50409875_pgfId-342856", " is_relative_index:<B>PK_LOGICAL_true</B> ", "Functional Description - Creating PSM Data From Foreign Facet Data");
top.note("chapters/fd_chap.087.html#50409875_pgfId-340544", " is_relative_index:<B>PK_LOGICAL_true</B> ", "Functional Description - Creating PSM Data From Foreign Facet Data");
top.note("chapters/fd_chap.089.html#50409877_pgfId-343308", " If <B>PK_LOGICAL_true</B>, then a polyline is created for each chain", "Functional Description - Filling Holes In Facet Bodies");
top.note("chapters/fd_chap.090.html#50409878_pgfId-449168", " is <B>PK_LOGICAL_true</B> and the two mfacets do not share a normal", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.090.html#50409878_pgfId-382808", " information about each mloop. When this is set to <B>PK_LOGICAL_true</B>, the polylines that represent the mloop and the", "Functional Description - Performing Evaluations On Meshes");
top.note("chapters/fd_chap.092.html#50409881_pgfId-297889", " is <B>PK_LOGICAL_true</B>, the face normal is parallel to the surface", "Functional Description - Importing Data");
top.note("chapters/fd_chap.093.html#50409882_pgfId-308651", " the surface to fit SP-curves that stray outside (Default: <B>PK_LOGICAL_true</B>). ", "Functional Description - Exporting Data");
top.note("chapters/fd_chap.097.html#50409887_pgfId-325964", " == 0) return <B>PK_LOGICAL_true</B>; ", "Functional Description - Attributes");
top.note("chapters/fd_chap.098.html#50409888_pgfId-294894", " option is <B>PK_LOGICAL_true</B>, non-empty partitions can be deleted as well, together", "Functional Description - Partitions");
top.note("chapters/fd_chap.099.html#50409889_pgfId-294951", " is set to <B>PK_LOGICAL_true</B>). ", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-294954", " is <B>PK_LOGICAL_true</B> and an entity was modified in more than one", "Functional Description - Rollback");
top.note("chapters/fd_chap.099.html#50409889_pgfId-294973", " If <B>PK_LOGICAL_true</B> (the default), the following modifications may sometimes be reported:", "Functional Description - Rollback");
top.note("chapters/fd_chap.101.html#50409891_pgfId-294980", " by calling PK_BB_output_events with the empty argument set to <B>PK_LOGICAL_true</B> ", "Functional Description - Bulletin Board");
top.note("chapters/fd_chap.102.html#50409892_pgfId-295055", " part stored in partition data. If this option is <B>PK_LOGICAL_true</B>, then the specified key is assumed to contain", "Functional Description - Archives");
top.note("chapters/fd_chap.102.html#50409892_pgfId-295257", " option is left at the default value of <B>PK_LOGICAL_true</B>, then all attribute definitions available in the Parasolid", "Functional Description - Archives");
top.note("chapters/fd_chap.102.html#50409892_pgfId-295313", " If <B>PK_LOGICAL_true</B> (the default), all attribute definitions in the received partition", "Functional Description - Archives");
top.note("chapters/fd_chap.107.html#50409898_pgfId-304133", " If <B>PK_LOGICAL_true</B>, ", "Functional Description - Rendering Option Settings");
top.note("chapters/fd_chap.109.html#50409900_pgfId-313230", " option is <B>PK_LOGICAL_true</B>, then its companion must be a positive, non-zero", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-1023996", " is set to <B>PK_LOGICAL_true</B>, facets will be repeatedly refined until the width", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-1029693", " is set to <B>PK_LOGICAL_true</B>, the value of ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-314996", " of these fields can be set to the value <B>PK_LOGICAL_true</B> with one or more of the corresponding fields -", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.109.html#50409900_pgfId-315025", " of these fields can be set to the value <B>PK_LOGICAL_true</B> with one or both of the corresponding fields, ", "Functional Description - Facet Mesh Generation");
top.note("chapters/fd_chap.111.html#50409902_pgfId-379044", " If this is <B>PK_LOGICAL_true</B>, then the callback function must be thread safe", "Functional Description - Tabular Output Of Faceting");
top.note("chapters/fd_chap.113.html#50409904_pgfId-300832", " option is <B>PK_LOGICAL_true</B> (this is its default value). In all other cases,", "Functional Description - Picking Topology");
top.note("chapters/fd_chap.123.html#50409916_marker-294871", " = <B>PK_LOGICAL_true</B> whether Parasolid was running directly (i.e., a PK function", "Functional Description - Signal Handling");
top.note("chapters/p2_chap.03.html#sec_b_1_1", " angle to path tangent, unless have_lock_direction is set to <B>PK_LOGICAL_true</B> and lock_type equals PK_sweep_lock_path_and_dir_c or PK_sweep_lock_path_c, in which case", "PK Reference - PK token Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.05.html#sec_d_1_app", " angle to path tangent, unless have_lock_direction is set to <B>PK_LOGICAL_true</B> and lock_type equals PK_sweep_lock_path_and_dir_c or PK_sweep_lock_path_c, in which case", "PK Reference - PK token Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.07.html#sec_f_1_1", " to <B>PK_LOGICAL_true</B> and the value supplied", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_2", " amalgamate is <B>PK_LOGICAL_true</B> and", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_3", " PK_ERROR_bad_tolerance 1043 PK_GEOM_render_o_t have_curve_chord_tol is <B>PK_LOGICAL_true</B>", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_4", " merge_in_edge is <B>PK_LOGICAL_true</B> but", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.09.html#sec_h_1_1", " to <B>PK_LOGICAL_true</B> and the value supplied", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_3", " amalgamate is <B>PK_LOGICAL_true</B> and", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.10.html#sec_i_1_1", " amalgamate is <B>PK_LOGICAL_true</B> and", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_2", " <B>PK_LOGICAL_true</B>,", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_3", " PK_GEOM_render_o_t 1043 PK_ERROR_bad_tolerance have_curve_chord_tol is <B>PK_LOGICAL_true</B>", "PK Reference - PK Error Codes (Functional)");
top.note("chapters/p2_chap.10.html#sec_i_1_4", " to <B>PK_LOGICAL_true</B> and the value supplied", "PK Reference - PK Error Codes (Functional)");
top.note("headers/pk_appitem_is.html#description", " This function returns <B>PK_LOGICAL_true</B> if its argument is an appitem.", "PK Reference - PK_APPITEM_is");
top.note("headers/pk_attrib_ask_no_roll_o_t.html#documentation", " check_consistency If this is set to <B>PK_LOGICAL_true</B>, then for", "PK Reference - PK_ATTRIB_ask_no_roll_o_t");
top.note("headers/pk_attrib_cb_f_t.html#documentation", "The function returns <B>PK_LOGICAL_true</B> if the attribute matches the applications", "PK Reference - PK_ATTRIB_cb_f_t");
top.note("headers/pk_bb_is_empty.html#description", " This function returns <B>PK_LOGICAL_true</B> if the Bulletin Board is off, or on and", "PK Reference - PK_BB_is_empty");
top.note("headers/pk_bb_output_events.html#documentation", "If empty is set to <B>PK_LOGICAL_true</B>, then all of these events are removed", "PK Reference - PK_BB_output_events");
top.note("headers/pk_bcurve_create_fitted_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_BCURVE_create_fitted_o_t");
top.note("headers/pk_bcurve_create_fitted_o_t.html#documentation", " If the value is <B>PK_LOGICAL_true</B>, then if the", "PK Reference - PK_BCURVE_create_fitted_o_t");
top.note("headers/pk_bcurve_create_spline_2_o_t.html#documentation", " of the positions . If is_periodic is <B>PK_LOGICAL_true</B>,", "PK Reference - PK_BCURVE_create_spline_2_o_t");
top.note("headers/pk_bcurve_create_spline_o_t.html#documentation", " have_clamp_axes This option must be set to <B>PK_LOGICAL_true</B> if and only if", "PK Reference - PK_BCURVE_create_spline_o_t");
top.note("headers/pk_bcurve_fit_eval_f_t.html#documentation", "If calculate_deriv is <B>PK_LOGICAL_true</B> then deriv should be the 1st", "PK Reference - PK_BCURVE_fit_eval_f_t");
top.note("headers/pk_bcurve_fit_fault_t.html#documentation", " no_faults this will have the value <B>PK_LOGICAL_true</B> if the fitting", "PK Reference - PK_BCURVE_fit_fault_t");
top.note("headers/pk_bcurve_lower_degree_o_t.html#documentation", " is <B>PK_LOGICAL_true</B>, then the bcurve will not be", "PK Reference - PK_BCURVE_lower_degree_o_t");
top.note("headers/pk_bcurve_make_bsurf_lofted.html#documentation", "If amalgamate is set to <B>PK_LOGICAL_true</B> then an attempt is made to", "PK Reference - PK_BCURVE_make_bsurf_lofted");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#errors", " amalgamate is <B>PK_LOGICAL_true</B> and", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#documentation", " amalgamate if this is set to <B>PK_LOGICAL_true</B> then the knot vectors", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_piecewise_sf_t.html#documentation", " is_rational == <B>PK_LOGICAL_true</B> then dim must be 4.", "PK Reference - PK_BCURVE_piecewise_sf_t");
top.note("headers/pk_bcurve_remove_knots_o_t.html#documentation", " is <B>PK_LOGICAL_true</B>, then the b-curve will not be", "PK Reference - PK_BCURVE_remove_knots_o_t");
top.note("headers/pk_blend_constraint_t.html#documentation", " <B>PK_LOGICAL_true</B>, a limit plane will trim the blend in", "PK Reference - PK_blend_constraint_t");
top.note("headers/pk_blend_fix_propagate_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>) [PF]", "PK Reference - PK_blend_fix_propagate_t");
top.note("headers/pk_blend_properties_t.html#declaration", " --- and fixed (<B>PK_LOGICAL_true</B>) [NF]", "PK Reference - PK_blend_properties_t");
top.note("headers/pk_blend_properties_t.html#documentation", " When draw_fix is <B>PK_LOGICAL_true</B>, the created unfixed blends are", "PK Reference - PK_blend_properties_t");
top.note("headers/pk_blend_setback_data_t.html#documentation", " If `which_end[i] is set to <B>PK_LOGICAL_true</B> , the", "PK Reference - PK_blend_setback_data_t");
top.note("headers/pk_blend_vx_blend_data_t.html#documentation", " vertex_blend when set to <B>PK_LOGICAL_true</B> switches vertex blending on.", "PK Reference - PK_blend_vx_blend_data_t");
top.note("headers/pk_blend_y_blend_data_t.html#documentation", " y_blend when set to <B>PK_LOGICAL_true</B> switches y-shaped vertex", "PK Reference - PK_blend_y_blend_data_t");
top.note("headers/pk_body_add_to_compound_o_t.html#documentation", " If <B>PK_LOGICAL_true</B>, and some geometries have been shared,", "PK Reference - PK_BODY_add_to_compound_o_t");
top.note("headers/pk_body_apply_knit_pattern_o_t.html#declaration", " PK_LOGICAL_t sort_face_shells; --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_BODY_apply_knit_pattern_o_t");
top.note("headers/pk_body_apply_knit_pattern_o_t.html#documentation", " sort_face_shells: If set to <B>PK_LOGICAL_true</B>, PK_BODY_apply_knit_pattern ", "PK Reference - PK_BODY_apply_knit_pattern_o_t");
top.note("headers/pk_body_ask_topology_o_t.html#documentation", " When it is set to <B>PK_LOGICAL_true</B>:", "PK Reference - PK_BODY_ask_topology_o_t");
top.note("headers/pk_body_boolean_2.html#errors", " merge_in_edge is <B>PK_LOGICAL_true</B> but", "PK Reference - PK_BODY_boolean_2");
top.note("headers/pk_body_boolean_o_t.html#documentation", " If this option is set to <B>PK_LOGICAL_true</B>,", "PK Reference - PK_BODY_boolean_o_t");
top.note("headers/pk_body_enlarge_o_t.html#documentation", " trimming_box If have_trimming_box is set to <B>PK_LOGICAL_true</B> then", "PK Reference - PK_BODY_enlarge_o_t");
top.note("headers/pk_body_extend_o_t.html#documentation", " (<B>PK_LOGICAL_true</B>) or always creates separate", "PK Reference - PK_BODY_extend_o_t");
top.note("headers/pk_body_extrude.html#documentation", "is <B>PK_LOGICAL_true</B> then the resulting body will contain disjoint components.", "PK Reference - PK_BODY_extrude");
top.note("headers/pk_body_extrude_o_t.html#declaration", " --- <B>PK_LOGICAL_true</B>,", "PK Reference - PK_BODY_extrude_o_t");
top.note("headers/pk_body_fill_hole_o_t.html#declaration", " --- ( <B>PK_LOGICAL_true</B> )", "PK Reference - PK_BODY_fill_hole_o_t");
top.note("headers/pk_body_find_facesets_o_t.html#documentation", " alternate If it is set to <B>PK_LOGICAL_true</B>, alternating facesets,", "PK Reference - PK_BODY_find_facesets_o_t");
top.note("headers/pk_body_fix_blends_o_t.html#documentation", " If local_check is set to <B>PK_LOGICAL_true</B>, then", "PK Reference - PK_BODY_fix_blends_o_t");
top.note("headers/pk_body_hollow_o_t.html#documentation", " report_sx If this is set to <B>PK_LOGICAL_true</B>, then a report will", "PK Reference - PK_BODY_hollow_o_t");
top.note("headers/pk_body_identify_facesets_o_t.html#declaration", " PK_LOGICAL_t check_manifold; --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_BODY_identify_facesets_o_t");
top.note("headers/pk_body_identify_facesets_o_t.html#documentation", " value is <B>PK_LOGICAL_true</B>, then the checks are carried", "PK Reference - PK_BODY_identify_facesets_o_t");
top.note("headers/pk_body_imprint_cus_normal_o_t.html#documentation", "`imprint_coi_exactly` If imprint_coi_exactly is set to <B>PK_LOGICAL_true</B>", "PK Reference - PK_BODY_imprint_cus_normal_o_t");
top.note("headers/pk_body_imprint_cus_shadow_o_t.html#documentation", "If the want_edges option is set to <B>PK_LOGICAL_true</B>, the tags of the new", "PK Reference - PK_BODY_imprint_cus_shadow_o_t");
top.note("headers/pk_body_imprint_cus_vec_o_t.html#documentation", " imprint_coi_exactly If imprint_coi_exactly is set to <B>PK_LOGICAL_true</B>", "PK Reference - PK_BODY_imprint_cus_vec_o_t");
top.note("headers/pk_body_imprint_faces_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_BODY_imprint_faces_o_t");
top.note("headers/pk_body_imprint_faces_o_t.html#documentation", " imprint_tool must be set to <B>PK_LOGICAL_true</B>", "PK Reference - PK_BODY_imprint_faces_o_t");
top.note("headers/pk_body_imprint_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_BODY_imprint_o_t");
top.note("headers/pk_body_imprint_o_t.html#documentation", " imprint_tool must be set to <B>PK_LOGICAL_true</B>", "PK Reference - PK_BODY_imprint_o_t");
top.note("headers/pk_body_make_compound_o_t.html#documentation", " If <B>PK_LOGICAL_true</B>, and some geometries have been shared,", "PK Reference - PK_BODY_make_compound_o_t");
top.note("headers/pk_body_make_curves_outline.html#documentation", " integers. If the value of want_body is set to <B>PK_LOGICAL_true</B>,", "PK Reference - PK_BODY_make_curves_outline");
top.note("headers/pk_body_make_curves_outline_o_t.html#documentation", " If this value is set to <B>PK_LOGICAL_true</B>, the curves", "PK Reference - PK_BODY_make_curves_outline_o_t");
top.note("headers/pk_body_make_facet_body_o_t.html#documentation", " <B>PK_LOGICAL_true</B> and max_facet_width is set to a", "PK Reference - PK_BODY_make_facet_body_o_t");
top.note("headers/pk_body_make_lofted_body.html#documentation", " If create_construction_topol is set to <B>PK_LOGICAL_true</B>, then additional", "PK Reference - PK_BODY_make_lofted_body");
top.note("headers/pk_body_make_lofted_body_o_t.html#documentation", " minimise_tolerance If set to <B>PK_LOGICAL_true</B>, topology will be created", "PK Reference - PK_BODY_make_lofted_body_o_t");
top.note("headers/pk_body_make_persp_outline_o_t.html#documentation", " If this value is set to <B>PK_LOGICAL_true</B>, the curves", "PK Reference - PK_BODY_make_persp_outline_o_t");
top.note("headers/pk_body_make_section.html#documentation", "If the tracking option is set to <B>PK_LOGICAL_true</B>, then tracking information", "PK Reference - PK_BODY_make_section");
top.note("headers/pk_body_make_section_o_t.html#documentation", " tracking If this option is set to <B>PK_LOGICAL_true</B>, tracking", "PK Reference - PK_BODY_make_section_o_t");
top.note("headers/pk_body_make_section_with_surfs.html#documentation", "If the tracking option is set to <B>PK_LOGICAL_true</B>, then tracking information", "PK Reference - PK_BODY_make_section_with_surfs");
top.note("headers/pk_body_make_spun_outline_o_t.html#documentation", " If this value is set to <B>PK_LOGICAL_true</B>, the curves", "PK Reference - PK_BODY_make_spun_outline_o_t");
top.note("headers/pk_body_make_swept_body_2.html#documentation", " have_lock_direction is set to <B>PK_LOGICAL_true</B>, and lock_type equals", "PK Reference - PK_BODY_make_swept_body_2");
top.note("headers/pk_body_make_swept_body_2_o_t.html#declaration", " --- possible (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_2_o_t.html#documentation", " have_twist_direction This option may only be set to <B>PK_LOGICAL_true</B> if a", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#declaration", " --- surfaces (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#documentation", " minimise_tolerance If set to <B>PK_LOGICAL_true</B>, topology will be created", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_make_swept_tool.html#documentation", "If want_edge_tracking is set to <B>PK_LOGICAL_true</B>, then the tracking records", "PK Reference - PK_BODY_make_swept_tool");
top.note("headers/pk_body_make_swept_tool_o_t.html#declaration", " --- surfaces (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_BODY_make_swept_tool_o_t");
top.note("headers/pk_body_make_swept_tool_o_t.html#documentation", " never be used in the resultant body. (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_BODY_make_swept_tool_o_t");
top.note("headers/pk_body_offset_o_t.html#documentation", " allow_disjoint If this flag is set to <B>PK_LOGICAL_true</B>, and if the", "PK Reference - PK_BODY_offset_o_t");
top.note("headers/pk_body_offset_planar_wire_o_t.html#documentation", " repair_self_int If this flag is set to <B>PK_LOGICAL_true</B>, the", "PK Reference - PK_BODY_offset_planar_wire_o_t");
top.note("headers/pk_body_pick_topols_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_BODY_pick_topols_o_t");
top.note("headers/pk_body_pick_topols_o_t.html#documentation", "value of ignore_excess_entities is set to <B>PK_LOGICAL_true</B>, all e_<entity>", "PK Reference - PK_BODY_pick_topols_o_t");
top.note("headers/pk_body_section_o_t.html#documentation", " selective_merge If this is set to <B>PK_LOGICAL_true</B>, the merge phase", "PK Reference - PK_BODY_section_o_t");
top.note("headers/pk_body_sew_bodies_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_BODY_sew_bodies_o_t");
top.note("headers/pk_body_sew_bodies_o_t.html#documentation", " being set to <B>PK_LOGICAL_true</B> and", "PK Reference - PK_BODY_sew_bodies_o_t");
top.note("headers/pk_body_share_geom.html#documentation", "If icurve_only is set to <B>PK_LOGICAL_true</B> then only intersection curves", "PK Reference - PK_BODY_share_geom");
top.note("headers/pk_body_simplify_geom.html#documentation", " o local = <B>PK_LOGICAL_true</B> - Local simplification", "PK Reference - PK_BODY_simplify_geom");
top.note("headers/pk_body_spin.html#documentation", "If local checking is switched on ( local_check = <B>PK_LOGICAL_true</B>), consistency", "PK Reference - PK_BODY_spin");
top.note("headers/pk_body_sweep.html#documentation", "If local checking is switched on ( local_check = <B>PK_LOGICAL_true</B>), consistency", "PK Reference - PK_BODY_sweep");
top.note("headers/pk_body_sweep_alignment_t.html#documentation", " set to <B>PK_LOGICAL_true</B> and lock_type ", "PK Reference - PK_BODY_sweep_alignment_t");
top.note("headers/pk_body_taper.html#documentation", "is set to <B>PK_LOGICAL_true</B>, then both sides must have the same number", "PK Reference - PK_BODY_taper");
top.note("headers/pk_body_taper_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_BODY_taper_o_t");
top.note("headers/pk_body_taper_o_t.html#documentation", " miter_at_parting If this flag is set to <B>PK_LOGICAL_true</B>, the", "PK Reference - PK_BODY_taper_o_t");
top.note("headers/pk_body_thicken_o_t.html#documentation", " report_sx If this is set to <B>PK_LOGICAL_true</B>, then a report will be", "PK Reference - PK_BODY_thicken_o_t");
top.note("headers/pk_body_transform_o_t.html#declaration", " --- if feasible (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_BODY_transform_o_t");
top.note("headers/pk_body_transform_o_t.html#documentation", " merge_face If this flag is set to <B>PK_LOGICAL_true</B>, the", "PK Reference - PK_BODY_transform_o_t");
top.note("headers/pk_body_trim.html#documentation", "If keep is set to <B>PK_LOGICAL_true</B> then any sets of faces which have a face", "PK Reference - PK_BODY_trim");
top.note("headers/pk_boolean_config_o_t.html#declaration", " PK_LOGICAL_t identical_intersect;--- (<B>PK_LOGICAL_true</B>) [PF]", "PK Reference - PK_boolean_config_o_t");
top.note("headers/pk_boolean_match_o_t.html#documentation", " For Imprinting, this MUST be set to <B>PK_LOGICAL_true</B> if", "PK Reference - PK_boolean_match_o_t");
top.note("headers/pk_bound_def_t.html#documentation", " nearest if <B>PK_LOGICAL_true</B> then divisions are numbered starting", "PK Reference - PK_bound_def_t");
top.note("headers/pk_bsurf_lower_degree_o_t.html#documentation", " is <B>PK_LOGICAL_true</B>, then the bsurf will not be", "PK Reference - PK_BSURF_lower_degree_o_t");
top.note("headers/pk_bsurf_piecewise_sf_t.html#documentation", " is_rational == <B>PK_LOGICAL_true</B> then dim must be 4.", "PK Reference - PK_BSURF_piecewise_sf_t");
top.note("headers/pk_bsurf_remove_knots_o_t.html#documentation", " is <B>PK_LOGICAL_true</B>, then the b-surface will not be", "PK Reference - PK_BSURF_remove_knots_o_t");
top.note("headers/pk_class_is_subclass.html#documentation", "The return argument is <B>PK_LOGICAL_true</B> if succession of calls to", "PK Reference - PK_CLASS_is_subclass");
top.note("headers/pk_curve_degen_t.html#documentation", " have_position If set to <B>PK_LOGICAL_true</B>, then a three-space position is", "PK Reference - PK_CURVE_degen_t");
top.note("headers/pk_curve_embed_in_surf_2.html#documentation", "the options structure should be set to <B>PK_LOGICAL_true</B> to indicate that the", "PK Reference - PK_CURVE_embed_in_surf_2");
top.note("headers/pk_curve_embed_in_surf_o_t.html#documentation", " surface. If set to <B>PK_LOGICAL_true</B> the section", "PK Reference - PK_CURVE_embed_in_surf_o_t");
top.note("headers/pk_curve_fix_self_int_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_CURVE_fix_self_int_o_t");
top.note("headers/pk_curve_fix_self_int_o_t.html#documentation", " If set to <B>PK_LOGICAL_true</B>, then multiple curves may be", "PK Reference - PK_CURVE_fix_self_int_o_t");
top.note("headers/pk_curve_make_bcurve.html#documentation", "is set to <B>PK_LOGICAL_true</B> if the result is exact, otherwise to", "PK Reference - PK_CURVE_make_bcurve");
top.note("headers/pk_curve_make_bcurve_array_o_t.html#documentation", " force_non_rational If set to <B>PK_LOGICAL_true</B>, B-curves are forced to be", "PK Reference - PK_CURVE_make_bcurve_array_o_t");
top.note("headers/pk_curve_make_bcurve_o_t.html#documentation", " force_non_rational If set to <B>PK_LOGICAL_true</B>, bcurve is forced to be", "PK Reference - PK_CURVE_make_bcurve_o_t");
top.note("headers/pk_curve_make_spcurves.html#documentation", " SP_Curves. If degenerate is <B>PK_LOGICAL_true</B> a zero length SP_Curve will be", "PK Reference - PK_CURVE_make_spcurves");
top.note("headers/pk_curve_make_spcurves_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_CURVE_make_spcurves_o_t");
top.note("headers/pk_curve_make_spcurves_o_t.html#documentation", " sense If sense is <B>PK_LOGICAL_true</B>, then the created", "PK Reference - PK_CURVE_make_spcurves_o_t");
top.note("headers/pk_curve_make_wire_body_2.html#documentation", "the options structure is set to <B>PK_LOGICAL_true</B>, then disjoint bodies can be", "PK Reference - PK_CURVE_make_wire_body_2");
top.note("headers/pk_curve_make_wire_body_o_t.html#declaration", " --- disjoint? (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_CURVE_make_wire_body_o_t");
top.note("headers/pk_curve_make_wire_body_o_t.html#documentation", " are set to <B>PK_LOGICAL_true</B>, more than two", "PK Reference - PK_CURVE_make_wire_body_o_t");
top.note("headers/pk_curve_project_o_t.html#declaration", " --- geometry (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_CURVE_project_o_t");
top.note("headers/pk_curve_spin_o_t.html#documentation", " If its value is <B>PK_LOGICAL_true</B> then, if possible,", "PK Reference - PK_CURVE_spin_o_t");
top.note("headers/pk_debug_body_compare_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_DEBUG_BODY_compare_o_t");
top.note("headers/pk_debug_body_extract_data.html#documentation", "<B>PK_LOGICAL_true</B> and the geometry will be returned in geom_array .", "PK Reference - PK_DEBUG_BODY_extract_data");
top.note("headers/pk_debug_report_start_o_t.html#declaration", " --- ( <B>PK_LOGICAL_true</B> )", "PK Reference - PK_DEBUG_report_start_o_t");
top.note("headers/pk_debug_report_start_o_t.html#documentation", " transmit_parts If <B>PK_LOGICAL_true</B>, then any necessary parts will be", "PK Reference - PK_DEBUG_report_start_o_t");
top.note("headers/pk_debug_try_error_handler_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_DEBUG_try_error_handler_o_t");
top.note("headers/pk_debug_try_error_handler_o_t.html#documentation", " use_protected If this is <B>PK_LOGICAL_true</B>, the call will be made from", "PK Reference - PK_DEBUG_try_error_handler_o_t");
top.note("headers/pk_detail_def_hole_t.html#documentation", " <B>PK_LOGICAL_true</B>, then this profile will be a wire body", "PK Reference - PK_detail_def_hole_t");
top.note("headers/pk_edge_ask_geometry.html#documentation", "the curve . If want_interval is set to <B>PK_LOGICAL_true</B>, then the parametric", "PK Reference - PK_EDGE_ask_geometry");
top.note("headers/pk_edge_ask_geometry_nmnl.html#documentation", "the curve . If want_interval is set to <B>PK_LOGICAL_true</B>, then the parametric", "PK Reference - PK_EDGE_ask_geometry_nmnl");
top.note("headers/pk_edge_ask_oriented_curve.html#documentation", "If orientation is <B>PK_LOGICAL_true</B>, then the edge direction is parallel to the", "PK Reference - PK_EDGE_ask_oriented_curve");
top.note("headers/pk_edge_attach_curve_nmnl_o_t.html#documentation", " t_int If have_interval is set to <B>PK_LOGICAL_true</B>, t_int ", "PK Reference - PK_EDGE_attach_curve_nmnl_o_t");
top.note("headers/pk_edge_euler_delete_make_loop.html#documentation", "manifold and have the same loop on both sides. If forward is <B>PK_LOGICAL_true</B>", "PK Reference - PK_EDGE_euler_delete_make_loop");
top.note("headers/pk_edge_euler_delete_with_face.html#documentation", " deletes an edge and a face. If on_left is <B>PK_LOGICAL_true</B> then", "PK Reference - PK_EDGE_euler_delete_with_face");
top.note("headers/pk_edge_euler_delete_with_loop.html#documentation", " deletes an edge and a loop. If on_left is <B>PK_LOGICAL_true</B> then", "PK Reference - PK_EDGE_euler_delete_with_loop");
top.note("headers/pk_edge_find_deviation_o_t.html#documentation", " curve. If this option is set to <B>PK_LOGICAL_true</B>, then such an", "PK Reference - PK_EDGE_find_deviation_o_t");
top.note("headers/pk_edge_find_g1_edges.html#documentation", "If convexity is <B>PK_LOGICAL_true</B>, then the function only considers tangent", "PK Reference - PK_EDGE_find_g1_edges");
top.note("headers/pk_edge_is_planar.html#documentation", " is_planar is returned as <B>PK_LOGICAL_true</B> if the function detects that the", "PK Reference - PK_EDGE_is_planar");
top.note("headers/pk_edge_make_wire_body_o_t.html#declaration", " --- (default <B>PK_LOGICAL_true</B>)", "PK Reference - PK_EDGE_make_wire_body_o_t");
top.note("headers/pk_edge_make_wire_body_o_t.html#documentation", " allow_disjoint If set to <B>PK_LOGICAL_true</B>, allows creation of", "PK Reference - PK_EDGE_make_wire_body_o_t");
top.note("headers/pk_edge_remove_to_bodies_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_EDGE_remove_to_bodies_o_t");
top.note("headers/pk_edge_remove_to_bodies_o_t.html#documentation", " allow_disjoint If this flag is set to <B>PK_LOGICAL_true</B>, and if the", "PK Reference - PK_EDGE_remove_to_bodies_o_t");
top.note("headers/pk_edge_repair.html#documentation", "If the option ensure_on_surfs is set to <B>PK_LOGICAL_true</B>, a suitable", "PK Reference - PK_EDGE_repair");
top.note("headers/pk_edge_repair_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_EDGE_repair_o_t");
top.note("headers/pk_edge_repair_o_t.html#documentation", " <B>PK_LOGICAL_true</B> then these large tolerances will not", "PK Reference - PK_EDGE_repair_o_t");
top.note("headers/pk_entity_ask_owning_groups_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_ENTITY_ask_owning_groups_o_t");
top.note("headers/pk_entity_ask_owning_groups_o_t.html#documentation", " (<B>PK_LOGICAL_true</B>), or whether it must have", "PK Reference - PK_ENTITY_ask_owning_groups_o_t");
top.note("headers/pk_entity_check_attribs_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_ENTITY_check_attribs_o_t");
top.note("headers/pk_entity_copy_o_t.html#documentation", " track_classes If want_tracking is set to <B>PK_LOGICAL_true</B> then this", "PK Reference - PK_ENTITY_copy_o_t");
top.note("headers/pk_entity_find_reparam_o_t.html#documentation", " stop_after_first If this is set to <B>PK_LOGICAL_true</B>, the function will", "PK Reference - PK_ENTITY_find_reparam_o_t");
top.note("headers/pk_entity_may_own_attdef.html#description", " This function returns <B>PK_LOGICAL_true</B> if an attribute constructed from the", "PK Reference - PK_ENTITY_may_own_attdef");
top.note("headers/pk_error_clear_last.html#documentation", "The value of was_error will be <B>PK_LOGICAL_true</B> if there was one.", "PK Reference - PK_ERROR_clear_last");
top.note("headers/pk_face_ask_faces_adjacent_o_t.html#documentation", " include_vertex_connected if set to <B>PK_LOGICAL_true</B>, all vertex-", "PK Reference - PK_FACE_ask_faces_adjacent_o_t");
top.note("headers/pk_face_ask_oriented_surf.html#documentation", "If orientation is <B>PK_LOGICAL_true</B>, then the face normal is parallel to the", "PK Reference - PK_FACE_ask_oriented_surf");
top.note("headers/pk_face_attach_surfs.html#documentation", "If `senses[i] is <B>PK_LOGICAL_true</B> then the face normal will point in the", "PK Reference - PK_FACE_attach_surfs");
top.note("headers/pk_face_boolean_o_t.html#documentation", " allow_disjoint If this option is set to <B>PK_LOGICAL_true</B>, the result", "PK Reference - PK_FACE_boolean_o_t");
top.note("headers/pk_face_change_data_replace_t.html#documentation", " <B>PK_LOGICAL_true</B> :", "PK Reference - PK_FACE_change_data_replace_t");
top.note("headers/pk_face_change_deform_o_t.html#errors", " <B>PK_LOGICAL_true</B>,", "PK Reference - PK_FACE_change_deform_o_t");
top.note("headers/pk_face_change_deform_o_t.html#documentation", " <B>PK_LOGICAL_true</B>, and SMP is enabled within Parasolid, then", "PK Reference - PK_FACE_change_deform_o_t");
top.note("headers/pk_face_change_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_change_o_t");
top.note("headers/pk_face_change_o_t.html#documentation", " merge_face If this flag is set to <B>PK_LOGICAL_true</B>, the", "PK Reference - PK_FACE_change_o_t");
top.note("headers/pk_face_change_offset_o_t.html#documentation", " report_sx If this is set to <B>PK_LOGICAL_true</B>, then a report will", "PK Reference - PK_FACE_change_offset_o_t");
top.note("headers/pk_face_change_radiate_o_t.html#documentation", " have_axis When set to <B>PK_LOGICAL_true</B>, axis is supplied", "PK Reference - PK_FACE_change_radiate_o_t");
top.note("headers/pk_face_contains_vectors_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_contains_vectors_o_t");
top.note("headers/pk_face_contains_vectors_o_t.html#documentation", "If is_on_surf is <B>PK_LOGICAL_true</B> then it is assumed that any given vectors ", "PK Reference - PK_FACE_contains_vectors_o_t");
top.note("headers/pk_face_cover_o_t.html#documentation", " <B>PK_LOGICAL_true</B>, then this should be larger than", "PK Reference - PK_FACE_cover_o_t");
top.note("headers/pk_face_delete_facesets_o_t.html#documentation", " allow_disjoint if set to <B>PK_LOGICAL_true</B>, then when the operation splits", "PK Reference - PK_FACE_delete_facesets_o_t");
top.note("headers/pk_face_delete_from_sheet.html#documentation", "bodies if the body is split during the operation. If set to <B>PK_LOGICAL_true</B>", "PK Reference - PK_FACE_delete_from_sheet");
top.note("headers/pk_face_delete_from_sheet_o_t.html#documentation", " allow_disjoint if set to <B>PK_LOGICAL_true</B>, then when the operation splits", "PK Reference - PK_FACE_delete_from_sheet_o_t");
top.note("headers/pk_face_delete_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_delete_o_t");
top.note("headers/pk_face_delete_o_t.html#errors", " <B>PK_LOGICAL_true</B> and heal_action ", "PK Reference - PK_FACE_delete_o_t");
top.note("headers/pk_face_delete_o_t.html#documentation", " <B>PK_LOGICAL_true</B>, a report of type PK_REPORT_1_t will be", "PK Reference - PK_FACE_delete_o_t");
top.note("headers/pk_face_details_hole_o_t.html#declaration", " --- ( <B>PK_LOGICAL_true</B> )", "PK Reference - PK_FACE_details_hole_o_t");
top.note("headers/pk_face_details_hole_o_t.html#documentation", " the model. If this is set to <B>PK_LOGICAL_true</B>, then the", "PK Reference - PK_FACE_details_hole_o_t");
top.note("headers/pk_face_fix_mesh_defects_o_t.html#documentation", " this is <B>PK_LOGICAL_true</B>, then max_deviation sets", "PK Reference - PK_FACE_fix_mesh_defects_o_t");
top.note("headers/pk_face_hollow_o_t.html#documentation", " report_sx If this is set to <B>PK_LOGICAL_true</B>, then a report will", "PK Reference - PK_FACE_hollow_o_t");
top.note("headers/pk_face_identify_blends_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_identify_blends_o_t");
top.note("headers/pk_face_identify_blends_o_t.html#documentation", " want_radii If this flag is set to <B>PK_LOGICAL_true</B> the radii of", "PK Reference - PK_FACE_identify_blends_o_t");
top.note("headers/pk_face_imprint_cus_isoclin_o_t.html#declaration", " PK_LOGICAL_t all_points; --- DEPRECATED (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_imprint_cus_isoclin_o_t");
top.note("headers/pk_face_imprint_cus_isoclin_o_t.html#documentation", " want_ret_faces If this option is set to <B>PK_LOGICAL_true</B>, the", "PK Reference - PK_FACE_imprint_cus_isoclin_o_t");
top.note("headers/pk_face_imprint_cus_normal_o_t.html#documentation", "`imprint_coi_exactly` If imprint_coi_exactly is set to <B>PK_LOGICAL_true</B>", "PK Reference - PK_FACE_imprint_cus_normal_o_t");
top.note("headers/pk_face_imprint_cus_vec_o_t.html#documentation", "`imprint_coi_exactly` If imprint_coi_exactly is set to <B>PK_LOGICAL_true</B>", "PK Reference - PK_FACE_imprint_cus_vec_o_t");
top.note("headers/pk_face_imprint_faces_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_imprint_faces_o_t");
top.note("headers/pk_face_imprint_faces_o_t.html#documentation", " imprint_tool must be set to <B>PK_LOGICAL_true</B>", "PK Reference - PK_FACE_imprint_faces_o_t");
top.note("headers/pk_face_imprint_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_imprint_o_t");
top.note("headers/pk_face_imprint_o_t.html#documentation", " imprint_tool must be set to <B>PK_LOGICAL_true</B>", "PK Reference - PK_FACE_imprint_o_t");
top.note("headers/pk_face_instance_bodies.html#documentation", "<B>PK_LOGICAL_true</B> when instanced tool bodies do intersect may result in", "PK Reference - PK_FACE_instance_bodies");
top.note("headers/pk_face_instance_bodies_o_t.html#documentation", " allow_disjoint If this option is set to <B>PK_LOGICAL_true</B>, the result", "PK Reference - PK_FACE_instance_bodies_o_t");
top.note("headers/pk_face_instance_tools.html#documentation", "If identical_intersect is set to <B>PK_LOGICAL_true</B> then an additional", "PK Reference - PK_FACE_instance_tools");
top.note("headers/pk_face_is_uvbox.html#declaration", " --- <B>PK_LOGICAL_true</B>", "PK Reference - PK_FACE_is_uvbox");
top.note("headers/pk_face_is_uvbox.html#documentation", "If is_uvbox is returned as <B>PK_LOGICAL_true</B> then uvbox will", "PK Reference - PK_FACE_is_uvbox");
top.note("headers/pk_face_make_3_face_blend_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_make_3_face_blend_o_t");
top.note("headers/pk_face_make_blend_o_t.html#documentation", " If this options is set to <B>PK_LOGICAL_true</B> the blend will", "PK Reference - PK_FACE_make_blend_o_t");
top.note("headers/pk_face_make_neutral_sheet_2.html#documentation", "If the option extend_and_fill_holes is set to <B>PK_LOGICAL_true</B> then the sheet", "PK Reference - PK_FACE_make_neutral_sheet_2");
top.note("headers/pk_face_make_neutral_sheet_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_make_neutral_sheet_o_t");
top.note("headers/pk_face_make_neutral_sheet_o_t.html#documentation", " <B>PK_LOGICAL_true</B>, then tolerance is used to determine", "PK Reference - PK_FACE_make_neutral_sheet_o_t");
top.note("headers/pk_face_make_sect_with_sfs_o_t.html#documentation", " tracking If this option is set to <B>PK_LOGICAL_true</B>, tracking", "PK Reference - PK_FACE_make_sect_with_sfs_o_t");
top.note("headers/pk_face_make_sheet_bodies_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_make_sheet_bodies_o_t");
top.note("headers/pk_face_make_sheet_bodies_o_t.html#documentation", " components. If it is set to <B>PK_LOGICAL_true</B>, then a", "PK Reference - PK_FACE_make_sheet_bodies_o_t");
top.note("headers/pk_face_offset.html#documentation", "face_face_check argument. If this is set to <B>PK_LOGICAL_true</B> then face-face", "PK Reference - PK_FACE_offset");
top.note("headers/pk_face_offset_o_t.html#documentation", " allow_disjoint If this flag is set to <B>PK_LOGICAL_true</B>, and if the", "PK Reference - PK_FACE_offset_o_t");
top.note("headers/pk_face_output_surf_trimmed.html#documentation", "direction (<B>PK_LOGICAL_true</B>) or opposite to (PK_LOGICAL_false) the face", "PK Reference - PK_FACE_output_surf_trimmed");
top.note("headers/pk_face_output_surf_trimmed_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_output_surf_trimmed_o_t");
top.note("headers/pk_face_output_surf_trimmed_o_t.html#documentation", " (default = <B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_output_surf_trimmed_o_t");
top.note("headers/pk_face_repair_o_t.html#declaration", " --- (default <B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_repair_o_t");
top.note("headers/pk_face_replace_surfs_2.html#documentation", " o <B>PK_LOGICAL_true</B>", "PK Reference - PK_FACE_replace_surfs_2");
top.note("headers/pk_face_replace_surfs_3.html#documentation", " o <B>PK_LOGICAL_true</B>", "PK Reference - PK_FACE_replace_surfs_3");
top.note("headers/pk_face_section_o_t.html#documentation", " selective_merge If this is set to <B>PK_LOGICAL_true</B>, the merge phase", "PK Reference - PK_FACE_section_o_t");
top.note("headers/pk_face_set_pair_t.html#documentation", " neutral sheet is to be trimmed. If it is <B>PK_LOGICAL_true</B>, then", "PK Reference - PK_FACE_set_pair_t");
top.note("headers/pk_face_simplify_geom.html#documentation", "structure is set to <B>PK_LOGICAL_true</B>, then the geoms array will be output.", "PK Reference - PK_FACE_simplify_geom");
top.note("headers/pk_face_spin.html#documentation", "If local checking is switched on ( local_check = <B>PK_LOGICAL_true</B>), consistency", "PK Reference - PK_FACE_spin");
top.note("headers/pk_face_sweep.html#documentation", "If local checking is switched on ( local_check = <B>PK_LOGICAL_true</B>), consistency", "PK Reference - PK_FACE_sweep");
top.note("headers/pk_face_taper_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_taper_o_t");
top.note("headers/pk_face_taper_o_t.html#documentation", " merge_face If this flag is set to <B>PK_LOGICAL_true</B>, the", "PK Reference - PK_FACE_taper_o_t");
top.note("headers/pk_face_transform_o_t.html#declaration", " --- if feasible (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FACE_transform_o_t");
top.note("headers/pk_face_transform_o_t.html#documentation", " merge_face If this flag is set to <B>PK_LOGICAL_true</B>, the", "PK Reference - PK_FACE_transform_o_t");
top.note("headers/pk_fin_ask_geometry.html#documentation", "the curve . If want_interval is set to <B>PK_LOGICAL_true</B>, then the parametric", "PK Reference - PK_FIN_ask_geometry");
top.note("headers/pk_fin_ask_oriented_curve.html#documentation", "If orientation is <B>PK_LOGICAL_true</B>, then the fin direction is parallel to the", "PK Reference - PK_FIN_ask_oriented_curve");
top.note("headers/pk_fin_euler_glue.html#documentation", "If same_dir is supplied <B>PK_LOGICAL_true</B> then fins from the second", "PK Reference - PK_FIN_euler_glue");
top.note("headers/pk_fin_find_curve_parameter.html#documentation", "If estimate is <B>PK_LOGICAL_true</B>, t_est will be used as an estimate of", "PK Reference - PK_FIN_find_curve_parameter");
top.note("headers/pk_fin_find_mtopols.html#documentation", "is also returned which is <B>PK_LOGICAL_true</B> if the mfins point in the same", "PK Reference - PK_FIN_find_mtopols");
top.note("headers/pk_fin_find_mtopols_o_t.html#declaration", " --- returned (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FIN_find_mtopols_o_t");
top.note("headers/pk_fin_find_mtopols_o_t.html#documentation", " (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_FIN_find_mtopols_o_t");
top.note("headers/pk_fin_find_surf_parameters.html#documentation", "If estimate is <B>PK_LOGICAL_true</B>, parms_est will be used as an", "PK Reference - PK_FIN_find_surf_parameters");
top.note("headers/pk_geom_enlarge_o_t.html#documentation", " trimming_box If have_trimming_box is set to <B>PK_LOGICAL_true</B> then", "PK Reference - PK_GEOM_enlarge_o_t");
top.note("headers/pk_geom_is_coincident.html#documentation", "position(s) in space, is_coincident will be returned as <B>PK_LOGICAL_true</B>,", "PK Reference - PK_GEOM_is_coincident");
top.note("headers/pk_geom_range.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_GEOM_range");
top.note("headers/pk_geom_range_array.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_GEOM_range_array");
top.note("headers/pk_geom_range_array_vector.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_GEOM_range_array_vector");
top.note("headers/pk_geom_range_local.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_GEOM_range_local");
top.note("headers/pk_geom_range_local_vector.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_GEOM_range_local_vector");
top.note("headers/pk_geom_range_vector.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_GEOM_range_vector");
top.note("headers/pk_geom_range_vector_many.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_GEOM_range_vector_many");
top.note("headers/pk_geom_render_o_t.html#errors", " PK_ERROR_bad_tolerance have_curve_chord_tol is <B>PK_LOGICAL_true</B>", "PK Reference - PK_GEOM_render_o_t");
top.note("headers/pk_geom_transform.html#documentation", "The returned argument exact is <B>PK_LOGICAL_true</B> if either in_geom is a", "PK Reference - PK_GEOM_transform");
top.note("headers/pk_geom_transform_2.html#documentation", "set to <B>PK_LOGICAL_true</B> for all of its fields.", "PK Reference - PK_GEOM_transform_2");
top.note("headers/pk_geom_transform_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_GEOM_transform_o_t");
top.note("headers/pk_geom_transform_o_t.html#documentation", " want_out_geoms If set to <B>PK_LOGICAL_true</B>, the out_geoms array for", "PK Reference - PK_GEOM_transform_o_t");
top.note("headers/pk_group_ask_closure_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_GROUP_ask_closure_o_t");
top.note("headers/pk_group_find_entities_o_t.html#declaration", " PK_LOGICAL_t want_entities; --- return entities (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_GROUP_find_entities_o_t");
top.note("headers/pk_group_find_entities_o_t.html#documentation", " entity_label If have_entity_label is <B>PK_LOGICAL_true</B> then only", "PK Reference - PK_GROUP_find_entities_o_t");
top.note("headers/pk_hole_component_t.html#documentation", "If the option face_tracking is <B>PK_LOGICAL_true</B>, the surface entities will", "PK Reference - PK_hole_component_t");
top.note("headers/pk_lattice_ask_regions_r_t.html#documentation", " <B>PK_LOGICAL_true</B> indicates that the interior of the lattice is", "PK Reference - PK_LATTICE_ask_regions_r_t");
top.note("headers/pk_lattice_clip.html#documentation", "If want_clipped_lballs was set to <B>PK_LOGICAL_true</B> in the options structure", "PK Reference - PK_LATTICE_clip");
top.note("headers/pk_lattice_combine_o_t.html#documentation", " this is <B>PK_LOGICAL_true</B>, then snap_tolerance sets", "PK Reference - PK_LATTICE_combine_o_t");
top.note("headers/pk_lattice_create_by_graph_o_t.html#documentation", " this is <B>PK_LOGICAL_true</B>, then snap_tolerance sets", "PK Reference - PK_LATTICE_create_by_graph_o_t");
top.note("headers/pk_lattice_do_for_all_lballs.html#documentation", " from more than one thread simultaneously. If set to <B>PK_LOGICAL_true</B>,", "PK Reference - PK_LATTICE_do_for_all_lballs");
top.note("headers/pk_lattice_do_for_all_lrods.html#documentation", " from more than one thread simultaneously. If set to <B>PK_LOGICAL_true</B>,", "PK Reference - PK_LATTICE_do_for_all_lrods");
top.note("headers/pk_lattice_find_nabox_o_t.html#errors", " both set to <B>PK_LOGICAL_true</B>", "PK Reference - PK_LATTICE_find_nabox_o_t");
top.note("headers/pk_lattice_find_nabox_o_t.html#documentation", "When have_axis1 is <B>PK_LOGICAL_true</B>, Parasolid will calculate a non-aligned", "PK Reference - PK_LATTICE_find_nabox_o_t");
top.note("headers/pk_law_sf_t.html#documentation", " This field should be set to <B>PK_LOGICAL_true</B> if the law is rational.", "PK Reference - PK_LAW_sf_t");
top.note("headers/pk_logical_t.html#documentation", " <B>PK_LOGICAL_true</B>", "PK Reference - PK_LOGICAL_t");
top.note("headers/pk_ltopol_is_null_m.html#documentation", " <B>PK_LOGICAL_true</B> : PK_LOGICAL_false \", "PK Reference - PK_LTOPOL_is_null_m");
top.note("headers/pk_mark_ask_forward.html#description", " This function returns <B>PK_LOGICAL_true</B> if roll-forward is enabled.", "PK Reference - PK_MARK_ask_forward");
top.note("headers/pk_mark_is_on.html#documentation", "This function returns <B>PK_LOGICAL_true</B> if rollback has been started via", "PK Reference - PK_MARK_is_on");
top.note("headers/pk_mark_start_o_t.html#declaration", " PK_LOGICAL_t forward; --- whether roll-forward is enabled (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_MARK_start_o_t");
top.note("headers/pk_mesh_defect_tolerances_t.html#documentation", " If have_degen_tolerance is set to <B>PK_LOGICAL_true</B> then", "PK Reference - PK_MESH_defect_tolerances_t");
top.note("headers/pk_mesh_eval_with_mtopol.html#documentation", " want_lowest_mfacet option is set to <B>PK_LOGICAL_true</B> (the default) the", "PK Reference - PK_MESH_eval_with_mtopol");
top.note("headers/pk_mesh_eval_with_mtopol_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_MESH_eval_with_mtopol_o_t");
top.note("headers/pk_mesh_eval_with_mtopol_o_t.html#documentation", " If want_lowest_mfacet is set to <B>PK_LOGICAL_true</B> (the default) the", "PK Reference - PK_MESH_eval_with_mtopol_o_t");
top.note("headers/pk_mesh_facet_fan_t.html#documentation", "{a,d,e} then, setting is_relative_index to <B>PK_LOGICAL_true</B>,", "PK Reference - PK_MESH_facet_fan_t");
top.note("headers/pk_mesh_facet_index_t.html#documentation", "If is_relative_index is <B>PK_LOGICAL_true</B>, then the facet_indices must be", "PK Reference - PK_MESH_facet_index_t");
top.note("headers/pk_mesh_facet_strip_t.html#documentation", " relative or absolute. When set to <B>PK_LOGICAL_true</B>,", "PK Reference - PK_MESH_facet_strip_t");
top.note("headers/pk_mesh_find_defects_o_t.html#documentation", " If have_tolerance is set to <B>PK_LOGICAL_true</B> then the value of", "PK Reference - PK_MESH_find_defects_o_t");
top.note("headers/pk_mesh_find_laminar_mfins_o_t.html#documentation", " want_plines If this flag is set to <B>PK_LOGICAL_true</B> then a", "PK Reference - PK_MESH_find_laminar_mfins_o_t");
top.note("headers/pk_mesh_find_sharp_mfins_o_t.html#declaration", " --- are returned (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_MESH_find_sharp_mfins_o_t");
top.note("headers/pk_mesh_find_sharp_mfins_o_t.html#documentation", " <B>PK_LOGICAL_true</B> when given this sharp_angle value. See", "PK Reference - PK_MESH_find_sharp_mfins_o_t");
top.note("headers/pk_mesh_find_sharp_mvxs_o_t.html#declaration", " --- are returned (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_MESH_find_sharp_mvxs_o_t");
top.note("headers/pk_mesh_fix_defects_o_t.html#documentation", " If have_tolerance is set to <B>PK_LOGICAL_true</B> then the values of", "PK Reference - PK_MESH_fix_defects_o_t");
top.note("headers/pk_mesh_imprint_vectors_o_t.html#documentation", " want_mvertices If set to <B>PK_LOGICAL_true</B>, an array of mvertices will", "PK Reference - PK_MESH_imprint_vectors_o_t");
top.note("headers/pk_mesh_make_bodies_o_t.html#declaration", " --- disjoint (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_MESH_make_bodies_o_t");
top.note("headers/pk_mesh_make_bodies_o_t.html#documentation", " If allow_disjoint is set to <B>PK_LOGICAL_true</B> then", "PK Reference - PK_MESH_make_bodies_o_t");
top.note("headers/pk_mesh_make_surf_trimmed.html#documentation", "direction (<B>PK_LOGICAL_true</B>) or opposite to (PK_LOGICAL_false) the mesh ", "PK Reference - PK_MESH_make_surf_trimmed");
top.note("headers/pk_mesh_make_surf_trimmed_o_t.html#documentation", " <B>PK_LOGICAL_true</B>, then this should be larger than", "PK Reference - PK_MESH_make_surf_trimmed_o_t");
top.note("headers/pk_mesh_store_normals_o_t.html#documentation", " If have_mesh_angle is set to <B>PK_LOGICAL_true</B> the supplied mesh_angle ", "PK Reference - PK_MESH_store_normals_o_t");
top.note("headers/pk_mfacet_find_perimeters_o_t.html#documentation", " want_plines If set to <B>PK_LOGICAL_true</B> then one or more", "PK Reference - PK_MFACET_find_perimeters_o_t");
top.note("headers/pk_mfin_is_sharp_o_t.html#documentation", " sharp_angle If have_sharp_angle is <B>PK_LOGICAL_true</B>, two", "PK Reference - PK_MFIN_is_sharp_o_t");
top.note("headers/pk_mtopol_is_null_m.html#documentation", " <B>PK_LOGICAL_true</B> : PK_LOGICAL_false \", "PK Reference - PK_MTOPOL_is_null_m");
top.note("headers/pk_mtopol_make_meshes_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_MTOPOL_make_meshes_o_t");
top.note("headers/pk_mtopol_make_meshes_o_t.html#documentation", " separate mesh. If set to <B>PK_LOGICAL_true</B> a single", "PK Reference - PK_MTOPOL_make_meshes_o_t");
top.note("headers/pk_mvertex_ask_normals_o_t.html#declaration", " --- returned (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_MVERTEX_ask_normals_o_t");
top.note("headers/pk_mvertex_is_laminar.html#description", " This function returns <B>PK_LOGICAL_true</B> if the given mvertex lies on the", "PK Reference - PK_MVERTEX_is_laminar");
top.note("headers/pk_param_sf_t.html#documentation", " if <B>PK_LOGICAL_true</B> then all derivatives are continuous, otherwise all", "PK Reference - PK_PARAM_sf_t");
top.note("headers/pk_part_ask_attribs_cb_o_t.html#declaration", " PK_LOGICAL_t want_attribs; --- return attributes (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_PART_ask_attribs_cb_o_t");
top.note("headers/pk_part_ask_groups_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_PART_ask_groups_o_t");
top.note("headers/pk_part_ask_groups_o_t.html#documentation", " (<B>PK_LOGICAL_true</B>), or whether it must have", "PK Reference - PK_PART_ask_groups_o_t");
top.note("headers/pk_part_receive_meshes.html#documentation", "<B>PK_LOGICAL_true</B> and any of the mesh owners are hidden by the cellular guise, a", "PK Reference - PK_PART_receive_meshes");
top.note("headers/pk_part_receive_meshes_o_t.html#documentation", " want_owners <B>PK_LOGICAL_true</B> if the optional array owners should be", "PK Reference - PK_PART_receive_meshes_o_t");
top.note("headers/pk_part_receive_o_t.html#documentation", " receive_user_fields <B>PK_LOGICAL_true</B> if user fields are to be received.", "PK Reference - PK_PART_receive_o_t");
top.note("headers/pk_part_transmit_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_PART_transmit_o_t");
top.note("headers/pk_part_transmit_o_t.html#documentation", " transmit_user_fields <B>PK_LOGICAL_true</B> if user fields are to be", "PK Reference - PK_PART_transmit_o_t");
top.note("headers/pk_partition_ask_facet_geom_o_t.html#documentation", " want_parts If set to <B>PK_LOGICAL_true</B>, all parts", "PK Reference - PK_PARTITION_ask_facet_geom_o_t");
top.note("headers/pk_partition_ask_pmarks_2_o_t.html#declaration", " --- pmarks (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_PARTITION_ask_pmarks_2_o_t");
top.note("headers/pk_partition_clone_pmark_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_PARTITION_clone_pmark_o_t");
top.note("headers/pk_partition_clone_pmark_o_t.html#documentation", " to <B>PK_LOGICAL_true</B>, only those entities that have been", "PK Reference - PK_PARTITION_clone_pmark_o_t");
top.note("headers/pk_partition_delete_o_t.html#documentation", " <B>PK_LOGICAL_true</B> then all model data in the partition, both", "PK Reference - PK_PARTITION_delete_o_t");
top.note("headers/pk_partition_has_lattices_o_t.html#documentation", " want_parts If set to <B>PK_LOGICAL_true</B>, all parts containing lattice geometry", "PK Reference - PK_PARTITION_has_lattices_o_t");
top.note("headers/pk_partition_is.html#description", " This function returns <B>PK_LOGICAL_true</B> if its argument is a partition.", "PK Reference - PK_PARTITION_is");
top.note("headers/pk_partition_is_clone_o_t.html#documentation", " box the box if have_box is <B>PK_LOGICAL_true</B>", "PK Reference - PK_PARTITION_is_clone_o_t");
top.note("headers/pk_partition_make_pmark_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_PARTITION_make_pmark_o_t");
top.note("headers/pk_partition_make_pmark_o_t.html#documentation", " to <B>PK_LOGICAL_true</B>, only those entities that have been", "PK Reference - PK_PARTITION_make_pmark_o_t");
top.note("headers/pk_partition_receive.html#documentation", " allow_missing_deltas is <B>PK_LOGICAL_true</B>, a partition file without its", "PK Reference - PK_PARTITION_receive");
top.note("headers/pk_partition_receive_b.html#documentation", " receive_prev_version_deltas is set to <B>PK_LOGICAL_true</B>, it is assumed that an", "PK Reference - PK_PARTITION_receive_b");
top.note("headers/pk_partition_receive_meshes.html#documentation", "<B>PK_LOGICAL_true</B> and any of the mesh owners are hidden by the cellular guise, a", "PK Reference - PK_PARTITION_receive_meshes");
top.note("headers/pk_partition_receive_meshes_o_t.html#documentation", " want_owners <B>PK_LOGICAL_true</B> if the optional array owners should be", "PK Reference - PK_PARTITION_receive_meshes_o_t");
top.note("headers/pk_partition_receive_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_PARTITION_receive_o_t");
top.note("headers/pk_partition_receive_o_t.html#documentation", " receive_user_fields <B>PK_LOGICAL_true</B> if user fields are to be received", "PK Reference - PK_PARTITION_receive_o_t");
top.note("headers/pk_partition_receive_u.html#documentation", " allow_missing_deltas is <B>PK_LOGICAL_true</B>, a partition file without its", "PK Reference - PK_PARTITION_receive_u");
top.note("headers/pk_partition_transmit_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_PARTITION_transmit_o_t");
top.note("headers/pk_partition_transmit_o_t.html#documentation", " transmit_user_fields <B>PK_LOGICAL_true</B> if user fields are to be transmitted.", "PK Reference - PK_PARTITION_transmit_o_t");
top.note("headers/pk_pattern_bound_t.html#declaration", " --- direction (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_pattern_bound_t");
top.note("headers/pk_pattern_bound_t.html#documentation", " <B>PK_LOGICAL_true</B> then the pattern is bound by the", "PK Reference - PK_pattern_bound_t");
top.note("headers/pk_pline_sf_t.html#documentation", " closed This field is set to <B>PK_LOGICAL_true</B> if the polyline is", "PK Reference - PK_PLINE_sf_t");
top.note("headers/pk_pmark_ask_entities_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_PMARK_ask_entities_o_t");
top.note("headers/pk_pmark_ask_entities_o_t.html#documentation", " to <B>PK_LOGICAL_true</B>, only those entities that would be", "PK Reference - PK_PMARK_ask_entities_o_t");
top.note("headers/pk_pmark_goto_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_PMARK_goto_o_t");
top.note("headers/pk_pmark_goto_o_t.html#documentation", " to <B>PK_LOGICAL_true</B>, only those entities that have been", "PK Reference - PK_PMARK_goto_o_t");
top.note("headers/pk_pmark_is.html#description", " This function returns <B>PK_LOGICAL_true</B> if its argument is a partition mark.", "PK Reference - PK_PMARK_is");
top.note("headers/pk_pmark_is_used_by_mark.html#description", " This function returns <B>PK_LOGICAL_true</B> if the given pmark is used in a session", "PK Reference - PK_PMARK_is_used_by_mark");
top.note("headers/pk_region_ask_lattices_r_t.html#documentation", " the sense of `lattices[i] in the region . <B>PK_LOGICAL_true</B>", "PK Reference - PK_REGION_ask_lattices_r_t");
top.note("headers/pk_region_embed_lattices.html#documentation", " o If `senses[i] is <B>PK_LOGICAL_true</B> then the interior of `lattices[i] is", "PK Reference - PK_REGION_embed_lattices");
top.note("headers/pk_region_is_solid.html#description", " This function returns <B>PK_LOGICAL_true</B> if the given region is solid and", "PK Reference - PK_REGION_is_solid");
top.note("headers/pk_report_is_open.html#description", " This function returns <B>PK_LOGICAL_true</B> if the given report is open and", "PK Reference - PK_REPORT_is_open");
top.note("headers/pk_session_ask_attdefs_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_SESSION_ask_attdefs_o_t");
top.note("headers/pk_session_ask_swept_spun_surfs.html#documentation", "If whether is returned as <B>PK_LOGICAL_true</B> then the functions:", "PK Reference - PK_SESSION_ask_swept_spun_surfs");
top.note("headers/pk_session_is_in_kernel.html#documentation", " <B>PK_LOGICAL_true</B> PK_LOGICAL_false execution is within a lightweight PK", "PK Reference - PK_SESSION_is_in_kernel");
top.note("headers/pk_session_is_in_kernel_2.html#documentation", " <B>PK_LOGICAL_true</B> PK_LOGICAL_false execution is within a lightweight PK", "PK Reference - PK_SESSION_is_in_kernel_2");
top.note("headers/pk_session_is_roll_forward_on.html#description", " This function returns <B>PK_LOGICAL_true</B> if the roll-forward interface parameter", "PK Reference - PK_SESSION_is_roll_forward_on");
top.note("headers/pk_session_is_rollback_on.html#description", " This function returns <B>PK_LOGICAL_true</B> if partitioned rollback has been enabled", "PK Reference - PK_SESSION_is_rollback_on");
top.note("headers/pk_session_receive_o_t.html#documentation", " receive_user_fields <B>PK_LOGICAL_true</B> if user fields are to be received", "PK Reference - PK_SESSION_receive_o_t");
top.note("headers/pk_session_register_fru_o_t.html#documentation", " PK_LOGICAL_t with value <B>PK_LOGICAL_true</B>, then Parasolid may call the GO", "PK Reference - PK_SESSION_register_fru_o_t");
top.note("headers/pk_session_set_swept_spun_surfs.html#documentation", "If whether is <B>PK_LOGICAL_true</B> then the functions:", "PK Reference - PK_SESSION_set_swept_spun_surfs");
top.note("headers/pk_session_smp_o_t.html#documentation", " on_single_processor <B>PK_LOGICAL_true</B> if SMP is to be enabled on", "PK Reference - PK_SESSION_smp_o_t");
top.note("headers/pk_session_smp_r_t.html#documentation", " on_single_processor <B>PK_LOGICAL_true</B> if SMP is to be enabled on", "PK Reference - PK_SESSION_smp_r_t");
top.note("headers/pk_session_start.html#documentation", " PK_SESSION_ask_check_arguments <B>PK_LOGICAL_true</B>", "PK Reference - PK_SESSION_start");
top.note("headers/pk_session_transmit_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_SESSION_transmit_o_t");
top.note("headers/pk_session_transmit_o_t.html#documentation", " transmit_user_fields <B>PK_LOGICAL_true</B> if user fields are to be transmitted", "PK Reference - PK_SESSION_transmit_o_t");
top.note("headers/pk_shell_ask_oriented_faces.html#documentation", "If the orientation is <B>PK_LOGICAL_true</B>, the faces normal points into the shell,", "PK Reference - PK_SHELL_ask_oriented_faces");
top.note("headers/pk_surf_degen_t.html#documentation", " three-space. If set to <B>PK_LOGICAL_true</B>, then the position", "PK Reference - PK_SURF_degen_t");
top.note("headers/pk_surf_eval.html#documentation", "Alternatively, if triangular is <B>PK_LOGICAL_true</B> then a triangular derivative", "PK Reference - PK_SURF_eval");
top.note("headers/pk_surf_find_vectors_o_t.html#documentation", "Otherwise, if have_proj_direction is set to <B>PK_LOGICAL_true</B>, the chord", "PK Reference - PK_SURF_find_vectors_o_t");
top.note("headers/pk_surf_fix_self_int_o_t.html#declaration", " --- to be generated (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_SURF_fix_self_int_o_t");
top.note("headers/pk_surf_fix_self_int_o_t.html#documentation", " If set to <B>PK_LOGICAL_true</B>, then multiple surfaces may be", "PK Reference - PK_SURF_fix_self_int_o_t");
top.note("headers/pk_surf_make_bsurf.html#documentation", "is set to <B>PK_LOGICAL_true</B> if the result is exact, otherwise to", "PK Reference - PK_SURF_make_bsurf");
top.note("headers/pk_surf_make_bsurf_2.html#documentation", "If force_cubic is set to <B>PK_LOGICAL_true</B>, then the resulting bsurf is", "PK Reference - PK_SURF_make_bsurf_2");
top.note("headers/pk_surf_make_bsurf_array.html#documentation", "<B>PK_LOGICAL_true</B> if the function succeeded in creating b-surfaces for all", "PK Reference - PK_SURF_make_bsurf_array");
top.note("headers/pk_surf_make_bsurf_array_o_t.html#documentation", " direction is specified. If this is set to <B>PK_LOGICAL_true</B>,", "PK Reference - PK_SURF_make_bsurf_array_o_t");
top.note("headers/pk_surf_make_bsurf_o_t.html#documentation", " force_cubic If set to <B>PK_LOGICAL_true</B>, the resultant surface will be", "PK Reference - PK_SURF_make_bsurf_o_t");
top.note("headers/pk_surf_make_curve_isoparam.html#documentation", "surface. If want_interval in the options is set to <B>PK_LOGICAL_true</B>,", "PK Reference - PK_SURF_make_curve_isoparam");
top.note("headers/pk_surf_make_curve_isoparam_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_SURF_make_curve_isoparam_o_t");
top.note("headers/pk_surf_make_curve_isoparam_o_t.html#documentation", "If want_interval is set to <B>PK_LOGICAL_true</B>, the interval of the portion of", "PK Reference - PK_SURF_make_curve_isoparam_o_t");
top.note("headers/pk_surf_make_cus_isocline_o_t.html#declaration", " PK_LOGICAL_t all_points; --- DEPRECATED (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_SURF_make_cus_isocline_o_t");
top.note("headers/pk_surf_make_sheet_trimmed.html#documentation", " With this option set to <B>PK_LOGICAL_true</B> checks are made to", "PK Reference - PK_SURF_make_sheet_trimmed");
top.note("headers/pk_thread_ask_exclusion.html#documentation", "value of was_this_thread set to <B>PK_LOGICAL_true</B> before other threads can", "PK Reference - PK_THREAD_ask_exclusion");
top.note("headers/pk_thread_clear_last_error.html#documentation", "The value of was_error will be <B>PK_LOGICAL_true</B> if there was one in the", "PK Reference - PK_THREAD_clear_last_error");
top.note("headers/pk_thread_lock_partitions_o_t.html#documentation", " want_locked_partitions If this flag is set to <B>PK_LOGICAL_true</B> then", "PK Reference - PK_THREAD_lock_partitions_o_t");
top.note("headers/pk_topol_ask_entities_by_attdef.html#documentation", " If have_attrib is set to <B>PK_LOGICAL_true</B> then selected entities", "PK Reference - PK_TOPOL_ask_entities_by_attdef");
top.note("headers/pk_topol_clash_o_t.html#documentation", " If find_all has the value <B>PK_LOGICAL_true</B>, it will", "PK Reference - PK_TOPOL_clash_o_t");
top.note("headers/pk_topol_delete_redundant_2_o_t.html#errors", " to <B>PK_LOGICAL_true</B> and the value supplied", "PK Reference - PK_TOPOL_delete_redundant_2_o_t");
top.note("headers/pk_topol_eval_mass_props_o_t.html#documentation", " single If this flag is set to <B>PK_LOGICAL_true</B>, and the", "PK Reference - PK_TOPOL_eval_mass_props_o_t");
top.note("headers/pk_topol_facet.html#documentation", "structure, set to <B>PK_LOGICAL_true</B> or PK_LOGICAL_false indicating whether", "PK Reference - PK_TOPOL_facet");
top.note("headers/pk_topol_facet_2.html#documentation", "structure. Setting these to <B>PK_LOGICAL_true</B> or PK_LOGICAL_false indicates", "PK Reference - PK_TOPOL_facet_2");
top.note("headers/pk_topol_facet_choice_2_o_t.html#documentation", "<B>PK_LOGICAL_true</B> or PK_LOGICAL_false indicating whether or not the application", "PK Reference - PK_TOPOL_facet_choice_2_o_t");
top.note("headers/pk_topol_facet_choice_o_t.html#documentation", "is set by the application to the value <B>PK_LOGICAL_true</B> or PK_LOGICAL_false", "PK Reference - PK_TOPOL_facet_choice_o_t");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#documentation", " <B>PK_LOGICAL_true</B> and the value set to a positive value. In", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#documentation", " <B>PK_LOGICAL_true</B> and the value set to a positive value. In", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_facet_r_t.html#documentation", "in PK_TOPOL_facet_choice_o_t to <B>PK_LOGICAL_true</B>), the table is returned with :", "PK Reference - PK_TOPOL_facet_r_t");
top.note("headers/pk_topol_find_nabox_o_t.html#errors", " both set to <B>PK_LOGICAL_true</B>", "PK Reference - PK_TOPOL_find_nabox_o_t");
top.note("headers/pk_topol_find_nabox_o_t.html#documentation", "When have_axis1 is <B>PK_LOGICAL_true</B>, Parasolid will calculate a non-aligned", "PK Reference - PK_TOPOL_find_nabox_o_t");
top.note("headers/pk_topol_identify_redundant_o_t.html#declaration", " --- (<B>PK_LOGICAL_true</B>)", "PK Reference - PK_TOPOL_identify_redundant_o_t");
top.note("headers/pk_topol_imprint_frames.html#documentation", "<B>PK_LOGICAL_true</B>, or void if the frames senses are PK_LOGICAL_false.", "PK Reference - PK_TOPOL_imprint_frames");
top.note("headers/pk_topol_make_facet_topol_o_t.html#errors", " PK_ERROR_bad_tolerance have_max_chord_length is <B>PK_LOGICAL_true</B>", "PK Reference - PK_TOPOL_make_facet_topol_o_t");
top.note("headers/pk_topol_make_facet_topol_o_t.html#documentation", " angular_tolerance : If have_angular_tolerance is <B>PK_LOGICAL_true</B>", "PK Reference - PK_TOPOL_make_facet_topol_o_t");
top.note("headers/pk_topol_range.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_TOPOL_range");
top.note("headers/pk_topol_range_array.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_TOPOL_range_array");
top.note("headers/pk_topol_range_array_vector.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_TOPOL_range_array_vector");
top.note("headers/pk_topol_range_geom.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_TOPOL_range_geom");
top.note("headers/pk_topol_range_geom_array.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_TOPOL_range_geom_array");
top.note("headers/pk_topol_range_local.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_TOPOL_range_local");
top.note("headers/pk_topol_range_local_vector.html#documentation", " <B>PK_LOGICAL_true</B> and PK_range_param_entity_sub_c ", "PK Reference - PK_TOPOL_range_local_vector");
top.note("headers/pk_topol_range_vector.html#documentation", " <B>PK_LOGICAL_true</B>, the solution is a regional solution upon", "PK Reference - PK_TOPOL_range_vector");
top.note("headers/pk_transf_create_view_o_t.html#documentation", " provided. If this variable is <B>PK_LOGICAL_true</B>,", "PK Reference - PK_TRANSF_create_view_o_t");
top.note("headers/pk_transf_enlarge.html#documentation", "<B>PK_LOGICAL_true</B>, in which case the given transf will be enlarged and", "PK Reference - PK_TRANSF_enlarge");
top.note("headers/pk_transf_enlarge_o_t.html#documentation", " <B>PK_LOGICAL_true</B>, the received transf will be modified.", "PK Reference - PK_TRANSF_enlarge_o_t");
top.note("headers/pk_transf_transform_2.html#documentation", "<B>PK_LOGICAL_true</B>, in which case it will be equal to transf_1 (i.e., the", "PK Reference - PK_TRANSF_transform_2");
top.note("headers/pk_transf_transform_o_t.html#documentation", " <B>PK_LOGICAL_true</B>, the received transf_1 will be modified.", "PK Reference - PK_TRANSF_transform_o_t");
top.note("headers/pk_ucoprd_f_t.html#documentation", " --- <B>PK_LOGICAL_true</B>:", "PK Reference - PK_UCOPRD_f_t");
top.note("headers/pk_vector_is_equal.html#description", "session precision. If they are, is_equal is set to <B>PK_LOGICAL_true</B>,", "PK Reference - PK_VECTOR_is_equal");
top.note("headers/pk_vector_is_parallel.html#description", "to <B>PK_LOGICAL_true</B>, otherwise to PK_LOGICAL_false.", "PK Reference - PK_VECTOR_is_parallel");
top.note("headers/pk_vector_is_zero.html#description", " session precision. If it is, is_zero is set to <B>PK_LOGICAL_true</B>,", "PK Reference - PK_VECTOR_is_zero");
top.note("headers/pk_vertex_ask_oriented_edges.html#documentation", "is <B>PK_LOGICAL_true</B>, the edge points towards the vertex, otherwise it", "PK Reference - PK_VERTEX_ask_oriented_edges");
top.note("headers/pk_vertex_spin.html#documentation", "If local checking local_check is <B>PK_LOGICAL_true</B>, consistency checks will be", "PK Reference - PK_VERTEX_spin");
top.note("headers/pk_vertex_sweep.html#documentation", "If local checking is switched on ( local_check = <B>PK_LOGICAL_true</B>), consistency", "PK Reference - PK_VERTEX_sweep");
top.display();
//-->
</SCRIPT>
</HEAD>
<BODY bgcolor=#FFFFFF link=#0F3A68 vlink=#878787 alink=#FF7600 leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
</BODY>
</HTML>
