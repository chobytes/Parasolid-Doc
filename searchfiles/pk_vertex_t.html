<HTML>
<HEAD>
<LINK REL=STYLESHEET HREF=../ps_doc.css CHARSET=ISO-8859-1 TYPE=text/css>
<SCRIPT LANGUAGE="JavaScript">
<!--

top.note("headers/pk_blend_limit_data_t.html#declaration", " const <B>PK_VERTEX_t</B> *vertices; --- vertices (NULL) [NF]", "PK Reference - PK_blend_limit_data_t");
top.note("headers/pk_blend_setback_shape_data_t.html#declaration", " const <B>PK_VERTEX_t</B> *vertices; --- array of vertices at which the", "PK Reference - PK_blend_setback_shape_data_t");
top.note("headers/pk_blend_vx_blend_data_t.html#declaration", " const <B>PK_VERTEX_t</B> *vertices; --- array of vertices to blend (NULL)", "PK Reference - PK_blend_vx_blend_data_t");
top.note("headers/pk_blend_vx_order_data_t.html#declaration", " const <B>PK_VERTEX_t</B> *vertices; --- vertices (NULL)", "PK Reference - PK_blend_vx_order_data_t");
top.note("headers/pk_blend_y_blend_data_t.html#declaration", " const <B>PK_VERTEX_t</B> *vertices; --- array of vertices to blend (NULL)", "PK Reference - PK_blend_y_blend_data_t");
top.note("headers/pk_body_ask_vertices.html#declaration", " <B>PK_VERTEX_t</B> **const vertices --- vertices (optional)", "PK Reference - PK_BODY_ask_vertices");
top.note("headers/pk_body_identify_facesets.html#declaration", "const <B>PK_VERTEX_t</B> target_vertices[], --- target vertices", "PK Reference - PK_BODY_identify_facesets");
top.note("headers/pk_body_loft_face_clamp_t.html#declaration", " const <B>PK_VERTEX_t</B> *vertices; --- array of vertices with scaling (NULL)", "PK Reference - PK_BODY_loft_face_clamp_t");
top.note("headers/pk_body_loft_vector_clamp_t.html#declaration", " const <B>PK_VERTEX_t</B> *vertices; --- array of vertices to be clamped (NULL)", "PK Reference - PK_BODY_loft_vector_clamp_t");
top.note("headers/pk_body_make_lofted_body.html#declaration", "const <B>PK_VERTEX_t</B> start_vertices[],--- start vertices", "PK Reference - PK_BODY_make_lofted_body");
top.note("headers/pk_body_make_swept_body.html#declaration", "const <B>PK_VERTEX_t</B> path_start, --- path start vertex", "PK Reference - PK_BODY_make_swept_body");
top.note("headers/pk_body_make_swept_body_2.html#declaration", "const <B>PK_VERTEX_t</B> path_vertices[], --- path vertices where", "PK Reference - PK_BODY_make_swept_body_2");
top.note("headers/pk_body_make_swept_body_2_o_t.html#declaration", " const <B>PK_VERTEX_t</B> *ignorable_vertices;", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#declaration", " const <B>PK_VERTEX_t</B> *ignorable_vertices;", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_make_swept_tool_o_t.html#declaration", " <B>PK_VERTEX_t</B> tool_site; --- vertex on the path corresponding", "PK Reference - PK_BODY_make_swept_tool_o_t");
top.note("headers/pk_body_one_vertex_match_t.html#declaration", " <B>PK_VERTEX_t</B> profile_vertex;", "PK Reference - PK_BODY_one_vertex_match_t");
top.note("headers/pk_body_sweep_law_discrete_t.html#declaration", " <B>PK_VERTEX_t</B> *vertices;", "PK Reference - PK_BODY_sweep_law_discrete_t");
top.note("headers/pk_body_trim_gap_analysis.html#declaration", " <B>PK_VERTEX_t</B> **const vertices --- problem vertices", "PK Reference - PK_BODY_trim_gap_analysis");
top.note("headers/pk_edge_ask_vertices.html#declaration", " <B>PK_VERTEX_t</B> vertices[2] --- vertices (possibly both PK_ENTITY_null)", "PK Reference - PK_EDGE_ask_vertices");
top.note("headers/pk_edge_curve_direction_t.html#declaration", " <B>PK_VERTEX_t</B> end_vertex; --- vertex sets direction", "PK Reference - PK_EDGE_curve_direction_t");
top.note("headers/pk_edge_euler_merge_vertices.html#declaration", " <B>PK_VERTEX_t</B> vertex --- Vertex to delete", "PK Reference - PK_EDGE_euler_merge_vertices");
top.note("headers/pk_edge_euler_open_zip.html#declaration", " <B>PK_VERTEX_t</B> *const new_vertex, --- New vertex created", "PK Reference - PK_EDGE_euler_open_zip");
top.note("headers/pk_edge_euler_split.html#declaration", " <B>PK_VERTEX_t</B> *const new_vertex, --- New vertex create by split", "PK Reference - PK_EDGE_euler_split");
top.note("headers/pk_edge_imprint_point.html#declaration", " <B>PK_VERTEX_t</B> *const new_vertex, --- new vertex", "PK Reference - PK_EDGE_imprint_point");
top.note("headers/pk_edge_split_at_param.html#declaration", " <B>PK_VERTEX_t</B> *const new_vertex, --- new vertex", "PK Reference - PK_EDGE_split_at_param");
top.note("headers/pk_extend_side_data_t.html#declaration", " const <B>PK_VERTEX_t</B> *vertices; --- terminal vertices of the", "PK Reference - PK_extend_side_data_t");
top.note("headers/pk_face_ask_vertices.html#declaration", " <B>PK_VERTEX_t</B> **const vertices --- vertices (optional)", "PK Reference - PK_FACE_ask_vertices");
top.note("headers/pk_face_close_gaps.html#declaration", " <B>PK_VERTEX_t</B> **const vertices --- vertices where gaps remain", "PK Reference - PK_FACE_close_gaps");
top.note("headers/pk_face_imprint_point.html#declaration", " <B>PK_VERTEX_t</B> *const new_vertex --- new vertex", "PK Reference - PK_FACE_imprint_point");
top.note("headers/pk_loop_ask_vertices.html#declaration", " <B>PK_VERTEX_t</B> **const vertices --- vertices (optional)", "PK Reference - PK_LOOP_ask_vertices");
top.note("headers/pk_loop_close_gaps.html#declaration", " <B>PK_VERTEX_t</B> **const vertices --- vertices where gaps remain", "PK Reference - PK_LOOP_close_gaps");
top.note("headers/pk_loop_euler_create_edge.html#declaration", " <B>PK_VERTEX_t</B> *const new_vertex, --- New vertex created", "PK Reference - PK_LOOP_euler_create_edge");
top.note("headers/pk_loop_euler_make_edge.html#declaration", " <B>PK_VERTEX_t</B> *const new_vertex, --- New vertex created", "PK Reference - PK_LOOP_euler_make_edge");
top.note("headers/pk_point_ask_vertex.html#declaration", " <B>PK_VERTEX_t</B> *const vertex --- owning vertex (possibly PK_ENTITY_null)", "PK Reference - PK_POINT_ask_vertex");
top.note("headers/pk_region_imprint_point.html#declaration", " <B>PK_VERTEX_t</B> *const new_vertex --- new vertex", "PK Reference - PK_REGION_imprint_point");
top.note("headers/pk_replace_vertex_data_t.html#declaration", " const <B>PK_VERTEX_t</B> *vertices; --- vertices to have positions", "PK Reference - PK_replace_vertex_data_t");
top.note("headers/pk_shell_ask_acorn_vertex.html#declaration", " <B>PK_VERTEX_t</B> *const vertex --- its acorn vertex (or PK_ENTITY_null)", "PK Reference - PK_SHELL_ask_acorn_vertex");
top.note("headers/pk_sweep_face_clamp_t.html#declaration", " const <B>PK_VERTEX_t</B> *vertices; --- array of clamped profile vertices", "PK Reference - PK_sweep_face_clamp_t");
top.note("headers/pk_sweep_guide_clamp_dirn_t.html#declaration", " const <B>PK_VERTEX_t</B> *vertices; --- the guide wire vertices (NULL)", "PK Reference - PK_sweep_guide_clamp_dirn_t");
top.note("headers/pk_topol_categorise_geom.html#documentation", "| <B>PK_VERTEX_t</B> | The point | The edges of the |", "PK Reference - PK_TOPOL_categorise_geom");
top.note("headers/pk_topol_fctab_fin_topol_t.html#documentation", " <B>PK_VERTEX_t</B> and is the topology whose geometry is associated with", "PK Reference - PK_TOPOL_fctab_fin_topol_t");
top.note("headers/pk_topol_fctab_point_topol_t.html#documentation", "topology. The associated topology will be a <B>PK_VERTEX_t</B> , PK_FIN_t or", "PK Reference - PK_TOPOL_fctab_point_topol_t");
top.note("headers/pk_topol_find_frames.html#documentation", " <B>PK_VERTEX_t</B> All frames directly attached to the region(s) of the", "PK Reference - PK_TOPOL_find_frames");
top.note("headers/pk_topol_t.html#documentation", " - <B>PK_VERTEX_t</B> : a vertex which is a single position in", "PK Reference - PK_TOPOL_t");
top.note("headers/pk_vertex_array_t.html#description", " This structure contains an array of entities of type <B>PK_VERTEX_t</B> ", "PK Reference - PK_VERTEX_array_t");
top.note("headers/pk_vertex_array_t.html#documentation", " <B>PK_VERTEX_t</B> *array; --- array of VERTEXs", "PK Reference - PK_VERTEX_array_t");
top.note("headers/pk_vertex_ask_body.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- a vertex", "PK Reference - PK_VERTEX_ask_body");
top.note("headers/pk_vertex_ask_faces.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- a vertex", "PK Reference - PK_VERTEX_ask_faces");
top.note("headers/pk_vertex_ask_isolated_loops.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- a vertex", "PK Reference - PK_VERTEX_ask_isolated_loops");
top.note("headers/pk_vertex_ask_oriented_edges.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- a vertex", "PK Reference - PK_VERTEX_ask_oriented_edges");
top.note("headers/pk_vertex_ask_point.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- a vertex", "PK Reference - PK_VERTEX_ask_point");
top.note("headers/pk_vertex_ask_precision.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- vertex", "PK Reference - PK_VERTEX_ask_precision");
top.note("headers/pk_vertex_ask_shells.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- a vertex", "PK Reference - PK_VERTEX_ask_shells");
top.note("headers/pk_vertex_ask_type.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- the vertex", "PK Reference - PK_VERTEX_ask_type");
top.note("headers/pk_vertex_attach_points.html#declaration", "const <B>PK_VERTEX_t</B> vertices[], --- vertices to have points attached", "PK Reference - PK_VERTEX_attach_points");
top.note("headers/pk_vertex_delete_acorn.html#declaration", "const <B>PK_VERTEX_t</B> vertices[] --- acorn vertices to delete", "PK Reference - PK_VERTEX_delete_acorn");
top.note("headers/pk_vertex_euler_delete.html#declaration", " <B>PK_VERTEX_t</B> vertex --- Vertex to be deleted", "PK Reference - PK_VERTEX_euler_delete");
top.note("headers/pk_vertex_euler_merge_edges.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- Vertex to be deleted", "PK Reference - PK_VERTEX_euler_merge_edges");
top.note("headers/pk_vertex_euler_split.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- Vertex to be split", "PK Reference - PK_VERTEX_euler_split");
top.note("headers/pk_vertex_make_blend.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- vertex to be blended", "PK Reference - PK_VERTEX_make_blend");
top.note("headers/pk_vertex_optimise.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- vertex to be", "PK Reference - PK_VERTEX_optimise");
top.note("headers/pk_vertex_remove_edge.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- vertex to split", "PK Reference - PK_VERTEX_remove_edge");
top.note("headers/pk_vertex_set_precision.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- vertex", "PK Reference - PK_VERTEX_set_precision");
top.note("headers/pk_vertex_spin.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- end vertex of wire body", "PK Reference - PK_VERTEX_spin");
top.note("headers/pk_vertex_sweep.html#declaration", " <B>PK_VERTEX_t</B> vertex, --- end vertex of wire body", "PK Reference - PK_VERTEX_sweep");
top.display();
//-->
</SCRIPT>
</HEAD>
<BODY bgcolor=#FFFFFF link=#0F3A68 vlink=#878787 alink=#FF7600 leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
</BODY>
</HTML>
