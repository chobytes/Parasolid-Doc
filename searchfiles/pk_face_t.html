<HTML>
<HEAD>
<LINK REL=STYLESHEET HREF=../ps_doc.css CHARSET=ISO-8859-1 TYPE=text/css>
<SCRIPT LANGUAGE="JavaScript">
<!--

top.note("chapters/fd_chap.010.html#50409790_pgfId-335199", " <B>PK_FACE_t</B> face; ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.010.html#50409790_pgfId-556523", " <B>PK_FACE_t</B> ** const faces // faces (optional) ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285293", " const <B>PK_FACE_t</B> [], /* faces in hole detail */ ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/p2_chap.03.html#sec_b_1_1", " PK_facet_fault_face_c 20700 The specified <B>PK_FACE_t</B> entity could not be facetted using the specified mesh", "PK Reference - PK token Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.05.html#sec_d_1_app", " PK_facet_fault_added_missing_c 20723 The specified <B>PK_FACE_t</B> entity was required in order to define a facetted", "PK Reference - PK token Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.07.html#sec_f_1_2", " A member of entities is a <B>PK_FACE_t</B>", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.07.html#sec_f_1_4", " PK_SURF_t or <B>PK_FACE_t</B>, or a member", "PK Reference - PK Error Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.09.html#sec_h_1_1", " PK_SURF_t or <B>PK_FACE_t</B>, or a member", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("chapters/p2_chap.09.html#sec_h_1_4", " A member of entities is a <B>PK_FACE_t</B>", "PK Reference - PK Error Codes with descriptions (Alphabetic)");
top.note("headers/pk_blend_cap_data_t.html#documentation", " If the entity is a <B>PK_FACE_t</B> , then it must belong to the", "PK Reference - PK_blend_cap_data_t");
top.note("headers/pk_blend_constraint_t.html#documentation", " <B>PK_FACE_t</B> , then it must belong to one of the", "PK Reference - PK_blend_constraint_t");
top.note("headers/pk_blend_delete_cap_data_t.html#declaration", " const <B>PK_FACE_t</B> *blends; --- blend faces", "PK Reference - PK_blend_delete_cap_data_t");
top.note("headers/pk_blend_delete_unders_data_t.html#declaration", " const <B>PK_FACE_t</B> *blends; --- blend faces ( NULL )", "PK Reference - PK_blend_delete_unders_data_t");
top.note("headers/pk_body_ask_faces.html#declaration", " <B>PK_FACE_t</B> **const faces --- faces (optional)", "PK Reference - PK_BODY_ask_faces");
top.note("headers/pk_body_ask_first_face.html#declaration", " <B>PK_FACE_t</B> *const first_face --- a face (possibly PK_ENTITY_null)", "PK Reference - PK_BODY_ask_first_face");
top.note("headers/pk_body_fix_blends.html#declaration", " <B>PK_FACE_t</B> **const blends, --- created blend faces", "PK Reference - PK_BODY_fix_blends");
top.note("headers/pk_body_hollow.html#declaration", " <B>PK_FACE_t</B> **const old_faces, --- faces in original body (optional)", "PK Reference - PK_BODY_hollow");
top.note("headers/pk_body_hollow_o_t.html#declaration", " const <B>PK_FACE_t</B> *pierce_faces; --- faces to be pierced (not offset)", "PK Reference - PK_BODY_hollow_o_t");
top.note("headers/pk_body_imprint_curve.html#declaration", " <B>PK_FACE_t</B> **const new_faces --- new faces (optional)", "PK Reference - PK_BODY_imprint_curve");
top.note("headers/pk_body_imprint_cus_shadow.html#declaration", " <B>PK_FACE_t</B> **const visible_faces --- visible faces", "PK Reference - PK_BODY_imprint_cus_shadow");
top.note("headers/pk_body_imprint_faces.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_BODY_imprint_faces");
top.note("headers/pk_body_imprint_faces_2.html#declaration", "const <B>PK_FACE_t</B> faces[], --- tool faces", "PK Reference - PK_BODY_imprint_faces_2");
top.note("headers/pk_body_loft_face_clamp_t.html#declaration", " const <B>PK_FACE_t</B> *faces; --- array of clamping faces (NULL)", "PK Reference - PK_BODY_loft_face_clamp_t");
top.note("headers/pk_body_make_spun_outline_o_t.html#declaration", " const <B>PK_FACE_t</B> *exclude_faces; --- faces to exclude from outlining", "PK Reference - PK_BODY_make_spun_outline_o_t");
top.note("headers/pk_body_make_swept_body_2_o_t.html#declaration", " const <B>PK_FACE_t</B> *lock_faces; --- the lock faces (NULL)", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_tool_o_t.html#declaration", " const <B>PK_FACE_t</B> *cap_faces; --- cap faces of the tool for", "PK Reference - PK_BODY_make_swept_tool_o_t");
top.note("headers/pk_body_offset_o_t.html#declaration", " const <B>PK_FACE_t</B> *offset_faces; --- faces to be offset by a different", "PK Reference - PK_BODY_offset_o_t");
top.note("headers/pk_body_taper_o_t.html#declaration", " const <B>PK_FACE_t</B> *upper_faces; --- faces to be tapered from", "PK Reference - PK_BODY_taper_o_t");
top.note("headers/pk_body_thicken_o_t.html#declaration", " const <B>PK_FACE_t</B> *faces; --- faces without default offsets", "PK Reference - PK_BODY_thicken_o_t");
top.note("headers/pk_body_trim.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_BODY_trim");
top.note("headers/pk_change_edge_geom_data_t.html#errors", " PK_SURF_t or <B>PK_FACE_t</B> , or a member", "PK Reference - PK_change_edge_geom_data_t");
top.note("headers/pk_change_edge_geom_data_t.html#documentation", " <B>PK_FACE_t</B> edges in the corresponding edge array", "PK Reference - PK_change_edge_geom_data_t");
top.note("headers/pk_debug_face_pair_r_t.html#declaration", " <B>PK_FACE_t</B> master_face;", "PK Reference - PK_DEBUG_face_pair_r_t");
top.note("headers/pk_detail_hole_cb_f_t.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces in hole detail", "PK Reference - PK_detail_hole_cb_f_t");
top.note("headers/pk_edge_ask_blend.html#declaration", " <B>PK_FACE_t</B> *const left_face, --- face to left of edge", "PK Reference - PK_EDGE_ask_blend");
top.note("headers/pk_edge_ask_faces.html#declaration", " <B>PK_FACE_t</B> **const faces --- faces (optional)", "PK Reference - PK_EDGE_ask_faces");
top.note("headers/pk_edge_euler_slit.html#declaration", " <B>PK_FACE_t</B> *const new_face, --- New face created by slit", "PK Reference - PK_EDGE_euler_slit");
top.note("headers/pk_edge_find_blend_topol.html#declaration", " <B>PK_FACE_t</B> **const faces --- affected faces", "PK Reference - PK_EDGE_find_blend_topol");
top.note("headers/pk_edge_make_faces_from_wire.html#declaration", " <B>PK_FACE_t</B> new_faces[] --- new faces created", "PK Reference - PK_EDGE_make_faces_from_wire");
top.note("headers/pk_edge_set_blend_chamfer.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces of first range", "PK Reference - PK_EDGE_set_blend_chamfer");
top.note("headers/pk_face_array_t.html#description", " This structure contains an array of entities of type <B>PK_FACE_t</B> ", "PK Reference - PK_FACE_array_t");
top.note("headers/pk_face_array_t.html#documentation", " <B>PK_FACE_t</B> *array; --- array of FACEs", "PK Reference - PK_FACE_array_t");
top.note("headers/pk_face_ask_body.html#declaration", " <B>PK_FACE_t</B> face, --- a face", "PK Reference - PK_FACE_ask_body");
top.note("headers/pk_face_ask_edges.html#declaration", " <B>PK_FACE_t</B> face, --- a face", "PK Reference - PK_FACE_ask_edges");
top.note("headers/pk_face_ask_faces_adjacent.html#declaration", "const <B>PK_FACE_t</B> faces[], --- array of faces", "PK Reference - PK_FACE_ask_faces_adjacent");
top.note("headers/pk_face_ask_first_loop.html#declaration", " <B>PK_FACE_t</B> face, --- a face", "PK Reference - PK_FACE_ask_first_loop");
top.note("headers/pk_face_ask_loops.html#declaration", " <B>PK_FACE_t</B> face, --- a face", "PK Reference - PK_FACE_ask_loops");
top.note("headers/pk_face_ask_next_in_body.html#declaration", " <B>PK_FACE_t</B> face, --- a face", "PK Reference - PK_FACE_ask_next_in_body");
top.note("headers/pk_face_ask_oriented_surf.html#declaration", " <B>PK_FACE_t</B> face, --- a face", "PK Reference - PK_FACE_ask_oriented_surf");
top.note("headers/pk_face_ask_shells.html#declaration", " <B>PK_FACE_t</B> face, --- a face", "PK Reference - PK_FACE_ask_shells");
top.note("headers/pk_face_ask_surf.html#declaration", " <B>PK_FACE_t</B> face, --- a face", "PK Reference - PK_FACE_ask_surf");
top.note("headers/pk_face_ask_type.html#declaration", " <B>PK_FACE_t</B> face, --- face", "PK Reference - PK_FACE_ask_type");
top.note("headers/pk_face_ask_vertices.html#declaration", " <B>PK_FACE_t</B> face, --- a face", "PK Reference - PK_FACE_ask_vertices");
top.note("headers/pk_face_attach_surf_fitting.html#declaration", " <B>PK_FACE_t</B> face, --- face", "PK Reference - PK_FACE_attach_surf_fitting");
top.note("headers/pk_face_attach_surfs.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces to have surfaces attached", "PK Reference - PK_FACE_attach_surfs");
top.note("headers/pk_face_boolean.html#declaration", "const <B>PK_FACE_t</B> targets[], --- target faces", "PK Reference - PK_FACE_boolean");
top.note("headers/pk_face_boolean_2.html#declaration", "const <B>PK_FACE_t</B> targets[], --- target faces", "PK Reference - PK_FACE_boolean_2");
top.note("headers/pk_face_change.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces to change", "PK Reference - PK_FACE_change");
top.note("headers/pk_face_change_blend_o_t.html#errors", " type <B>PK_FACE_t</B> .", "PK Reference - PK_FACE_change_blend_o_t");
top.note("headers/pk_face_change_deform_eval_f_t.html#declaration", " <B>PK_FACE_t</B> face, --- face for this operation", "PK Reference - PK_FACE_change_deform_eval_f_t");
top.note("headers/pk_face_change_deform_o_t.html#documentation", " face ( <B>PK_FACE_t</B> ) - The face for the evaluation.", "PK Reference - PK_FACE_change_deform_o_t");
top.note("headers/pk_face_change_offset_o_t.html#declaration", " <B>PK_FACE_t</B> reference; --- reference face (PK_ENTITY_null)", "PK Reference - PK_FACE_change_offset_o_t");
top.note("headers/pk_face_change_transform_o_t.html#declaration", " const <B>PK_FACE_t</B> *target_faces; --- For each boundary loop, the", "PK Reference - PK_FACE_change_transform_o_t");
top.note("headers/pk_face_check.html#declaration", " <B>PK_FACE_t</B> face, --- face to be checked", "PK Reference - PK_FACE_check");
top.note("headers/pk_face_check_pair.html#declaration", " <B>PK_FACE_t</B> face_1, --- face to be checked", "PK Reference - PK_FACE_check_pair");
top.note("headers/pk_face_close_gaps.html#declaration", " <B>PK_FACE_t</B> face, --- face", "PK Reference - PK_FACE_close_gaps");
top.note("headers/pk_face_contains_vectors.html#declaration", " <B>PK_FACE_t</B> face, --- face", "PK Reference - PK_FACE_contains_vectors");
top.note("headers/pk_face_cover.html#declaration", "const <B>PK_FACE_t</B> faces[], --- target faces to cover", "PK Reference - PK_FACE_cover");
top.note("headers/pk_face_delete.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_FACE_delete");
top.note("headers/pk_face_delete_2.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces to delete", "PK Reference - PK_FACE_delete_2");
top.note("headers/pk_face_delete_blends.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces to delete", "PK Reference - PK_FACE_delete_blends");
top.note("headers/pk_face_delete_from_gen_body.html#declaration", "const <B>PK_FACE_t</B> faces[] --- faces to delete", "PK Reference - PK_FACE_delete_from_gen_body");
top.note("headers/pk_face_delete_from_sheet.html#declaration", "const <B>PK_FACE_t</B> faces[], --- array of faces", "PK Reference - PK_FACE_delete_from_sheet");
top.note("headers/pk_face_delete_from_sheet_body.html#declaration", " <B>PK_FACE_t</B> face --- face", "PK Reference - PK_FACE_delete_from_sheet_body");
top.note("headers/pk_face_emboss.html#declaration", "const <B>PK_FACE_t</B> faces[], --- target faces upon which the", "PK Reference - PK_FACE_emboss");
top.note("headers/pk_face_euler_make_loop.html#declaration", " <B>PK_FACE_t</B> face, --- Face to contain new loop", "PK Reference - PK_FACE_euler_make_loop");
top.note("headers/pk_face_euler_make_ring_face.html#declaration", " <B>PK_FACE_t</B> face, --- Face to contain new face", "PK Reference - PK_FACE_euler_make_ring_face");
top.note("headers/pk_face_euler_make_ring_loop.html#declaration", " <B>PK_FACE_t</B> face, --- Face to contain new loop", "PK Reference - PK_FACE_euler_make_ring_loop");
top.note("headers/pk_face_euler_unslit.html#declaration", " <B>PK_FACE_t</B> face, --- Face to be unslit", "PK Reference - PK_FACE_euler_unslit");
top.note("headers/pk_face_find_blend_unders.html#declaration", " <B>PK_FACE_t</B> face, --- the face", "PK Reference - PK_FACE_find_blend_unders");
top.note("headers/pk_face_find_edges_common.html#declaration", " <B>PK_FACE_t</B> face_1, --- first face", "PK Reference - PK_FACE_find_edges_common");
top.note("headers/pk_face_find_extreme.html#declaration", " <B>PK_FACE_t</B> face, --- face on which extreme sought", "PK Reference - PK_FACE_find_extreme");
top.note("headers/pk_face_find_interior_vec.html#declaration", " <B>PK_FACE_t</B> face, --- face to find interior", "PK Reference - PK_FACE_find_interior_vec");
top.note("headers/pk_face_find_outer_loop.html#declaration", " <B>PK_FACE_t</B> face, --- face to find outer loop", "PK Reference - PK_FACE_find_outer_loop");
top.note("headers/pk_face_find_uvbox.html#declaration", " <B>PK_FACE_t</B> face, --- face for which uvbox required", "PK Reference - PK_FACE_find_uvbox");
top.note("headers/pk_face_fix_mesh_defects.html#declaration", "const <B>PK_FACE_t</B> faces[], --- array of faces to process", "PK Reference - PK_FACE_fix_mesh_defects");
top.note("headers/pk_face_grow_cb_f_t.html#declaration", "const <B>PK_FACE_t</B> faces1[], --- first set of clashing faces", "PK Reference - PK_FACE_grow_cb_f_t");
top.note("headers/pk_face_hollow.html#declaration", " <B>PK_FACE_t</B> faces[], --- faces to hollow", "PK Reference - PK_FACE_hollow");
top.note("headers/pk_face_hollow_2.html#declaration", " <B>PK_FACE_t</B> faces[], --- faces to hollow", "PK Reference - PK_FACE_hollow_2");
top.note("headers/pk_face_hollow_3.html#declaration", " <B>PK_FACE_t</B> faces[], --- faces to hollow", "PK Reference - PK_FACE_hollow_3");
top.note("headers/pk_face_identify_blends.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_FACE_identify_blends");
top.note("headers/pk_face_imprint_curve.html#declaration", " <B>PK_FACE_t</B> face, --- face", "PK Reference - PK_FACE_imprint_curve");
top.note("headers/pk_face_imprint_curves_2.html#declaration", " <B>PK_FACE_t</B> face, --- face", "PK Reference - PK_FACE_imprint_curves_2");
top.note("headers/pk_face_imprint_curves_isocline.html#declaration", "const <B>PK_FACE_t</B> rec_faces[], --- received faces", "PK Reference - PK_FACE_imprint_curves_isocline");
top.note("headers/pk_face_imprint_cus_isoclin.html#declaration", "const <B>PK_FACE_t</B> rec_faces[],--- received faces", "PK Reference - PK_FACE_imprint_cus_isoclin");
top.note("headers/pk_face_imprint_cus_normal.html#declaration", "const <B>PK_FACE_t</B> targets[], --- array of faces", "PK Reference - PK_FACE_imprint_cus_normal");
top.note("headers/pk_face_imprint_cus_vec.html#declaration", "const <B>PK_FACE_t</B> targets[], --- array of faces", "PK Reference - PK_FACE_imprint_cus_vec");
top.note("headers/pk_face_imprint_cus_vector.html#declaration", "const <B>PK_FACE_t</B> targets[], --- array of faces", "PK Reference - PK_FACE_imprint_cus_vector");
top.note("headers/pk_face_imprint_faces.html#declaration", "const <B>PK_FACE_t</B> targets[], --- target faces", "PK Reference - PK_FACE_imprint_faces");
top.note("headers/pk_face_imprint_faces_2.html#declaration", "const <B>PK_FACE_t</B> targets[], --- target faces", "PK Reference - PK_FACE_imprint_faces_2");
top.note("headers/pk_face_imprint_point.html#declaration", " <B>PK_FACE_t</B> face, --- face", "PK Reference - PK_FACE_imprint_point");
top.note("headers/pk_face_install_surfs_isocline.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces to be drafted", "PK Reference - PK_FACE_install_surfs_isocline");
top.note("headers/pk_face_instance_bodies.html#declaration", "const <B>PK_FACE_t</B> target_faces[], --- target faces", "PK Reference - PK_FACE_instance_bodies");
top.note("headers/pk_face_instance_tools.html#declaration", "const <B>PK_FACE_t</B> target_faces[], --- target faces", "PK Reference - PK_FACE_instance_tools");
top.note("headers/pk_face_intersect_curve.html#declaration", " <B>PK_FACE_t</B> face, --- face", "PK Reference - PK_FACE_intersect_curve");
top.note("headers/pk_face_intersect_face.html#declaration", " <B>PK_FACE_t</B> face_1, --- first face", "PK Reference - PK_FACE_intersect_face");
top.note("headers/pk_face_intersect_surf.html#declaration", " <B>PK_FACE_t</B> face, --- face", "PK Reference - PK_FACE_intersect_surf");
top.note("headers/pk_face_is_coincident.html#declaration", " <B>PK_FACE_t</B> face1, --- first face", "PK Reference - PK_FACE_is_coincident");
top.note("headers/pk_face_is_periodic.html#declaration", " <B>PK_FACE_t</B> face, --- a face", "PK Reference - PK_FACE_is_periodic");
top.note("headers/pk_face_is_uvbox.html#declaration", " <B>PK_FACE_t</B> face, --- face for which uvbox required", "PK Reference - PK_FACE_is_uvbox");
top.note("headers/pk_face_make_3_face_blend.html#declaration", "const <B>PK_FACE_t</B> left_wall_faces[], --- left wall faces", "PK Reference - PK_FACE_make_3_face_blend");
top.note("headers/pk_face_make_3_face_blend_o_t.html#documentation", " If the entity is a <B>PK_FACE_t</B> , then it must", "PK Reference - PK_FACE_make_3_face_blend_o_t");
top.note("headers/pk_face_make_blend.html#declaration", "const <B>PK_FACE_t</B> left_wall_faces[], --- faces in left wall", "PK Reference - PK_FACE_make_blend");
top.note("headers/pk_face_make_neutral_sheet.html#declaration", " <B>PK_FACE_t</B> faces[2], --- two faces", "PK Reference - PK_FACE_make_neutral_sheet");
top.note("headers/pk_face_make_neutral_sheet_2.html#declaration", "const <B>PK_FACE_t</B> left_faces[], --- left faces", "PK Reference - PK_FACE_make_neutral_sheet_2");
top.note("headers/pk_face_make_sect_with_sfs.html#declaration", " <B>PK_FACE_t</B> targets[], --- Target faces", "PK Reference - PK_FACE_make_sect_with_sfs");
top.note("headers/pk_face_make_sheet_bodies.html#declaration", "const <B>PK_FACE_t</B> faces[], --- array of faces", "PK Reference - PK_FACE_make_sheet_bodies");
top.note("headers/pk_face_make_sheet_body.html#declaration", "const <B>PK_FACE_t</B> faces[], --- array of faces", "PK Reference - PK_FACE_make_sheet_body");
top.note("headers/pk_face_make_solid_bodies.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_FACE_make_solid_bodies");
top.note("headers/pk_face_neutral_causes_t.html#declaration", " <B>PK_FACE_t</B> neutral_face; --- Face in neutral sheet.", "PK Reference - PK_FACE_neutral_causes_t");
top.note("headers/pk_face_offset.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces to offset", "PK Reference - PK_FACE_offset");
top.note("headers/pk_face_offset_2.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces to offset", "PK Reference - PK_FACE_offset_2");
top.note("headers/pk_face_output_surf_trimmed.html#declaration", " <B>PK_FACE_t</B> face, --- face", "PK Reference - PK_FACE_output_surf_trimmed");
top.note("headers/pk_face_pattern.html#declaration", "const <B>PK_FACE_t</B> pattern_faces[], --- pattern faces", "PK Reference - PK_FACE_pattern");
top.note("headers/pk_face_pattern_2.html#declaration", "const <B>PK_FACE_t</B> pattern_faces[], --- pattern faces", "PK Reference - PK_FACE_pattern_2");
top.note("headers/pk_face_pattern_data_r_t.html#declaration", " <B>PK_FACE_t</B> *pattern_faces;", "PK Reference - PK_FACE_pattern_data_r_t");
top.note("headers/pk_face_pattern_instance_r_t.html#declaration", " <B>PK_FACE_t</B> *result_faces; --- result faces for this", "PK Reference - PK_FACE_pattern_instance_r_t");
top.note("headers/pk_face_remove_to_solid_bodies.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_FACE_remove_to_solid_bodies");
top.note("headers/pk_face_repair.html#declaration", " <B>PK_FACE_t</B> face, --- face", "PK Reference - PK_FACE_repair");
top.note("headers/pk_face_reparameterise_surf.html#declaration", " <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_FACE_reparameterise_surf");
top.note("headers/pk_face_reparameterise_surf_r_t.html#declaration", " <B>PK_FACE_t</B> *faces;", "PK Reference - PK_FACE_reparameterise_surf_r_t");
top.note("headers/pk_face_replace_surfs.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_FACE_replace_surfs");
top.note("headers/pk_face_replace_surfs_2.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_FACE_replace_surfs_2");
top.note("headers/pk_face_replace_surfs_3.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_FACE_replace_surfs_3");
top.note("headers/pk_face_replace_with_sheet.html#declaration", "const <B>PK_FACE_t</B> faces[], --- target faces to replace", "PK Reference - PK_FACE_replace_with_sheet");
top.note("headers/pk_face_reverse.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_FACE_reverse");
top.note("headers/pk_face_section_with_sheet.html#declaration", "const <B>PK_FACE_t</B> targets[], --- Target faces", "PK Reference - PK_FACE_section_with_sheet");
top.note("headers/pk_face_section_with_sheet_2.html#declaration", "const <B>PK_FACE_t</B> targets[], --- target faces", "PK Reference - PK_FACE_section_with_sheet_2");
top.note("headers/pk_face_set_approx.html#declaration", "const <B>PK_FACE_t</B> faces[] --- faces for which approximations are required", "PK Reference - PK_FACE_set_approx");
top.note("headers/pk_face_set_pair_t.html#declaration", " <B>PK_FACE_t</B> *faces1; --- First set of faces", "PK Reference - PK_FACE_set_pair_t");
top.note("headers/pk_face_simplify_geom.html#declaration", " <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_FACE_simplify_geom");
top.note("headers/pk_face_spin.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_FACE_spin");
top.note("headers/pk_face_split_at_param.html#declaration", " <B>PK_FACE_t</B> face, --- Target face", "PK Reference - PK_FACE_split_at_param");
top.note("headers/pk_face_sweep.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_FACE_sweep");
top.note("headers/pk_face_taper.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces to be drafted", "PK Reference - PK_FACE_taper");
top.note("headers/pk_face_taper_o_t.html#declaration", " const <B>PK_FACE_t</B> *taper_faces; --- faces which are tapered with", "PK Reference - PK_FACE_taper_o_t");
top.note("headers/pk_face_tracking_r_t.html#declaration", " <B>PK_FACE_t</B> original_face;", "PK Reference - PK_FACE_tracking_r_t");
top.note("headers/pk_face_transform.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces", "PK Reference - PK_FACE_transform");
top.note("headers/pk_face_transform_2.html#declaration", "const <B>PK_FACE_t</B> faces[], --- faces to transform", "PK Reference - PK_FACE_transform_2");
top.note("headers/pk_face_trim_cb_f_t.html#declaration", "const <B>PK_FACE_t</B> faces1[], --- first set of clashing faces", "PK Reference - PK_FACE_trim_cb_f_t");
top.note("headers/pk_face_unset_approx.html#declaration", "const <B>PK_FACE_t</B> faces[] --- faces to clear of approximations", "PK Reference - PK_FACE_unset_approx");
top.note("headers/pk_fin_ask_face.html#declaration", " <B>PK_FACE_t</B> *const face --- owning face", "PK Reference - PK_FIN_ask_face");
top.note("headers/pk_loop_ask_face.html#declaration", " <B>PK_FACE_t</B> *const face --- owning face", "PK Reference - PK_LOOP_ask_face");
top.note("headers/pk_loop_euler_make_edge_face.html#declaration", " <B>PK_FACE_t</B> *const new_face, --- New face created", "PK Reference - PK_LOOP_euler_make_edge_face");
top.note("headers/pk_loop_euler_transfer.html#declaration", " <B>PK_FACE_t</B> face --- destination face", "PK Reference - PK_LOOP_euler_transfer");
top.note("headers/pk_mtopol_make_meshes_o_t.html#declaration", " const <B>PK_FACE_t</B> *faces; --- faces (NULL)", "PK Reference - PK_MTOPOL_make_meshes_o_t");
top.note("headers/pk_pattern_face_map_t.html#declaration", " const <B>PK_FACE_t</B> *target_faces; --- For each boundary loop, the", "PK Reference - PK_pattern_face_map_t");
top.note("headers/pk_region_imprint_curve.html#declaration", " <B>PK_FACE_t</B> **const new_faces --- new faces (optional)", "PK Reference - PK_REGION_imprint_curve");
top.note("headers/pk_replace_patch_data_t.html#declaration", " const <B>PK_FACE_t</B> *tool_patches; --- the tool faces to replace the", "PK Reference - PK_replace_patch_data_t");
top.note("headers/pk_replace_variation_data_t.html#declaration", " const <B>PK_FACE_t</B> *variation_faces; --- faces to have surfaces replaced", "PK Reference - PK_replace_variation_data_t");
top.note("headers/pk_section_2_r_t.html#declaration", " <B>PK_FACE_t</B> *front_faces; --- faces in front of section", "PK Reference - PK_section_2_r_t");
top.note("headers/pk_shell_ask_oriented_faces.html#declaration", " <B>PK_FACE_t</B> **const faces, --- faces (optional)", "PK Reference - PK_SHELL_ask_oriented_faces");
top.note("headers/pk_surf_ask_faces.html#declaration", " <B>PK_FACE_t</B> **const faces --- faces (optional)", "PK Reference - PK_SURF_ask_faces");
top.note("headers/pk_sweep_face_clamp_t.html#declaration", " const <B>PK_FACE_t</B> *faces; --- array of clamping faces (NULL)", "PK Reference - PK_sweep_face_clamp_t");
top.note("headers/pk_topol_categorise_geom.html#documentation", "| <B>PK_FACE_t</B> | The surface | The edges of the |", "PK Reference - PK_TOPOL_categorise_geom");
top.note("headers/pk_topol_fctab_error_facet_t.html#documentation", " PK_facet_fault_face_c The specified <B>PK_FACE_t</B> entity could not be", "PK Reference - PK_TOPOL_fctab_error_facet_t");
top.note("headers/pk_topol_fctab_error_object_t.html#documentation", " PK_facet_fault_face_c The specified <B>PK_FACE_t</B> entity could not be", "PK Reference - PK_TOPOL_fctab_error_object_t");
top.note("headers/pk_topol_fctab_facet_face_t.html#declaration", " <B>PK_FACE_t</B> *face;", "PK Reference - PK_TOPOL_fctab_facet_face_t");
top.note("headers/pk_topol_fctab_incr_faces_t.html#declaration", " <B>PK_FACE_t</B> face;", "PK Reference - PK_TOPOL_fctab_incr_faces_t");
top.note("headers/pk_topol_fctab_incr_faces_t.html#documentation", " PK_facet_fault_added_missing_c The specified <B>PK_FACE_t</B> entity was required", "PK Reference - PK_TOPOL_fctab_incr_faces_t");
top.note("headers/pk_topol_fctab_strip_face_t.html#declaration", " <B>PK_FACE_t</B> *face;", "PK Reference - PK_TOPOL_fctab_strip_face_t");
top.note("headers/pk_topol_find_frames.html#documentation", " <B>PK_FACE_t</B> All frames directly attached to the region(s) of the", "PK Reference - PK_TOPOL_find_frames");
top.note("headers/pk_topol_t.html#documentation", " - <B>PK_FACE_t</B> : a face which is a bounded connected subset", "PK Reference - PK_TOPOL_t");
top.note("headers/pk_vertex_ask_faces.html#declaration", " <B>PK_FACE_t</B> **const faces --- faces (optional)", "PK Reference - PK_VERTEX_ask_faces");
top.display();
//-->
</SCRIPT>
</HEAD>
<BODY bgcolor=#FFFFFF link=#0F3A68 vlink=#878787 alink=#FF7600 leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
</BODY>
</HTML>
