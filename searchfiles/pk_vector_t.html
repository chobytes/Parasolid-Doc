<HTML>
<HEAD>
<LINK REL=STYLESHEET HREF=../ps_doc.css CHARSET=ISO-8859-1 TYPE=text/css>
<SCRIPT LANGUAGE="JavaScript">
<!--

top.note("chapters/fd_chap.003.html#50409782_pgfId-298425", " <B>PK_VECTOR_t</B> ", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.003.html#50409782_pgfId-298431", " typedef struct {double coord[3];} <B>PK_VECTOR_t</B> ; ", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.003.html#50409782_pgfId-298441", " same as <B>PK_VECTOR_t</B> , but it must be a unit vector (enforced", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.010.html#50409790_pgfId-335201", " <B>PK_VECTOR_t</B> point; ", "Functional Description - PK Interface Programming Concepts ");
top.note("chapters/fd_chap.016.html#50409797_pgfId-295049", " PK_AXIS2_sf_t has three fields, each of which is a <B>PK_VECTOR_t</B> : ", "Functional Description - Body Types");
top.note("headers/pk_attrib_ask_named_vectors.html#declaration", " <B>PK_VECTOR_t</B> **const vectors --- vectors (optional)", "PK Reference - PK_ATTRIB_ask_named_vectors");
top.note("headers/pk_attrib_ask_nth_vector.html#declaration", " <B>PK_VECTOR_t</B> *const vector --- nth vector", "PK Reference - PK_ATTRIB_ask_nth_vector");
top.note("headers/pk_attrib_ask_vectors.html#declaration", " <B>PK_VECTOR_t</B> **const vectors --- vectors (optional)", "PK Reference - PK_ATTRIB_ask_vectors");
top.note("headers/pk_attrib_field_values_t.html#declaration", " const <B>PK_VECTOR_t</B> *vectors;", "PK Reference - PK_ATTRIB_field_values_t");
top.note("headers/pk_attrib_set_named_vectors.html#declaration", "const <B>PK_VECTOR_t</B> vectors[] --- vectors to set", "PK Reference - PK_ATTRIB_set_named_vectors");
top.note("headers/pk_attrib_set_vectors.html#declaration", "const <B>PK_VECTOR_t</B> vectors[] --- vectors to set", "PK Reference - PK_ATTRIB_set_vectors");
top.note("headers/pk_axis1_sf_t.html#declaration", " <B>PK_VECTOR_t</B> location; --- a cartesian point.", "PK Reference - PK_AXIS1_sf_t");
top.note("headers/pk_axis2_sf_t.html#declaration", " <B>PK_VECTOR_t</B> location; --- a cartesian point.", "PK Reference - PK_AXIS2_sf_t");
top.note("headers/pk_basis_set_sf_t.html#declaration", " <B>PK_VECTOR_t</B> location; --- a cartesian point.", "PK Reference - PK_BASIS_SET_sf_t");
top.note("headers/pk_bcurve_create_spline.html#declaration", "const <B>PK_VECTOR_t</B> *positions, --- positions to spline", "PK Reference - PK_BCURVE_create_spline");
top.note("headers/pk_bcurve_create_spline_2.html#declaration", "const <B>PK_VECTOR_t</B> *positions, --- positions to spline", "PK Reference - PK_BCURVE_create_spline_2");
top.note("headers/pk_bcurve_create_spline_2_o_t.html#declaration", " const <B>PK_VECTOR_t</B> *derivs; --- derivatives at positions ", "PK Reference - PK_BCURVE_create_spline_2_o_t");
top.note("headers/pk_bcurve_create_spline_o_t.html#declaration", " const <B>PK_VECTOR_t</B> *derivs; --- derivatives at positions ", "PK Reference - PK_BCURVE_create_spline_o_t");
top.note("headers/pk_bcurve_fit_eval_f_t.html#declaration", " <B>PK_VECTOR_t</B> *const point, --- sample point at parameter ", "PK Reference - PK_BCURVE_fit_eval_f_t");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#declaration", " <B>PK_VECTOR_t</B> u_v_twist; --- lower u lower v twist vector (0,0,0)", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_splinewise_sf_t.html#declaration", " <B>PK_VECTOR_t</B> *positions; --- The positions", "PK Reference - PK_BCURVE_splinewise_sf_t");
top.note("headers/pk_bcurve_sweep.html#declaration", " <B>PK_VECTOR_t</B> path, --- translation vector", "PK Reference - PK_BCURVE_sweep");
top.note("headers/pk_blend_edge_shape_t.html#declaration", " <B>PK_VECTOR_t</B> *positions; --- positions where ranges apply", "PK Reference - PK_blend_edge_shape_t");
top.note("headers/pk_blend_limit_data_t.html#declaration", " const <B>PK_VECTOR_t</B> *limit_points; --- limit points (NULL)", "PK Reference - PK_blend_limit_data_t");
top.note("headers/pk_body_contains_vector.html#declaration", " <B>PK_VECTOR_t</B> vector, --- the position vector", "PK Reference - PK_BODY_contains_vector");
top.note("headers/pk_body_create_sheet_planar.html#declaration", "const <B>PK_VECTOR_t</B> vectors[], --- position vectors", "PK Reference - PK_BODY_create_sheet_planar");
top.note("headers/pk_body_find_extreme.html#declaration", " <B>PK_VECTOR_t</B> direction_1, --- first direction", "PK Reference - PK_BODY_find_extreme");
top.note("headers/pk_body_imprint_curves_vector.html#declaration", " <B>PK_VECTOR_t</B> direction, --- direction to project curves in", "PK Reference - PK_BODY_imprint_curves_vector");
top.note("headers/pk_body_imprint_cus_vec.html#declaration", "const <B>PK_VECTOR_t</B> direction, --- direction to project", "PK Reference - PK_BODY_imprint_cus_vec");
top.note("headers/pk_body_imprint_cus_vector.html#declaration", "const <B>PK_VECTOR_t</B> direction, --- direction to project", "PK Reference - PK_BODY_imprint_cus_vector");
top.note("headers/pk_body_loft_status_r_t.html#declaration", " <B>PK_VECTOR_t</B> fault_location;", "PK Reference - PK_BODY_loft_status_r_t");
top.note("headers/pk_body_loft_vector_clamp_t.html#declaration", " const <B>PK_VECTOR_t</B> *tangents; --- array of derivative vectors (NULL)", "PK Reference - PK_BODY_loft_vector_clamp_t");
top.note("headers/pk_body_make_curves_outline_o_t.html#declaration", " <B>PK_VECTOR_t</B> project_position;--- position of plane if projecting", "PK Reference - PK_BODY_make_curves_outline_o_t");
top.note("headers/pk_body_make_persp_outline.html#declaration", "const <B>PK_VECTOR_t</B> eye_position, --- eye position", "PK Reference - PK_BODY_make_persp_outline");
top.note("headers/pk_body_make_persp_outline_o_t.html#declaration", " <B>PK_VECTOR_t</B> project_location; --- the location of the projection", "PK Reference - PK_BODY_make_persp_outline_o_t");
top.note("headers/pk_body_make_spun_outline_o_t.html#declaration", " <B>PK_VECTOR_t</B> project_position; --- position of plane if projecting", "PK Reference - PK_BODY_make_spun_outline_o_t");
top.note("headers/pk_body_make_swept_body_2_o_t.html#declaration", " <B>PK_VECTOR_t</B> scale_point;--- defining point for scale laws of", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#declaration", " <B>PK_VECTOR_t</B> scale_point; --- defining point for scale", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_pick_topol_r_t.html#declaration", " <B>PK_VECTOR_t</B> intersect;", "PK Reference - PK_BODY_pick_topol_r_t");
top.note("headers/pk_body_pick_topols_o_t.html#declaration", " <B>PK_VECTOR_t</B> near_point; --- point on near_plane", "PK Reference - PK_BODY_pick_topols_o_t");
top.note("headers/pk_body_sweep.html#declaration", " <B>PK_VECTOR_t</B> path, --- translation vector", "PK Reference - PK_BODY_sweep");
top.note("headers/pk_body_sweep_status_2_r_t.html#declaration", " <B>PK_VECTOR_t</B> *fault_locations;", "PK Reference - PK_BODY_sweep_status_2_r_t");
top.note("headers/pk_body_sweep_status_r_t.html#declaration", " <B>PK_VECTOR_t</B> fault_location;", "PK Reference - PK_BODY_sweep_status_r_t");
top.note("headers/pk_body_sweep_tool_status_r_t.html#declaration", " <B>PK_VECTOR_t</B> *fault_locations;", "PK Reference - PK_BODY_sweep_tool_status_r_t");
top.note("headers/pk_boolean_region_select_o_t.html#declaration", " const <B>PK_VECTOR_t</B> *help_points; --- (NULL)", "PK Reference - PK_boolean_region_select_o_t");
top.note("headers/pk_boolean_select_topolset_o_t.html#declaration", " const <B>PK_VECTOR_t</B> *help_points; --- (NULL)", "PK Reference - PK_boolean_select_topolset_o_t");
top.note("headers/pk_bsurf_create_constrained_o_t.html#declaration", " const <B>PK_VECTOR_t</B> *positions; --- position constraints (NULL)", "PK Reference - PK_BSURF_create_constrained_o_t");
top.note("headers/pk_bsurf_splinewise_sf_t.html#declaration", " <B>PK_VECTOR_t</B> *positions; --- The positions", "PK Reference - PK_BSURF_splinewise_sf_t");
top.note("headers/pk_change_edge_geom_data_t.html#declaration", " const <B>PK_VECTOR_t</B> *directions; --- array of directions", "PK Reference - PK_change_edge_geom_data_t");
top.note("headers/pk_check_fault_t.html#declaration", " <B>PK_VECTOR_t</B> position; --- position within faulty geometry or the", "PK Reference - PK_check_fault_t");
top.note("headers/pk_curve_degen_t.html#declaration", " <B>PK_VECTOR_t</B> position;", "PK Reference - PK_CURVE_degen_t");
top.note("headers/pk_curve_eval.html#declaration", " <B>PK_VECTOR_t</B> p[] --- point and derivatives.", "PK Reference - PK_CURVE_eval");
top.note("headers/pk_curve_eval_handed.html#declaration", " <B>PK_VECTOR_t</B> p[] --- point and derivatives.", "PK Reference - PK_CURVE_eval_handed");
top.note("headers/pk_curve_eval_with_tan_handed.html#declaration", " <B>PK_VECTOR_t</B> p[], --- point and derivatives.", "PK Reference - PK_CURVE_eval_with_tan_handed");
top.note("headers/pk_curve_eval_with_tangent.html#declaration", " <B>PK_VECTOR_t</B> p[], --- point and derivatives.", "PK Reference - PK_CURVE_eval_with_tangent");
top.note("headers/pk_curve_find_min_radius.html#declaration", " <B>PK_VECTOR_t</B> *const position, --- position vector where minimum occurs", "PK Reference - PK_CURVE_find_min_radius");
top.note("headers/pk_curve_find_non_aligned_box.html#declaration", " <B>PK_VECTOR_t</B> *const centre, --- box centre", "PK Reference - PK_CURVE_find_non_aligned_box");
top.note("headers/pk_curve_find_vector_interval.html#declaration", " <B>PK_VECTOR_t</B> vector_1, --- first position vector", "PK Reference - PK_CURVE_find_vector_interval");
top.note("headers/pk_curve_find_vectors_r_t.html#declaration", " <B>PK_VECTOR_t</B> *vectors;", "PK Reference - PK_CURVE_find_vectors_r_t");
top.note("headers/pk_curve_intersect_curve.html#declaration", " <B>PK_VECTOR_t</B> **const vectors, --- positions of intersections", "PK Reference - PK_CURVE_intersect_curve");
top.note("headers/pk_curve_output_vectors.html#declaration", " <B>PK_VECTOR_t</B> **const vectors, --- position vectors", "PK Reference - PK_CURVE_output_vectors");
top.note("headers/pk_curve_parameterise_vector.html#declaration", " <B>PK_VECTOR_t</B> position, --- position on curve", "PK Reference - PK_CURVE_parameterise_vector");
top.note("headers/pk_curve_project_o_t.html#declaration", " <B>PK_VECTOR_t</B> eye_position; --- position for perspective", "PK Reference - PK_CURVE_project_o_t");
top.note("headers/pk_curve_self_int_t.html#declaration", " <B>PK_VECTOR_t</B> *positions;", "PK Reference - PK_CURVE_self_int_t");
top.note("headers/pk_edge_ask_geometry.html#declaration", " <B>PK_VECTOR_t</B> ends[2], --- positions at ends of edge", "PK Reference - PK_EDGE_ask_geometry");
top.note("headers/pk_edge_ask_geometry_nmnl.html#declaration", " <B>PK_VECTOR_t</B> ends[2], --- positions at ends of edge", "PK Reference - PK_EDGE_ask_geometry_nmnl");
top.note("headers/pk_edge_contains_vector.html#declaration", " <B>PK_VECTOR_t</B> vector, --- the position vector", "PK Reference - PK_EDGE_contains_vector");
top.note("headers/pk_edge_curve_direction_t.html#declaration", " <B>PK_VECTOR_t</B> point; --- point to be used with direction", "PK Reference - PK_EDGE_curve_direction_t");
top.note("headers/pk_edge_find_deviation.html#declaration", " <B>PK_VECTOR_t</B> **const edge1_vecs, --- points on edge1", "PK Reference - PK_EDGE_find_deviation");
top.note("headers/pk_edge_find_deviation_t.html#declaration", " <B>PK_VECTOR_t</B> *edge1_vecs; --- points on edge1 ", "PK Reference - PK_EDGE_find_deviation_t");
top.note("headers/pk_edge_find_end_tangents.html#declaration", " <B>PK_VECTOR_t</B> *const start, --- start position of edge", "PK Reference - PK_EDGE_find_end_tangents");
top.note("headers/pk_edge_find_extreme.html#declaration", " <B>PK_VECTOR_t</B> direction_1, --- first direction", "PK Reference - PK_EDGE_find_extreme");
top.note("headers/pk_edge_set_blend_chain_o_t.html#declaration", " <B>PK_VECTOR_t</B> *positions; --- positions where the blend", "PK Reference - PK_EDGE_set_blend_chain_o_t");
top.note("headers/pk_edge_set_blend_chain_o_t.html#documentation", " An array of <B>PK_VECTOR_t</B> specifying where the blend parameters with the", "PK Reference - PK_EDGE_set_blend_chain_o_t");
top.note("headers/pk_entity_range_end_t.html#declaration", " <B>PK_VECTOR_t</B> vector; --- end position (0.0, 0.0, 0.0)", "PK Reference - PK_ENTITY_range_end_t");
top.note("headers/pk_entity_range_vector.html#declaration", "const <B>PK_VECTOR_t</B> vectors[], --- position array", "PK Reference - PK_ENTITY_range_vector");
top.note("headers/pk_expr_value_t.html#declaration", " <B>PK_VECTOR_t</B> vector;", "PK Reference - PK_EXPR_value_t");
top.note("headers/pk_face_change_data_taper_t.html#declaration", " <B>PK_VECTOR_t</B> direction; --- taper direction", "PK Reference - PK_FACE_change_data_taper_t");
top.note("headers/pk_face_change_deform_eval_f_t.html#declaration", " <B>PK_VECTOR_t</B> position, --- input position", "PK Reference - PK_FACE_change_deform_eval_f_t");
top.note("headers/pk_face_contains_vectors_o_t.html#declaration", " <B>PK_VECTOR_t</B> *vectors; --- xyz positions (NULL)", "PK Reference - PK_FACE_contains_vectors_o_t");
top.note("headers/pk_face_details_hole_o_t.html#declaration", " <B>PK_VECTOR_t</B> up; --- up vector for through holes", "PK Reference - PK_FACE_details_hole_o_t");
top.note("headers/pk_face_find_extreme.html#declaration", " <B>PK_VECTOR_t</B> direction_1, --- first direction", "PK Reference - PK_FACE_find_extreme");
top.note("headers/pk_face_find_interior_vec.html#declaration", " <B>PK_VECTOR_t</B> *const int_vec, --- vector interior to face", "PK Reference - PK_FACE_find_interior_vec");
top.note("headers/pk_face_imprint_cus_vec.html#declaration", " <B>PK_VECTOR_t</B> direction, --- direction to project", "PK Reference - PK_FACE_imprint_cus_vec");
top.note("headers/pk_face_imprint_cus_vector.html#declaration", " <B>PK_VECTOR_t</B> direction, --- direction to project", "PK Reference - PK_FACE_imprint_cus_vector");
top.note("headers/pk_face_intersect_curve.html#declaration", " <B>PK_VECTOR_t</B> **const vectors, --- positions of intersections", "PK Reference - PK_FACE_intersect_curve");
top.note("headers/pk_face_intersect_face.html#declaration", " <B>PK_VECTOR_t</B> **const vectors, --- posns of point intersections", "PK Reference - PK_FACE_intersect_face");
top.note("headers/pk_face_intersect_face_o_t.html#declaration", " <B>PK_VECTOR_t</B> vector; --- only return branch containing", "PK Reference - PK_FACE_intersect_face_o_t");
top.note("headers/pk_face_intersect_surf.html#declaration", " <B>PK_VECTOR_t</B> **const vectors, --- posns of point intersections", "PK Reference - PK_FACE_intersect_surf");
top.note("headers/pk_face_intersect_surf_o_t.html#declaration", " <B>PK_VECTOR_t</B> vector; --- only return branch containing", "PK Reference - PK_FACE_intersect_surf_o_t");
top.note("headers/pk_face_is_coincident.html#declaration", " <B>PK_VECTOR_t</B> *const point --- non-coincidence point", "PK Reference - PK_FACE_is_coincident");
top.note("headers/pk_face_make_3_face_blend_o_t.html#declaration", " <B>PK_VECTOR_t</B> help_point; --- help point", "PK Reference - PK_FACE_make_3_face_blend_o_t");
top.note("headers/pk_face_make_3_face_blend_r_t.html#declaration", " <B>PK_VECTOR_t</B> *points; --- error points", "PK Reference - PK_FACE_make_3_face_blend_r_t");
top.note("headers/pk_face_make_blend_o_t.html#declaration", " <B>PK_VECTOR_t</B> help_point; --- help point", "PK Reference - PK_FACE_make_blend_o_t");
top.note("headers/pk_face_sweep.html#declaration", " <B>PK_VECTOR_t</B> path, --- translation vector", "PK Reference - PK_FACE_sweep");
top.note("headers/pk_fill_hole_point_data_t.html#declaration", " <B>PK_VECTOR_t</B> *points;", "PK Reference - PK_fill_hole_point_data_t");
top.note("headers/pk_fin_ask_geometry.html#declaration", " <B>PK_VECTOR_t</B> ends[2], --- positions at ends of fin", "PK Reference - PK_FIN_ask_geometry");
top.note("headers/pk_fxf_error_t.html#declaration", " <B>PK_VECTOR_t</B> *points; --- error points", "PK Reference - PK_fxf_error_t");
top.note("headers/pk_geom_range_array_vector.html#declaration", " <B>PK_VECTOR_t</B> vector, --- position vector", "PK Reference - PK_GEOM_range_array_vector");
top.note("headers/pk_geom_range_local_vector.html#declaration", " <B>PK_VECTOR_t</B> vector, --- position vector", "PK Reference - PK_GEOM_range_local_vector");
top.note("headers/pk_geom_range_vector.html#declaration", " <B>PK_VECTOR_t</B> vector, --- position vector", "PK Reference - PK_GEOM_range_vector");
top.note("headers/pk_geom_range_vector_many.html#declaration", "const <B>PK_VECTOR_t</B> vectors[], --- position array", "PK Reference - PK_GEOM_range_vector_many");
top.note("headers/pk_lattice_graph_cone_o_t.html#declaration", " <B>PK_VECTOR_t</B> *lball_positions; --- Positions of lballs.", "PK Reference - PK_LATTICE_graph_cone_o_t");
top.note("headers/pk_lattice_graph_cyl_o_t.html#declaration", " <B>PK_VECTOR_t</B> *lball_positions; --- Positions of lballs.", "PK Reference - PK_LATTICE_graph_cyl_o_t");
top.note("headers/pk_lball_ask_position_r_t.html#declaration", " <B>PK_VECTOR_t</B> position; --- position of lball", "PK Reference - PK_LBALL_ask_position_r_t");
top.note("headers/pk_mesh_defect_details_t.html#declaration", " <B>PK_VECTOR_t</B> *positions; --- positions of defect", "PK Reference - PK_MESH_defect_details_t");
top.note("headers/pk_mesh_eval_with_mtopol.html#declaration", " <B>PK_VECTOR_t</B> *const position, --- position returned", "PK Reference - PK_MESH_eval_with_mtopol");
top.note("headers/pk_mesh_facet_fan_t.html#declaration", " <B>PK_VECTOR_t</B> *vertex_positions; --- Positions of vertices.", "PK Reference - PK_MESH_facet_fan_t");
top.note("headers/pk_mesh_facet_index_t.html#declaration", " <B>PK_VECTOR_t</B> *vertex_positions; --- Positions of vertices.", "PK Reference - PK_MESH_facet_index_t");
top.note("headers/pk_mesh_facet_strip_t.html#declaration", " <B>PK_VECTOR_t</B> *vertex_positions; --- Positions of vertices", "PK Reference - PK_MESH_facet_strip_t");
top.note("headers/pk_mesh_facet_vector_t.html#declaration", " <B>PK_VECTOR_t</B> *vertex_positions; --- Positions of vertices", "PK Reference - PK_MESH_facet_vector_t");
top.note("headers/pk_mesh_find_laminar_mfins_o_t.html#declaration", " <B>PK_VECTOR_t</B> *help_positions; --- help positions (NULL)", "PK Reference - PK_MESH_find_laminar_mfins_o_t");
top.note("headers/pk_mesh_imprint_vectors.html#declaration", "const <B>PK_VECTOR_t</B> *vectors, --- vectors", "PK Reference - PK_MESH_imprint_vectors");
top.note("headers/pk_mfacet_ask_positions.html#declaration", " <B>PK_VECTOR_t</B> positions[3] --- the positions at the mfacet s mvertices", "PK Reference - PK_MFACET_ask_positions");
top.note("headers/pk_mfacet_parameterise_vec.html#declaration", " <B>PK_VECTOR_t</B> position, --- position on the mfacet", "PK Reference - PK_MFACET_parameterise_vec");
top.note("headers/pk_mvertex_ask_position.html#declaration", " <B>PK_VECTOR_t</B> *const position --- position", "PK Reference - PK_MVERTEX_ask_position");
top.note("headers/pk_mvertex_set_positions.html#declaration", "const <B>PK_VECTOR_t</B> positions[], --- the positions for each", "PK Reference - PK_MVERTEX_set_positions");
top.note("headers/pk_pattern_axial_o_t.html#declaration", " <B>PK_VECTOR_t</B> origin; --- origin of pattern (0, 0, 0)", "PK Reference - PK_pattern_axial_o_t");
top.note("headers/pk_pattern_cb_f_t.html#declaration", "const <B>PK_VECTOR_t</B> receive_positions[],", "PK Reference - PK_pattern_cb_f_t");
top.note("headers/pk_pattern_rectilinear_o_t.html#declaration", " <B>PK_VECTOR_t</B> origin; --- origin of pattern (0, 0, 0)", "PK Reference - PK_pattern_rectilinear_o_t");
top.note("headers/pk_pline_sf_t.html#declaration", " <B>PK_VECTOR_t</B> *positions;", "PK Reference - PK_PLINE_sf_t");
top.note("headers/pk_point_sf_t.html#declaration", " <B>PK_VECTOR_t</B> position; --- cartesian position", "PK Reference - PK_POINT_sf_t");
top.note("headers/pk_range_end_t.html#declaration", " <B>PK_VECTOR_t</B> vector; --- end position (0.0, 0.0, 0.0)", "PK Reference - PK_range_end_t");
top.note("headers/pk_range_guess_t.html#declaration", " <B>PK_VECTOR_t</B> vector; --- end position (0.0, 0.0, 0.0)", "PK Reference - PK_range_guess_t");
top.note("headers/pk_replace_help_points_t.html#declaration", " const <B>PK_VECTOR_t</B> *positions; --- help point positions (NULL)", "PK Reference - PK_replace_help_points_t");
top.note("headers/pk_replace_vertex_data_t.html#declaration", " const <B>PK_VECTOR_t</B> *positions; --- vertices replacement positions (NULL)", "PK Reference - PK_replace_vertex_data_t");
top.note("headers/pk_surf_create_blend.html#declaration", " <B>PK_VECTOR_t</B> start, --- help point for start", "PK Reference - PK_SURF_create_blend");
top.note("headers/pk_surf_create_blend_o_t.html#declaration", " <B>PK_VECTOR_t</B> help; --- help vector", "PK Reference - PK_SURF_create_blend_o_t");
top.note("headers/pk_surf_degen_t.html#declaration", " <B>PK_VECTOR_t</B> position;", "PK Reference - PK_SURF_degen_t");
top.note("headers/pk_surf_eval.html#declaration", " <B>PK_VECTOR_t</B> p[] --- point and derivatives", "PK Reference - PK_SURF_eval");
top.note("headers/pk_surf_eval_grid.html#declaration", " <B>PK_VECTOR_t</B> p[] --- points", "PK Reference - PK_SURF_eval_grid");
top.note("headers/pk_surf_eval_handed.html#declaration", " <B>PK_VECTOR_t</B> p[] --- point and derivatives", "PK Reference - PK_SURF_eval_handed");
top.note("headers/pk_surf_eval_with_normal.html#declaration", " <B>PK_VECTOR_t</B> p[], --- point and derivatives", "PK Reference - PK_SURF_eval_with_normal");
top.note("headers/pk_surf_eval_with_normal_handed.html#declaration", " <B>PK_VECTOR_t</B> p[], --- point and derivatives", "PK Reference - PK_SURF_eval_with_normal_handed");
top.note("headers/pk_surf_extend_o_t.html#declaration", " <B>PK_VECTOR_t</B> extension_point; --- point to extend to", "PK Reference - PK_SURF_extend_o_t");
top.note("headers/pk_surf_find_min_radii.html#declaration", " <B>PK_VECTOR_t</B> positions[2], --- position vectors where minima occur", "PK Reference - PK_SURF_find_min_radii");
top.note("headers/pk_surf_find_non_aligned_box.html#declaration", " <B>PK_VECTOR_t</B> *const centre, --- box centre", "PK Reference - PK_SURF_find_non_aligned_box");
top.note("headers/pk_surf_find_vectors_o_t.html#declaration", " <B>PK_VECTOR_t</B> help_point; --- help position vector", "PK Reference - PK_SURF_find_vectors_o_t");
top.note("headers/pk_surf_find_vectors_r_t.html#declaration", " <B>PK_VECTOR_t</B> *vectors;", "PK Reference - PK_SURF_find_vectors_r_t");
top.note("headers/pk_surf_intersect_curve.html#declaration", " <B>PK_VECTOR_t</B> **const vectors, --- positions of intersections", "PK Reference - PK_SURF_intersect_curve");
top.note("headers/pk_surf_intersect_surf.html#declaration", " <B>PK_VECTOR_t</B> **const vectors, --- posns of point intersections", "PK Reference - PK_SURF_intersect_surf");
top.note("headers/pk_surf_intersect_surf_o_t.html#declaration", " <B>PK_VECTOR_t</B> vector; --- only return branch containing", "PK Reference - PK_SURF_intersect_surf_o_t");
top.note("headers/pk_surf_parameterise_vector.html#declaration", " <B>PK_VECTOR_t</B> position, --- position on surf", "PK Reference - PK_SURF_parameterise_vector");
top.note("headers/pk_surf_self_int_t.html#declaration", " <B>PK_VECTOR_t</B> *positions;", "PK Reference - PK_SURF_self_int_t");
top.note("headers/pk_topol_fctab_curv_dirs_t.html#declaration", " <B>PK_VECTOR_t</B> principal_direction_1;", "PK Reference - PK_TOPOL_fctab_curv_dirs_t");
top.note("headers/pk_topol_fctab_deriv_d2p_t.html#declaration", " <B>PK_VECTOR_t</B> du2;", "PK Reference - PK_TOPOL_fctab_deriv_d2p_t");
top.note("headers/pk_topol_fctab_deriv_dp_t.html#declaration", " <B>PK_VECTOR_t</B> du;", "PK Reference - PK_TOPOL_fctab_deriv_dp_t");
top.note("headers/pk_topol_fctab_normal_vec_t.html#declaration", " <B>PK_VECTOR_t</B> *vec;", "PK Reference - PK_TOPOL_fctab_normal_vec_t");
top.note("headers/pk_topol_fctab_param_d2p_t.html#declaration", " <B>PK_VECTOR_t</B> du2;", "PK Reference - PK_TOPOL_fctab_param_d2p_t");
top.note("headers/pk_topol_fctab_param_dp_t.html#declaration", " <B>PK_VECTOR_t</B> du;", "PK Reference - PK_TOPOL_fctab_param_dp_t");
top.note("headers/pk_topol_fctab_point_vec_t.html#declaration", " <B>PK_VECTOR_t</B> *vec;", "PK Reference - PK_TOPOL_fctab_point_vec_t");
top.note("headers/pk_topol_range_array_vector.html#declaration", " <B>PK_VECTOR_t</B> vector, --- position vector", "PK Reference - PK_TOPOL_range_array_vector");
top.note("headers/pk_topol_range_local_vector.html#declaration", " <B>PK_VECTOR_t</B> vector, --- position vector", "PK Reference - PK_TOPOL_range_local_vector");
top.note("headers/pk_topol_range_vector.html#declaration", " <B>PK_VECTOR_t</B> vector, --- position", "PK Reference - PK_TOPOL_range_vector");
top.note("headers/pk_transf_classify_r_t.html#declaration", " <B>PK_VECTOR_t</B> unit_rows_deviations;", "PK Reference - PK_TRANSF_classify_r_t");
top.note("headers/pk_transf_create_equal_scale.html#declaration", " <B>PK_VECTOR_t</B> centre, --- centre of scaling", "PK Reference - PK_TRANSF_create_equal_scale");
top.note("headers/pk_transf_create_reflection.html#declaration", " <B>PK_VECTOR_t</B> position, --- position on plane", "PK Reference - PK_TRANSF_create_reflection");
top.note("headers/pk_transf_create_rotation.html#declaration", " <B>PK_VECTOR_t</B> position, --- position on axis", "PK Reference - PK_TRANSF_create_rotation");
top.note("headers/pk_transf_create_translation.html#declaration", " <B>PK_VECTOR_t</B> displacement, --- direction and distance", "PK Reference - PK_TRANSF_create_translation");
top.note("headers/pk_transf_create_view_o_t.html#declaration", " <B>PK_VECTOR_t</B> eye_position; --- perspective eye position", "PK Reference - PK_TRANSF_create_view_o_t");
top.note("headers/pk_vector1_t.html#documentation", "This type is identical to <B>PK_VECTOR_t</B> except that the vector magnitude must", "PK Reference - PK_VECTOR1_t");
top.note("headers/pk_vector_array_t.html#declaration", " <B>PK_VECTOR_t</B> *array;", "PK Reference - PK_VECTOR_array_t");
top.note("headers/pk_vector_array_t.html#description", " This structure contains an array of <B>PK_VECTOR_t</B> .", "PK Reference - PK_VECTOR_array_t");
top.note("headers/pk_vector_array_t.html#documentation", " array array of <B>PK_VECTOR_t</B> ", "PK Reference - PK_VECTOR_array_t");
top.note("headers/pk_vector_is_equal.html#declaration", " <B>PK_VECTOR_t</B> v1,", "PK Reference - PK_VECTOR_is_equal");
top.note("headers/pk_vector_is_parallel.html#declaration", " <B>PK_VECTOR_t</B> v1,", "PK Reference - PK_VECTOR_is_parallel");
top.note("headers/pk_vector_is_zero.html#declaration", " <B>PK_VECTOR_t</B> vec,", "PK Reference - PK_VECTOR_is_zero");
top.note("headers/pk_vector_make_lsq_plane.html#declaration", "const <B>PK_VECTOR_t</B> *positions, --- positions to fit to", "PK Reference - PK_VECTOR_make_lsq_plane");
top.note("headers/pk_vector_normalise.html#declaration", " <B>PK_VECTOR_t</B> vec, --- direction vector", "PK Reference - PK_VECTOR_normalise");
top.note("headers/pk_vector_perpendicular.html#declaration", " <B>PK_VECTOR_t</B> vector2, --- vector", "PK Reference - PK_VECTOR_perpendicular");
top.note("headers/pk_vector_perpendicular.html#description", " This function accepts a PK_VECTOR1_t and a <B>PK_VECTOR_t</B> and returns a", "PK Reference - PK_VECTOR_perpendicular");
top.note("headers/pk_vector_t.html#declaration", "typedef struct PK_VECTOR_s <B>PK_VECTOR_t</B>;", "PK Reference - PK_VECTOR_t");
top.note("headers/pk_vector_transform.html#declaration", " <B>PK_VECTOR_t</B> p, --- original point", "PK Reference - PK_VECTOR_transform");
top.note("headers/pk_vertex_sweep.html#declaration", " <B>PK_VECTOR_t</B> path, --- translation vector", "PK Reference - PK_VERTEX_sweep");
top.note("chapters/kd_chap.05.html#50475010_pgfId-273928", " --- a struct containing a <B>PK_VECTOR_t</B> ", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.note("chapters/kd_chap.05.html#50475010_pgfId-281048", " <B>PK_VECTOR_t</B> ", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.display();
//-->
</SCRIPT>
</HEAD>
<BODY bgcolor=#FFFFFF link=#0F3A68 vlink=#878787 alink=#FF7600 leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
</BODY>
</HTML>
