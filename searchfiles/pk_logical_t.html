<HTML>
<HEAD>
<LINK REL=STYLESHEET HREF=../ps_doc.css CHARSET=ISO-8859-1 TYPE=text/css>
<SCRIPT LANGUAGE="JavaScript">
<!--

top.note("chapters/fd_chap.003.html#50409782_pgfId-298409", " <B>PK_LOGICAL_t</B> ", "Functional Description - Parasolid Concepts");
top.note("chapters/fd_chap.013.html#50409793_pgfId-295057", " logical type in the C interface of Parasolid is <B>PK_LOGICAL_t</B> ; this becomes a struct named PK.LOGICAL_t in C#.", "Functional Description - Calling Parasolid From .NET Code");
top.note("chapters/fd_chap.022.html#50409803_pgfId-373784", " array of <B>PK_LOGICAL_t</B> tokens, one for each transformed geometry. ", "Functional Description - Transformations");
top.note("chapters/fd_chap.074.html#50409860_pgfId-306684", " An array of <B>PK_LOGICAL_t</B> values that indicates whether the direction of the associated", "Functional Description - Generic Face Editing");
top.note("chapters/fd_chap.077.html#50409864_pgfId-298711", " An array of type <B>PK_LOGICAL_t</B> , one for each entry in ", "Functional Description - Edge Blending Options");
top.note("chapters/fd_chap.097.html#50409887_pgfId-295020", " <B>PK_LOGICAL_t</B> my_callback ", "Functional Description - Attributes");
top.note("chapters/fd_chap.122.html#50409915_pgfId-294934", " <B>PK_LOGICAL_t</B> was_error; ", "Functional Description - Error Handling ");
top.note("chapters/fd_chap.122.html#50409915_pgfId-295026", " <B>PK_LOGICAL_t</B> was_error; ", "Functional Description - Error Handling ");
top.note("chapters/fd_chap.122.html#50409915_pgfId-295334", " <B>PK_LOGICAL_t</B> was_error; ", "Functional Description - Error Handling ");
top.note("chapters/fd_chap.123.html#50409916_pgfId-294878", " <B>PK_LOGICAL_t</B> is_in_kernel, is_protected; ", "Functional Description - Signal Handling");
top.note("chapters/fd_chap.123.html#50409916_pgfId-294917", " <B>PK_LOGICAL_t</B> is_in_kernel, is_protected; ", "Functional Description - Signal Handling");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285346", " <B>PK_LOGICAL_t</B> rational; /* if B-curve is to be rational */", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/fd_chap.126.html#50409920_pgfId-285885", " <B>PK_LOGICAL_t</B> * const is_appitem ", "Functional Description - How the C# Binding is Implemented");
top.note("chapters/p2_chap.03.html#sec_b_1_1", " the blend face. and will contain elements of type <B>PK_LOGICAL_t</B> to indicate whether the corresponding underlying face is adjacent", "PK Reference - PK token Codes with descriptions (Numeric)");
top.note("chapters/p2_chap.05.html#sec_d_1_app", " the blend face. and will contain elements of type <B>PK_LOGICAL_t</B> to indicate whether the corresponding underlying face is adjacent", "PK Reference - PK token Codes with descriptions (Alphabetic)");
top.note("headers/pk_appitem_is.html#declaration", " <B>PK_LOGICAL_t</B> *const is_appitem", "PK Reference - PK_APPITEM_is");
top.note("headers/pk_attdef_callback_flags_t.html#declaration", " <B>PK_LOGICAL_t</B> split_callback_on;", "PK Reference - PK_ATTDEF_callback_flags_t");
top.note("headers/pk_attdef_is_group_closing.html#declaration", " <B>PK_LOGICAL_t</B> *const group_closing --- whether group closing", "PK Reference - PK_ATTDEF_is_group_closing");
top.note("headers/pk_attdef_sf_2_t.html#declaration", " <B>PK_LOGICAL_t</B> unicode_names; --- Unicode or char names", "PK Reference - PK_ATTDEF_sf_2_t");
top.note("headers/pk_attrib_ask_no_roll_o_t.html#declaration", " <B>PK_LOGICAL_t</B> check_consistency; --- check that no-roll", "PK Reference - PK_ATTRIB_ask_no_roll_o_t");
top.note("headers/pk_attrib_cb_f_t.html#declaration", " typedef <B>PK_LOGICAL_t</B> (*PK_ATTRIB_cb_f_t)", "PK Reference - PK_ATTRIB_cb_f_t");
top.note("headers/pk_attrib_field_id_t.html#declaration", " <B>PK_LOGICAL_t</B> unicode_name; --- Whether the name is a Unicode", "PK Reference - PK_ATTRIB_field_id_t");
top.note("headers/pk_bb_is.html#declaration", " <B>PK_LOGICAL_t</B> *const whether --- whether the received argument is a", "PK Reference - PK_BB_is");
top.note("headers/pk_bb_is_empty.html#declaration", " <B>PK_LOGICAL_t</B> *const is_empty --- true if the BB is off", "PK Reference - PK_BB_is_empty");
top.note("headers/pk_bb_output_events.html#declaration", " <B>PK_LOGICAL_t</B> empty, --- whether to empty bulletin board", "PK Reference - PK_BB_output_events");
top.note("headers/pk_bcurve_ask_knots_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_expanded_knots; --- whether to return expanded knot", "PK Reference - PK_BCURVE_ask_knots_o_t");
top.note("headers/pk_bcurve_create_fitted_o_t.html#declaration", " <B>PK_LOGICAL_t</B> preserve_parameterisation; --- whether or not the fitted", "PK Reference - PK_BCURVE_create_fitted_o_t");
top.note("headers/pk_bcurve_create_spline_2_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_fit_tol; --- whether a fitted tolerance is", "PK Reference - PK_BCURVE_create_spline_2_o_t");
top.note("headers/pk_bcurve_create_spline_o_t.html#declaration", " <B>PK_LOGICAL_t</B> is_periodic; --- whether B-curve is periodic", "PK Reference - PK_BCURVE_create_spline_o_t");
top.note("headers/pk_bcurve_fit_data_t.html#declaration", " <B>PK_LOGICAL_t</B> rational; --- if bcurve is to be rational", "PK Reference - PK_BCURVE_fit_data_t");
top.note("headers/pk_bcurve_fit_eval_f_t.html#declaration", " <B>PK_LOGICAL_t</B> calculate_deriv,--- whether the evaluator should", "PK Reference - PK_BCURVE_fit_eval_f_t");
top.note("headers/pk_bcurve_fit_fault_t.html#declaration", " <B>PK_LOGICAL_t</B> no_faults; --- true if the fit succeeded", "PK Reference - PK_BCURVE_fit_fault_t");
top.note("headers/pk_bcurve_lower_degree_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- whether tolerance was supplied", "PK Reference - PK_BCURVE_lower_degree_o_t");
top.note("headers/pk_bcurve_make_bsurf_lofted_o_t.html#declaration", " <B>PK_LOGICAL_t</B> amalgamate; --- whether to amalgamate knot vectors", "PK Reference - PK_BCURVE_make_bsurf_lofted_o_t");
top.note("headers/pk_bcurve_piecewise_sf_t.html#declaration", " <B>PK_LOGICAL_t</B> is_rational; --- True if the curve is rational.", "PK Reference - PK_BCURVE_piecewise_sf_t");
top.note("headers/pk_bcurve_remove_knots_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- whether tolerance is set", "PK Reference - PK_BCURVE_remove_knots_o_t");
top.note("headers/pk_bcurve_sf_t.html#declaration", " <B>PK_LOGICAL_t</B> is_rational; --- True if the curve is rational.", "PK Reference - PK_BCURVE_sf_t");
top.note("headers/pk_blend_cap_data_t.html#declaration", " const <B>PK_LOGICAL_t</B> *reverse_cap; --- whether cap orientation should be", "PK Reference - PK_blend_cap_data_t");
top.note("headers/pk_blend_constraint_t.html#declaration", " const <B>PK_LOGICAL_t</B> *reverse_cap; --- whether cap orientation", "PK Reference - PK_blend_constraint_t");
top.note("headers/pk_blend_fix_propagate_t.html#declaration", " <B>PK_LOGICAL_t</B> propagate; --- whether to propagate", "PK Reference - PK_blend_fix_propagate_t");
top.note("headers/pk_blend_properties_t.html#declaration", " <B>PK_LOGICAL_t</B> draw_fix; --- whether blend will be drawn", "PK Reference - PK_blend_properties_t");
top.note("headers/pk_blend_setback_data_t.html#declaration", " const <B>PK_LOGICAL_t</B> * which_end; --- whether setback is on", "PK Reference - PK_blend_setback_data_t");
top.note("headers/pk_blend_vx_blend_data_t.html#declaration", " <B>PK_LOGICAL_t</B> vertex_blend; --- whether to vertex blend", "PK Reference - PK_blend_vx_blend_data_t");
top.note("headers/pk_blend_y_blend_data_t.html#declaration", " <B>PK_LOGICAL_t</B> y_blend; --- whether to y blend", "PK Reference - PK_blend_y_blend_data_t");
top.note("headers/pk_body_add_to_compound_o_t.html#declaration", " <B>PK_LOGICAL_t</B> report_shared_geometry;", "PK Reference - PK_BODY_add_to_compound_o_t");
top.note("headers/pk_body_apply_knit_pattern_o_t.html#declaration", " <B>PK_LOGICAL_t</B> sort_face_shells; --- (PK_LOGICAL_true)", "PK Reference - PK_BODY_apply_knit_pattern_o_t");
top.note("headers/pk_body_ask_topology_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_fins; --- whether fins required in output", "PK Reference - PK_BODY_ask_topology_o_t");
top.note("headers/pk_body_blend_propagate_f_t.html#declaration", " typedef <B>PK_LOGICAL_t</B> (*PK_BODY_blend_propagate_f_t)", "PK Reference - PK_BODY_blend_propagate_f_t");
top.note("headers/pk_body_boolean_o_t.html#declaration", " <B>PK_LOGICAL_t</B> merge_imprinted; --- (PK_LOGICAL_false)", "PK Reference - PK_BODY_boolean_o_t");
top.note("headers/pk_body_copy_topology_o_t.html#declaration", " <B>PK_LOGICAL_t</B> retain_tolerances; --- whether to retain tolerances", "PK Reference - PK_BODY_copy_topology_o_t");
top.note("headers/pk_body_enlarge_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_trimming_box; --- whether a trimming box has been", "PK Reference - PK_BODY_enlarge_o_t");
top.note("headers/pk_body_extend_o_t.html#declaration", " <B>PK_LOGICAL_t</B> modify; --- whether to modify the original", "PK Reference - PK_BODY_extend_o_t");
top.note("headers/pk_body_extrude_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_disjoint; --- swept body can have a disjoint", "PK Reference - PK_BODY_extrude_o_t");
top.note("headers/pk_body_fill_hole_o_t.html#declaration", " <B>PK_LOGICAL_t</B> attach_sheet;", "PK Reference - PK_BODY_fill_hole_o_t");
top.note("headers/pk_body_find_facesets_o_t.html#declaration", " <B>PK_LOGICAL_t</B> alternate; --- whether to return alternating", "PK Reference - PK_BODY_find_facesets_o_t");
top.note("headers/pk_body_fix_blends_o_t.html#declaration", " <B>PK_LOGICAL_t</B> local_check; --- whether to perform local", "PK Reference - PK_BODY_fix_blends_o_t");
top.note("headers/pk_body_hollow.html#declaration", " <B>PK_LOGICAL_t</B> face_face_check, --- do face face checks", "PK Reference - PK_BODY_hollow");
top.note("headers/pk_body_hollow_o_t.html#declaration", " <B>PK_LOGICAL_t</B> pierce_tangent; --- DEPRECATED (PK_LOGICAL_false) [NF]", "PK Reference - PK_BODY_hollow_o_t");
top.note("headers/pk_body_identify_facesets_o_t.html#declaration", " <B>PK_LOGICAL_t</B> check_manifold; --- (PK_LOGICAL_true)", "PK Reference - PK_BODY_identify_facesets_o_t");
top.note("headers/pk_body_imprint_cus_normal_o_t.html#declaration", " <B>PK_LOGICAL_t</B> imprint_coi_exactly; --- whether to imprint curves", "PK Reference - PK_BODY_imprint_cus_normal_o_t");
top.note("headers/pk_body_imprint_cus_shadow_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_edges; --- whether to return new edges", "PK Reference - PK_BODY_imprint_cus_shadow_o_t");
top.note("headers/pk_body_imprint_cus_vec_o_t.html#declaration", " <B>PK_LOGICAL_t</B> imprint_coi_exactly;", "PK Reference - PK_BODY_imprint_cus_vec_o_t");
top.note("headers/pk_body_imprint_faces_o_t.html#declaration", " <B>PK_LOGICAL_t</B> imprint_tool; --- whether to imprint on tool", "PK Reference - PK_BODY_imprint_faces_o_t");
top.note("headers/pk_body_imprint_o_t.html#declaration", " <B>PK_LOGICAL_t</B> imprint_tool; --- whether to imprint on tool", "PK Reference - PK_BODY_imprint_o_t");
top.note("headers/pk_body_imprint_plane_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- whether a tolerance is provided", "PK Reference - PK_BODY_imprint_plane_o_t");
top.note("headers/pk_body_make_compound_o_t.html#declaration", " <B>PK_LOGICAL_t</B> report_shared_geometry;", "PK Reference - PK_BODY_make_compound_o_t");
top.note("headers/pk_body_make_curves_outline_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_topols; --- whether to return edges or faces", "PK Reference - PK_BODY_make_curves_outline_o_t");
top.note("headers/pk_body_make_facet_body_o_t.html#declaration", " <B>PK_LOGICAL_t</B> is_max_facet_width; --- Whether max_facet_width is set.", "PK Reference - PK_BODY_make_facet_body_o_t");
top.note("headers/pk_body_make_lofted_body_o_t.html#declaration", " <B>PK_LOGICAL_t</B> minimise_tolerance;", "PK Reference - PK_BODY_make_lofted_body_o_t");
top.note("headers/pk_body_make_persp_outline_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_tracking; --- whether to return the tracking", "PK Reference - PK_BODY_make_persp_outline_o_t");
top.note("headers/pk_body_make_section_o_t.html#declaration", " <B>PK_LOGICAL_t</B> tracking; --- (PK_LOGICAL_false)", "PK Reference - PK_BODY_make_section_o_t");
top.note("headers/pk_body_make_spun_outline_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_topols; --- (PK_LOGICAL_false)", "PK Reference - PK_BODY_make_spun_outline_o_t");
top.note("headers/pk_body_make_swept_body_2_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_twist_direction;", "PK Reference - PK_BODY_make_swept_body_2_o_t");
top.note("headers/pk_body_make_swept_body_o_t.html#declaration", " <B>PK_LOGICAL_t</B> minimise_tolerance;", "PK Reference - PK_BODY_make_swept_body_o_t");
top.note("headers/pk_body_make_swept_tool_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_rationals;", "PK Reference - PK_BODY_make_swept_tool_o_t");
top.note("headers/pk_body_offset.html#declaration", " <B>PK_LOGICAL_t</B> face_face_check --- do face face checks", "PK Reference - PK_BODY_offset");
top.note("headers/pk_body_offset_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_disjoint; --- whether disjoint body can be", "PK Reference - PK_BODY_offset_o_t");
top.note("headers/pk_body_offset_planar_wire_o_t.html#declaration", " <B>PK_LOGICAL_t</B> local_check; --- whether to perform local checks", "PK Reference - PK_BODY_offset_planar_wire_o_t");
top.note("headers/pk_body_pick_topols_o_t.html#declaration", " <B>PK_LOGICAL_t</B> near_plane; --- whether set", "PK Reference - PK_BODY_pick_topols_o_t");
top.note("headers/pk_body_pick_topols_o_t.html#documentation", "The tolerance values are defined by pair of <B>PK_LOGICAL_t</B> and double values.", "PK Reference - PK_BODY_pick_topols_o_t");
top.note("headers/pk_body_section_o_t.html#declaration", " <B>PK_LOGICAL_t</B> merge_imprinted;--- whether mergeable imprinted", "PK Reference - PK_BODY_section_o_t");
top.note("headers/pk_body_sew_bodies_o_t.html#declaration", " <B>PK_LOGICAL_t</B> set_global_tolerance;", "PK Reference - PK_BODY_sew_bodies_o_t");
top.note("headers/pk_body_share_geom.html#declaration", " <B>PK_LOGICAL_t</B> icurve_only, --- only process intersection curves", "PK Reference - PK_BODY_share_geom");
top.note("headers/pk_body_simplify_geom.html#declaration", " <B>PK_LOGICAL_t</B> local, --- whether partial replacement allowed", "PK Reference - PK_BODY_simplify_geom");
top.note("headers/pk_body_spin.html#declaration", " <B>PK_LOGICAL_t</B> local_check, --- whether local checking will be done", "PK Reference - PK_BODY_spin");
top.note("headers/pk_body_sweep.html#declaration", " <B>PK_LOGICAL_t</B> local_check, --- whether local checking will be done", "PK Reference - PK_BODY_sweep");
top.note("headers/pk_body_taper_o_t.html#declaration", " <B>PK_LOGICAL_t</B> miter_at_parting;", "PK Reference - PK_BODY_taper_o_t");
top.note("headers/pk_body_thicken.html#declaration", " <B>PK_LOGICAL_t</B> face_face_check, --- do face face checks", "PK Reference - PK_BODY_thicken");
top.note("headers/pk_body_thicken_o_t.html#declaration", " <B>PK_LOGICAL_t</B> report_sx; --- whether to report faces that", "PK Reference - PK_BODY_thicken_o_t");
top.note("headers/pk_body_transform.html#declaration", " <B>PK_LOGICAL_t</B> **const exact --- whether replaced geometry is exact", "PK Reference - PK_BODY_transform");
top.note("headers/pk_body_transform_o_t.html#declaration", " <B>PK_LOGICAL_t</B> merge_face; --- whether transformed faces are to be", "PK Reference - PK_BODY_transform_o_t");
top.note("headers/pk_body_trim.html#declaration", " <B>PK_LOGICAL_t</B> keep --- Logical to determine whether we keep", "PK Reference - PK_BODY_trim");
top.note("headers/pk_body_trim_neutral_sheets_o_t.html#declaration", " <B>PK_LOGICAL_t</B> extend_and_fill_holes;", "PK Reference - PK_BODY_trim_neutral_sheets_o_t");
top.note("headers/pk_boolean_config_o_t.html#declaration", " <B>PK_LOGICAL_t</B> no_tool_intersect; --- (PK_LOGICAL_false)", "PK Reference - PK_boolean_config_o_t");
top.note("headers/pk_boolean_match_o_t.html#declaration", " <B>PK_LOGICAL_t</B> auto_match; --- (PK_LOGICAL_false)", "PK Reference - PK_boolean_match_o_t");
top.note("headers/pk_bound_def_t.html#declaration", " <B>PK_LOGICAL_t</B> forward; --- whether bound in positive sense of path", "PK Reference - PK_bound_def_t");
top.note("headers/pk_bsurf_ask_knots_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_expanded_knots; --- whether to return expanded knots", "PK Reference - PK_BSURF_ask_knots_o_t");
top.note("headers/pk_bsurf_lower_degree_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- whether tolerance was specified", "PK Reference - PK_BSURF_lower_degree_o_t");
top.note("headers/pk_bsurf_piecewise_sf_t.html#declaration", " <B>PK_LOGICAL_t</B> is_rational; --- True if the surface is rational", "PK Reference - PK_BSURF_piecewise_sf_t");
top.note("headers/pk_bsurf_remove_knots_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- whether tolerance is set", "PK Reference - PK_BSURF_remove_knots_o_t");
top.note("headers/pk_bsurf_reparameterise_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_u_interval; --- whether to reparameterise along U", "PK Reference - PK_BSURF_reparameterise_o_t");
top.note("headers/pk_bsurf_sf_t.html#declaration", " <B>PK_LOGICAL_t</B> is_rational; --- True if the surface is rational", "PK Reference - PK_BSURF_sf_t");
top.note("headers/pk_change_edge_geom_data_t.html#declaration", " const <B>PK_LOGICAL_t</B> *reversals; --- array of logicals", "PK Reference - PK_change_edge_geom_data_t");
top.note("headers/pk_change_edge_geom_data_t.html#documentation", " reversals A <B>PK_LOGICAL_t</B> array indicating whether the associated", "PK Reference - PK_change_edge_geom_data_t");
top.note("headers/pk_class_is_subclass.html#declaration", " <B>PK_LOGICAL_t</B> *const is_subclass --- whether it was a subclass", "PK Reference - PK_CLASS_is_subclass");
top.note("headers/pk_curve_ask_parm_different.html#declaration", " <B>PK_LOGICAL_t</B> *const different --- true if pk and ki parametrisations", "PK Reference - PK_CURVE_ask_parm_different");
top.note("headers/pk_curve_degen_t.html#declaration", " <B>PK_LOGICAL_t</B> have_position;", "PK Reference - PK_CURVE_degen_t");
top.note("headers/pk_curve_embed_in_surf_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_curve_interval;", "PK Reference - PK_CURVE_embed_in_surf_o_t");
top.note("headers/pk_curve_find_box_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_interval; --- whether an interval is provided", "PK Reference - PK_CURVE_find_box_o_t");
top.note("headers/pk_curve_find_discontinuity_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_interval; --- whether to query a curve portion", "PK Reference - PK_CURVE_find_discontinuity_o_t");
top.note("headers/pk_curve_fix_self_int_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_multiple; --- whether to allow multiple curves", "PK Reference - PK_CURVE_fix_self_int_o_t");
top.note("headers/pk_curve_general_user_t.html#declaration", " <B>PK_LOGICAL_t</B> is_closed; --- closure of curve", "PK Reference - PK_CURVE_general_user_t");
top.note("headers/pk_curve_intersect_curve_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_box; --- whether box provided (PK_LOGICAL_false)", "PK Reference - PK_CURVE_intersect_curve_o_t");
top.note("headers/pk_curve_is_isoparam_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_interval; --- whether range on surface is wanted", "PK Reference - PK_CURVE_is_isoparam_o_t");
top.note("headers/pk_curve_make_approx.html#declaration", " <B>PK_LOGICAL_t</B> *const exact --- if returned curve is exact", "PK Reference - PK_CURVE_make_approx");
top.note("headers/pk_curve_make_bcurve.html#declaration", " <B>PK_LOGICAL_t</B> cubic, --- force cubic BCURVE", "PK Reference - PK_CURVE_make_bcurve");
top.note("headers/pk_curve_make_bcurve_array.html#declaration", " <B>PK_LOGICAL_t</B> *const all_succeeded --- whether succeeded for", "PK Reference - PK_CURVE_make_bcurve_array");
top.note("headers/pk_curve_make_bcurve_array_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_degree; --- whether a degree is", "PK Reference - PK_CURVE_make_bcurve_array_o_t");
top.note("headers/pk_curve_make_bcurve_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_degree; --- whether a degree is", "PK Reference - PK_CURVE_make_bcurve_o_t");
top.note("headers/pk_curve_make_spcurves.html#declaration", " <B>PK_LOGICAL_t</B> degenerate, --- create degenerate spcurves", "PK Reference - PK_CURVE_make_spcurves");
top.note("headers/pk_curve_make_spcurves_o_t.html#declaration", " <B>PK_LOGICAL_t</B> sense; --- SP-curves in same direction", "PK Reference - PK_CURVE_make_spcurves_o_t");
top.note("headers/pk_curve_make_wire_body_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_disjoint; --- is the wire body allowed to be", "PK Reference - PK_CURVE_make_wire_body_o_t");
top.note("headers/pk_curve_output_vectors.html#declaration", " <B>PK_LOGICAL_t</B> want_ts, --- whether curve parameters required", "PK Reference - PK_CURVE_output_vectors");
top.note("headers/pk_curve_project_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_direction; --- whether direction is set", "PK Reference - PK_CURVE_project_o_t");
top.note("headers/pk_curve_spin_o_t.html#declaration", " <B>PK_LOGICAL_t</B> simplify; --- (PK_LOGICAL_false)", "PK Reference - PK_CURVE_spin_o_t");
top.note("headers/pk_debug_body_compare_o_t.html#declaration", " <B>PK_LOGICAL_t</B> all_tests; --- perform all local tests", "PK Reference - PK_DEBUG_BODY_compare_o_t");
top.note("headers/pk_debug_data_t.html#declaration", " <B>PK_LOGICAL_t</B> is_geom_array; --- whether geom_array has data", "PK Reference - PK_DEBUG_data_t");
top.note("headers/pk_debug_local_diffs_r_t.html#declaration", " <B>PK_LOGICAL_t</B> master_logical;", "PK Reference - PK_DEBUG_local_diffs_r_t");
top.note("headers/pk_debug_report_start_o_t.html#declaration", " <B>PK_LOGICAL_t</B> transmit_parts; --- whether to transmit parts", "PK Reference - PK_DEBUG_report_start_o_t");
top.note("headers/pk_debug_try_error_handler_o_t.html#declaration", " <B>PK_LOGICAL_t</B> use_protected; --- Call from protected code", "PK Reference - PK_DEBUG_try_error_handler_o_t");
top.note("headers/pk_edge_ask_convexity_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_angular_tolerance; --- whether angular tolerance", "PK Reference - PK_EDGE_ask_convexity_o_t");
top.note("headers/pk_edge_ask_geometry.html#declaration", " <B>PK_LOGICAL_t</B> want_interval, --- whether parametric interval required", "PK Reference - PK_EDGE_ask_geometry");
top.note("headers/pk_edge_ask_geometry_nmnl.html#declaration", " <B>PK_LOGICAL_t</B> want_interval, --- whether parametric interval required", "PK Reference - PK_EDGE_ask_geometry_nmnl");
top.note("headers/pk_edge_ask_oriented_curve.html#declaration", " <B>PK_LOGICAL_t</B> *const orientation --- the edge orientation with respect to", "PK Reference - PK_EDGE_ask_oriented_curve");
top.note("headers/pk_edge_attach_curve_nmnl_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_interval; --- t_int is set (PK_LOGICAL_false)", "PK Reference - PK_EDGE_attach_curve_nmnl_o_t");
top.note("headers/pk_edge_attach_curves_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_senses; --- the senses array is set", "PK Reference - PK_EDGE_attach_curves_o_t");
top.note("headers/pk_edge_euler_delete_make_loop.html#declaration", " <B>PK_LOGICAL_t</B> forward, --- Forward vertex connects to new loop", "PK Reference - PK_EDGE_euler_delete_make_loop");
top.note("headers/pk_edge_euler_delete_ring_face.html#declaration", " <B>PK_LOGICAL_t</B> on_left --- Face on the left is to be", "PK Reference - PK_EDGE_euler_delete_ring_face");
top.note("headers/pk_edge_euler_delete_with_face.html#declaration", " <B>PK_LOGICAL_t</B> on_left --- Face to delete is on left of", "PK Reference - PK_EDGE_euler_delete_with_face");
top.note("headers/pk_edge_euler_delete_with_loop.html#declaration", " <B>PK_LOGICAL_t</B> on_left --- Loop to delete is on left of", "PK Reference - PK_EDGE_euler_delete_with_loop");
top.note("headers/pk_edge_euler_slit.html#declaration", " <B>PK_LOGICAL_t</B> on_left, --- New face is on left of edge", "PK Reference - PK_EDGE_euler_slit");
top.note("headers/pk_edge_euler_split.html#declaration", " <B>PK_LOGICAL_t</B> forward, --- New vertex is forward vertex", "PK Reference - PK_EDGE_euler_split");
top.note("headers/pk_edge_find_deviation_o_t.html#declaration", " <B>PK_LOGICAL_t</B> bound_at_split_vertex; --- Whether vertices of split ring", "PK Reference - PK_EDGE_find_deviation_o_t");
top.note("headers/pk_edge_find_g1_edges.html#declaration", " <B>PK_LOGICAL_t</B> convexity, --- convexity checking switch", "PK Reference - PK_EDGE_find_g1_edges");
top.note("headers/pk_edge_is_planar.html#declaration", " <B>PK_LOGICAL_t</B> want_plane, --- whether plane is wanted", "PK Reference - PK_EDGE_is_planar");
top.note("headers/pk_edge_is_smooth.html#declaration", " <B>PK_LOGICAL_t</B> *const is_smooth --- whether the edge is smooth", "PK Reference - PK_EDGE_is_smooth");
top.note("headers/pk_edge_make_faces_from_wire.html#declaration", "const <B>PK_LOGICAL_t</B> senses[], --- senses of initial fins", "PK Reference - PK_EDGE_make_faces_from_wire");
top.note("headers/pk_edge_make_wire_body_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_disjoint; --- the operation may return disjoint", "PK Reference - PK_EDGE_make_wire_body_o_t");
top.note("headers/pk_edge_remove_to_bodies_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_disjoint; --- Whether disjoint bodies can", "PK Reference - PK_EDGE_remove_to_bodies_o_t");
top.note("headers/pk_edge_repair_o_t.html#declaration", " <B>PK_LOGICAL_t</B> ensure_on_surfs; --- ensure edges lie on surfaces", "PK Reference - PK_EDGE_repair_o_t");
top.note("headers/pk_emboss_overflow_data_t.html#declaration", " <B>PK_LOGICAL_t</B> laminar_walled;", "PK Reference - PK_emboss_overflow_data_t");
top.note("headers/pk_entity_ask_owning_groups_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_groups; --- whether groups to be returned", "PK Reference - PK_ENTITY_ask_owning_groups_o_t");
top.note("headers/pk_entity_check_attribs_o_t.html#declaration", " <B>PK_LOGICAL_t</B> return_faults; --- return fault information", "PK Reference - PK_ENTITY_check_attribs_o_t");
top.note("headers/pk_entity_copy_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_user_fields; --- copy user fields", "PK Reference - PK_ENTITY_copy_o_t");
top.note("headers/pk_entity_find_reparam_o_t.html#declaration", " <B>PK_LOGICAL_t</B> stop_after_first; --- whether to stop after the", "PK Reference - PK_ENTITY_find_reparam_o_t");
top.note("headers/pk_entity_is.html#declaration", " <B>PK_LOGICAL_t</B> *const is_entity --- whether it is an entity", "PK Reference - PK_ENTITY_is");
top.note("headers/pk_entity_is_curve.html#declaration", " <B>PK_LOGICAL_t</B> *const is_curve --- whether entity is a curve", "PK Reference - PK_ENTITY_is_curve");
top.note("headers/pk_entity_is_geom.html#declaration", " <B>PK_LOGICAL_t</B> *const is_geom --- whether entity is geometry", "PK Reference - PK_ENTITY_is_geom");
top.note("headers/pk_entity_is_part.html#declaration", " <B>PK_LOGICAL_t</B> *const is_part --- whether entity is a part", "PK Reference - PK_ENTITY_is_part");
top.note("headers/pk_entity_is_surf.html#declaration", " <B>PK_LOGICAL_t</B> *const is_surf --- whether entity is a surface", "PK Reference - PK_ENTITY_is_surf");
top.note("headers/pk_entity_is_topol.html#declaration", " <B>PK_LOGICAL_t</B> *const is_topol --- whether entity is topology", "PK Reference - PK_ENTITY_is_topol");
top.note("headers/pk_entity_may_own_attdef.html#declaration", " <B>PK_LOGICAL_t</B> *const whether", "PK Reference - PK_ENTITY_may_own_attdef");
top.note("headers/pk_error_ask_last.html#declaration", " <B>PK_LOGICAL_t</B> *const was_error, --- whether there was an error", "PK Reference - PK_ERROR_ask_last");
top.note("headers/pk_error_clear_last.html#declaration", " <B>PK_LOGICAL_t</B> *const was_error --- whether there was an error to", "PK Reference - PK_ERROR_clear_last");
top.note("headers/pk_error_reraise.html#declaration", " <B>PK_LOGICAL_t</B> *const was_error --- whether there was an error to", "PK Reference - PK_ERROR_reraise");
top.note("headers/pk_face_ask_faces_adjacent_o_t.html#declaration", " <B>PK_LOGICAL_t</B> include_vertex_connected; --- Whether vertex-", "PK Reference - PK_FACE_ask_faces_adjacent_o_t");
top.note("headers/pk_face_ask_oriented_surf.html#declaration", " <B>PK_LOGICAL_t</B> *const orientation --- the face orientation with respect to", "PK Reference - PK_FACE_ask_oriented_surf");
top.note("headers/pk_face_attach_surf_fitting.html#declaration", " <B>PK_LOGICAL_t</B> local_check, --- whether to perform local check", "PK Reference - PK_FACE_attach_surf_fitting");
top.note("headers/pk_face_attach_surfs.html#declaration", "const <B>PK_LOGICAL_t</B> senses[] --- face senses", "PK Reference - PK_FACE_attach_surfs");
top.note("headers/pk_face_boolean_o_t.html#declaration", " <B>PK_LOGICAL_t</B> stop_self_intersection;", "PK Reference - PK_FACE_boolean_o_t");
top.note("headers/pk_face_change_data_replace_t.html#declaration", " <B>PK_LOGICAL_t</B> sense; --- replace surface orientation", "PK Reference - PK_FACE_change_data_replace_t");
top.note("headers/pk_face_change_deform_eval_f_t.html#declaration", " <B>PK_LOGICAL_t</B> have_params, --- whether surface parameters are", "PK Reference - PK_FACE_change_deform_eval_f_t");
top.note("headers/pk_face_change_deform_o_t.html#declaration", " <B>PK_LOGICAL_t</B> thread_safe; --- whether the external evaluator", "PK Reference - PK_FACE_change_deform_o_t");
top.note("headers/pk_face_change_o_t.html#declaration", " <B>PK_LOGICAL_t</B> merge_face;", "PK Reference - PK_FACE_change_o_t");
top.note("headers/pk_face_change_offset_o_t.html#declaration", " <B>PK_LOGICAL_t</B> report_sx; --- whether to report faces that have", "PK Reference - PK_FACE_change_offset_o_t");
top.note("headers/pk_face_change_radiate_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_axis; --- whether the axis of rotation is", "PK Reference - PK_FACE_change_radiate_o_t");
top.note("headers/pk_face_contains_vectors_o_t.html#declaration", " <B>PK_LOGICAL_t</B> is_on_surf; --- whether position vector is assumed", "PK Reference - PK_FACE_contains_vectors_o_t");
top.note("headers/pk_face_cover_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_bdry_tolerance;", "PK Reference - PK_FACE_cover_o_t");
top.note("headers/pk_face_delete.html#declaration", " <B>PK_LOGICAL_t</B> local_check, --- whether to perform local check", "PK Reference - PK_FACE_delete");
top.note("headers/pk_face_delete_facesets_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_disjoint; --- allow function to produce disjoint", "PK Reference - PK_FACE_delete_facesets_o_t");
top.note("headers/pk_face_delete_from_sheet_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_disjoint; --- Whether to allow a disjoint body to", "PK Reference - PK_FACE_delete_from_sheet_o_t");
top.note("headers/pk_face_delete_o_t.html#declaration", " <B>PK_LOGICAL_t</B> local_check; --- whether to perform local checking", "PK Reference - PK_FACE_delete_o_t");
top.note("headers/pk_face_details_hole_o_t.html#declaration", " <B>PK_LOGICAL_t</B> include_zero_depth;--- whether zero depth components", "PK Reference - PK_FACE_details_hole_o_t");
top.note("headers/pk_face_fix_mesh_defects_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_max_deviation;", "PK Reference - PK_FACE_fix_mesh_defects_o_t");
top.note("headers/pk_face_hollow.html#declaration", " <B>PK_LOGICAL_t</B> face_face_check, --- do face face checks", "PK Reference - PK_FACE_hollow");
top.note("headers/pk_face_hollow_2.html#declaration", " <B>PK_LOGICAL_t</B> face_face_check, --- do face face checks", "PK Reference - PK_FACE_hollow_2");
top.note("headers/pk_face_hollow_o_t.html#declaration", " <B>PK_LOGICAL_t</B> pierce_tangent; --- DEPRECATED", "PK Reference - PK_FACE_hollow_o_t");
top.note("headers/pk_face_identify_blends_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_pi; --- whether to return blends", "PK Reference - PK_FACE_identify_blends_o_t");
top.note("headers/pk_face_imprint_curves_isocline.html#declaration", " <B>PK_LOGICAL_t</B> **const is_steep, --- whether faces are steep (optional)", "PK Reference - PK_FACE_imprint_curves_isocline");
top.note("headers/pk_face_imprint_cus_isoclin.html#declaration", " <B>PK_LOGICAL_t</B> **const is_steep, --- whether faces are steep", "PK Reference - PK_FACE_imprint_cus_isoclin");
top.note("headers/pk_face_imprint_cus_isoclin_o_t.html#declaration", " <B>PK_LOGICAL_t</B> old_iso; --- DEPRECATED (PK_LOGICAL_false)", "PK Reference - PK_FACE_imprint_cus_isoclin_o_t");
top.note("headers/pk_face_imprint_cus_normal_o_t.html#declaration", " <B>PK_LOGICAL_t</B> imprint_coi_exactly; --- whether to imprint curves", "PK Reference - PK_FACE_imprint_cus_normal_o_t");
top.note("headers/pk_face_imprint_cus_vec_o_t.html#declaration", " <B>PK_LOGICAL_t</B> imprint_coi_exactly;", "PK Reference - PK_FACE_imprint_cus_vec_o_t");
top.note("headers/pk_face_imprint_faces_o_t.html#declaration", " <B>PK_LOGICAL_t</B> imprint_tool; --- whether to imprint on tool", "PK Reference - PK_FACE_imprint_faces_o_t");
top.note("headers/pk_face_imprint_o_t.html#declaration", " <B>PK_LOGICAL_t</B> imprint_tool; --- whether to imprint on tool", "PK Reference - PK_FACE_imprint_o_t");
top.note("headers/pk_face_install_surfs_isocline.html#declaration", " <B>PK_LOGICAL_t</B> face_face_check --- do face face checks", "PK Reference - PK_FACE_install_surfs_isocline");
top.note("headers/pk_face_instance_bodies_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_disjoint; --- allow disjoint body", "PK Reference - PK_FACE_instance_bodies_o_t");
top.note("headers/pk_face_intersect_face_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_box; --- whether box provided", "PK Reference - PK_FACE_intersect_face_o_t");
top.note("headers/pk_face_intersect_surf_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_box; --- whether box provided", "PK Reference - PK_FACE_intersect_surf_o_t");
top.note("headers/pk_face_is_uvbox.html#declaration", " <B>PK_LOGICAL_t</B> *const is_uvbox, --- whether face is parametric rectangle", "PK Reference - PK_FACE_is_uvbox");
top.note("headers/pk_face_make_3_face_blend_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_propagation_tolerance;", "PK Reference - PK_FACE_make_3_face_blend_o_t");
top.note("headers/pk_face_make_blend.html#declaration", " <B>PK_LOGICAL_t</B> left_sense, --- blend direction", "PK Reference - PK_FACE_make_blend");
top.note("headers/pk_face_make_blend_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_help_point;", "PK Reference - PK_FACE_make_blend_o_t");
top.note("headers/pk_face_make_neutral_sheet_o_t.html#declaration", " <B>PK_LOGICAL_t</B> extend_and_fill_holes;", "PK Reference - PK_FACE_make_neutral_sheet_o_t");
top.note("headers/pk_face_make_sect_with_sfs_o_t.html#declaration", " <B>PK_LOGICAL_t</B> tracking; --- Whether the tracking", "PK Reference - PK_FACE_make_sect_with_sfs_o_t");
top.note("headers/pk_face_make_sheet_bodies_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_disjoint; --- allow disjoint bodies", "PK Reference - PK_FACE_make_sheet_bodies_o_t");
top.note("headers/pk_face_make_solid_bodies.html#declaration", " <B>PK_LOGICAL_t</B> local_check, --- whether to perform local check", "PK Reference - PK_FACE_make_solid_bodies");
top.note("headers/pk_face_offset.html#declaration", " <B>PK_LOGICAL_t</B> face_face_check --- do face face checks", "PK Reference - PK_FACE_offset");
top.note("headers/pk_face_offset_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_disjoint; --- whether disjoint body can be", "PK Reference - PK_FACE_offset_o_t");
top.note("headers/pk_face_output_surf_trimmed.html#declaration", " <B>PK_LOGICAL_t</B> *const sense, --- which side of surface", "PK Reference - PK_FACE_output_surf_trimmed");
top.note("headers/pk_face_output_surf_trimmed_o_t.html#declaration", " <B>PK_LOGICAL_t</B> cubic; --- bsurf to be cubic", "PK Reference - PK_FACE_output_surf_trimmed_o_t");
top.note("headers/pk_face_overflow_data_o_t.html#declaration", " <B>PK_LOGICAL_t</B> laminar_walled; --- whether to add side faces", "PK Reference - PK_FACE_overflow_data_o_t");
top.note("headers/pk_face_remove_to_solid_bodies.html#declaration", " <B>PK_LOGICAL_t</B> local_check, --- whether to do local check", "PK Reference - PK_FACE_remove_to_solid_bodies");
top.note("headers/pk_face_repair_o_t.html#declaration", " <B>PK_LOGICAL_t</B> split_g1; --- split at G1 discontinuities", "PK Reference - PK_FACE_repair_o_t");
top.note("headers/pk_face_reparameterise_surf_o_t.html#declaration", " <B>PK_LOGICAL_t</B> transpose; --- whether to transpose U and V", "PK Reference - PK_FACE_reparameterise_surf_o_t");
top.note("headers/pk_face_replace_surfs.html#declaration", " <B>PK_LOGICAL_t</B> local_check, --- whether to perform local check", "PK Reference - PK_FACE_replace_surfs");
top.note("headers/pk_face_replace_surfs_2.html#declaration", "const <B>PK_LOGICAL_t</B> senses[], --- surface orientation", "PK Reference - PK_FACE_replace_surfs_2");
top.note("headers/pk_face_replace_surfs_3.html#declaration", "const <B>PK_LOGICAL_t</B> senses[], --- surface orientation", "PK Reference - PK_FACE_replace_surfs_3");
top.note("headers/pk_face_section_o_t.html#declaration", " <B>PK_LOGICAL_t</B> extend_face_list; --- (PK_LOGICAL_false)", "PK Reference - PK_FACE_section_o_t");
top.note("headers/pk_face_set_pair_t.html#declaration", " <B>PK_LOGICAL_t</B> sheet_pretrimmed;", "PK Reference - PK_FACE_set_pair_t");
top.note("headers/pk_face_simplify_geom_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_geoms; --- user requires new geoms to be returned", "PK Reference - PK_FACE_simplify_geom_o_t");
top.note("headers/pk_face_spin.html#declaration", " <B>PK_LOGICAL_t</B> local_check, --- whether local checking will be done", "PK Reference - PK_FACE_spin");
top.note("headers/pk_face_sweep.html#declaration", " <B>PK_LOGICAL_t</B> local_check, --- whether local checking will be done", "PK Reference - PK_FACE_sweep");
top.note("headers/pk_face_taper_o_t.html#declaration", " <B>PK_LOGICAL_t</B> merge_face; --- whether tapered faces are to", "PK Reference - PK_FACE_taper_o_t");
top.note("headers/pk_face_transform.html#declaration", " <B>PK_LOGICAL_t</B> local_check, --- whether to perform local check", "PK Reference - PK_FACE_transform");
top.note("headers/pk_face_transform_o_t.html#declaration", " <B>PK_LOGICAL_t</B> merge_face; --- whether transformed faces are to be", "PK Reference - PK_FACE_transform_o_t");
top.note("headers/pk_fill_hole_clamp_planar_t.html#declaration", " <B>PK_LOGICAL_t</B> have_normal;", "PK Reference - PK_fill_hole_clamp_planar_t");
top.note("headers/pk_fin_ask_geometry.html#declaration", " <B>PK_LOGICAL_t</B> want_interval, --- whether parametric interval required", "PK Reference - PK_FIN_ask_geometry");
top.note("headers/pk_fin_ask_oriented_curve.html#declaration", " <B>PK_LOGICAL_t</B> *const orientation --- the fin orientation with respect to", "PK Reference - PK_FIN_ask_oriented_curve");
top.note("headers/pk_fin_euler_glue.html#declaration", " <B>PK_LOGICAL_t</B> same_dir --- orientation of fins belonging to second edge", "PK Reference - PK_FIN_euler_glue");
top.note("headers/pk_fin_find_curve_parameter.html#declaration", " <B>PK_LOGICAL_t</B> estimate, --- whether t_est is to be used", "PK Reference - PK_FIN_find_curve_parameter");
top.note("headers/pk_fin_find_mtopols.html#declaration", " <B>PK_LOGICAL_t</B> *const sense --- whether the mfins are", "PK Reference - PK_FIN_find_mtopols");
top.note("headers/pk_fin_find_mtopols_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_mvertices; --- whether the mvertices are", "PK Reference - PK_FIN_find_mtopols_o_t");
top.note("headers/pk_fin_find_surf_parameters.html#declaration", " <B>PK_LOGICAL_t</B> estimate, --- whether parms_est is to be used", "PK Reference - PK_FIN_find_surf_parameters");
top.note("headers/pk_fin_is_positive.html#declaration", " <B>PK_LOGICAL_t</B> *const is_positive --- whether fin is positive or negative", "PK Reference - PK_FIN_is_positive");
top.note("headers/pk_frame_ask_sense.html#declaration", " <B>PK_LOGICAL_t</B> *const sense --- sense", "PK Reference - PK_FRAME_ask_sense");
top.note("headers/pk_geom_enlarge_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_trimming_box; --- whether a trimming box has been", "PK Reference - PK_GEOM_enlarge_o_t");
top.note("headers/pk_geom_is_coincident.html#declaration", " <B>PK_LOGICAL_t</B> *const is_coincident --- whether coincident", "PK Reference - PK_GEOM_is_coincident");
top.note("headers/pk_geom_range_array_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- (PK_LOGICAL_false)", "PK Reference - PK_GEOM_range_array_o_t");
top.note("headers/pk_geom_range_array_vector_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- (PK_LOGICAL_false)", "PK Reference - PK_GEOM_range_array_vector_o_t");
top.note("headers/pk_geom_range_local_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- (PK_LOGICAL_false)", "PK Reference - PK_GEOM_range_local_o_t");
top.note("headers/pk_geom_range_local_vector_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- (PK_LOGICAL_false)", "PK Reference - PK_GEOM_range_local_vector_o_t");
top.note("headers/pk_geom_range_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- whether tolerance value is", "PK Reference - PK_GEOM_range_o_t");
top.note("headers/pk_geom_range_vector_many_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- whether tolerance value is", "PK Reference - PK_GEOM_range_vector_many_o_t");
top.note("headers/pk_geom_range_vector_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- (PK_LOGICAL_false)", "PK Reference - PK_GEOM_range_vector_o_t");
top.note("headers/pk_geom_render_line_o_t.html#declaration", " <B>PK_LOGICAL_t</B> is_curve_chord_tol;", "PK Reference - PK_GEOM_render_line_o_t");
top.note("headers/pk_geom_render_line_o_t.html#documentation", " <B>PK_LOGICAL_t</B> flag and a double precision value. If a specific", "PK Reference - PK_GEOM_render_line_o_t");
top.note("headers/pk_geom_render_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_curve_chord_tol;--- Whether curve_chord_tol is", "PK Reference - PK_GEOM_render_o_t");
top.note("headers/pk_geom_render_o_t.html#documentation", " <B>PK_LOGICAL_t</B> flag and a double precision value. If a specific", "PK Reference - PK_GEOM_render_o_t");
top.note("headers/pk_geom_transform.html#declaration", " <B>PK_LOGICAL_t</B> *const exact --- whether result is exact", "PK Reference - PK_GEOM_transform");
top.note("headers/pk_geom_transform_2.html#declaration", " <B>PK_LOGICAL_t</B> exact[] --- whether result is exact", "PK Reference - PK_GEOM_transform_2");
top.note("headers/pk_geom_transform_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_out_geoms;--- fill return array with new geom", "PK Reference - PK_GEOM_transform_o_t");
top.note("headers/pk_group_ask_closure_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_attribs; --- return closing attributes", "PK Reference - PK_GROUP_ask_closure_o_t");
top.note("headers/pk_group_contains_entity.html#declaration", " <B>PK_LOGICAL_t</B> *const is_contained --- is the entity contained in the", "PK Reference - PK_GROUP_contains_entity");
top.note("headers/pk_group_find_entities_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_entities; --- return entities (PK_LOGICAL_true)", "PK Reference - PK_GROUP_find_entities_o_t");
top.note("headers/pk_lattice_ask_regions_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_senses; --- whether the senses of the lattice in", "PK Reference - PK_LATTICE_ask_regions_o_t");
top.note("headers/pk_lattice_ask_regions_r_t.html#declaration", " <B>PK_LOGICAL_t</B> *senses; --- the senses", "PK Reference - PK_LATTICE_ask_regions_r_t");
top.note("headers/pk_lattice_clip_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_clipped_lballs;", "PK Reference - PK_LATTICE_clip_o_t");
top.note("headers/pk_lattice_combine_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_snap_tolerance; --- Whether a snapping tolerance value", "PK Reference - PK_LATTICE_combine_o_t");
top.note("headers/pk_lattice_create_by_graph_o_t.html#declaration", " <B>PK_LOGICAL_t</B> thread_safe; --- Whether the graph_reader ", "PK Reference - PK_LATTICE_create_by_graph_o_t");
top.note("headers/pk_lattice_do_for_all_lballs.html#declaration", " <B>PK_LOGICAL_t</B> thread_safe --- whether the callback function is", "PK Reference - PK_LATTICE_do_for_all_lballs");
top.note("headers/pk_lattice_do_for_all_lrods.html#declaration", " <B>PK_LOGICAL_t</B> thread_safe --- whether the callback function is", "PK Reference - PK_LATTICE_do_for_all_lrods");
top.note("headers/pk_lattice_find_nabox_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_axis1; --- whether axis1 supplied", "PK Reference - PK_LATTICE_find_nabox_o_t");
top.note("headers/pk_law_sf_t.html#declaration", " <B>PK_LOGICAL_t</B> is_rational; --- If the law is rational.", "PK Reference - PK_LAW_sf_t");
top.note("headers/pk_lball_ask_lballs_adj_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_lballs; --- whether to return the lballs", "PK Reference - PK_LBALL_ask_lballs_adj_o_t");
top.note("headers/pk_lball_ask_lrods_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_lrods; --- whether to return the lrods", "PK Reference - PK_LBALL_ask_lrods_o_t");
top.note("headers/pk_logical_t.html#declaration", " typedef unsigned char <B>PK_LOGICAL_t</B>;", "PK Reference - PK_LOGICAL_t");
top.note("headers/pk_loop_is_isolated.html#declaration", " <B>PK_LOGICAL_t</B> *const is_isolated --- whether loop is isolated or not", "PK Reference - PK_LOOP_is_isolated");
top.note("headers/pk_ltopol_is_r_t.html#declaration", " <B>PK_LOGICAL_t</B> is_ltopol; --- whether the ltopol exists", "PK Reference - PK_LTOPOL_is_r_t");
top.note("headers/pk_mark_ask_forward.html#declaration", " <B>PK_LOGICAL_t</B> *const is_enabled --- whether roll forward is enabled", "PK Reference - PK_MARK_ask_forward");
top.note("headers/pk_mark_ask_state.html#declaration", " <B>PK_LOGICAL_t</B> *const is_at_mark --- whether modeller is at mark", "PK Reference - PK_MARK_ask_state");
top.note("headers/pk_mark_frustrum_t.html#declaration", " typedef PK_ERROR_code_t (*PK_MARK_open_f_t)( PK_MARK_t , <B>PK_LOGICAL_t</B> );", "PK Reference - PK_MARK_frustrum_t");
top.note("headers/pk_mark_is.html#declaration", " <B>PK_LOGICAL_t</B> *const is_mark --- whether it is a mark", "PK Reference - PK_MARK_is");
top.note("headers/pk_mark_is_on.html#declaration", " <B>PK_LOGICAL_t</B> *const is_on --- whether non-partitioned rollback active", "PK Reference - PK_MARK_is_on");
top.note("headers/pk_mark_start_o_t.html#declaration", " <B>PK_LOGICAL_t</B> forward; --- whether roll-forward is enabled (PK_LOGICAL_true)", "PK Reference - PK_MARK_start_o_t");
top.note("headers/pk_mesh_create_from_facets_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_box; --- Whether box of mesh is provided", "PK Reference - PK_MESH_create_from_facets_o_t");
top.note("headers/pk_mesh_defect_tolerances_t.html#declaration", " <B>PK_LOGICAL_t</B> have_degen_tolerance;", "PK Reference - PK_MESH_defect_tolerances_t");
top.note("headers/pk_mesh_eval_with_mtopol_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_lowest_mfacet; --- whether to return the mfacet", "PK Reference - PK_MESH_eval_with_mtopol_o_t");
top.note("headers/pk_mesh_facet_fan_t.html#declaration", " <B>PK_LOGICAL_t</B> is_relative_index; --- Indicates whether the", "PK Reference - PK_MESH_facet_fan_t");
top.note("headers/pk_mesh_facet_index_t.html#declaration", " <B>PK_LOGICAL_t</B> is_relative_index; --- Indicates whether", "PK Reference - PK_MESH_facet_index_t");
top.note("headers/pk_mesh_facet_strip_t.html#declaration", " <B>PK_LOGICAL_t</B> is_relative_index; --- Indicates whether the", "PK Reference - PK_MESH_facet_strip_t");
top.note("headers/pk_mesh_find_defects_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance;", "PK Reference - PK_MESH_find_defects_o_t");
top.note("headers/pk_mesh_find_laminar_mfins_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_plines; --- whether to return a pline", "PK Reference - PK_MESH_find_laminar_mfins_o_t");
top.note("headers/pk_mesh_find_sharp_mfins_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_sharp_mfins; --- whether the sharp mfins", "PK Reference - PK_MESH_find_sharp_mfins_o_t");
top.note("headers/pk_mesh_find_sharp_mvxs_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_sharp_mvxs; --- whether the sharp mvertices", "PK Reference - PK_MESH_find_sharp_mvxs_o_t");
top.note("headers/pk_mesh_fix_defects_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance;", "PK Reference - PK_MESH_fix_defects_o_t");
top.note("headers/pk_mesh_has_unique_normals.html#declaration", " <B>PK_LOGICAL_t</B> *const has_unique_normals --- whether the mesh", "PK Reference - PK_MESH_has_unique_normals");
top.note("headers/pk_mesh_imprint_vectors_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_mvertices; --- whether to return mvertices ", "PK Reference - PK_MESH_imprint_vectors_o_t");
top.note("headers/pk_mesh_is_loaded_r_t.html#declaration", " <B>PK_LOGICAL_t</B> is_loaded; --- whether mesh is loaded or not", "PK Reference - PK_MESH_is_loaded_r_t");
top.note("headers/pk_mesh_make_bodies_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_disjoint; --- whether result body may be", "PK Reference - PK_MESH_make_bodies_o_t");
top.note("headers/pk_mesh_make_surf_trimmed.html#declaration", " <B>PK_LOGICAL_t</B> *const sense, --- which side of surface", "PK Reference - PK_MESH_make_surf_trimmed");
top.note("headers/pk_mesh_make_surf_trimmed.html#documentation", " PK_SURF_t , a <B>PK_LOGICAL_t</B> representing the sense of the surface,", "PK Reference - PK_MESH_make_surf_trimmed");
top.note("headers/pk_mesh_make_surf_trimmed_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_bdry_tolerance;", "PK Reference - PK_MESH_make_surf_trimmed_o_t");
top.note("headers/pk_mesh_store_normals_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_mesh_angle;--- whether a mesh_angle is", "PK Reference - PK_MESH_store_normals_o_t");
top.note("headers/pk_mfacet_find_perimeters_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_plines; --- whether to return", "PK Reference - PK_MFACET_find_perimeters_o_t");
top.note("headers/pk_mfin_is_laminar.html#declaration", " <B>PK_LOGICAL_t</B> *const is_laminar --- whether the mfin is laminar", "PK Reference - PK_MFIN_is_laminar");
top.note("headers/pk_mfin_is_same_mfacet.html#declaration", " <B>PK_LOGICAL_t</B> * const is_same_mfacet --- whether the two mfins belong", "PK Reference - PK_MFIN_is_same_mfacet");
top.note("headers/pk_mfin_is_sharp.html#declaration", " <B>PK_LOGICAL_t</B> *const is_sharp --- whether the mfin is sharp", "PK Reference - PK_MFIN_is_sharp");
top.note("headers/pk_mfin_is_sharp_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_sharp_angle; --- whether sharp_angle is", "PK Reference - PK_MFIN_is_sharp_o_t");
top.note("headers/pk_mtopol_is.html#declaration", " <B>PK_LOGICAL_t</B> * is_mtopol --- whether the mtopol is valid", "PK Reference - PK_MTOPOL_is");
top.note("headers/pk_mtopol_make_meshes_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_disjoint; --- allow disjoint", "PK Reference - PK_MTOPOL_make_meshes_o_t");
top.note("headers/pk_mtopol_make_meshes_o_t.html#documentation", " senses An array of <B>PK_LOGICAL_t</B> values of length n_faces .", "PK Reference - PK_MTOPOL_make_meshes_o_t");
top.note("headers/pk_mtopol_select_cb_f_t.html#declaration", " <B>PK_LOGICAL_t</B> *select, --- mtopol select decision", "PK Reference - PK_MTOPOL_select_cb_f_t");
top.note("headers/pk_mvertex_ask_normals_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_normals; --- whether the normals are", "PK Reference - PK_MVERTEX_ask_normals_o_t");
top.note("headers/pk_mvertex_is_laminar.html#declaration", " <B>PK_LOGICAL_t</B> *const is_laminar --- whether mvertex is on the laminar", "PK Reference - PK_MVERTEX_is_laminar");
top.note("headers/pk_param_sf_t.html#declaration", " <B>PK_LOGICAL_t</B> continuous; --- whether continuous", "PK Reference - PK_PARAM_sf_t");
top.note("headers/pk_part_ask_attribs_cb_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_attribs; --- return attributes (PK_LOGICAL_true)", "PK Reference - PK_PART_ask_attribs_cb_o_t");
top.note("headers/pk_part_ask_groups_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_groups; --- whether groups to be returned", "PK Reference - PK_PART_ask_groups_o_t");
top.note("headers/pk_part_receive_meshes_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_owners; --- Whether function should", "PK Reference - PK_PART_receive_meshes_o_t");
top.note("headers/pk_part_receive_o_t.html#declaration", " <B>PK_LOGICAL_t</B> receive_user_fields;", "PK Reference - PK_PART_receive_o_t");
top.note("headers/pk_part_transmit_o_t.html#declaration", " <B>PK_LOGICAL_t</B> transmit_user_fields;", "PK Reference - PK_PART_transmit_o_t");
top.note("headers/pk_partition_ask_facet_geom_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_parts; --- whether parts with", "PK Reference - PK_PARTITION_ask_facet_geom_o_t");
top.note("headers/pk_partition_ask_pmark.html#declaration", " <B>PK_LOGICAL_t</B> *const is_at_pmark --- whether partition is at this pmark", "PK Reference - PK_PARTITION_ask_pmark");
top.note("headers/pk_partition_ask_pmarks_2_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_pmarks; --- whether to return an array of", "PK Reference - PK_PARTITION_ask_pmarks_2_o_t");
top.note("headers/pk_partition_ask_r_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_partial_pmarks; --- whether the partition allows", "PK Reference - PK_PARTITION_ask_r_t");
top.note("headers/pk_partition_clone_pmark_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_attrib_mod; --- return entities modified", "PK Reference - PK_PARTITION_clone_pmark_o_t");
top.note("headers/pk_partition_create_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_partial_pmarks;--- whether to allow partial", "PK Reference - PK_PARTITION_create_o_t");
top.note("headers/pk_partition_delete_o_t.html#declaration", " <B>PK_LOGICAL_t</B> delete_non_empty; --- forcibly delete non-empty partitions", "PK Reference - PK_PARTITION_delete_o_t");
top.note("headers/pk_partition_has_guard.html#declaration", " <B>PK_LOGICAL_t</B> *const has_guard, --- whether partition has a guard", "PK Reference - PK_PARTITION_has_guard");
top.note("headers/pk_partition_has_lattices_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_parts; --- whether parts with lattice geometry are", "PK Reference - PK_PARTITION_has_lattices_o_t");
top.note("headers/pk_partition_has_lattices_r_t.html#declaration", " <B>PK_LOGICAL_t</B> has_lattices; --- whether the partition contains lattices", "PK Reference - PK_PARTITION_has_lattices_r_t");
top.note("headers/pk_partition_is.html#declaration", " <B>PK_LOGICAL_t</B> *const is_partition --- whether it is a partition", "PK Reference - PK_PARTITION_is");
top.note("headers/pk_partition_is_clone_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_box; --- whether a box is provided", "PK Reference - PK_PARTITION_is_clone_o_t");
top.note("headers/pk_partition_make_pmark_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_attrib_mod; --- return entities modified", "PK Reference - PK_PARTITION_make_pmark_o_t");
top.note("headers/pk_partition_receive_meshes_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_owners; --- Whether function should", "PK Reference - PK_PARTITION_receive_meshes_o_t");
top.note("headers/pk_partition_receive_o_t.html#declaration", " <B>PK_LOGICAL_t</B> receive_user_fields;", "PK Reference - PK_PARTITION_receive_o_t");
top.note("headers/pk_partition_transmit_o_t.html#declaration", " <B>PK_LOGICAL_t</B> transmit_user_fields;", "PK Reference - PK_PARTITION_transmit_o_t");
top.note("headers/pk_pattern_bound_t.html#declaration", " <B>PK_LOGICAL_t</B> have_repetitions_i;", "PK Reference - PK_pattern_bound_t");
top.note("headers/pk_pattern_callback_t.html#declaration", " <B>PK_LOGICAL_t</B> thread_safe; --- whether the pattern_cb ", "PK Reference - PK_pattern_callback_t");
top.note("headers/pk_pline_sf_t.html#declaration", " <B>PK_LOGICAL_t</B> closed;", "PK Reference - PK_PLINE_sf_t");
top.note("headers/pk_pmark_ask_entities_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_new_entities; --- return new entities", "PK Reference - PK_PMARK_ask_entities_o_t");
top.note("headers/pk_pmark_goto_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_attrib_mod; --- return entities modified", "PK Reference - PK_PMARK_goto_o_t");
top.note("headers/pk_pmark_is.html#declaration", " <B>PK_LOGICAL_t</B> *const is_pmark --- whether it is a pmark", "PK Reference - PK_PMARK_is");
top.note("headers/pk_pmark_is_used_by_mark.html#declaration", " <B>PK_LOGICAL_t</B> *const is_used --- whether it is used by a", "PK Reference - PK_PMARK_is_used_by_mark");
top.note("headers/pk_range_bound_t.html#declaration", " <B>PK_LOGICAL_t</B> have_upper_bound; --- (PK_LOGICAL_false)", "PK Reference - PK_range_bound_t");
top.note("headers/pk_range_end_t.html#declaration", " <B>PK_LOGICAL_t</B> region; --- whether solution is regional", "PK Reference - PK_range_end_t");
top.note("headers/pk_range_param_bound_t.html#declaration", " <B>PK_LOGICAL_t</B> have_param_bound;", "PK Reference - PK_range_param_bound_t");
top.note("headers/pk_region_ask_lattices_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_senses; --- whether the senses of the lattices in", "PK Reference - PK_REGION_ask_lattices_o_t");
top.note("headers/pk_region_ask_lattices_r_t.html#declaration", " <B>PK_LOGICAL_t</B> *senses; --- the senses", "PK Reference - PK_REGION_ask_lattices_r_t");
top.note("headers/pk_region_embed_lattices.html#declaration", "const <B>PK_LOGICAL_t</B> senses[], --- frame senses", "PK Reference - PK_REGION_embed_lattices");
top.note("headers/pk_region_embed_lattices_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_frames; --- Whether frames created by", "PK Reference - PK_REGION_embed_lattices_o_t");
top.note("headers/pk_region_is_solid.html#declaration", " <B>PK_LOGICAL_t</B> *const is_solid --- whether region is solid or void", "PK Reference - PK_REGION_is_solid");
top.note("headers/pk_report_3_t.html#documentation", " and will contain elements of type <B>PK_LOGICAL_t</B> to indicate whether the", "PK Reference - PK_REPORT_3_t");
top.note("headers/pk_report_is_open.html#declaration", " <B>PK_LOGICAL_t</B> *const is_open --- whether report is open or closed", "PK Reference - PK_REPORT_is_open");
top.note("headers/pk_session_ask_attdefs_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_attdefs; --- return attribute definitions", "PK Reference - PK_SESSION_ask_attdefs_o_t");
top.note("headers/pk_session_ask_check_arguments.html#declaration", " <B>PK_LOGICAL_t</B> *const whether --- whether argument checking is enabled", "PK Reference - PK_SESSION_ask_check_arguments");
top.note("headers/pk_session_ask_check_continuity.html#declaration", " <B>PK_LOGICAL_t</B> *const whether --- whether continuity checking is enabled", "PK Reference - PK_SESSION_ask_check_continuity");
top.note("headers/pk_session_ask_check_self_int.html#declaration", " <B>PK_LOGICAL_t</B> *const whether --- whether self intersection checking is enabled", "PK Reference - PK_SESSION_ask_check_self_int");
top.note("headers/pk_session_ask_close_knots.html#declaration", " <B>PK_LOGICAL_t</B> *const whether --- whether close knots are allowed", "PK Reference - PK_SESSION_ask_close_knots");
top.note("headers/pk_session_ask_fru_o_t.html#declaration", " <B>PK_LOGICAL_t</B> *go_thread_safe;", "PK Reference - PK_SESSION_ask_fru_o_t");
top.note("headers/pk_session_ask_general_topology.html#declaration", " <B>PK_LOGICAL_t</B> *const whether --- whether generalised topology is enabled", "PK Reference - PK_SESSION_ask_general_topology");
top.note("headers/pk_session_ask_journalling.html#declaration", " <B>PK_LOGICAL_t</B> *const whether --- whether journalling is enabled", "PK Reference - PK_SESSION_ask_journalling");
top.note("headers/pk_session_ask_mark.html#declaration", " <B>PK_LOGICAL_t</B> *const at_mark --- whether at the mark or not", "PK Reference - PK_SESSION_ask_mark");
top.note("headers/pk_session_ask_swept_spun_surfs.html#declaration", " <B>PK_LOGICAL_t</B> *const whether --- whether swept/spun surfaces enabled", "PK Reference - PK_SESSION_ask_swept_spun_surfs");
top.note("headers/pk_session_ask_unicode.html#declaration", " <B>PK_LOGICAL_t</B> *const whether", "PK Reference - PK_SESSION_ask_unicode");
top.note("headers/pk_session_is_in_kernel.html#declaration", " <B>PK_LOGICAL_t</B> *const is_in_kernel, --- whether called from within the kernel", "PK Reference - PK_SESSION_is_in_kernel");
top.note("headers/pk_session_is_in_kernel_2.html#declaration", " <B>PK_LOGICAL_t</B> *const is_in_kernel, --- whether called from within the kernel", "PK Reference - PK_SESSION_is_in_kernel_2");
top.note("headers/pk_session_is_roll_forward_on.html#declaration", " <B>PK_LOGICAL_t</B> *const roll_forward_on --- roll forward interface parameter", "PK Reference - PK_SESSION_is_roll_forward_on");
top.note("headers/pk_session_is_rollback_on.html#declaration", " <B>PK_LOGICAL_t</B> *const rollback_on --- true if rollback is on", "PK Reference - PK_SESSION_is_rollback_on");
top.note("headers/pk_session_receive_o_t.html#declaration", " <B>PK_LOGICAL_t</B> receive_user_fields;", "PK Reference - PK_SESSION_receive_o_t");
top.note("headers/pk_session_register_fru_o_t.html#declaration", " <B>PK_LOGICAL_t</B> *go_thread_safe;", "PK Reference - PK_SESSION_register_fru_o_t");
top.note("headers/pk_session_register_fru_o_t.html#documentation", " <B>PK_LOGICAL_t</B> with value PK_LOGICAL_true, then Parasolid may call the GO", "PK Reference - PK_SESSION_register_fru_o_t");
top.note("headers/pk_session_set_check_arguments.html#declaration", " <B>PK_LOGICAL_t</B> whether --- whether argument checking required", "PK Reference - PK_SESSION_set_check_arguments");
top.note("headers/pk_session_set_check_continuity.html#declaration", " <B>PK_LOGICAL_t</B> whether --- whether continuity checking required", "PK Reference - PK_SESSION_set_check_continuity");
top.note("headers/pk_session_set_check_self_int.html#declaration", " <B>PK_LOGICAL_t</B> whether --- whether self intersection checking required", "PK Reference - PK_SESSION_set_check_self_int");
top.note("headers/pk_session_set_close_knots.html#declaration", " <B>PK_LOGICAL_t</B> whether --- whether close knots are allowed", "PK Reference - PK_SESSION_set_close_knots");
top.note("headers/pk_session_set_general_topology.html#declaration", " <B>PK_LOGICAL_t</B> whether --- whether generalised topology is to be enabled", "PK Reference - PK_SESSION_set_general_topology");
top.note("headers/pk_session_set_journalling.html#declaration", " <B>PK_LOGICAL_t</B> whether --- whether journalling is to be enabled", "PK Reference - PK_SESSION_set_journalling");
top.note("headers/pk_session_set_roll_forward.html#declaration", " <B>PK_LOGICAL_t</B> roll_forward_on --- roll_forward parameter setting", "PK Reference - PK_SESSION_set_roll_forward");
top.note("headers/pk_session_set_swept_spun_surfs.html#declaration", " <B>PK_LOGICAL_t</B> whether --- whether swept/spun surfs are to be enabled", "PK Reference - PK_SESSION_set_swept_spun_surfs");
top.note("headers/pk_session_set_unicode.html#declaration", " <B>PK_LOGICAL_t</B> whether --- whether to enable Unicode keys", "PK Reference - PK_SESSION_set_unicode");
top.note("headers/pk_session_smp_o_t.html#declaration", " <B>PK_LOGICAL_t</B> on_single_processor; --- (PK_LOGICAL_false)", "PK Reference - PK_SESSION_smp_o_t");
top.note("headers/pk_session_smp_r_t.html#declaration", " <B>PK_LOGICAL_t</B> on_single_processor;", "PK Reference - PK_SESSION_smp_r_t");
top.note("headers/pk_session_transmit_o_t.html#declaration", " <B>PK_LOGICAL_t</B> transmit_user_fields;", "PK Reference - PK_SESSION_transmit_o_t");
top.note("headers/pk_shell_ask_oriented_faces.html#declaration", " <B>PK_LOGICAL_t</B> **const orients --- orientations (optional)", "PK Reference - PK_SHELL_ask_oriented_faces");
top.note("headers/pk_surf_create_blend_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_help; --- (PK_LOGICAL_false)", "PK Reference - PK_SURF_create_blend_o_t");
top.note("headers/pk_surf_degen_t.html#declaration", " <B>PK_LOGICAL_t</B> have_position;", "PK Reference - PK_SURF_degen_t");
top.note("headers/pk_surf_eval.html#declaration", " <B>PK_LOGICAL_t</B> triangular, --- triangular derivative array required", "PK Reference - PK_SURF_eval");
top.note("headers/pk_surf_eval_grid.html#declaration", " <B>PK_LOGICAL_t</B> triangular, --- triangular derivative array required", "PK Reference - PK_SURF_eval_grid");
top.note("headers/pk_surf_eval_handed.html#declaration", " <B>PK_LOGICAL_t</B> triangular, --- triangular derivative array required", "PK Reference - PK_SURF_eval_handed");
top.note("headers/pk_surf_eval_with_normal.html#declaration", " <B>PK_LOGICAL_t</B> triangular, --- triangular derivative array required", "PK Reference - PK_SURF_eval_with_normal");
top.note("headers/pk_surf_eval_with_normal_handed.html#declaration", " <B>PK_LOGICAL_t</B> triangular, --- triangular derivative array required", "PK Reference - PK_SURF_eval_with_normal_handed");
top.note("headers/pk_surf_extend_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_partial_extension;", "PK Reference - PK_SURF_extend_o_t");
top.note("headers/pk_surf_find_box_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_uvbox; --- whether a uvbox is provided", "PK Reference - PK_SURF_find_box_o_t");
top.note("headers/pk_surf_find_discontinuity_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_uvbox; --- true if sub-domain is to be used", "PK Reference - PK_SURF_find_discontinuity_o_t");
top.note("headers/pk_surf_find_vectors_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_help_point; --- whether a help_point has", "PK Reference - PK_SURF_find_vectors_o_t");
top.note("headers/pk_surf_fix_self_int_o_t.html#declaration", " <B>PK_LOGICAL_t</B> allow_multiple; --- whether to allow multiple surfaces", "PK Reference - PK_SURF_fix_self_int_o_t");
top.note("headers/pk_surf_general_user_t.html#declaration", " <B>PK_LOGICAL_t</B> is_u_closed; --- closure of surface in u", "PK Reference - PK_SURF_general_user_t");
top.note("headers/pk_surf_intersect_curve_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_box; --- whether box provided (PK_LOGICAL_false)", "PK Reference - PK_SURF_intersect_curve_o_t");
top.note("headers/pk_surf_intersect_surf_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_box; --- whether box provided", "PK Reference - PK_SURF_intersect_surf_o_t");
top.note("headers/pk_surf_make_bsurf.html#declaration", " <B>PK_LOGICAL_t</B> cubic, --- force cubic BCURVE", "PK Reference - PK_SURF_make_bsurf");
top.note("headers/pk_surf_make_bsurf_array.html#declaration", " <B>PK_LOGICAL_t</B> *const all_succeeded --- whether succeeded for", "PK Reference - PK_SURF_make_bsurf_array");
top.note("headers/pk_surf_make_bsurf_array_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_u_degree;", "PK Reference - PK_SURF_make_bsurf_array_o_t");
top.note("headers/pk_surf_make_bsurf_o_t.html#declaration", " <B>PK_LOGICAL_t</B> force_cubic;", "PK Reference - PK_SURF_make_bsurf_o_t");
top.note("headers/pk_surf_make_curve_isoparam_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_interval; --- whether to return the", "PK Reference - PK_SURF_make_curve_isoparam_o_t");
top.note("headers/pk_surf_make_cus_isocline_o_t.html#declaration", " <B>PK_LOGICAL_t</B> old_iso; --- DEPRECATED (PK_LOGICAL_false)", "PK Reference - PK_SURF_make_cus_isocline_o_t");
top.note("headers/pk_surf_make_sheet_trimmed_o_t.html#declaration", " <B>PK_LOGICAL_t</B> check_wires; --- identify wire topology", "PK Reference - PK_SURF_make_sheet_trimmed_o_t");
top.note("headers/pk_thread_ask_exclusion.html#declaration", " <B>PK_LOGICAL_t</B> *const was_this_thread --- whether the calling thread", "PK Reference - PK_THREAD_ask_exclusion");
top.note("headers/pk_thread_ask_id.html#declaration", " <B>PK_LOGICAL_t</B> *const is_subthread --- whether called from internal thread", "PK Reference - PK_THREAD_ask_id");
top.note("headers/pk_thread_ask_last_error.html#declaration", " <B>PK_LOGICAL_t</B> *const was_error, --- whether there was an error", "PK Reference - PK_THREAD_ask_last_error");
top.note("headers/pk_thread_clear_exclusion.html#declaration", " <B>PK_LOGICAL_t</B> *const was_this_thread --- whether the calling thread", "PK Reference - PK_THREAD_clear_exclusion");
top.note("headers/pk_thread_clear_last_error.html#declaration", " <B>PK_LOGICAL_t</B> *const was_error --- whether there was an error to", "PK Reference - PK_THREAD_clear_last_error");
top.note("headers/pk_thread_is_in_kernel.html#declaration", " <B>PK_LOGICAL_t</B> *const is_in_kernel, --- whether called from within the kernel", "PK Reference - PK_THREAD_is_in_kernel");
top.note("headers/pk_thread_lock_partitions_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_locked_partitions;", "PK Reference - PK_THREAD_lock_partitions_o_t");
top.note("headers/pk_topol_ask_entities_by_attdef.html#declaration", " <B>PK_LOGICAL_t</B> have_attrib, --- whether entities have an attribute", "PK Reference - PK_TOPOL_ask_entities_by_attdef");
top.note("headers/pk_topol_clash_o_t.html#declaration", " <B>PK_LOGICAL_t</B> find_all; --- Find all clashes, not just the first", "PK Reference - PK_TOPOL_clash_o_t");
top.note("headers/pk_topol_delete_redundant_2_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_vertex_angle; --- whether a vertex_angle ", "PK Reference - PK_TOPOL_delete_redundant_2_o_t");
top.note("headers/pk_topol_eval_mass_props_o_t.html#declaration", " <B>PK_LOGICAL_t</B> single; --- whether to treat topols as", "PK Reference - PK_TOPOL_eval_mass_props_o_t");
top.note("headers/pk_topol_facet_choice_2_o_t.html#declaration", " <B>PK_LOGICAL_t</B> thread_safe; --- whether the callback function is", "PK Reference - PK_TOPOL_facet_choice_2_o_t");
top.note("headers/pk_topol_facet_choice_2_o_t.html#documentation", "Each of the <B>PK_LOGICAL_t</B> fields may be set by the application to the", "PK Reference - PK_TOPOL_facet_choice_2_o_t");
top.note("headers/pk_topol_facet_choice_o_t.html#declaration", " <B>PK_LOGICAL_t</B> facet_fin;", "PK Reference - PK_TOPOL_facet_choice_o_t");
top.note("headers/pk_topol_facet_choice_o_t.html#documentation", " <B>PK_LOGICAL_t</B> <from>_<to>", "PK Reference - PK_TOPOL_facet_choice_o_t");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#declaration", " <B>PK_LOGICAL_t</B> is_min_facet_width; --- whether min_facet_width is set", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_2_o_t.html#documentation", " The tolerance values are defined by pair of <B>PK_LOGICAL_t</B> and double values,", "PK Reference - PK_TOPOL_facet_mesh_2_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#declaration", " <B>PK_LOGICAL_t</B> is_min_facet_width; --- whether min_facet_width is set", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_facet_mesh_o_t.html#documentation", " The tolerance values are defined by pair of <B>PK_LOGICAL_t</B> and double values,", "PK Reference - PK_TOPOL_facet_mesh_o_t");
top.note("headers/pk_topol_facet_r_t.html#documentation", " <B>PK_LOGICAL_t</B> switch names in PK_TOPOL_facet_choice_o_t ", "PK Reference - PK_TOPOL_facet_r_t");
top.note("headers/pk_topol_facet_table_t.html#documentation", "\"<table>\" field name corresponds to one of the <B>PK_LOGICAL_t</B> switch names in", "PK Reference - PK_TOPOL_facet_table_t");
top.note("headers/pk_topol_find_box_2_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_topol_boxes; --- whether boxes of individual", "PK Reference - PK_TOPOL_find_box_2_o_t");
top.note("headers/pk_topol_find_frames_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_geoms; --- whether the geometries of the frames should", "PK Reference - PK_TOPOL_find_frames_o_t");
top.note("headers/pk_topol_find_frames_r_t.html#declaration", " <B>PK_LOGICAL_t</B> *senses; --- the frame senses", "PK Reference - PK_TOPOL_find_frames_r_t");
top.note("headers/pk_topol_find_nabox_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_axis1; --- whether axis1 supplied", "PK Reference - PK_TOPOL_find_nabox_o_t");
top.note("headers/pk_topol_identify_redundant_o_t.html#declaration", " <B>PK_LOGICAL_t</B> want_redundant_topols; --- whether redundant topols", "PK Reference - PK_TOPOL_identify_redundant_o_t");
top.note("headers/pk_topol_make_facet_topol_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_angular_tolerance; --- Whether angular_tolerance", "PK Reference - PK_TOPOL_make_facet_topol_o_t");
top.note("headers/pk_topol_range_array_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- (PK_LOGICAL_false)", "PK Reference - PK_TOPOL_range_array_o_t");
top.note("headers/pk_topol_range_array_vector_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- (PK_LOGICAL_false)", "PK Reference - PK_TOPOL_range_array_vector_o_t");
top.note("headers/pk_topol_range_geom_array_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- whether tolerance value is", "PK Reference - PK_TOPOL_range_geom_array_o_t");
top.note("headers/pk_topol_range_geom_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- whether tolerance value is", "PK Reference - PK_TOPOL_range_geom_o_t");
top.note("headers/pk_topol_range_local_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- (PK_LOGICAL_false)", "PK Reference - PK_TOPOL_range_local_o_t");
top.note("headers/pk_topol_range_local_vector_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- (PK_LOGICAL_false)", "PK Reference - PK_TOPOL_range_local_vector_o_t");
top.note("headers/pk_topol_range_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- whether tolerance value is provided", "PK Reference - PK_TOPOL_range_o_t");
top.note("headers/pk_topol_range_vector_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_tolerance; --- (PK_LOGICAL_false)", "PK Reference - PK_TOPOL_range_vector_o_t");
top.note("headers/pk_topol_render_line_o_t.html#declaration", " <B>PK_LOGICAL_t</B> is_curve_chord_tol;", "PK Reference - PK_TOPOL_render_line_o_t");
top.note("headers/pk_topol_render_line_o_t.html#documentation", " <B>PK_LOGICAL_t</B> flag and a double precision value. If a specific", "PK Reference - PK_TOPOL_render_line_o_t");
top.note("headers/pk_topol_render_volume_o_t.html#declaration", " <B>PK_LOGICAL_t</B> is_min_facet_width; --- Whether min_facet_width", "PK Reference - PK_TOPOL_render_volume_o_t");
top.note("headers/pk_topol_render_volume_o_t.html#documentation", " tolerance values are each defined by a pair of <B>PK_LOGICAL_t</B> and double", "PK Reference - PK_TOPOL_render_volume_o_t");
top.note("headers/pk_transf_create_view_o_t.html#declaration", " <B>PK_LOGICAL_t</B> have_eye_position; --- whether a perspective vector exists", "PK Reference - PK_TRANSF_create_view_o_t");
top.note("headers/pk_transf_enlarge_o_t.html#declaration", " <B>PK_LOGICAL_t</B> modify; --- whether to modify transf ", "PK Reference - PK_TRANSF_enlarge_o_t");
top.note("headers/pk_transf_is_equal.html#declaration", " <B>PK_LOGICAL_t</B> *const is_equal --- whether transformations are equal", "PK Reference - PK_TRANSF_is_equal");
top.note("headers/pk_transf_transform_o_t.html#declaration", " <B>PK_LOGICAL_t</B> modify; --- whether to modify transf_1 ", "PK Reference - PK_TRANSF_transform_o_t");
top.note("headers/pk_ucoprd_f_t.html#declaration", "const <B>PK_LOGICAL_t</B> skiphd,", "PK Reference - PK_UCOPRD_f_t");
top.note("headers/pk_ucoprd_f_t.html#documentation", " <B>PK_LOGICAL_t</B> skiphd --- action required on opening file", "PK Reference - PK_UCOPRD_f_t");
top.note("headers/pk_vector_is_equal.html#declaration", " <B>PK_LOGICAL_t</B> *const is_equal", "PK Reference - PK_VECTOR_is_equal");
top.note("headers/pk_vector_is_parallel.html#declaration", " <B>PK_LOGICAL_t</B> *const is_parallel", "PK Reference - PK_VECTOR_is_parallel");
top.note("headers/pk_vector_is_zero.html#declaration", " <B>PK_LOGICAL_t</B> *const is_zero", "PK Reference - PK_VECTOR_is_zero");
top.note("headers/pk_vertex_ask_oriented_edges.html#declaration", " <B>PK_LOGICAL_t</B> **const orients --- edge orientations (optional)", "PK Reference - PK_VERTEX_ask_oriented_edges");
top.note("headers/pk_vertex_make_blend.html#declaration", " <B>PK_LOGICAL_t</B> local_check, --- whether local checking required", "PK Reference - PK_VERTEX_make_blend");
top.note("headers/pk_vertex_spin.html#declaration", " <B>PK_LOGICAL_t</B> local_check, --- whether local checking will be done", "PK Reference - PK_VERTEX_spin");
top.note("headers/pk_vertex_sweep.html#declaration", " <B>PK_LOGICAL_t</B> local_check, --- whether local checking will be done", "PK Reference - PK_VERTEX_sweep");
top.note("chapters/kd_chap.05.html#50475010_pgfId-281044", " <B>PK_LOGICAL_t</B> ", "KID Manual - Calling the KI/PK Using KID (FLICK)");
top.display();
//-->
</SCRIPT>
</HEAD>
<BODY bgcolor=#FFFFFF link=#0F3A68 vlink=#878787 alink=#FF7600 leftmargin=0 topmargin=0 marginwidth=0 marginheight=0>
</BODY>
</HTML>
