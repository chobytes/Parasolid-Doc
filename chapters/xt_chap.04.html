<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 2015/HTML Export Filter">
<SCRIPT LANGUAGE="JavaScript">
<!--
if (parent.theMenu) {
    var entryID = parent.theMenu.findEntry(location.pathname, "url", "right", 0);
    if (entryID >= 0) {
        parent.theMenu.selectEntry(entryID);
        if (parent.theMenu.setEntry(entryID, true)) {
            parent.theMenu.refresh();
        }
    }
}
//-->
</SCRIPT>
<LINK REL="STYLESHEET" HREF="../ps_doc.css" CHARSET="UTF-8" TYPE="text/css">
<TITLE>Physical Layout</TITLE></HEAD>
<BODY BACKGROUND=../images/background.gif link="#0F3A68" vlink="#878787" alink="#FF7600" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<A NAME="topofdoc"></A>


<TABLE cellpadding=0 cellspacing=0 border=0 width=100%>
  <TR>
    <TD>&nbsp;<IMG src="../graphics/psbar_l.gif" border=0></TD>
    <TD align=RIGHT valign=CENTER>
        <FONT face="helvetica,arial" SIZE=5 class=NS28pt>
        <B>Physical Layout</B></FONT></TD>
    <TD>&nbsp;&nbsp;</TD>
  </TR>
</TABLE>

<P></P><TABLE BORDER ALIGN=CENTER><TR>
  <TD>&lt;&lt;&lt; <A HREF="xt_chap.03.html">Logical Layout</A></TD>
  <TD><A HREF="../xt_index.html">Chapters</A></TD>
  <TD><A HREF="xt_chap.05.html">Model Structure</A> &gt;&gt;&gt;</TD>
</TR></TABLE>

<H1>Contents</H1>
<UL>
<LI> <A HREF="xt_chap.04.html#50487320_pgfId-339086">3.1	Common header</A>
<UL>
<LI> <A HREF="xt_chap.04.html#50487320_pgfId-339146">3.1.1	Keyword syntax</A>
</UL>
<LI> <A HREF="xt_chap.04.html#50487320_pgfId-339180">3.2	Text</A>
<LI> <A HREF="xt_chap.04.html#50487320_pgfId-294772">3.3	Binary</A>
<UL>
<LI> <A HREF="xt_chap.04.html#50487320_pgfId-339258">3.3.1	Bare binary</A>
<LI> <A HREF="xt_chap.04.html#50487320_pgfId-339260">3.3.2	Typed binary</A>
<LI> <A HREF="xt_chap.04.html#50487320_pgfId-294805">3.3.3	Neutral binary</A>
</UL>
</UL>
<A NAME="endofcontents"></A>
<P>
<A NAME="50487320_pgfId-339083"></A>The XT data has two headers:</P>
<UL>
<LI>
<A NAME="50487320_pgfId-339084"></A>A textual introduction containing human-directed information about the part, written by the Frustrum and not accessible to the XT data, and</LI>
<LI>
<A NAME="50487320_pgfId-339085"></A>An internal prefix to the part data, describing to the XT data the format of the part data and thus not seen explicitly by an application's Frustrum.</LI>
</UL>


<P ALIGN=RIGHT>
<A HREF="#topofdoc"><I>[back to top]</I></A>
</P>

<HR>

<H1>
<A NAME="50487320_pgfId-339086"></A>3.1	Common header


</H1>
<P>
<A NAME="50487320_pgfId-339087"></A>The XT common header recommended to Frustrum writers consists of:</P>
<UL>
<LI>
<A NAME="50487320_pgfId-339088"></A>A preamble containing all characters in the ASCII printing set. This is used by the KID Frustrum to detect obvious network corruption, but could be used to attempt to translate a text file from one character set to another.</LI>
<LI>
<A NAME="50487320_pgfId-339089"></A>Part 1 data: a sequence of keyword-value pairs, separated by semicolons, of possibly interesting information. All are optional.</LI>
</UL>
<P>
<A NAME="50487320_pgfId-339121"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487320_pgfId-339092"></A>	MC  		=  	vax, hppa, sparc, ...</PRE>
<PRE><A NAME="50487320_pgfId-339093"></A>               			// make of computer</PRE>
<PRE><A NAME="50487320_pgfId-339094"></A>  	MC_MODEL  	=  	4090, 9000/780, sun4m, ...</PRE>
<PRE><A NAME="50487320_pgfId-339095"></A>               			//  model of computer</PRE>
<PRE><A NAME="50487320_pgfId-339096"></A>     	MC_ID  	=  	...</PRE>
<PRE><A NAME="50487320_pgfId-339097"></A>               			//  unique machine identifier</PRE>
<PRE><A NAME="50487320_pgfId-339098"></A>      	OS  		=  	vms, HP-UX, SunOS, ...</PRE>
<PRE><A NAME="50487320_pgfId-339099"></A>               			//  name of operating system</PRE>
<PRE><A NAME="50487320_pgfId-339100"></A>OS_RELEASE 	=  	V6.2, B.10.20, 5.5.1, ...</PRE>
<PRE><A NAME="50487320_pgfId-339101"></A>               			//  version of operating system</PRE>
<PRE><A NAME="50487320_pgfId-339102"></A>FRU         =     sdl_parasolid_test_vax,</PRE>
<PRE><A NAME="50487320_pgfId-339103"></A>                    	mdc_ugii_v7.0_djl_can_vrh, ...</PRE>
<PRE><A NAME="50487320_pgfId-339104"></A>//  frustrum supplier and implementation name</PRE>
<PRE><A NAME="50487320_pgfId-339105"></A>      	APPL  		=  	kid, unigraphics, ...</PRE>
<PRE><A NAME="50487320_pgfId-339106"></A>//  application which is using Parasolid</PRE>
<PRE><A NAME="50487320_pgfId-339107"></A>      	SITE  		=  	...</PRE>
<PRE><A NAME="50487320_pgfId-339108"></A>//  site at which application is running</PRE>
<PRE><A NAME="50487320_pgfId-339109"></A>      	USER  		=  	...</PRE>
<PRE><A NAME="50487320_pgfId-339110"></A>               			//  login name of user</PRE>
<PRE><A NAME="50487320_pgfId-339111"></A>    	FORMAT  	=  	binary, text, applio</PRE>
<PRE><A NAME="50487320_pgfId-339112"></A>               			//  format of file</PRE>
<PRE><A NAME="50487320_pgfId-339113"></A>     	GUISE  	=  	transmit, transmit_partition</PRE>
<PRE><A NAME="50487320_pgfId-339114"></A>               			//  guise of file</PRE>
<PRE><A NAME="50487320_pgfId-339115"></A>      KEY  		=  	...</PRE>
<PRE><A NAME="50487320_pgfId-339116"></A>               			//  name of key </PRE>
<PRE><A NAME="50487320_pgfId-339117"></A>      	FILE  		=  	...</PRE>
<PRE><A NAME="50487320_pgfId-339118"></A>               			//  name of file </PRE>
<PRE><A NAME="50487320_pgfId-339119"></A>      	DATE  		=  	dd-mmm-yyyy</PRE>
<PRE><A NAME="50487320_pgfId-339120"></A>//  e.g. 5-apr-1998</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487320_pgfId-339122"></A>The ‘part 1’ data is ‘standard’ information which should be accessible to the Frustrum (e.g. by operating system calls). It is the responsibility of the Frustrum to gather the relevant information and to format it as described in this specification. </P>
<UL>
<LI>
<A NAME="50487320_pgfId-339123"></A>Part 2 data: a sequence of keyword-value pairs, separated by semicolons.</LI>
</UL>
<P>
<A NAME="50487320_pgfId-339130"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487320_pgfId-339126"></A>SCH  		=  	SCH_m_n</PRE>
<PRE><A NAME="50487320_pgfId-339127"></A>//  name of schema key e.g.<CODE>SCH_3400000_34000</CODE>
</PRE>
<PRE><A NAME="50487320_pgfId-339128"></A>USFLD_SIZE	=  	m</PRE>
<PRE><A NAME="50487320_pgfId-339129"></A>//  length of user field (0 - 16 integer words)</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487320_pgfId-339131"></A>Applications writing XT data must use a schema name of SCH_3400000_34000</P>
<P>
<A NAME="50487320_pgfId-339132"></A>&nbsp;</P>
<UL>
<LI>
<A NAME="50487320_pgfId-339133"></A>Part 3 data: non-standard information, which is only comprehensible to the Frustrum which wrote it.</LI>
</UL>
<P>
<A NAME="50487320_pgfId-339134"></A>The ‘part 3’ data is non-standard information, which is only comprehensible to the Frustrum which wrote it. However, other Frustrum implementations must be able to parse it (in order to reach the end of the header), and it should therefore conform to the same keyword/value syntax as for ‘part 1’ and ‘part 2’ data. However, the choice and interpretation of keywords for the ‘part 3’ data is entirely at the discretion of the Frustrum which is writing the header.</P>
<UL>
<LI>
<A NAME="50487320_pgfId-339135"></A>A trailer record.</LI>
</UL>
<P>
<A NAME="50487320_pgfId-339136"></A>An example is given below:</P>
<P>
<A NAME="50487320_pgfId-339145"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487320_pgfId-339139"></A>**ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz************</PRE>
<PRE><A NAME="50487320_pgfId-339140"></A>**PARASOLID !&quot;#$%&amp;&acute;()*+,-./:;&lt;=&gt;?@[\]^_`{|}~0123456789******************</PRE>
<PRE><A NAME="50487320_pgfId-339141"></A>**PART1;MC=vax;MC_MODEL=4090;MC_ID=VAX14;OS=vms;OS_RELEASE=V6.2;FRU=sdl_parasolid_test_vax;APPL=unknown;SITE=sdl-cambridge u.k.;USER=ALANS;FORMAT=text;GUISE=transmit;KEY=temp;FILE=TEMP.XMT_TXT;DATE=8-sep-1997;</PRE>
<PRE><A NAME="50487320_pgfId-339142"></A>**PART2;SCH=SCH_701169_7007;USFLD_SIZE=0;</PRE>
<PRE><A NAME="50487320_pgfId-339143"></A>**PART3;</PRE>
<P>
<A NAME="50487320_pgfId-339144"></A>**END_OF_HEADER***************************************************</P>
</TD>
</TR>
</TABLE>

<H3>
<A NAME="50487320_pgfId-339146"></A>	3.1.1 	Keyword syntax</H3>
<P>
<A NAME="50487320_pgfId-339147"></A>All keyword definitions which appear in the three parts of data are written in the form</P>
<P>
<A NAME="50487320_pgfId-339151"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487320_pgfId-339150"></A>&lt;name&gt;=&lt;value&gt; e.g. MC=hppa;MC_MODEL=9000/710;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487320_pgfId-339152"></A>Where</P>
<P>
<A NAME="50487320_pgfId-339153"></A><CODE>
&lt;name&gt;</CODE>
 consists of 1 to 80 uppercase, digit, or underscore characters </P>
<P>
<A NAME="50487320_pgfId-339154"></A><CODE>
&lt;value&gt;</CODE>
 consists of 1 or more ASCII printing characters (except space)</P>
<P>
<A NAME="50487320_pgfId-339155"></A>Escape sequences provide a way of being able to use the full (7 bit) set of ASCII printing characters and the new line character within keyword values. Certain characters must be escaped if they are to appear in a keyword value:</P>
<P>
<A NAME="50487320_pgfId-339177"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339158"></A>Character</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339160"></A>Escape Sequence</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339162"></A>newline</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339164"></A>^n</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339166"></A>space</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339168"></A>^-</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339170"></A>semicolon</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339172"></A>^;</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339174"></A>uparrow</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339176"></A>^^</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487320_pgfId-339178"></A>The two character escape sequences may be split by a new line character as they are written to file. They must not cause any output lines to be longer than 80 characters.</P>
<P>
<A NAME="50487320_pgfId-339179"></A>Only those characters which belong to the ASCII (7 bit) printing sequence, plus the new line character, can be included as part of a keyword value.</P>




<P ALIGN=RIGHT>
<A HREF="#topofdoc"><I>[back to top]</I></A>
</P>

<HR>

<H1>
<A NAME="50487320_pgfId-339180"></A>3.2	Text


</H1>
<P>
<A NAME="50487320_pgfId-339181"></A>XT has no knowledge of how data is stored. On writing, XT produces an internal bytestream which is then split into roughly 80-character records separated by newline characters ('<CODE>
\n</CODE>
'). The newlines are not significant.</P>
<P>
<A NAME="50487320_pgfId-339182"></A>As operating systems vary in their treatment of text data, on reading all newline and carriage return characters ('<CODE>
\r</CODE>
') are ignored, along with any trailing spaces added to the records. However, leading spaces are not ignored, and the XT data must not contain adjacent space characters not at the end of a record.</P>
<P>
<A NAME="50487320_pgfId-339183"></A>Text XT files written by version 12.1 and later versions use escape sequences to output the following characters, except for '<CODE>
\n</CODE>
' at the end of each line:</P>
<P>
<A NAME="50487320_pgfId-339205"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339186"></A>Item</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339188"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339190"></A>null</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339192"></A>“<CODE>
\0</CODE>
”</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339194"></A>carriage return</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339196"></A>“<CODE>
\n</CODE>
”</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339198"></A>line feed</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339200"></A>“<CODE>
\r</CODE>
”</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339202"></A>backslash</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339204"></A>“<CODE>
\\</CODE>
”</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487320_pgfId-339206"></A>These characters are not escaped by versions 12.0 and earlier. </P>
<P>
<A NAME="50487320_pgfId-339207"></A>The flag sequence is the character ‘T’. This is followed by the length of the modeler version, separated by a space from the characters of the modeler version, similarly the ‘, finally the userfield size. For example:</P>
<P>
<A NAME="50487320_pgfId-339214"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487320_pgfId-339210"></A>T</PRE>
<PRE><A NAME="50487320_pgfId-339211"></A>51 : TRANSMIT FILE created by modeller version <CODE>3000000</CODE>
</PRE>
<PRE><A NAME="50487320_pgfId-339212"></A>17 SCH_3000000_30000</PRE>
<PRE><A NAME="50487320_pgfId-339213"></A>0</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487320_pgfId-339218"></A>NB: because of ignored layout, what Parasolid would read is as follows:</P>
<P>
<A NAME="50487320_pgfId-339222"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487320_pgfId-339221"></A>T51 : TRANSMIT FILE created by modeller version 300000017 SCH_3000000_300000</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487320_pgfId-339223"></A>For partition files, the modeller version string would be given as follows:</P>
<P>
<A NAME="50487320_pgfId-339227"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487320_pgfId-339226"></A>63 : TRANSMIT FILE (partition) created by modeller version 3000000</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487320_pgfId-339228"></A>All numbers are followed by a single space to separate them from the next entry. Fields of type c and l are not followed by a space.</P>
<P>
<A NAME="50487320_pgfId-339229"></A>Logical values (0,1) are represented as characters F,T.</P>
<P>
<A NAME="50487320_pgfId-339230"></A>There are two special numeric values (-32764 for integral values, -3.14158e13 for floating point) which are used inside Parasolid to mark an ‘unset’ or ‘null’ value, and they are represented in a text transmit file as the question mark ‘?’. If a vector has one component null, then all three components must be null, and it will be output in a text file as a single ‘?’.</P>



<P ALIGN=RIGHT>
<A HREF="#topofdoc"><I>[back to top]</I></A>
</P>

<HR>

<H1>
<A NAME="50487320_pgfId-294772"></A>3.3	Binary


</H1>
<P>
<A NAME="50487320_pgfId-294773"></A>There are three types of binary file: 'bare' binary, typed binary, and neutral binary. They are distinguished by a short flag sequence at the beginning of the file. In all cases, the flag sequence is followed by the length of the modeller version as a 2-byte integer, the characters of the modeller version, the length of the schema version as a 4-byte integer, the characters of the schema version, and finally the userfield size as a 4-byte integer.</P>
<P>
<A NAME="50487320_pgfId-297822"></A>As with text files, there are two special numeric values (-32764 for integral values, -3.14158e13 for floating point) which are used inside XT to mark an ‘unset’ or ‘null’ value, and they are represented in the text XT data as the question mark ‘?’.</P>

<H3>
<A NAME="50487320_pgfId-339258"></A>	3.3.1 	Bare binary</H3>
<P>
<A NAME="50487320_pgfId-339259"></A>In bare binary, data is represented in the natural format of the machine which wrote the data. The flag sequence is the single character 'B' (for ASCII machines, '<CODE>
\102</CODE>
'). The data must be read on a machine with the same natural format with respect to character set, endianness and floating point format.</P>


<H3>
<A NAME="50487320_pgfId-339260"></A>	3.3.2 	Typed binary</H3>
<P>
<A NAME="50487320_pgfId-339261"></A>In typed binary, data is represented in the natural format of the machine that wrote the data. The flag sequence is the 4-byte sequence “<CODE>
PS</CODE>
” followed by a zero byte and a one byte, i.e., ‘<CODE>
P</CODE>
’ ‘<CODE>
S</CODE>
’ ‘<CODE>
\0</CODE>
’ ‘<CODE>
\1</CODE>
’, followed by a 3-by		te sequence of machine description. </P>
<P>
<A NAME="50487320_pgfId-339287"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339264"></A>&nbsp;</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339266"></A>Byte Order</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339268"></A>Double Representation</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339270"></A>Character Representation</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339272"></A>0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339274"></A>Big-endian</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339276"></A>IEEE</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339278"></A>ASCII</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339280"></A>1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339282"></A>Little-endian</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339284"></A>VAX D-float</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487320_pgfId-339286"></A>EBCDIC</P>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487320_pgfId-294805"></A>	3.3.3 	Neutral binary</H3>
<P>
<A NAME="50487320_pgfId-334610"></A>In neutral binary, data is represented in big-endian format, with IEEE floating point numbers and ASCII characters. The flag sequence is the 4-byte sequence &quot;<CODE>
PS</CODE>
&quot; followed by two zero bytes, i.e., '<CODE>
P</CODE>
' '<CODE>
S</CODE>
' '<CODE>
\0</CODE>
' '<CODE>
\0</CODE>
'. At Parasolid V9, the initial letters are ASCII, thus '<CODE>
\120</CODE>
' '<CODE>
\123</CODE>
'. The nodetype at the start of a node is a 2-byte integer, the variable length which may follow it is a 4-byte integer.</P>
<P>
<A NAME="50487320_pgfId-294809"></A>Logical values (0,1) are represented as themselves in 1 byte.</P>
<P>
<A NAME="50487320_pgfId-294810"></A>Small pointer indices (in the range 0-32766) are implemented as a 2-byte integer, larger indices are represented as a pair, thus:</P>
<P>
<A NAME="50487320_pgfId-294822"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487320_pgfId-294813"></A>if (index &lt; 32767)</PRE>
<PRE><A NAME="50487320_pgfId-294814"></A>{                       	// case: small index</PRE>
<PRE><A NAME="50487320_pgfId-294815"></A>op_short( index + 1 );  	// offset so is &gt; 0</PRE>
<PRE><A NAME="50487320_pgfId-294816"></A>}	</PRE>
<PRE><A NAME="50487320_pgfId-294817"></A>    else</PRE>
<PRE><A NAME="50487320_pgfId-294818"></A>{                                 	// case: big index</PRE>
<PRE><A NAME="50487320_pgfId-294819"></A>op_short( -(index % 32767 + 1) ); 	// remainder: add 1 so &gt; 0</PRE>
<PRE><A NAME="50487320_pgfId-294820"></A>op_short( index / 32767 );        	// nonzero quotient</PRE>
<PRE><A NAME="50487320_pgfId-294821"></A>}	</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487320_pgfId-294823"></A>where <CODE>
op_short</CODE>
 outputs a 2-byte integer.</P>
<P>
<A NAME="50487320_pgfId-294824"></A>The inverse is performed on reading:</P>
<P>
<A NAME="50487320_pgfId-294835"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487320_pgfId-294827"></A>short q = 0, r;</PRE>
<PRE><A NAME="50487320_pgfId-294828"></A>    ip_short( &amp;r );</PRE>
<PRE><A NAME="50487320_pgfId-294829"></A>    if (r &lt; 0)</PRE>
<PRE><A NAME="50487320_pgfId-294830"></A>{</PRE>
<PRE><A NAME="50487320_pgfId-294831"></A>ip_short( &amp;q );</PRE>
<PRE><A NAME="50487320_pgfId-294832"></A>r = -r;</PRE>
<PRE><A NAME="50487320_pgfId-294833"></A>}</PRE>
<PRE><A NAME="50487320_pgfId-294834"></A>    index = q * 32767 + r - 1;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487320_pgfId-334626"></A>where <CODE>
ip_short</CODE>
 reads a 2-byte integer.</P>


<A NAME="endofdoc"></A>

<P ALIGN=RIGHT>
<A HREF="#topofdoc"><I>[back to top]</I></A>
</P>

<P></P><TABLE BORDER ALIGN=CENTER><TR>
  <TD>&lt;&lt;&lt; <A HREF="xt_chap.03.html">Logical Layout</A></TD>
  <TD><A HREF="../xt_index.html">Chapters</A></TD>
  <TD><A HREF="xt_chap.05.html">Model Structure</A> &gt;&gt;&gt;</TD>
</TR></TABLE>

</BODY>
</HTML>
