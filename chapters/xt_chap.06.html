<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 2015/HTML Export Filter">
<SCRIPT LANGUAGE="JavaScript">
<!--
if (parent.theMenu) {
    var entryID = parent.theMenu.findEntry(location.pathname, "url", "right", 0);
    if (entryID >= 0) {
        parent.theMenu.selectEntry(entryID);
        if (parent.theMenu.setEntry(entryID, true)) {
            parent.theMenu.refresh();
        }
    }
}
//-->
</SCRIPT>
<LINK REL="STYLESHEET" HREF="../ps_doc.css" CHARSET="UTF-8" TYPE="text/css">
<TITLE>Schema Definitions</TITLE></HEAD>
<BODY BACKGROUND=../images/background.gif link="#0F3A68" vlink="#878787" alink="#FF7600" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0">
<A NAME="topofdoc"></A>


<TABLE cellpadding=0 cellspacing=0 border=0 width=100%>
  <TR>
    <TD>&nbsp;<IMG src="../graphics/psbar_l.gif" border=0></TD>
    <TD align=RIGHT valign=CENTER>
        <FONT face="helvetica,arial" SIZE=5 class=NS28pt>
        <B>Schema Definitions</B></FONT></TD>
    <TD>&nbsp;&nbsp;</TD>
  </TR>
</TABLE>

<P></P><TABLE BORDER ALIGN=CENTER><TR>
  <TD>&lt;&lt;&lt; <A HREF="xt_chap.05.html">Model Structure</A></TD>
  <TD><A HREF="../xt_index.html">Chapters</A></TD>
  <TD><A HREF="xt_chap.07.html">Nodes and Classes</A> &gt;&gt;&gt;</TD>
</TR></TABLE>

<H1>Contents</H1>
<UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-313248">5.1	Underlying types</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-286484">5.2	Geometry</A>
<UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-286526">5.2.1	Curves</A>
<UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-286607">5.2.1.1	Line</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-286684">5.2.1.2	Circle</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-286777">5.2.1.3	Ellipse</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-286878">5.2.1.4	B_CURVE (B-spline curve)</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-314204">5.2.1.5	Intersection</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-287418">5.2.1.6	Trimmed_curve</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-22299727">5.2.1.7	PE_CURVE (Foreign geometry curve)</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-287592">5.2.1.8	SP_CURVE</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-287644">5.2.1.9	Polyline</A>
</UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-287645">5.2.2	Surfaces</A>
<UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-287711">5.2.2.1	Plane</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-287795">5.2.2.2	Cylinder</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-287888">5.2.2.3	Cone</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-287996">5.2.2.4	Sphere</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-288088">5.2.2.5	Torus</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-288166">5.2.2.6	Blended_edge (Rolling ball blend)</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-288295">5.2.2.7	Blend_bound (Blend boundary surface)</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-288343">5.2.2.8	Offset_surf</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-288413">5.2.2.9	B_surface</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-288690">5.2.2.10	Swept_surf</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-288774">5.2.2.11	Spun_surf</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-22300255">5.2.2.12	PE_surf (Foreign geometry surface)</A>
</UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-22230340">5.2.3	Mesh Surfaces</A>
<UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-22230409">5.2.3.1	PSM mesh</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-22230509">5.2.3.2	Position pool</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-22230515">5.2.3.3	Position indices</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-22230521">5.2.3.4	Normal pool</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-22230525">5.2.3.5	Normal indices</A>
</UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-21092362">5.2.4	Lattices</A>
<UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-21098701">5.2.4.1	Irregular lattice node</A>
</UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-495065">5.2.5	Point</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-289029">5.2.6	Transform</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-21103130">5.2.7	Comb nodes</A>
<UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-21098748">5.2.7.1	VECTOR_COMB nodes</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-21101596">5.2.7.2	INTEGER_COMB nodes</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-21101224">5.2.7.3	REAL_COMB nodes</A>
</UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-289157">5.2.8	Curve, surface and lattice senses</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-289161">5.2.9	Geometric_owner</A>
</UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-289215">5.3	Topology</A>
<UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-289218">5.3.1	World</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-289331">5.3.2	Assembly</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-289498">5.3.3	Instance</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-289606">5.3.4	Body</A>
<UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-21344984">5.3.4.1	Attaching geometry to topology</A>
</UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-289919">5.3.5	Region</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-289991">5.3.6	Shell</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-290048">5.3.7	Face</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-290162">5.3.8	Loop</A>
<UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-21344990">5.3.8.1	Isolated loops</A>
</UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-290215">5.3.9	Fin</A>
<UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-21345034">5.3.9.1	Dummy fins</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-22230836">5.3.9.2	Fin chain at a vertex</A>
</UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-408352">5.3.10	Vertex</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-290383">5.3.11	Edge</A>
</UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-395484">5.4	Associated Data</A>
<UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-395485">5.4.1	List</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-290587">5.4.2	Pointer_lis_block</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-290645">5.4.3	Att_def_id</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-290668">5.4.4	Field_names</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-471459">5.4.5	Attrib_def</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-291020">5.4.6	Attribute</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-291130">5.4.7	Int_values</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-291153">5.4.8	Real_values</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-291176">5.4.9	Char_values</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-291199">5.4.10	Unicode_values</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-291222">5.4.11	Point_values</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-291245">5.4.12	Vector_values</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-291268">5.4.13	Direction_values</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-291291">5.4.14	Axis_values</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-291314">5.4.15	Tag_values</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-382297">5.4.16	Feature</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-326309">5.4.17	Member_of_feature</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20068404">5.4.18	Part_XMT_block</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20140805">5.4.19	Mesh_offset_data</A>
<UL>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20140855">5.4.19.1	Offset_values</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20140880">5.4.19.2	Schema_data</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20146749">5.4.19.3	Node_map union</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20145779">5.4.19.4	Node map nodes</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20150406">5.4.19.5	Any_node_map</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20140916">5.4.19.6	Old_node_map</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20146107">5.4.19.7	New_node_map</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20140904">5.4.19.8	Modified_node_map</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20145807">5.4.19.9	Field_map union</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20146130">5.4.19.10	Old_field_map</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20146369">5.4.19.11	New_field_map</A>
<LI> <A HREF="xt_chap.06.html#50487361_pgfId-20140918">5.4.19.12	Schema_char_values</A>
</UL>
</UL>
</UL>
<A NAME="endofcontents"></A>


<P ALIGN=RIGHT>
<A HREF="#topofdoc"><I>[back to top]</I></A>
</P>

<HR>

<H1>
<A NAME="50487361_pgfId-313248"></A>5.1	Underlying types


</H1>
<P>
<A NAME="50487361_pgfId-286483"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-286461"></A>union CURVE_OWNER_u</PRE>
<PRE><A NAME="50487361_pgfId-18974478"></A>     {</PRE>
<PRE><A NAME="50487361_pgfId-477060"></A>     struct EDGE_s                *edge;</PRE>
<PRE><A NAME="50487361_pgfId-22300731"></A>     struct HALFEDGE_s            *halfedge;</PRE>
<PRE><A NAME="50487361_pgfId-477076"></A>     struct BODY_s                *body;</PRE>
<PRE><A NAME="50487361_pgfId-477084"></A>     struct ASSEMBLY_s            *assembly;</PRE>
<PRE><A NAME="50487361_pgfId-477092"></A>     struct WORLD_s               *world;</PRE>
<PRE><A NAME="50487361_pgfId-477100"></A>     };</PRE>
<PRE><A NAME="50487361_pgfId-22300736"></A>typedef union CURVE_OWNER_u CURVE_OWNER;</PRE>
<PRE><A NAME="50487361_pgfId-477108"></A>union SURFACE_OWNER_u</PRE>
<PRE><A NAME="50487361_pgfId-477116"></A>     {</PRE>
<PRE><A NAME="50487361_pgfId-477037"></A>     struct FACE_s                *face;</PRE>
<PRE><A NAME="50487361_pgfId-477124"></A>     struct BODY_s                *body;</PRE>
<PRE><A NAME="50487361_pgfId-477132"></A>     struct ASSEMBLY_s            *assembly;</PRE>
<PRE><A NAME="50487361_pgfId-477140"></A>     struct WORLD_s               *world;</PRE>
<PRE><A NAME="50487361_pgfId-327484"></A>     };</PRE>
<PRE><A NAME="50487361_pgfId-22300741"></A>typedef union SURFACE_OWNER_u SURFACE_OWNER;</PRE>
<PRE><A NAME="50487361_pgfId-546403"></A>union ATTRIB_FEAT_u</PRE>
<PRE><A NAME="50487361_pgfId-546408"></A>     {</PRE>
<PRE><A NAME="50487361_pgfId-477164"></A>     struct ATTRIBUTE_s           *attribute;</PRE>
<PRE><A NAME="50487361_pgfId-22300751"></A>     struct FEATURE_s             *feature;</PRE>
<PRE><A NAME="50487361_pgfId-22300752"></A>     struct MEMBER_OF_FEATURE_s   *member_of_feature;</PRE>
<PRE><A NAME="50487361_pgfId-477188"></A>     };</PRE>
<PRE><A NAME="50487361_pgfId-477196"></A>typedef union ATTRIB_FEAT_u ATTRIB_FEAT;</PRE>
</TD>
</TR>
</TABLE>



<P ALIGN=RIGHT>
<A HREF="#topofdoc"><I>[back to top]</I></A>
</P>

<HR>

<H1>
<A NAME="50487361_pgfId-286484"></A>5.2	Geometry


</H1>
<P>
<A NAME="50487361_pgfId-286525"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-286487"></A>union CURVE_u</PRE>
<PRE><A NAME="50487361_pgfId-478845"></A>     {</PRE>
<PRE><A NAME="50487361_pgfId-478853"></A>     struct LINE_s                *line;</PRE>
<PRE><A NAME="50487361_pgfId-478861"></A>     struct CIRCLE_s              *circle;</PRE>
<PRE><A NAME="50487361_pgfId-478869"></A>     struct ELLIPSE_s             *ellipse;</PRE>
<PRE><A NAME="50487361_pgfId-478877"></A>     struct INTERSECTION_s        *intersection;</PRE>
<PRE><A NAME="50487361_pgfId-478885"></A>     struct TRIMMED_CURVE_s       *trimmed_curve;</PRE>
<PRE><A NAME="50487361_pgfId-478893"></A>     struct PE_CURVE_s            *pe_curve;</PRE>
<PRE><A NAME="50487361_pgfId-478901"></A>     struct B_CURVE_s             *b_curve;</PRE>
<PRE><A NAME="50487361_pgfId-478909"></A>     struct SP_CURVE_s            *sp_curve;</PRE>
<PRE><A NAME="50487361_pgfId-17784660"></A>     struct POLYLINE_s            *polyline;</PRE>
<PRE><A NAME="50487361_pgfId-478917"></A>     };</PRE>
<PRE><A NAME="50487361_pgfId-478925"></A>typedef union CURVE_u      CURVE;</PRE>
<PRE><A NAME="50487361_pgfId-478933"></A>union SURFACE_u</PRE>
<PRE><A NAME="50487361_pgfId-478941"></A>     {</PRE>
<PRE><A NAME="50487361_pgfId-478949"></A>     struct PLANE_s               *plane;</PRE>
<PRE><A NAME="50487361_pgfId-478957"></A>     struct CYLINDER_s            *cylinder;</PRE>
<PRE><A NAME="50487361_pgfId-478965"></A>     struct CONE_s                *cone;</PRE>
<PRE><A NAME="50487361_pgfId-478973"></A>     struct SPHERE_s              *sphere;</PRE>
<PRE><A NAME="50487361_pgfId-478981"></A>     struct TORUS_s               *torus;</PRE>
<PRE><A NAME="50487361_pgfId-478989"></A>     struct BLENDED_EDGE_s        *blended_edge;</PRE>
<PRE><A NAME="50487361_pgfId-478997"></A>     struct BLEND_BOUND_s         *blend_bound;</PRE>
<PRE><A NAME="50487361_pgfId-479005"></A>     struct OFFSET_SURF_s         *offset_surf;</PRE>
<PRE><A NAME="50487361_pgfId-479013"></A>     struct SWEPT_SURF_s          *swept_surf;</PRE>
<PRE><A NAME="50487361_pgfId-479021"></A>     struct SPUN_SURF_s           *spun_surf;</PRE>
<PRE><A NAME="50487361_pgfId-479029"></A>     struct PE_SURF_s             *pe_surf;</PRE>
<PRE><A NAME="50487361_pgfId-479037"></A>     struct B_SURFACE_s           *b_surface;</PRE>
<PRE><A NAME="50487361_pgfId-17784791"></A>     struct MESH_s                *mesh;</PRE>
<PRE><A NAME="50487361_pgfId-479045"></A>     };</PRE>
<PRE><A NAME="50487361_pgfId-479053"></A>typedef union SURFACE_u    SURFACE;</PRE>
<PRE><A NAME="50487361_pgfId-479061"></A>union GEOMETRY_u</PRE>
<PRE><A NAME="50487361_pgfId-479069"></A>     {</PRE>
<PRE><A NAME="50487361_pgfId-479077"></A>     struct LATTICE_s             *lattice;</PRE>
<PRE><A NAME="50487361_pgfId-21088248"></A>     union SURFACE_u               surface;</PRE>
<PRE><A NAME="50487361_pgfId-479085"></A>     union CURVE_u                 curve;</PRE>
<PRE><A NAME="50487361_pgfId-479093"></A>     struct POINT_s               *point;</PRE>
<PRE><A NAME="50487361_pgfId-479101"></A>     struct TRANSFORM_s           *transform;</PRE>
<PRE><A NAME="50487361_pgfId-479117"></A>     };</PRE>
<PRE><A NAME="50487361_pgfId-479125"></A>typedef union GEOMETRY_u GEOMETRY;</PRE>
</TD>
</TR>
</TABLE>

<H3>
<A NAME="50487361_pgfId-286526"></A>	5.2.1 	Curves</H3>
<P>
<A NAME="50487361_pgfId-286527"></A>In the following field tables, ‘pointer0’ means a reference to another node which may be null. ‘pointer’ means a non-null reference.</P>
<P>
<A NAME="50487361_pgfId-286528"></A>All curve nodes share the following common fields:</P>
<P>
<A NAME="50487361_pgfId-286578"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286531"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286533"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286535"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286537"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286539"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286541"></A>Integer value unique to curve in part</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286543"></A><CODE>
attributes_features</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286545"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286547"></A>Attributes and featuresassociated with any curve</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286549"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286551"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286553"></A>topological owner</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286555"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286557"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286559"></A>next curve in geometry chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286561"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286563"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286565"></A>previous curve in geometry chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286567"></A><CODE>
geometric_owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286569"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286571"></A>geometric owner node</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286573"></A><CODE>
sense</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286575"></A>char</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286577"></A>sense of curve “+” or “-” (see end of Geometry section)</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-286606"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-286581"></A>struct ANY_CURVE_s              //Any Curve</PRE>
<PRE><A NAME="50487361_pgfId-479134"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-479142"></A>    int                           node_id;              // $d</PRE>
<PRE><A NAME="50487361_pgfId-479150"></A>    union  ATTRIB_FEAT_u          attributes_features;  // $p</PRE>
<PRE><A NAME="50487361_pgfId-479158"></A>    union  CURVE_OWNER_u          owner;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-479166"></A>    union  CURVE_u                next;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-479174"></A>    union  CURVE_u                previous;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-479182"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;      // $p</PRE>
<PRE><A NAME="50487361_pgfId-479190"></A>    char                          sense;                // $c</PRE>
<PRE><A NAME="50487361_pgfId-479198"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-479206"></A>typedef struct ANY_CURVE_s *ANY_CURVE;</PRE>
</TD>
</TR>
</TABLE>

<H4>
<A NAME="50487361_pgfId-286607"></A>5.2.1.1 Line</H4>
<P>
<A NAME="50487361_pgfId-286608"></A>A straight line has a parametric representation of the form:</P>
<P>
<A NAME="50487361_pgfId-286609"></A><CODE>
R(t) = P + t D</CODE>
</P>
<P>
<A NAME="50487361_pgfId-286610"></A>Where:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-286611"></A><CODE>
P</CODE>
 is a point on the line</LI>
<LI>
<A NAME="50487361_pgfId-286612"></A><CODE>
D</CODE>
 is its direction</LI>
</UL>
<P>
<A NAME="50487361_pgfId-286647"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-9.gif">

<P>
<A NAME="50487361_pgfId-286667"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286650"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286652"></A>Data Types</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286654"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286656"></A><CODE>
pvec</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286658"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286660"></A>point on the line</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286662"></A><CODE>
direction</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286664"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286666"></A>direction of the line (a unit vector)</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-286683"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-286670"></A>struct LINE_s == ANY_CURVE_s      //Straight line</PRE>
<PRE><A NAME="50487361_pgfId-479215"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-601194"></A>    int                           node_id;              // $d</PRE>
<PRE><A NAME="50487361_pgfId-601195"></A>    union  ATTRIB_FEAT_u          attributes_features;  // $p</PRE>
<PRE><A NAME="50487361_pgfId-601196"></A>    union  CURVE_OWNER_u          owner;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-601197"></A>    union  CURVE_u                next;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-601198"></A>    union  CURVE_u                previous;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-601173"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;      // $p</PRE>
<PRE><A NAME="50487361_pgfId-601218"></A>    char                          sense;                // $c</PRE>
<PRE><A NAME="50487361_pgfId-479279"></A>    vector                        pvec;                 // $v</PRE>
<PRE><A NAME="50487361_pgfId-479287"></A>    vector                        direction;            // $v</PRE>
<PRE><A NAME="50487361_pgfId-479295"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-479303"></A>typedef struct LINE_s       *LINE;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-286684"></A>5.2.1.2 Circle</H4>
<P>
<A NAME="50487361_pgfId-286685"></A>A circle has a parametric representation of the form:</P>
<P>
<A NAME="50487361_pgfId-286686"></A><CODE>
R(t) = C + r X cos(t) + r Y sin(t)</CODE>
</P>
<P>
<A NAME="50487361_pgfId-614110"></A>Where:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-286688"></A><CODE>
C</CODE>
 is the centre of the circle</LI>
<LI>
<A NAME="50487361_pgfId-286689"></A><CODE>
r</CODE>
 is the radius of the circle</LI>
<LI>
<A NAME="50487361_pgfId-286690"></A><CODE>
X</CODE>
 and <CODE>
Y</CODE>
 are the axes in the plane of the circle</LI>
</UL>
<P>
<A NAME="50487361_pgfId-293889"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-10.gif">

<P>
<A NAME="50487361_pgfId-293921"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293892"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293894"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293896"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293898"></A><CODE>
centre</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293900"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293902"></A>Centre of circle</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293904"></A><CODE>
normal</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293906"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293908"></A>Normal to the plane containing the circle (a unit vector)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293910"></A><CODE>
x_axis</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293912"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293914"></A>X axis in the plane of the circle (a unit vector)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293916"></A><CODE>
radius</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293918"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-293920"></A>Radius of circle</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-286758"></A>The <CODE>
Y</CODE>
 axis in the definition above is the vector cross product of the normal and <CODE>
x_axis</CODE>
.</P>
<P>
<A NAME="50487361_pgfId-286776"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-286761"></A>struct CIRCLE_s == ANY_CURVE_s    //Circle</PRE>
<PRE><A NAME="50487361_pgfId-621979"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-621980"></A>    int                           node_id;              // $d</PRE>
<PRE><A NAME="50487361_pgfId-621981"></A>    union  ATTRIB_FEAT_u          attributes_features;  // $p</PRE>
<PRE><A NAME="50487361_pgfId-621982"></A>    union  CURVE_OWNER_u          owner;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-621983"></A>    union  CURVE_u                next;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-621984"></A>    union  CURVE_u                previous;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-621985"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;      // $p</PRE>
<PRE><A NAME="50487361_pgfId-621986"></A>    char                          sense;                // $c</PRE>
<PRE><A NAME="50487361_pgfId-479385"></A>    vector                        centre;               // $v</PRE>
<PRE><A NAME="50487361_pgfId-479394"></A>    vector                        normal;               // $v</PRE>
<PRE><A NAME="50487361_pgfId-479403"></A>    vector                        x_axis;               // $v</PRE>
<PRE><A NAME="50487361_pgfId-479412"></A>    double                        radius;               // $f</PRE>
<PRE><A NAME="50487361_pgfId-479421"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-479430"></A>typedef struct CIRCLE_s    *CIRCLE;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-286777"></A>5.2.1.3 Ellipse</H4>
<P>
<A NAME="50487361_pgfId-286778"></A>An ellipse has a parametric representation of the form:</P>
<P>
<A NAME="50487361_pgfId-286779"></A><CODE>
R(t) = C + a X cos(t) + b Y sin(t)</CODE>
</P>
<P>
<A NAME="50487361_pgfId-286780"></A>Where:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-286781"></A><CODE>
C</CODE>
 is the centre of the ellipse</LI>
<LI>
<A NAME="50487361_pgfId-286782"></A><CODE>
X</CODE>
 is the major axis</LI>
<LI>
<A NAME="50487361_pgfId-286783"></A><CODE>
a</CODE>
 is the major radius</LI>
<LI>
<A NAME="50487361_pgfId-286784"></A><CODE>
Y</CODE>
 and b are the minor axis and minor radius respectively</LI>
</UL>
<P>
<A NAME="50487361_pgfId-286819"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-11.gif">

<P>
<A NAME="50487361_pgfId-286857"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286822"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286824"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286826"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286828"></A><CODE>
centre</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286830"></A>Vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286832"></A>Centre of ellipse</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286834"></A><CODE>
normal</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286836"></A>Vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286838"></A>Normal to the plane containing the ellipse (a unit vector)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286840"></A><CODE>
x_axis</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286842"></A>Vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286844"></A>major axis in the plane of the ellipse (a unit vector)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286846"></A><CODE>
major_radius</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286848"></A>Double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286850"></A>major radius</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286852"></A><CODE>
minor_radius</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286854"></A>Double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-286856"></A>minor radius</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-286858"></A>The minor axis (Y) in the definition above is the vector cross product of the normal and <CODE>
x_axis</CODE>
.</P>
<P>
<A NAME="50487361_pgfId-286877"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-286861"></A>struct ELLIPSE_s == ANY_CURVE_s   //Ellipse</PRE>
<PRE><A NAME="50487361_pgfId-643457"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-643458"></A>    int                           node_id;              // $d</PRE>
<PRE><A NAME="50487361_pgfId-643459"></A>    union  ATTRIB_FEAT_u          attributes_features;  // $p</PRE>
<PRE><A NAME="50487361_pgfId-643460"></A>    union  CURVE_OWNER_u          owner;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-643461"></A>    union  CURVE_u                next;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-643462"></A>    union  CURVE_u                previous;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-643463"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;      // $p</PRE>
<PRE><A NAME="50487361_pgfId-479494"></A>    vector                        centre;               // $v</PRE>
<PRE><A NAME="50487361_pgfId-479502"></A>    char                          sense;                // $c</PRE>
<PRE><A NAME="50487361_pgfId-479510"></A>    vector                        normal;               // $v</PRE>
<PRE><A NAME="50487361_pgfId-479518"></A>    vector                        x_axis;               // $v</PRE>
<PRE><A NAME="50487361_pgfId-479526"></A>    double                        major_radius;         // $f</PRE>
<PRE><A NAME="50487361_pgfId-479534"></A>    double                        minor_radius;         // $f</PRE>
<PRE><A NAME="50487361_pgfId-479542"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-479550"></A>typedef struct ELLIPSE_s   *ELLIPSE;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-286878"></A>5.2.1.4 B_CURVE (B-spline curve)</H4>
<P>
<A NAME="50487361_pgfId-286879"></A>XT supports B-spline curves in full NURBS format. The mathematical description of these curves is:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-286880"></A>Non Uniform Rational B-splines as (NURBS), and</LI>
</UL>
<P>
<A NAME="50487361_pgfId-312861"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-12.gif">

<UL>
<LI>
<A NAME="50487361_pgfId-312862"></A>the more simple Non Uniform B-spline</LI>
</UL>
<P>
<A NAME="50487361_pgfId-21343173"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-13.gif">

<UL>
<LI>
<A NAME="50487361_pgfId-22193987"></A>Where:</LI>
<P>
<A NAME="50487361_pgfId-22193988"></A><CODE>
n</CODE>
 = number of vertices (<CODE>
n_vertices</CODE>
 in the PK standard form)</P>
<P>
<A NAME="50487361_pgfId-22193989"></A><CODE>
V0</CODE>
 ...<CODE>
Vn-1</CODE>
 are the B-spline vertices</P>
<P>
<A NAME="50487361_pgfId-22193990"></A><CODE>
w0</CODE>
 ...<CODE>
wn-1</CODE>
 are the weights</P>
<P>
<A NAME="50487361_pgfId-22193991"></A><CODE>
bi (t),i = 0...n-1</CODE>
 are the B-spline basis functions</P>
</UL>
<P>
<A NAME="50487361_pgfId-22193992"></A>KNOT VECTORS</P>
<P>
<A NAME="50487361_pgfId-286958"></A>The parameter t above is global. The user supplies an ordered set of values of t at specific points. The points are called knots and the set of values of t is called the knot vector. Each successive value in the set shall be greater than or equal to its predecessor. Where two or more such values are the same to angular resolution we say that the knots are coincident, or that the knot has multiplicity greater than 1. In this case it is best to think of the knot set as containing a null or zero length span. The principal use of coincident knots is to allow the curve to have less continuity at that point than is formally required for a spline. A curve with a knot of multiplicity equal to its degree can have a discontinuity of first derivative and hence of tangent direction. This is the highest permitted multiplicity except at the first or last knot where it can go as high as (degree+1).</P>
<P>
<A NAME="50487361_pgfId-314155"></A>In order to avoid problems associated, for example with rounding errors in the knot set, XT stores an array of distinct values and an array of integer multiplicities. This is reflected in the standard form used by the PK for input and output of B-curve data.</P>
<P>
<A NAME="50487361_pgfId-309127"></A>Most algorithms in the literature, and the following discussion refer to the expanded knot set in which a knot of multiplicity n appears explicitly n times.</P>
<P>
<A NAME="50487361_pgfId-22194002"></A>THE NUMBER OF KNOTS AND VERTICES</P>
<P>
<A NAME="50487361_pgfId-286962"></A>The knot set determines a set of basis functions which are bell shaped, and non zero over a span of (degree+1) intervals. One basis function starts at each knot, and each one finishes (degree+1) knots higher. The control vectors are the coefficients applied to these basis functions in a linear sum to obtain positions on the curve. Thus it can be seen that we require the number of knots <CODE>
n_knots = n_vertices + degree + 1</CODE>
.</P>
<P>
<A NAME="50487361_pgfId-22194007"></A>THE VALID RANGE OF THE B-CURVE</P>
<P>
<A NAME="50487361_pgfId-286964"></A>So if the knot set is numbered {t0 to tn_knots-1 } it can be seen then that it is only after tdegree that sufficient (degree+1) basis functions are present for the curve to be fully defined, and that the B-curve ceases to be fully defined after tn_knots - 1 - degree.</P>
<P>
<A NAME="50487361_pgfId-463858"></A>The first degree knots and the last degree knots are known as the imaginary knots because their parameter values are outside the defined range of the B-curve.</P>
<P>
<A NAME="50487361_pgfId-22194037"></A>PERIODIC B-CURVES</P>
<P>
<A NAME="50487361_pgfId-463863"></A>When the end of a B-curve meets its start sufficiently smoothly XT allows it to be defined to have periodic parameterisation. That is to say that if the valid range were from tdegree to tn_knots - 1 - degree then the difference between these values is called the period and the curve can continue to be evaluated with the same point reoccurring every period.</P>
<P>
<A NAME="50487361_pgfId-286968"></A>The minimal smoothness requirement for periodic curves in XT is tangent continuity to angular resolution, but we strongly recommend Cdegree-1, or continuity in the (degree-1)th derivative. This in turn is best achieved by repeating the first degree vertices at the end, and by matching knot intervals so that counting from the start of the defined range, tdegree, the first degree intervals between knots match the last degree intervals, and similarly matching the last degree knot intervals before the end of the defined range to the first degree intervals.</P>
<P>
<A NAME="50487361_pgfId-22194092"></A>CLOSED B-CURVES</P>
<P>
<A NAME="50487361_pgfId-286970"></A>A periodic B-curve shall also be closed, but it is permitted to have a closed B-curve that is not periodic.</P>
<P>
<A NAME="50487361_pgfId-286971"></A>In this case the rules for continuity are relaxed so that only C0 or positional continuity is required between the start and end. Such closed non-periodic curves are not able to be attached to topology.</P>
<P>
<A NAME="50487361_pgfId-22194107"></A>RATIONAL B-CURVE</P>
<P>
<A NAME="50487361_pgfId-286973"></A>In the rational form of the curve, each vertex is associated with a weight, which increases or decreases the effect of the vertex without changing the curve hull. To ensure that the convex hull property is retained, the curve equation is divided by a denominator which makes the coefficients of the vertices sum to one.</P>
<P>
<A NAME="50487361_pgfId-310493"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-14.gif">

<UL>
<UL>
<P>
<A NAME="50487361_pgfId-22194112"></A>Where <CODE>
w0</CODE>
... <CODE>
wn-1</CODE>
 are weights.</P>
</UL>
</UL>
<P>
<A NAME="50487361_pgfId-287010"></A>Each weight may take any positive value, and the larger the value, the greater the effect of the associated vertex. However, it is the relative sizes of the weights which is important, as may be seen from the fact that in the equation given above, all the weights may be multiplied by a constant without changing the equation.</P>
<P>
<A NAME="50487361_pgfId-287011"></A>In XT the weights are stored with the vertices by treating these as having an extra dimension. In the usual case of a curve in 3-d cartesian space this means that <CODE>
vertex_dim</CODE>
 is 4, the x, y, z values are multiplied through by the corresponding weight and the 4th value is the weight itself.</P>
<P>
<A NAME="50487361_pgfId-287085"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287072"></A>struct B_CURVE_s == ANY_CURVE_s   //B curve</PRE>
<PRE><A NAME="50487361_pgfId-782962"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-782963"></A>    int                           node_id;              // $d</PRE>
<PRE><A NAME="50487361_pgfId-782964"></A>    union  ATTRIB_FEAT_u          attributes_features;  // $p</PRE>
<PRE><A NAME="50487361_pgfId-782965"></A>    union  CURVE_OWNER_u          owner;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-782966"></A>    union  CURVE_u                next;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-782967"></A>    union  CURVE_u                previous;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-782968"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;      // $p</PRE>
<PRE><A NAME="50487361_pgfId-782969"></A>    char                          sense;                // $c</PRE>
<PRE><A NAME="50487361_pgfId-479622"></A>    struct NURBS_CURVE_s         *nurbs;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-479630"></A>    struct CURVE_DATA_s          *data;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-479638"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-479646"></A>typedef struct B_CURVE_s     *B_CURVE;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287086"></A>The data stored in the XT data for a NURBS_CURVE is</P>
<P>
<A NAME="50487361_pgfId-287166"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287089"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287091"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287093"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287095"></A><CODE>
degree</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287097"></A>Short</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287099"></A>degree of the curve</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287101"></A><CODE>
n_vertices</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287103"></A>Int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287105"></A>number of control vertices (“poles”)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287107"></A><CODE>
vertex_dim</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287109"></A>Short</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287111"></A>dimension of control vertices</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287113"></A><CODE>
n_knot</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287115"></A>Int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287117"></A>number of distinct knots</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287119"></A><CODE>
knot_type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287121"></A>Byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287123"></A>form of knot vector</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287125"></A><CODE>
periodic</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287127"></A>Logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287129"></A>true if curve is periodic</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287131"></A><CODE>
closed</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287133"></A>Logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287135"></A>true if curve is closed</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287137"></A><CODE>
rational</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287139"></A>Logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287141"></A>true if curve is rational</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287143"></A><CODE>
curve_form</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287145"></A>Byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287147"></A>shape of curve, if special</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287149"></A><CODE>
bspline_vertices</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287151"></A>Pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287153"></A>control vertices node</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287155"></A><CODE>
knot_mult</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287157"></A>Pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287159"></A>knot multiplicities node</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287161"></A><CODE>
knot</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287163"></A>Pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287165"></A>knots node</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287167"></A>The <CODE>
knot_type</CODE>
 enum is used to describe whether or not the knot vector has a certain regular spacing or other common property:</P>
<P>
<A NAME="50487361_pgfId-287180"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-451987"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-479654"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-479662"></A>    SCH_unset = 1,             //Unknown</PRE>
<PRE><A NAME="50487361_pgfId-479670"></A>    SCH_non_uniform = 2,       //Known to be not special</PRE>
<PRE><A NAME="50487361_pgfId-479678"></A>    SCH_uniform = 3,           //Uniform knot set</PRE>
<PRE><A NAME="50487361_pgfId-922467"></A>    SCH_quasi_uniform = 4,     //Uniform apart from bezier ends</PRE>
<PRE><A NAME="50487361_pgfId-22198934"></A>    SCH_piecewise_bezier = 5,  //Internal multiplicity of </PRE>
<PRE><A NAME="50487361_pgfId-819710"></A>                                 order-1</PRE>
<PRE><A NAME="50487361_pgfId-906132"></A>    SCH_bezier_ends = 6        //Bezier ends, no other property</PRE>
<PRE><A NAME="50487361_pgfId-909963"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-479718"></A>    SCH_knot_type_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287181"></A>A uniform knot set is one where all the knots are of multiplicity one and are equally spaced. A curve has bezier ends if the first and last knots both have multiplicity ‘order’.</P>
<P>
<A NAME="50487361_pgfId-287182"></A>The <CODE>
curve_form</CODE>
 enum describes the geometric shape of the curve. The parameterisation of the curve is not relevant.</P>
<P>
<A NAME="50487361_pgfId-287212"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287185"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-479726"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-479734"></A>    SCH_unset          = 1,     //Form is not known</PRE>
<PRE><A NAME="50487361_pgfId-22198995"></A>    SCH_arbitrary      = 2,     //Known to be of no particular </PRE>
<PRE><A NAME="50487361_pgfId-479742"></A>                                  shape</PRE>
<PRE><A NAME="50487361_pgfId-479750"></A>    SCH_polyline       = 3,</PRE>
<PRE><A NAME="50487361_pgfId-479758"></A>    SCH_circular_arc   = 4,</PRE>
<PRE><A NAME="50487361_pgfId-479766"></A>    SCH_elliptic_arc   = 5,</PRE>
<PRE><A NAME="50487361_pgfId-479774"></A>    SCH_parabolic_arc  = 6,</PRE>
<PRE><A NAME="50487361_pgfId-479782"></A>    SCH_hyperbolic_arc = 7</PRE>
<PRE><A NAME="50487361_pgfId-479790"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-479798"></A>    SCH_curve_form_t;</PRE>
<PRE><A NAME="50487361_pgfId-479806"></A>struct NURBS_CURVE_s             //NURBS curve</PRE>
<PRE><A NAME="50487361_pgfId-479814"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-479822"></A>    short                          degree;              // $n</PRE>
<PRE><A NAME="50487361_pgfId-479830"></A>    int                            n_vertices;          // $d</PRE>
<PRE><A NAME="50487361_pgfId-479838"></A>    short                          vertex_dim;          // $n</PRE>
<PRE><A NAME="50487361_pgfId-479846"></A>    int                            n_knots;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-479854"></A>    SCH_knot_type_t                knot_type;           // $u</PRE>
<PRE><A NAME="50487361_pgfId-479862"></A>    logical                        periodic;            // $l</PRE>
<PRE><A NAME="50487361_pgfId-479870"></A>    logical                        closed;              // $l</PRE>
<PRE><A NAME="50487361_pgfId-479878"></A>    logical                        rational;            // $l</PRE>
<PRE><A NAME="50487361_pgfId-479886"></A>    SCH_curve_form_t               curve_form;          // $u</PRE>
<PRE><A NAME="50487361_pgfId-479894"></A>    struct BSPLINE_VERTICES_s     *bspline_vertices;    // $p</PRE>
<PRE><A NAME="50487361_pgfId-479902"></A>    struct KNOT_MULT_s            *knot_mult;           // $p</PRE>
<PRE><A NAME="50487361_pgfId-479910"></A>    struct KNOT_SET_s             *knots;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-479918"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-479926"></A>typedef struct NURBS_CURVE_s *NURBS_CURVE;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287213"></A>The bspline vertices node is simply an array of doubles; <CODE>
vertex_dim</CODE>
 doubles together define one control vertex. Thus the length of the array is <CODE>
n_vertices * vertex_dim</CODE>
.</P>
<P>
<A NAME="50487361_pgfId-287221"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287216"></A>struct BSPLINE_VERTICES_s        // B-spline vertices</PRE>
<PRE><A NAME="50487361_pgfId-287217"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-287218"></A>    double                 vertices[ 1 ];               // $f[]</PRE>
<PRE><A NAME="50487361_pgfId-287219"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-287220"></A>typedef struct BSPLINE_VERTICES_s *BSPLINE_VERTICES;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287222"></A>The knot vector of the <CODE>
NURBS_CURVE</CODE>
 is stored as an array of distinct knots and an array describing the multiplicity of each distinct knot. Hence the two nodes:</P>
<P>
<A NAME="50487361_pgfId-287230"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287225"></A>struct KNOT_SET_s                //Knot set</PRE>
<PRE><A NAME="50487361_pgfId-479934"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-479942"></A>    double                 knots[ 1 ];                  // $f[]</PRE>
<PRE><A NAME="50487361_pgfId-479950"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-479958"></A>typedef struct KNOT_SET_s *KNOT_SET;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287231"></A>and</P>
<P>
<A NAME="50487361_pgfId-287243"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287234"></A>struct KNOT_MULT_s               //Knot multiplicities</PRE>
<PRE><A NAME="50487361_pgfId-479966"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-479974"></A>    short                  mult[ 1 ];                   // $n[]</PRE>
<PRE><A NAME="50487361_pgfId-479982"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-479990"></A>typedef struct KNOT_MULT_s *KNOT_MULT;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287244"></A>The data stored in the XT data for a CURVE_DATA node is:</P>
<P>
<A NAME="50487361_pgfId-287261"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287247"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-479998"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-22199431"></A>    SCH_unset                     = 1,  //check has not been </PRE>
<PRE><A NAME="50487361_pgfId-1126843"></A>                                         performed</PRE>
<PRE><A NAME="50487361_pgfId-480014"></A>    SCH_no_self_intersections     = 2,  //passed checks</PRE>
<PRE><A NAME="50487361_pgfId-480022"></A>    SCH_self_intersects           = 3,  //fails checks</PRE>
<PRE><A NAME="50487361_pgfId-480030"></A>    SCH_checked_ok_in_old_version = 4  //see below</PRE>
<PRE><A NAME="50487361_pgfId-480038"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-480046"></A>    SCH_self_int_t;</PRE>
<PRE><A NAME="50487361_pgfId-480054"></A>struct CURVE_DATA_s  //curve_data</PRE>
<PRE><A NAME="50487361_pgfId-480062"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-480070"></A>    SCH_self_int_t               self_int;              // $u</PRE>
<PRE><A NAME="50487361_pgfId-480078"></A>    Struct HELIX_CU_FORM_s      *analytic_form          // $p</PRE>
<PRE><A NAME="50487361_pgfId-480086"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-480094"></A>typedef struct CURVE_DATA_s *CURVE_DATA;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287262"></A>The self-intersection enum describes whether or not the geometry has been checked for self-intersections, and whether such self-intersections were found to exist:</P>
<P>
<A NAME="50487361_pgfId-22299623"></A>The <CODE>
SCH_checked_ok_in_old_version</CODE>
 enum indicates that the self-intersection check has been performed by a Parasolid version 5 or earlier but not since.</P>
<P>
<A NAME="50487361_pgfId-287264"></A>If the <CODE>
analytic_form</CODE>
 field is not null, it will point to a <CODE>
HELIX_CU_FORM</CODE>
 node, which indicates that the curve has a helical shape, as follows:</P>
<P>
<A NAME="50487361_pgfId-287278"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287267"></A>struct HELIX_CU_FORM_s</PRE>
<PRE><A NAME="50487361_pgfId-480102"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-480110"></A>    vector                      axis_pt                 // $v</PRE>
<PRE><A NAME="50487361_pgfId-480118"></A>    vector                      axis_dir                // $v</PRE>
<PRE><A NAME="50487361_pgfId-480126"></A>    vector                      point                   // $v</PRE>
<PRE><A NAME="50487361_pgfId-480134"></A>    char                        hand                    // $c</PRE>
<PRE><A NAME="50487361_pgfId-480142"></A>    interval                    turns                   // $i</PRE>
<PRE><A NAME="50487361_pgfId-480150"></A>    double                      pitch                   // $f</PRE>
<PRE><A NAME="50487361_pgfId-480158"></A>    double                      tol                     // $f</PRE>
<PRE><A NAME="50487361_pgfId-480166"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-480174"></A>typedef struct HELIX_CU_FORM_s *HELIX_CU_FORM;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287279"></A>The <CODE>
axis_pt</CODE>
 and <CODE>
axis_dir</CODE>
 fields define the axis of the helix. The hand field is ‘+’ for a right-handed and ‘-’ for a left-handed helix. A representative point on the helix is at turn position zero. The turns field gives the extent of the helix relative to the point. For instance, an interval [0 10] indicates a start position at the point and an end 10 turns along the axis. Pitch is the distance travelled along the axis in one turn. <CODE>
Tol</CODE>
 is the accuracy to which the owning <CODE>
B-curve</CODE>
 fits this specification.</P>


<H4>
<A NAME="50487361_pgfId-314204"></A>5.2.1.5 <A NAME="50487361_41220"></A>Intersection </H4>
<P>
<A NAME="50487361_pgfId-314205"></A>An intersection curve is one of the branches of a surface / surface intersection. XT represents these curves exactly; the information held in an intersection curve node is sufficient to identify the particular intersection branch involved, to identify the behaviour of the curve at its ends, and to evaluate precisely at any point in the curve. Specifically, the data is:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-287282"></A>The two surfaces involved in the intersection.</LI>
<LI>
<A NAME="50487361_pgfId-287283"></A>The two ends of the intersection curve. These are referred to as the ‘limits’ of the curve. They identify the particular branch involved.</LI>
<LI>
<A NAME="50487361_pgfId-287284"></A>An ordered array of points along the curve. This array is referred to as the ‘chart’ of the curve. It defines the parameterisation of the curve, which increases as the array index increases.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-287285"></A>The natural tangent to the curve at any point (i.e. in the increasing parameter direction) is given by the vector cross-product of the surface normals at that point, taking into account the senses of the surfaces.</P>
<P>
<A NAME="50487361_pgfId-287286"></A>Singular points where the cross-product of the surface normals is zero, or where one of the surfaces is degenerate, are called terminators. Intersection curves do not contain terminators in their interior. At terminators, the tangent to the curve is defined by the limit of the curve tangent as the curve parameter approaches the terminating value.</P>
<P>
<A NAME="50487361_pgfId-287318"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287289"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287291"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287293"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287295"></A><CODE>
surface</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287297"></A>pointer array [2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287299"></A>surfaces of intersection curve</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287301"></A><CODE>
chart</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287303"></A>Pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287305"></A>array of hvecs on the curve - see below</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287307"></A><CODE>
start</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287309"></A>Pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287311"></A>start limit of the curve</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287313"></A><CODE>
end</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287315"></A>Pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287317"></A>end limit of the curve</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16799149"></A>intersection_data</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16799151"></A>Pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16799153"></A>optional structure for storing additional information associated with an intersection curve</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287336"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287321"></A>struct INTERSECTION_s == ANY_CURVE_s // Intersection</PRE>
<PRE><A NAME="50487361_pgfId-480182"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1223739"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1223740"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-1223741"></A>    union  CURVE_OWNER_u          owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1223742"></A>    union  CURVE_u                next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-1223743"></A>    union  CURVE_u                previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-1223744"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-480238"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-480246"></A>    union  SURFACE_u             surface[ 2 ];         // $p[2]</PRE>
<PRE><A NAME="50487361_pgfId-480254"></A>    struct CHART_s               *chart;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-480262"></A>    struct LIMIT_s               *start;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-480270"></A>    struct LIMIT_s               *end;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-16796137"></A>nolog struct INTERSECTION_DATA *intersection_data      // $p</PRE>
<PRE><A NAME="50487361_pgfId-480278"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-480286"></A>typedef struct INTERSECTION_s *INTERSECTION;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287337"></A>A point on an intersection curve is stored in a data structure called an <CODE>
hvec</CODE>
 (<CODE>
hepta-vec</CODE>
, or <CODE>
7-vector</CODE>
):</P>
<P>
<A NAME="50487361_pgfId-287348"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287340"></A>typedef struct hvec_s         // hepta_vec</PRE>
<PRE><A NAME="50487361_pgfId-480294"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-480302"></A>    vector          Pvec;               //position</PRE>
<PRE><A NAME="50487361_pgfId-480310"></A>    double          u[2];               //surface parameters</PRE>
<PRE><A NAME="50487361_pgfId-480318"></A>    double          v[2]; </PRE>
<PRE><A NAME="50487361_pgfId-480326"></A>    vector          Tangent;            //curve tangent</PRE>
<PRE><A NAME="50487361_pgfId-480334"></A>    double          t;                  //curve parameter</PRE>
<PRE><A NAME="50487361_pgfId-480342"></A>    } hvec;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287349"></A>Where:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-287350"></A><CODE>
pvec</CODE>
 is a point common to both surfaces.</LI>
<LI>
<A NAME="50487361_pgfId-287351"></A><CODE>
u[]</CODE>
 and <CODE>
v[]</CODE>
 are the <CODE>
u</CODE>
 and <CODE>
v</CODE>
 parameters of the <CODE>
pvec</CODE>
 on each of the surfaces.</LI>
<LI>
<A NAME="50487361_pgfId-287352"></A>tangent is the tangent to the curve at <CODE>
pvec</CODE>
. This will be equal to the (normalized) vector cross product of the surface normals at <CODE>
pvec</CODE>
, when this cross product is non-zero. These surface normals take account of the surface sense fields.</LI>
<LI>
<A NAME="50487361_pgfId-287353"></A><CODE>
t</CODE>
 is the parameter of the <CODE>
pvec</CODE>
 on the curve</LI>
</UL>
<P>
<A NAME="50487361_pgfId-17673294"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<ADDRESS>
<A NAME="50487361_pgfId-17673293"></A>Note:  Only the <CODE>
pvec</CODE>
 part of an <CODE>
hvec</CODE>
 is actually transmitted.</ADDRESS><BR>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287358"></A>The chart data structure essentially describes a piecewise-linear (chordal) approximation to the true curve. As well as containing the ordered array of hvec’s defining this approximation, it contains extra information pertaining to the accuracy of the approximation:</P>
<P>
<A NAME="50487361_pgfId-287371"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287361"></A>struct CHART_s          //Chart</PRE>
<PRE><A NAME="50487361_pgfId-480350"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-480358"></A>    double              base_parameter;                // $f</PRE>
<PRE><A NAME="50487361_pgfId-480366"></A>    double              base_scale;                    // $f</PRE>
<PRE><A NAME="50487361_pgfId-480374"></A>    int                 chart_count;                   // $d</PRE>
<PRE><A NAME="50487361_pgfId-480382"></A>    double              chordal_error;                 // $f</PRE>
<PRE><A NAME="50487361_pgfId-480390"></A>    double              angular_error;                 // $f</PRE>
<PRE><A NAME="50487361_pgfId-480398"></A>    double              parameter_error[2];            // $f[2]</PRE>
<PRE><A NAME="50487361_pgfId-480406"></A>    hvec                hvec[ 1 ];                     // $h[]</PRE>
<PRE><A NAME="50487361_pgfId-480414"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-480422"></A>typedef struct CHART_s *CHART;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-1334465"></A>Where:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-460817"></A><CODE>
base_parameter</CODE>
 is the parameter of the first <CODE>
hvec</CODE>
 in the chart.</LI>
<LI>
<A NAME="50487361_pgfId-460818"></A><CODE>
base_scale</CODE>
 determines the scale of the parameterization (see below).</LI>
<LI>
<A NAME="50487361_pgfId-460819"></A><CODE>
chart_count</CODE>
 is the length of the <CODE>
hvec</CODE>
 array.</LI>
<LI>
<A NAME="50487361_pgfId-287376"></A><CODE>
chordal_error</CODE>
 is an estimate of the maximum deviation of the curve from the piecewise-linear approximation given by the <CODE>
hvec</CODE>
 array. It may be null.</LI>
<LI>
<A NAME="50487361_pgfId-287377"></A><CODE>
angular_error</CODE>
 is the maximum angle between the tangents of two sequential <CODE>
hvecs</CODE>
. It may be null.</LI>
<LI>
<A NAME="50487361_pgfId-287378"></A><CODE>
parameter_error[]</CODE>
 is always [null, null].</LI>
<LI>
<A NAME="50487361_pgfId-287379"></A><CODE>
hvec[]</CODE>
 is the ordered array of hvec’s.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-287380"></A>The limits of the intersection curve are stored in the following data structure:</P>
<P>
<A NAME="50487361_pgfId-287388"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287383"></A>struct LIMIT_s          // Limit</PRE>
<PRE><A NAME="50487361_pgfId-480430"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-480438"></A>    char                type;                          // $c</PRE>
<PRE><A NAME="50487361_pgfId-22300767"></A>char  term_use;//$c</PRE>
<PRE><A NAME="50487361_pgfId-480446"></A>    hvec                hvec[ 1 ];                     // $h[]</PRE>
<PRE><A NAME="50487361_pgfId-480454"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-480462"></A>typdef struct LIMIT_s *LIMIT;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287389"></A>The ‘type’ field may take one of the following values</P>
<P>
<A NAME="50487361_pgfId-492053"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287392"></A>    const char SCH_help           =&acute;H&acute;;      // help hvec</PRE>
<PRE><A NAME="50487361_pgfId-287393"></A>    const char SCH_terminator     =&acute;T&acute;;      // terminator</PRE>
<PRE><A NAME="50487361_pgfId-287394"></A>    const char SCH_limit          =&acute;L&acute;;      // arbitrary limit</PRE>
<PRE><A NAME="50487361_pgfId-287395"></A>    const char SCH_boundary       =&acute;B&acute;;      // spine boundary</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22299701"></A>The ‘term_use’ field takes one of the following values</P>
<P>
<A NAME="50487361_pgfId-22299707"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22299704"></A>const char SCH_unset_char = &acute;?&acute; //generic uninvestigated value</PRE>
<PRE><A NAME="50487361_pgfId-22299705"></A>const char SCH_first =&acute;F&acute;       //first item</PRE>
<PRE><A NAME="50487361_pgfId-22299706"></A>const char SCH_second =&acute;S&acute;      //second item</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287397"></A>The length of the <CODE>
hvec</CODE>
 array depends on the type of the limit.</P>
<UL>
<LI>
<A NAME="50487361_pgfId-287398"></A>a <CODE>
SCH_help</CODE>
 limit is an arbitrary point on a closed intersection curve. There will be one <CODE>
hvec</CODE>
 in the <CODE>
hvec</CODE>
 array, locating the curve.</LI>
<LI>
<A NAME="50487361_pgfId-287399"></A>a <CODE>
SCH_terminator</CODE>
 limit is a point where one of the surface normals is degenerate, or where their cross-product is zero. Typically, there will be more than one branch of intersection between the two surfaces at these singularities. There will be two values in the <CODE>
hvec</CODE>
 array. The first will be the exact position of the singularity, and the second will be a point on the curve a small distance away from the terminator. This ‘branch point’ identifies which branch relates to the curve in question. The branch point is the one which appears in the chart, at the corresponding end - so the singularity lies just outside the parameter range of the chart.</LI>
<LI>
<A NAME="50487361_pgfId-287400"></A>a <CODE>
SCH_limit</CODE>
 limit is an artificial boundary of an intersection curve on an otherwise potentially infinite branch. The single <CODE>
hvec</CODE>
 describes the end of the curve.</LI>
<LI>
<A NAME="50487361_pgfId-287401"></A>a <CODE>
SCH_boundary</CODE>
 limit is used to describe the end of a degenerate rolling-ball blend. It is not relevant to intersection curves.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-287402"></A>The parameterisation of the curve is given as follows. If the chart points are <CODE>
Pi</CODE>
, <CODE>
i = 0</CODE>
 to <CODE>
n</CODE>
, with parameters <CODE>
ti</CODE>
, and natural tangent vectors <CODE>
Ti</CODE>
, then define</P>
<UL>
<P>
<A NAME="50487361_pgfId-22194177"></A><CODE>
Ci = | Pi+1 - Pi |</CODE>
</P>
<P>
<A NAME="50487361_pgfId-22194178"></A><CODE>
cos(ai) = Ti.(Pi+1 - Pi)/Ci</CODE>
</P>
<P>
<A NAME="50487361_pgfId-22194179"></A><CODE>
cos(bi) = Ti.(Pi - Pi-1)/Ci-1</CODE>
</P>
</UL>
<P>
<A NAME="50487361_pgfId-287406"></A>Then at any chart point <CODE>
Pi</CODE>
 the angles <CODE>
ai</CODE>
 and <CODE>
bi</CODE>
 are the deviations between the tangent at the chart point and the next and previous chords respectively.</P>
<P>
<A NAME="50487361_pgfId-287407"></A>Let <CODE>
f0 = base_scale</CODE>
</P>
<UL>
<P>
<A NAME="50487361_pgfId-22194189"></A><CODE>
fi = (cos(bi) / cos(ai)) fi-1</CODE>
</P>
</UL>
<P>
<A NAME="50487361_pgfId-287409"></A>Then <CODE>
t0 = base_parameter</CODE>
</P>
<UL>
<P>
<A NAME="50487361_pgfId-22194195"></A><CODE>
ti = ti-1 + Ci-1 fi-1</CODE>
</P>
</UL>
<P>
<A NAME="50487361_pgfId-287411"></A>The factors <CODE>
fi</CODE>
 are chosen so that the parameterisation is <CODE>
C1</CODE>
. The parameter of a point between two chart points is given by projecting the point onto the chord between the previous and next chart points.</P>
<P>
<A NAME="50487361_pgfId-287412"></A>The point on the intersection curve corresponding to a given parameter is defined as follows:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-287413"></A>For a parameter equal to that of a chart point, it is the position of the chart point.</LI>
<LI>
<A NAME="50487361_pgfId-287414"></A>For a parameter interior to the chart, it is the local point of intersection of three surfaces: the two surfaces of the intersection, and a plane defined by the chart. If the parameter <CODE>
t</CODE>
 lies between chart parameters <CODE>
ti</CODE>
, <CODE>
ti+1</CODE>
, then the chord point corresponding to <CODE>
t</CODE>
 lies at</LI>
</UL>
<P>
<A NAME="50487361_pgfId-17673397"></A><CODE>
(ti+1 - t) / (ti+1 - ti) Pi + (t - ti) / (ti+1 - ti) Pi+1</CODE>
</P>
<P>
<A NAME="50487361_pgfId-17673402"></A>The plane lies through this point and is orthogonal to the chord (<CODE>
Pi+1, Pi</CODE>
).</P>
<UL>
<LI>
<A NAME="50487361_pgfId-21343504"></A>For a parameter between a branch chart point and a terminator, it is the local point of intersection of three surfaces: one of the intersection surfaces and two planes. Surface[0] is used unless</LI>
<UL>
<LI>
<A NAME="50487361_pgfId-22299712"></A>it is singular at the terminator and surface[1] is not</LI>
<LI>
<A NAME="50487361_pgfId-22299713"></A>or it has the node type BLEND_BOUND_nt</LI>
<LI>
<A NAME="50487361_pgfId-22299714"></A>or ‘term_use’ specifies to use surface[1] </LI>
</UL>
</UL>
<P>
<A NAME="50487361_pgfId-1484918"></A>The first plane contains the chord between the branch and the terminator, and the normal of the chosen intersection surface at the terminator or the curve tangent at the branch chart point if the surface normal cannot be defined. The second plane is the plane orthogonal to the chord between the branch and terminator points through the chord point as calculated above.</P>
<P>
<A NAME="50487361_pgfId-16852634"></A>The <CODE>
intersection_data</CODE>
 node is an optional structure for storing surface uv parameters from hvecs that are associated with an intersection curve.</P>
<P>
<A NAME="50487361_pgfId-22299722"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<ADDRESS>
<A NAME="50487361_pgfId-22299721"></A>Note: The <CODE>
intersection_data</CODE>
 must match the hvecs</ADDRESS><BR>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-16800925"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-16800156"></A>struct INTERSECTION_DATA_s          //Intersection data</PRE>
<PRE><A NAME="50487361_pgfId-16800157"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-16800158"></A>    SCH_intersection_uv_type_t uv_type; // $u</PRE>
<PRE><A NAME="50487361_pgfId-16800159"></A>    double values [1]; // $f[]</PRE>
<PRE><A NAME="50487361_pgfId-16800160"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-16800161"></A>typedef struct INTERSECTION_DATA_s*INTERSECTION_DATA;</PRE>
<PRE><A NAME="50487361_pgfId-16800162"></A>               inline double      *SCH_INTERSECTION_DATA_values(INTERSECTION_DATA self)</PRE>
<PRE><A NAME="50487361_pgfId-16800163"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-16800164"></A>   return self -&gt; values;</PRE>
<PRE><A NAME="50487361_pgfId-16800165"></A>}</PRE>
<PRE><A NAME="50487361_pgfId-16800166"></A>SCH_define_init_fn_m(INTERSECTION_DATA_s, self,</PRE>
<PRE><A NAME="50487361_pgfId-16800167"></A>                     self -&gt; uv_type = SCH_intersection_uv_none;</PRE>
<PRE><A NAME="50487361_pgfId-16800168"></A>                     double*values   = SCH_INTERSECTION_DATA_values(self);</PRE>
<PRE><A NAME="50487361_pgfId-16800169"></A>                         for (int i = 0; i&lt; n_variable; ++i)</PRE>
<PRE><A NAME="50487361_pgfId-16800170"></A>                         values [i] = null;</PRE>
<PRE><A NAME="50487361_pgfId-16800171"></A>                    )</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-16796226"></A>The <CODE>
intersection_data</CODE>
 node contains an enum value and a variable length double array. The enum value specifies the uv values stored in the values array and is set based on the following:</P>
<P>
<A NAME="50487361_pgfId-16798065"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-16796706"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-16796758"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-16796793"></A>    SCH_intersection_uv_none      = 1,</PRE>
<PRE><A NAME="50487361_pgfId-16796832"></A>    SCH_intersection_uv_first     = 2,</PRE>
<PRE><A NAME="50487361_pgfId-16796870"></A>    SCH_intersection_uv_second    = 3,</PRE>
<PRE><A NAME="50487361_pgfId-16796930"></A>    SCH_intersection_uv_both      = 4,</PRE>
<PRE><A NAME="50487361_pgfId-16796783"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-16796986"></A>    SCH_intersection_uv_type_t;</PRE>
<PRE><A NAME="50487361_pgfId-16797017"></A>char *SCH_intersection_uv_type_sprintf</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-16804476"></A>The uv values are converted to the number of parameters which are stored for each chart <CODE>
hvec</CODE>
 as follows:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-16798329"></A>If <CODE>
SCH_intersection_uv_none</CODE>
, the number of parameters is 0</LI>
<LI>
<A NAME="50487361_pgfId-16798330"></A>If <CODE>
SCH_intersection_uv_first</CODE>
 or <CODE>
SCH_intersection_uv_second</CODE>
, the number of parameters is 2</LI>
<LI>
<A NAME="50487361_pgfId-16798331"></A>If <CODE>
SCH_intersection_uv_both</CODE>
, the number of parameters is 4</LI>
</UL>
<P>
<A NAME="50487361_pgfId-16798056"></A>The variable length double array contains these parameters, and the start and end limits. The values for the start and end limits can be found in the variable length arrays in the LIMIT start, and LIMIT end fields of the INTERSECTION node. </P>
<P>
<A NAME="50487361_pgfId-16804123"></A>The number of values in the double array is calculated as:</P>
<P>
<A NAME="50487361_pgfId-16851597"></A>(The number of chart points + The number of terminator limits) * (The number of parameters per <CODE>
hvec)</CODE>
</P>
<P>
<A NAME="50487361_pgfId-16800633"></A>For each terminator present in the array the number of values will increase by 0, 2, or 4 depending on the <CODE>
intersection_uv_type</CODE>
 field. For example, if both the start and the end limits are terminators and the <CODE>
intersection_uv_type</CODE>
 is set to <CODE>
SCH_intersection_uv_both</CODE>
 the value will increase by 8. </P>
<P>
<A NAME="50487361_pgfId-16848242"></A>The order of values in the array is as follows:</P>
<P>
<A NAME="50487361_pgfId-16849453"></A>If the start limit is a terminator:</P>
<P>
<A NAME="50487361_pgfId-16849336"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849323"></A>If the intersection_uv_type is...</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849325"></A>The order of values in array is...</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849327"></A><CODE>
SCH_intersection_uv_first</CODE>
 or<CODE>
 SCH_intersection_uv_both</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849512"></A>intersection node -&gt;start-&gt;hvec[0].u[0]</P>
<P>
<A NAME="50487361_pgfId-16849538"></A>intersection node -&gt;start-&gt;hvec[0].v[0]</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849332"></A><CODE>
SCH_intersection_uv_second</CODE>
 or <CODE>
SCH_intersection_uv_both</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849552"></A>intersection node -&gt;start -&gt;hvec[0].u[1]</P>
<P>
<A NAME="50487361_pgfId-16849334"></A>intersection node -&gt;start -&gt;hvec[0].v[1]</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-16849252"></A>For each <CODE>
hvec</CODE>
 in the chart:</P>
<P>
<A NAME="50487361_pgfId-16850979"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16848962"></A>If the intersection_uv_type is...</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16848964"></A>The order of values in array is...</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16848966"></A><CODE>
SCH_intersection_uv_first</CODE>
 or<CODE>
 SCH_intersection_uv_both</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849093"></A>intersection node-&gt;chart -&gt;hvec[i].u[0]</P>
<P>
<A NAME="50487361_pgfId-16849119"></A>intersection node-&gt;chart -&gt;hvec[i].v[0]</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16848970"></A><CODE>
SCH_intersection_uv_second</CODE>
 or <CODE>
SCH_intersection_uv_both</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849151"></A>intersection node-&gt;chart -&gt;hvec[i].u[1]</P>
<P>
<A NAME="50487361_pgfId-16849177"></A>intersection node-&gt;chart -&gt;hvec[i].v[1]</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22211708"></A>chart hvecs are wrapped in a loop where i = 0 to the (number of chart hvecs -1).</P>
<P>
<A NAME="50487361_pgfId-16849601"></A>If end limit is a terminator:</P>
<P>
<A NAME="50487361_pgfId-16849584"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849571"></A>If the intersection_uv_type is...</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849573"></A>The order of values in array is...</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849575"></A><CODE>
SCH_intersection_uv_first</CODE>
 or<CODE>
 SCH_intersection_uv_both</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849577"></A>intersection node-&gt;end -&gt;hvec[0].u[0]</P>
<P>
<A NAME="50487361_pgfId-16849578"></A>intersection node-&gt;end -&gt;hvec[0].v[0]</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849580"></A><CODE>
SCH_intersection_uv_second</CODE>
 or <CODE>
SCH_intersection_uv_both</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16849582"></A>intersection node-&gt;end -&gt;hvec[0].u[1]</P>
<P>
<A NAME="50487361_pgfId-16849583"></A>intersection node-&gt;end -&gt;hvec[0].v[1]</P>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-287418"></A>5.2.1.6 Trimmed_curve</H4>
<P>
<A NAME="50487361_pgfId-287419"></A>A trimmed curve is a bounded region of another curve, referred to as its basis curve. It is defined by the basis curve and two points and their corresponding parameters. Trimmed curves are most commonly attached to fins (fins) of tolerant edges in order to specify which portion of the underlying basis curve corresponds to the tolerant edge. They are necessary since the tolerant vertices of the edge do not necessarily lie exactly on the basis curve; the ‘point’ fields of the trimmed curve lie exactly on the basis curve, and within tolerance of the relevant vertex.</P>
<P>
<A NAME="50487361_pgfId-287420"></A>The rules governing the parameter fields and points are:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-287421"></A><CODE>
point_1</CODE>
 and <CODE>
point_2</CODE>
 correspond to <CODE>
parm_1</CODE>
 and <CODE>
parm_2</CODE>
 respectively.</LI>
<LI>
<A NAME="50487361_pgfId-287422"></A>If the basis curve has positive sense, <CODE>
parm_2 &gt; parm_1</CODE>
.</LI>
<LI>
<A NAME="50487361_pgfId-287423"></A>If the basis curve has negative sense, <CODE>
parm_2 &lt; parm_1</CODE>
.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-287424"></A>In addition,</P>
<P>
<A NAME="50487361_pgfId-287425"></A>For open basis curves.</P>
<UL>
<LI>
<A NAME="50487361_pgfId-287426"></A>Both <CODE>
parm_1</CODE>
 and <CODE>
parm_2</CODE>
 shall be in the parameter range of the basis curve.</LI>
<LI>
<A NAME="50487361_pgfId-287427"></A><CODE>
point_1</CODE>
 and <CODE>
point_2</CODE>
 shall not be equal.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-287428"></A>For periodic basis curves</P>
<UL>
<LI>
<A NAME="50487361_pgfId-287429"></A><CODE>
parm_1</CODE>
 shall lie in the base range of the basis curve.</LI>
<LI>
<A NAME="50487361_pgfId-287430"></A>If the whole basis curve is required then <CODE>
parm_1</CODE>
 and <CODE>
parm_2</CODE>
 should be a period apart and <CODE>
point_1 = point_2</CODE>
. Equality of <CODE>
parm_1</CODE>
 and <CODE>
parm_2</CODE>
 is not permitted.</LI>
<LI>
<A NAME="50487361_pgfId-287431"></A><CODE>
parm_1</CODE>
 and <CODE>
parm_2</CODE>
 shall not be more than a period apart.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-287432"></A>For closed but non-periodic basis curves</P>
<UL>
<LI>
<A NAME="50487361_pgfId-287433"></A>Both <CODE>
parm_1</CODE>
 and <CODE>
parm_2</CODE>
 shall be in the parameter range of the basis curve.</LI>
<LI>
<A NAME="50487361_pgfId-314214"></A>If the whole of the basis curve is required, <CODE>
parm_1</CODE>
 and <CODE>
parm_2</CODE>
 shall lie close enough to each end of the valid parameter range in order that <CODE>
point_1</CODE>
 and <CODE>
point_2</CODE>
 are coincident to XT tolerance (1.0e-8 by default).</LI>
</UL>
<P>
<A NAME="50487361_pgfId-314215"></A>The sense of a trimmed curve is positive.</P>
<P>
<A NAME="50487361_pgfId-419989"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420004"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420006"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420008"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420052"></A><CODE>
basis curve</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420054"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420056"></A>basis curve</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420058"></A><CODE>
point_1</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420060"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420062"></A>start of trimmed portion</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420064"></A><CODE>
point_2</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420066"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420068"></A>end of trimmed portion</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420070"></A><CODE>
parm_1</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420072"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420074"></A>parameter on basis curve corresponding to point_1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420080"></A><CODE>
parm_2</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420082"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-420084"></A>parameter on basis curve corresponding to point_2</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-419969"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-419953"></A>struct TRIMMED_CURVE_s == ANY_CURVE_s  //Trimmed Curve</PRE>
<PRE><A NAME="50487361_pgfId-1550747"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1550748"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1550749"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-1550750"></A>    union  CURVE_OWNER_u          owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1550751"></A>    union  CURVE_u                next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-1550752"></A>    union  CURVE_u                previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-1550753"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-1550754"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-480534"></A>    union  CURVE_u                basis_curve;         // $p</PRE>
<PRE><A NAME="50487361_pgfId-480542"></A>    vector                        point_1;             // $v</PRE>
<PRE><A NAME="50487361_pgfId-480550"></A>    vector                        point_2;             // $v</PRE>
<PRE><A NAME="50487361_pgfId-480558"></A>    double                        parm_1;              // $f</PRE>
<PRE><A NAME="50487361_pgfId-480566"></A>    double                        parm_2;              // $f</PRE>
<PRE><A NAME="50487361_pgfId-480574"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-480582"></A>typedef struct TRIMMED_CURVE_s *TRIMMED_CURVE;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-22299727"></A>5.2.1.7 PE_CURVE (Foreign geometry curve)</H4>
<P>
<A NAME="50487361_pgfId-22299728"></A>Foreign geometry in XT is a type used for representing customers’ in-house proprietary data. It is also known as PE (parametrically evaluated) geometry. It can also be used internally for representing geometry connected with this data (for example, offsets of foreign surfaces). These two types of foreign geometry usage are referred to as ‘external’ and ‘internal’ PE data respectively. Internal PE-curves are not used at present.</P>
<P>
<A NAME="50487361_pgfId-22299729"></A>Applications not using foreign geometry will never encounter either external or internal PE data structures at Parasolid V9 or beyond.</P>
<P>
<A NAME="50487361_pgfId-22299772"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299735"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299737"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299739"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299741"></A><CODE>
type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299743"></A>char</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299745"></A>whether internal or external</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299747"></A><CODE>
data</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299749"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299751"></A>internal or external data</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299753"></A><CODE>
tf</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299755"></A>pointer(0)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299757"></A>transform applied to geometry</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299759"></A><CODE>
internal geom</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299761"></A>pointer array</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22299763"></A>reference to other related geometry</P>
</TD>
</TR>
</TABLE>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22299766"></A>union PE_DATA_u  //PE_data_u</PRE>
<PRE><A NAME="50487361_pgfId-22299767"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22299768"></A>struct EXT_PE_DATA_s  *external;  //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299769"></A>struct INT_PE_DATA_s  *internal;  //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299770"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-22299771"></A>typedef union PE_DATA_u PE_DATA;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22299773"></A>The PE internal geometry union defined below is used by internal foreign geometry only.</P>
<P>
<A NAME="50487361_pgfId-22299782"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22299776"></A>union PE_INT_GEOM_u</PRE>
<PRE><A NAME="50487361_pgfId-22299777"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22299778"></A>union SURFACE_u  surface;  //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299779"></A>union CURVE_u  curve;      //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299780"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-22299781"></A>typedef union PE_INT_GEOM_u PE_INT_GEOM;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22299800"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22299785"></A>struct PE_CURVE_s == ANY_CURVE_s  //PE_curve</PRE>
<PRE><A NAME="50487361_pgfId-22299786"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22299787"></A>int  node_id;                               /$d</PRE>
<PRE><A NAME="50487361_pgfId-22299788"></A>union ATTRIB_FEAT_u  attributes_features;   //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299789"></A>union CURVE_OWNER_u  owner;                 //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299790"></A>union CURVE_u  next;                        //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299791"></A>union CURVE_u  previous;                    //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299792"></A>struct GEOMETRIC_OWNER_s  *geometric_owner; //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299793"></A>char  sense;                                //$c</PRE>
<PRE><A NAME="50487361_pgfId-22299794"></A>char  type;                                 //$c</PRE>
<PRE><A NAME="50487361_pgfId-22299795"></A>union PE_DATA_u  data;                      //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299796"></A>struct TRANSFORM_s  *tf;                    //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299797"></A>union PE_INT_GEOM_u  internal_geom[ 1 ];    //$p[]</PRE>
<PRE><A NAME="50487361_pgfId-22299798"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-22299799"></A>typedef struct PE_CURVE_s *PE_CURVE;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22299801"></A>The type of the foreign geometry (whether internal or external) is identified in the PE-curve node by means of the char ‘type’ field, taking one of the values:</P>
<P>
<A NAME="50487361_pgfId-22299806"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22299804"></A>const char SCH_external = &acute;E&acute;; //external PE geometry</PRE>
<PRE><A NAME="50487361_pgfId-22299805"></A>const char SCH_interna = &acute;I&acute;; //internal PE geometry</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22299807"></A>The <CODE>
PE_data</CODE>
 union is used in a PE curve or surface node to identify the internal or external evaluator corresponding to the geometry, and also holds an array of real and/or integer parameters to be passed to the evaluator. The data stored corresponds exactly to that passed to the XT routine <CODE>
<A HREF=../headers/pk_fsurf_create.html>PK_FSURF_create</A></CODE>
 when the geometry is created.</P>
<P>
<A NAME="50487361_pgfId-22299817"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22299810"></A>struct EXT_PE_DATA_s //ext_PE_data</PRE>
<PRE><A NAME="50487361_pgfId-22299811"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22299812"></A>struct KEY_s  *key;                    //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299813"></A>struct REAL_VALUES_s  *real_array;     //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299814"></A>struct INT_VALUES_s  *int_array;       //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299815"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-22299816"></A>typedef struct EXT_PE_DATA_s *EXT_PE_DATA;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22299827"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22299820"></A>struct INT_PE_DATA_s // int_PE_data</PRE>
<PRE><A NAME="50487361_pgfId-22299821"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22299822"></A>int  geom_type;                        //$d</PRE>
<PRE><A NAME="50487361_pgfId-22299823"></A>struct REAL_VALUES_s  *real_array;     //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299824"></A>struct INT_VALUES_s  *int_array;       //$p</PRE>
<PRE><A NAME="50487361_pgfId-22299825"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-22299826"></A>typedef struct INT_PE_DATA_s *INT_PE_DATA;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22299828"></A>The only internal pe type in use at the moment is the offset PE-surface, for which the <CODE>
geom_type</CODE>
 is 2.</P>


<H4>
<A NAME="50487361_pgfId-287592"></A>5.2.1.8 SP_CURVE</H4>
<P>
<A NAME="50487361_pgfId-287593"></A>An SP-curve is the 3D curve resulting from embedding a 2D curve in the parameter space of a surface.</P>
<P>
<A NAME="50487361_pgfId-287594"></A>The 2D curve shall be a 2D B-curve; that is it shall either be a rational B-curve with a vertex dimensionality of 3, or a non-rational B-curve with a vertex dimensionality of 2.</P>
<P>
<A NAME="50487361_pgfId-287626"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287597"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287599"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287601"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287603"></A><CODE>
surface</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287605"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287607"></A>surface</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287609"></A><CODE>
b_curve</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287611"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287613"></A>2D B-curve</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287615"></A><CODE>
original</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287617"></A>pointer(0)</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287619"></A>not used</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287621"></A><CODE>
tolerance_to_original</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287623"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287625"></A>not used</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-16853009"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-420525"></A>struct SP_CURVE_s == ANY_CURVE_s //SP curve</PRE>
<PRE><A NAME="50487361_pgfId-1732440"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1732441"></A>    int                           node_id;                // $d</PRE>
<PRE><A NAME="50487361_pgfId-1732442"></A>    union  ATTRIB_FEAT_u          attributes_features;    // $p</PRE>
<PRE><A NAME="50487361_pgfId-1732443"></A>    union  CURVE_OWNER_u          owner;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-1732444"></A>    union  CURVE_u                next;                   // $p</PRE>
<PRE><A NAME="50487361_pgfId-1732445"></A>    union  CURVE_u                previous;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1732446"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;        // $p</PRE>
<PRE><A NAME="50487361_pgfId-1732447"></A>    char                          sense;                  // $c</PRE>
<PRE><A NAME="50487361_pgfId-480942"></A>    union  SURFACE_u              surface;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-480950"></A>    struct B_CURVE_s             *b_curve;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-480958"></A>    union  CURVE_u                 original;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-480966"></A>    double                        tolerance_to_original;  // $f</PRE>
<PRE><A NAME="50487361_pgfId-480974"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-480982"></A>typedef struct SP_CURVE_s *SP_CURVE;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-287644"></A>5.2.1.9 Polyline</H4>
<P>
<A NAME="50487361_pgfId-17100253"></A>A polyline describes a connected chain of linear segments. It takes the following additional field:</P>
<P>
<A NAME="50487361_pgfId-17101655"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16853104"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16853106"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16853108"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16853110"></A><CODE>
data</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16853112"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16853114"></A>contains the data information of the polyline.</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-17101681"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-17101669"></A>struct POLYLINE_s == ANY_CURVE_s  //Polyline</PRE>
<PRE><A NAME="50487361_pgfId-17101670"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-17101671"></A>  int                        node_id;             //$d</PRE>
<PRE><A NAME="50487361_pgfId-17101672"></A>  union ATTRIB_FEAT_u        attributes_features; //$p</PRE>
<PRE><A NAME="50487361_pgfId-17101673"></A>  union CURVE_OWNER_u        owner;               //$p</PRE>
<PRE><A NAME="50487361_pgfId-17101674"></A>  union CURVE_u              next;                //$p</PRE>
<PRE><A NAME="50487361_pgfId-17101675"></A>  union CURVE_u              previous;            //$p</PRE>
<PRE><A NAME="50487361_pgfId-17101676"></A>  struct GEOMETRIC_OWNER_s  *geometric_owner;     //$p</PRE>
<PRE><A NAME="50487361_pgfId-17101677"></A>  char                       sense;               //$c</PRE>
<PRE><A NAME="50487361_pgfId-17101678"></A>  struct POLYLINE_DATA_s    *data;                //$p</PRE>
<PRE><A NAME="50487361_pgfId-17101679"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-17101680"></A>typedef struct POLYLINE_s *POLYLINE;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-16870429"></A>The data stored in the XT data for a POLYLINE is as follows:</P>
<P>
<A NAME="50487361_pgfId-17102282"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-17102145"></A>struct POLYLINE_DATA_s  //Polyline data</PRE>
<PRE><A NAME="50487361_pgfId-17102146"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-17102147"></A>  int       n_pvecs;              //$d</PRE>
<PRE><A NAME="50487361_pgfId-17102148"></A>  logical   closed;               //$I</PRE>
<PRE><A NAME="50487361_pgfId-17102149"></A>  double    base_parm;            //$f</PRE>
<PRE><A NAME="50487361_pgfId-17102150"></A>  struct    POINT_VALUES_s*pvec;  //$p</PRE>
<PRE><A NAME="50487361_pgfId-17102151"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-17102152"></A>typedef struct POLYLINE_DATA_s*POLYLINE_DATA;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-17102153"></A>Where:</P>
<P>
<A NAME="50487361_pgfId-17038904"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16870445"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16870447"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16870449"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16870451"></A><CODE>
n_pvecs</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16870453"></A>integer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16870455"></A>number of point vectors </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16870457"></A>closed</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16870459"></A>logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16870461"></A>true if polyline is closed</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16976106"></A>base_parm</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16976108"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16976110"></A>the parameter of the first pvec in the polyline</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16976136"></A>pvec</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16976138"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-16976140"></A>point vectors that describe the shape of the polyline</P>
</TD>
</TR>
</TABLE>



<H3>
<A NAME="50487361_pgfId-287645"></A>	5.2.2 	Surfaces</H3>
<P>
<A NAME="50487361_pgfId-287646"></A>All surface nodes share the following common fields:</P>
<P>
<A NAME="50487361_pgfId-287696"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287649"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287651"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287653"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287655"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287657"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287659"></A>integer value unique to surface in part</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287661"></A><CODE>
attributes_features</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287663"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287665"></A>attributes and features associated with surface</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287667"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287669"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287671"></A>topological owner</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287673"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287675"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287677"></A>next surface in geometry chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287679"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287681"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287683"></A>previous surface in geometry chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287685"></A><CODE>
geometric_owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287687"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287689"></A>geometric owner node</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287691"></A><CODE>
sense</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287693"></A>char</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287695"></A>sense of surface: ‘+’ or ‘-’(see end of Geometry section)</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287710"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-452816"></A>struct ANY_SURF_s     //Any Surface</PRE>
<PRE><A NAME="50487361_pgfId-1778571"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1778572"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1778573"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-481015"></A>    union  SURFACE_OWNER_u        owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-481023"></A>    union  SURFACE_u              next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-481031"></A>    union  SURFACE_u              previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-481039"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-481047"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-481055"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-481063"></A>typedef struct ANY_SURF_s *ANY_SURF;</PRE>
</TD>
</TR>
</TABLE>

<H4>
<A NAME="50487361_pgfId-287711"></A>5.2.2.1 Plane</H4>
<P>
<A NAME="50487361_pgfId-287712"></A>A plane has a parametric representation of the form</P>
<P>
<A NAME="50487361_pgfId-287713"></A><CODE>
R(u, v) = P + uX + vY</CODE>
</P>
<P>
<A NAME="50487361_pgfId-287714"></A>Where:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-287715"></A><CODE>
P</CODE>
 is a point on the plane</LI>
</UL>
<P>
<A NAME="50487361_pgfId-287749"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-15.gif">

<UL>
<LI>
<A NAME="50487361_pgfId-287750"></A><CODE>
X</CODE>
 and <CODE>
Y</CODE>
 are axes in the plane</LI>
</UL>
<P>
<A NAME="50487361_pgfId-287776"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287753"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287755"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287757"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287759"></A><CODE>
pvec</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287761"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287763"></A>point on the plane</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287765"></A><CODE>
normal</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287767"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287769"></A>normal to the plane (a unit vector)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287771"></A><CODE>
x_axis</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287773"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287775"></A>X axis of the plane (a unit vector)</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287777"></A>The <CODE>
Y</CODE>
 axis in the definition above is the vector cross product of the normal and <CODE>
x_axis</CODE>
.</P>
<P>
<A NAME="50487361_pgfId-287794"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287780"></A>struct PLANE_s == ANY_SURF_s      //Plane</PRE>
<PRE><A NAME="50487361_pgfId-1875630"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1875631"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1875632"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875633"></A>    union  SURFACE_OWNER_u        owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875634"></A>    union  SURFACE_u              next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875635"></A>    union  SURFACE_u              previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875636"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875637"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-481136"></A>    vector                        pvec;                // $v</PRE>
<PRE><A NAME="50487361_pgfId-481144"></A>    vector                        normal;              // $v</PRE>
<PRE><A NAME="50487361_pgfId-481152"></A>    vector                        x_axis;              // $v</PRE>
<PRE><A NAME="50487361_pgfId-481160"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-481168"></A>typedef struct PLANE_s *PLANE;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-287795"></A>5.2.2.2 Cylinder</H4>
<P>
<A NAME="50487361_pgfId-287796"></A>A cylinder has a parametric representation of the form:</P>
<P>
<A NAME="50487361_pgfId-287797"></A><CODE>
R(u,v) = P + rXcos(u) + rYsin(u) + vA</CODE>
</P>
<P>
<A NAME="50487361_pgfId-287798"></A>Where:</P>
<P>
<A NAME="50487361_pgfId-287832"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-16.gif">

<UL>
<LI>
<A NAME="50487361_pgfId-287833"></A><CODE>
P</CODE>
 is a point on the cylinder axis.</LI>
<LI>
<A NAME="50487361_pgfId-287834"></A><CODE>
r</CODE>
 is the cylinder radius.</LI>
<LI>
<A NAME="50487361_pgfId-287835"></A><CODE>
A</CODE>
 is the cylinder axis.</LI>
<LI>
<A NAME="50487361_pgfId-287836"></A><CODE>
X</CODE>
 and <CODE>
Y</CODE>
 are unit vectors such that <CODE>
A</CODE>
, <CODE>
X</CODE>
 and <CODE>
Y</CODE>
 form an orthonormal set.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-305250"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305221"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305223"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305225"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305227"></A><CODE>
pvec</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305229"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305231"></A>point on the cylinder axis</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305233"></A><CODE>
axis</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305235"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305237"></A>direction of the cylinder axis (a unit vector)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305239"></A><CODE>
radius</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305241"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305243"></A>radius of cylinder</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305245"></A><CODE>
x_axis</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305247"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-305249"></A>X axis of the cylinder (a unit vector)</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-305251"></A>The <CODE>
Y</CODE>
 axis in the definition above is the vector cross product of the <CODE>
axis</CODE>
 and <CODE>
x_axis</CODE>
.</P>
<P>
<A NAME="50487361_pgfId-305269"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-305254"></A>struct CYLINDER_s == ANY_SURF_s   //Cylinder </PRE>
<PRE><A NAME="50487361_pgfId-1875649"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1875650"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1875651"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875652"></A>    union  SURFACE_OWNER_u        owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875653"></A>    union  SURFACE_u              next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875654"></A>    union  SURFACE_u              previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875655"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875656"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-481240"></A>    vector                        pvec;                // $v</PRE>
<PRE><A NAME="50487361_pgfId-481248"></A>    vector                        axis;                // $v</PRE>
<PRE><A NAME="50487361_pgfId-481256"></A>    double                        radius;              // $f</PRE>
<PRE><A NAME="50487361_pgfId-481264"></A>    vector                        x_axis;              // $v</PRE>
<PRE><A NAME="50487361_pgfId-481272"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-481280"></A>typedef struct CYLINDER_s *CYLINDER;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-287888"></A>5.2.2.3 Cone</H4>
<P>
<A NAME="50487361_pgfId-287889"></A>A cone in XT is only half of a mathematical cone. By convention, the cone axis points away from the half of the cone in use. A cone has a parametric representation of the form:</P>
<P>
<A NAME="50487361_pgfId-287890"></A><CODE>
R(u, v) = P - vA + (Xcos(u) + Ysin(u))(r + vtan(a))</CODE>
</P>
<P>
<A NAME="50487361_pgfId-2038037"></A>Where:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-287892"></A><CODE>
P</CODE>
 is a point on the cone axis.</LI>
<LI>
<A NAME="50487361_pgfId-287893"></A><CODE>
r</CODE>
 is the cone radius at the point P.</LI>
<LI>
<A NAME="50487361_pgfId-287894"></A><CODE>
A</CODE>
 is the cone axis.</LI>
<LI>
<A NAME="50487361_pgfId-287895"></A><CODE>
X</CODE>
 and <CODE>
Y</CODE>
 are unit vectors such that <CODE>
A</CODE>
, <CODE>
X</CODE>
 and <CODE>
Y</CODE>
 form an orthonormal set, i.e. <CODE>
Y = A x X</CODE>
.</LI>
<LI>
<A NAME="50487361_pgfId-287896"></A><CODE>
a</CODE>
 is the cone half angle.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-287930"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-17.gif">

<P>
<A NAME="50487361_pgfId-22299971"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<ADDRESS>
<A NAME="50487361_pgfId-22299970"></A>Note: At the PK interface, the cone axis is in the opposite direction to that stored in the XT data.</ADDRESS><BR>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287974"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287933"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287935"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287937"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287939"></A><CODE>
pvec</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287941"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287943"></A>point on the cone axis</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287945"></A><CODE>
axis</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287947"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287949"></A>direction of the cone axis (a unit vector)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287951"></A><CODE>
radius</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287953"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287955"></A>radius of the cone at its pvec</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287957"></A><CODE>
sin_half_angle</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287959"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287961"></A>sine of the cone’s half angle</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287963"></A><CODE>
cos_half_angle</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287965"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287967"></A>cosine of the cone’s half angle</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287969"></A><CODE>
x_axis</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287971"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-287973"></A>X axis of the cone (a unit vector)</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-287975"></A>The <CODE>
Y</CODE>
 axis in the definition above is the vector cross product of the axis and <CODE>
x_axis</CODE>
.</P>
<P>
<A NAME="50487361_pgfId-287995"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-287978"></A>struct CONE_s == ANY_SURF_s       //Cone</PRE>
<PRE><A NAME="50487361_pgfId-1875674"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1875675"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1875676"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875677"></A>    union  SURFACE_OWNER_u        owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875678"></A>    union  SURFACE_u              next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875679"></A>    union  SURFACE_u              previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875680"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875681"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-481363"></A>    vector                        pvec;                // $v</PRE>
<PRE><A NAME="50487361_pgfId-481372"></A>    vector                        axis;                // $v</PRE>
<PRE><A NAME="50487361_pgfId-481381"></A>    double                        radius;              // $f</PRE>
<PRE><A NAME="50487361_pgfId-481390"></A>    double                        sin_half_angle;      // $f</PRE>
<PRE><A NAME="50487361_pgfId-481399"></A>    double                        cos_half_angle;      // $f</PRE>
<PRE><A NAME="50487361_pgfId-481408"></A>    vector                        x_axis;              // $v</PRE>
<PRE><A NAME="50487361_pgfId-481417"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-481426"></A>typedef struct CONE_s *CONE;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-287996"></A>5.2.2.4 Sphere</H4>
<P>
<A NAME="50487361_pgfId-287997"></A>A sphere has a parametric representation of the form:</P>
<P>
<A NAME="50487361_pgfId-287998"></A><CODE>
R(u, v) = C + (Xcos(u) + Ysin(u)) rcos(v) + rAsin(v)</CODE>
</P>
<P>
<A NAME="50487361_pgfId-287999"></A>Where:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-288000"></A><CODE>
C</CODE>
 is centre of the sphere.</LI>
<LI>
<A NAME="50487361_pgfId-288001"></A><CODE>
r</CODE>
 is the sphere radius.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-288035"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-18.gif">

<UL>
<LI>
<A NAME="50487361_pgfId-288036"></A><CODE>
A</CODE>
, <CODE>
X</CODE>
 and <CODE>
Y</CODE>
 form an orthonormal axis set.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-288068"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288039"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288041"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288043"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288045"></A><CODE>
centre</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288047"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288049"></A>centre of the sphere</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288051"></A><CODE>
radius</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288053"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288055"></A>radius of the sphere</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288057"></A><CODE>
axis</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288059"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288061"></A>A axis of the sphere (a unit vector)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288063"></A><CODE>
x_axis</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288065"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288067"></A>X axis of the sphere (a unit vector)</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288069"></A>The <CODE>
Y</CODE>
 axis of the sphere is the vector cross product of its <CODE>
A</CODE>
 and <CODE>
X</CODE>
 axes.</P>
<P>
<A NAME="50487361_pgfId-288087"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288072"></A>struct SPHERE_s == ANY_SURF_s     //Sphere</PRE>
<PRE><A NAME="50487361_pgfId-1875696"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1875697"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1875698"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875699"></A>    union  SURFACE_OWNER_u        owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875700"></A>    union  SURFACE_u              next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875701"></A>    union  SURFACE_u              previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875702"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875703"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-481498"></A>    vector                        centre;              // $v</PRE>
<PRE><A NAME="50487361_pgfId-481506"></A>    double                        radius;              // $f</PRE>
<PRE><A NAME="50487361_pgfId-481514"></A>    vector                        axis;                // $v</PRE>
<PRE><A NAME="50487361_pgfId-481522"></A>    vector                        x_axis;              // $v</PRE>
<PRE><A NAME="50487361_pgfId-481530"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-481538"></A>typedef struct SPHERE_s *SPHERE;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-288088"></A>5.2.2.5 Torus</H4>
<P>
<A NAME="50487361_pgfId-288089"></A>A torus has a parametric representation of the form</P>
<P>
<A NAME="50487361_pgfId-288090"></A><CODE>
R(u, v) = C + (X cos(u) + Y sin(u))(a + b cos(v)) + b A sin(v)</CODE>
</P>
<P>
<A NAME="50487361_pgfId-288091"></A>Where:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-288092"></A><CODE>
C</CODE>
 is centre of the torus.</LI>
<LI>
<A NAME="50487361_pgfId-288093"></A><CODE>
A</CODE>
 is the torus axis.</LI>
<LI>
<A NAME="50487361_pgfId-288094"></A><CODE>
a</CODE>
 is the major radius.</LI>
<LI>
<A NAME="50487361_pgfId-288095"></A><CODE>
b</CODE>
 is the minor radius.</LI>
<LI>
<A NAME="50487361_pgfId-288096"></A><CODE>
X</CODE>
 and <CODE>
Y</CODE>
 are unit vectors such that <CODE>
A</CODE>
, <CODE>
X</CODE>
 and <CODE>
Y</CODE>
 form an orthonormal set.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-288097"></A>In XT, there are three types of torus:</P>
<P>
<A NAME="50487361_pgfId-288098"></A><EM>
Doughnut</EM> - the torus is not self-intersecting (<CODE>
a &gt; b</CODE>
)</P>
<P>
<A NAME="50487361_pgfId-288099"></A><EM>
Apple</EM> - the outer part of a self-intersecting torus (<CODE>
a &lt;= b, a &gt; 0</CODE>
)</P>
<P>
<A NAME="50487361_pgfId-288100"></A><EM>
Lemon</EM> - the inner part of a self-intersecting torus (<CODE>
a &lt; 0, |a| &lt; b</CODE>
)</P>
<P>
<A NAME="50487361_pgfId-288101"></A>The limiting case <CODE>
a = b</CODE>
 is allowed; it is called an ‘osculating apple’, but there is no ‘lemon’ surface corresponding to this case.</P>
<P>
<A NAME="50487361_pgfId-288102"></A>The limiting case <CODE>
a = 0</CODE>
 cannot be represented as a torus; this must be represented as a sphere.</P>
<P>
<A NAME="50487361_pgfId-288140"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288105"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288107"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288109"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288111"></A><CODE>
centre</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288113"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288115"></A>centre of the torus</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288117"></A><CODE>
axis</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288119"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288121"></A>axis of the torus (a unit vector)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288123"></A><CODE>
major_radius</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288125"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288127"></A>major radius</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288129"></A><CODE>
minor_radius</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288131"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288133"></A>minor radius</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288135"></A><CODE>
x_axis</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288137"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288139"></A>X axis of the torus (a unit vector)</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288141"></A>The <CODE>
Y</CODE>
 axis in the definition above is the vector cross product of the axis of the torus and the <CODE>
x_axis</CODE>
.</P>
<P>
<A NAME="50487361_pgfId-288160"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288144"></A>struct TORUS_s == ANY_SURF_s      //Torus</PRE>
<PRE><A NAME="50487361_pgfId-1875718"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1875719"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1875720"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875721"></A>    union  SURFACE_OWNER_u        owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875722"></A>    union  SURFACE_u              next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875723"></A>    union  SURFACE_u              previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875724"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875725"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-481621"></A>    vector                        centre;              // $v</PRE>
<PRE><A NAME="50487361_pgfId-481630"></A>    vector                        axis;                // $v</PRE>
<PRE><A NAME="50487361_pgfId-481639"></A>    double                        major_radius;        // $f</PRE>
<PRE><A NAME="50487361_pgfId-481648"></A>    double                        minor_radius;        // $f</PRE>
<PRE><A NAME="50487361_pgfId-430210"></A>    vector                        x_axis;              // $v</PRE>
<PRE><A NAME="50487361_pgfId-481657"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-481666"></A>typedef struct TORUS_s *TORUS;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-288166"></A>5.2.2.6 Blended_edge (Rolling ball blend)</H4>
<P>
<A NAME="50487361_pgfId-288167"></A>XT supports exact rolling ball blends. They have a parametric representation of the form</P>
<P>
<A NAME="50487361_pgfId-288168"></A><CODE>
R(u, v) = C(u) + rX(u)cos(v a(u)) + rY(u)sin(va(u))</CODE>
</P>
<P>
<A NAME="50487361_pgfId-288169"></A>Where:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-288170"></A><CODE>
C(u)</CODE>
 is the spine curve</LI>
<LI>
<A NAME="50487361_pgfId-288171"></A><CODE>
r</CODE>
 is the blend radius</LI>
<LI>
<A NAME="50487361_pgfId-288172"></A><CODE>
X(u)</CODE>
 and <CODE>
Y(u)</CODE>
 are unit vectors such that <CODE>
C’(u). X(u) = C’(u). Y(u) = 0</CODE>
</LI>
<LI>
<A NAME="50487361_pgfId-288173"></A><CODE>
a(u)</CODE>
 is the angle subtended by points on the boundary curves at the spine</LI>
</UL>
<P>
<A NAME="50487361_pgfId-431316"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-19.gif">

<P>
<A NAME="50487361_pgfId-288205"></A><CODE>
X</CODE>
 and <CODE>
Y</CODE>
 are expressed as functions of <CODE>
u</CODE>
, as their values change with <CODE>
u</CODE>
.</P>
<P>
<A NAME="50487361_pgfId-288206"></A>The spine of the rolling ball blend is the center line of the blend; i.e. the path along which the center of the ball moves.</P>
<P>
<A NAME="50487361_pgfId-288262"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288209"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288211"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288213"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288215"></A><CODE>
type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288217"></A>char</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288219"></A>type of blend: ‘R’ or ‘E’</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288221"></A><CODE>
surface</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288223"></A>pointer[2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288225"></A>supporting surfaces (adjacent to original edge)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288227"></A><CODE>
spine</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288229"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288231"></A>spine of blend</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288233"></A><CODE>
range</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288235"></A>double[2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288237"></A>offsets to be applied to surfaces</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288239"></A><CODE>
thumb_weight</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288241"></A>double[2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288243"></A>always [1,1]</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288245"></A><CODE>
boundary</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288247"></A>pointer0[2]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288249"></A>always [0, 0]</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288251"></A><CODE>
start</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288253"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288255"></A>Start LIMIT in certain degenerate cases</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288257"></A><CODE>
end</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288259"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288261"></A>End LIMIT in certain degenerate cases</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288284"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288265"></A>struct BLENDED_EDGE_s == ANY_SURF_s  //Blended edge</PRE>
<PRE><A NAME="50487361_pgfId-1875739"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1875740"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1875741"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875742"></A>    union  SURFACE_OWNER_u        owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875743"></A>    union  SURFACE_u              next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875744"></A>    union  SURFACE_u              previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875745"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875746"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-481738"></A>    char                          blend_type;          // $c</PRE>
<PRE><A NAME="50487361_pgfId-481746"></A>    union  SURFACE_u              surface[2];          // $p[2]</PRE>
<PRE><A NAME="50487361_pgfId-481754"></A>    union  CURVE_u                spine;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-481762"></A>    double                        range[2];            // $f[2]</PRE>
<PRE><A NAME="50487361_pgfId-481770"></A>    double                        thumb_weight[2];     // $f[2]</PRE>
<PRE><A NAME="50487361_pgfId-481778"></A>    union  SURFACE_u              boundary[2];         // $p[2]</PRE>
<PRE><A NAME="50487361_pgfId-481786"></A>    struct LIMIT_s               *start;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-481794"></A>    struct LIMIT_s               *end;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-481802"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-481810"></A>typedef struct BLENDED_EDGE_s *BLENDED_EDGE;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288285"></A>The parameterisation of the blend is as follows. The <CODE>
u</CODE>
 parameter is inherited from the spine, the constant <CODE>
u</CODE>
 lines being circles perpendicular to the spine curve. The <CODE>
v</CODE>
 parameter is zero at the blend boundary on the first surface, and one on the blend boundary on the second surface; unless the sense of the spine curve is negative, in which case it is the other way round. The <CODE>
v</CODE>
 parameter is proportional to the angle around the circle.</P>
<P>
<A NAME="50487361_pgfId-288286"></A>XT data can contain blends of the following types:</P>
<P>
<A NAME="50487361_pgfId-288291"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288289"></A>    const char SCH_rolling_ball = &acute;R&acute;;   // rolling ball blend</PRE>
<PRE><A NAME="50487361_pgfId-288290"></A>    const char SCH_cliff_edge =   &acute;E&acute;;   // cliff edge blend</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288292"></A>For rolling ball blends, the spine curve will be the intersection of the two surfaces obtained by offsetting the supporting surfaces by an amount given by the respective entry in <CODE>
range[]</CODE>
. Note that the offsets to be applied may be positive or negative, and that the sense of the surface is significant; i.e. the offset vector is the natural unit surface normal, times the range, times -1 if the sense is negative.</P>
<P>
<A NAME="50487361_pgfId-288293"></A>For cliff edge blends, one of the surfaces will be a <CODE>
blended_edge</CODE>
 with a range of [0,0]; its spine will be the cliff edge curve, and its supporting surfaces will be the surfaces of the faces adjacent to the cliff edge. Its type will be <CODE>
R</CODE>
.</P>
<P>
<A NAME="50487361_pgfId-288294"></A>The limit fields will only be non-null if the spine curve is periodic but the edge curve being blended has terminators - for example if the spine is elliptical but the blend degenerates. In this case the two LIMIT nodes, of type ‘L’, determine the extent of the spine.</P>


<H4>
<A NAME="50487361_pgfId-288295"></A>5.2.2.7 Blend_bound (Blend boundary surface)</H4>
<P>
<A NAME="50487361_pgfId-288296"></A>A <CODE>
blend_bound</CODE>
 surface is a construction surface, used to define the boundary curve where a blend becomes tangential to its supporting surface. It is an implicit surface defined internally so that it intersects one of the supporting surfaces along the boundary curve. It is orthogonal to the blend and the supporting surface along this boundary curve. The supporting surface corresponding to the <CODE>
blend_bound</CODE>
 is</P>
<P>
<A NAME="50487361_pgfId-17673892"></A><CODE>
Blend_bound -&gt; blend.blended_edge -&gt; surface[1-blend_bound-&gt;boundary]</CODE>
</P>
<P>
<A NAME="50487361_pgfId-288298"></A>Blend boundary surfaces have no parameterisation, but are defined by the distance function</P>
<P>
<A NAME="50487361_pgfId-17673902"></A><CODE>
f(X) = f0 (X + r1 * grad_f1 (X)) - r0</CODE>
</P>
<P>
<A NAME="50487361_pgfId-288300"></A>Where:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-288301"></A><CODE>
f0</CODE>
 is the surface distance function of the supporting surface corresponding to the <CODE>
blend_bound</CODE>
</LI>
<LI>
<A NAME="50487361_pgfId-288302"></A><CODE>
r0</CODE>
 is the blend radius corresponding to that supporting surface</LI>
<LI>
<A NAME="50487361_pgfId-288303"></A><CODE>
f1</CODE>
 is the surface distance function of the other supporting surface of the blend</LI>
<LI>
<A NAME="50487361_pgfId-288304"></A><CODE>
r1</CODE>
 is the blend radius corresponding to the other supporting surface</LI>
</UL>
<P>
<A NAME="50487361_pgfId-288305"></A>Blend boundary surfaces are most commonly referenced by the intersection curve representing the boundary curve of the blend.</P>
<P>
<A NAME="50487361_pgfId-288306"></A>The data stored in the XT data for a <CODE>
blend_bound</CODE>
 is only that necessary to identify the relevant blend and supporting surface:</P>
<P>
<A NAME="50487361_pgfId-288326"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288309"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288311"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288313"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288315"></A><CODE>
boundary</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288317"></A>short</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288319"></A>index into supporting surface array</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288321"></A><CODE>
blend</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288323"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288325"></A>corresponding blend surface</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288342"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288329"></A>struct BLEND_BOUND_s == ANY_SURF_s  //Blend boundary</PRE>
<PRE><A NAME="50487361_pgfId-1875758"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1875759"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1875760"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875761"></A>    union  SURFACE_OWNER_u        owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875762"></A>    union  SURFACE_u              next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875763"></A>    union  SURFACE_u              previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875764"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875765"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-481882"></A>    short                         boundary;            // $n</PRE>
<PRE><A NAME="50487361_pgfId-481890"></A>    union  SURFACE_u              blend;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-481898"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-481906"></A>typedef struct BLEND_BOUND_s *BLEND_BOUND;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22221091"></A>The supporting surface corresponding to the <CODE>
blend_bound</CODE>
 is</P>
<P>
<A NAME="50487361_pgfId-22329971"></A><CODE>
Blend_bound -&gt; blend.blended_edge -&gt; surface[1-blend_bound-&gt;boundary]</CODE>
</P>


<H4>
<A NAME="50487361_pgfId-288343"></A>5.2.2.8 Offset_surf</H4>
<P>
<A NAME="50487361_pgfId-288344"></A>An offset surface is the result of offsetting a surface a certain distance along its normal, taking into account the surface sense. It inherits the parameterisation of this underlying surface.</P>
<P>
<A NAME="50487361_pgfId-288382"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288347"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288349"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288351"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288353"></A><CODE>
check</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288355"></A>char</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288357"></A>check status</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288359"></A><CODE>
true_offset</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288361"></A>logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288363"></A>not used</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288365"></A><CODE>
surface</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288367"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288369"></A>underlying surface</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288371"></A><CODE>
offset</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288373"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288375"></A>signed offset distance</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288377"></A><CODE>
scale</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288379"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288381"></A>for internal use only - may be set to null</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288401"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288385"></A>struct OFFSET_SURF_s == ANY_SURF_s  //Offset surface</PRE>
<PRE><A NAME="50487361_pgfId-1875777"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1875778"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1875779"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875780"></A>    union  SURFACE_OWNER_u        owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875781"></A>    union  SURFACE_u              next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875782"></A>    union  SURFACE_u              previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875783"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875784"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-481978"></A>    char                          check;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-481986"></A>    logical                       true_offset;         // $l</PRE>
<PRE><A NAME="50487361_pgfId-481994"></A>    union  SURFACE_u              surface;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-482002"></A>    double                        offset;              // $f</PRE>
<PRE><A NAME="50487361_pgfId-482010"></A>    double                        scale;               // $f</PRE>
<PRE><A NAME="50487361_pgfId-482018"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-482026"></A>typedef struct OFFSET_SURF_s *OFFSET_SURF;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288402"></A>The offset surface is subject to the following restrictions:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-288403"></A>The offset distance shall not be within modeller linear resolution of zero</LI>
<LI>
<A NAME="50487361_pgfId-288404"></A>The sense of the offset surface shall be the same as that of the underlying surface</LI>
<LI>
<A NAME="50487361_pgfId-288405"></A>Offset surfaces may not share a common underlying surface</LI>
</UL>
<P>
<A NAME="50487361_pgfId-288406"></A>The ‘check’ field may take one of the following values:</P>
<P>
<A NAME="50487361_pgfId-288412"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288409"></A>    const char SCH_valid      = &acute;V&acute;;    // valid</PRE>
<PRE><A NAME="50487361_pgfId-288410"></A>    const char SCH_invalid    = &acute;I&acute;;    // invalid</PRE>
<PRE><A NAME="50487361_pgfId-288411"></A>    const char SCH_unchecked  = &acute;U&acute;;    // has not been checked</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-288413"></A>5.2.2.9 B_surface</H4>
<P>
<A NAME="50487361_pgfId-288414"></A>XT supports B-spline surfaces in full NURBS format.</P>
<P>
<A NAME="50487361_pgfId-22194529"></A>B-SURFACE DEFINITION</P>
<P>
<A NAME="50487361_pgfId-466186"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-20.gif">

<P>
<A NAME="50487361_pgfId-466187"></A>The B-surface definition is best thought of as an extension of the B-curve definition into two parameters, usually called <CODE>
u</CODE>
 and <CODE>
v</CODE>
. Two knot sets are required and the number of control vertices is the product of the number that would be required for a curve using each knot vector. The rules for periodicity and closure given above for curves are extended to surfaces in an obvious way.</P>
<P>
<A NAME="50487361_pgfId-466188"></A>For attachment to topology a B-surface is required to have G1 continuity. That is to say that the surface normal direction shall be continuous.</P>
<P>
<A NAME="50487361_pgfId-466189"></A>XT does not support modelling with surfaces that are self-intersecting or contain cusps. Although they can be created they are not permitted to be attached to topology.</P>
<P>
<A NAME="50487361_pgfId-466209"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-466192"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-466194"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-466196"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-466198"></A><CODE>
nurbs</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-466200"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-466202"></A>Geometric definition</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-466204"></A><CODE>
data</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-466206"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-466208"></A>Auxiliary information</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288450"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288437"></A>struct B_SURFACE_s == ANY_SURF_s  //B surface</PRE>
<PRE><A NAME="50487361_pgfId-1875804"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1875805"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1875806"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875807"></A>    union  SURFACE_OWNER_u        owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875808"></A>    union  SURFACE_u              next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875809"></A>    union  SURFACE_u              previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875810"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875811"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-433074"></A>    struct NURBS_SURF_s          *nurbs;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-482082"></A>    struct SURFACE_DATA_s        *data;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-482090"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-482098"></A>typedef struct B_SURFACE_s *B_SURFACE;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-433135"></A>The data stored in the XT data for a NURBS surface is:</P>
<P>
<A NAME="50487361_pgfId-433263"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433138"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433140"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433142"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433144"></A><CODE>
u_periodic</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433146"></A>logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433148"></A>true if surface is periodic in u parameter</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433150"></A><CODE>
v_periodic</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433152"></A>logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433154"></A>true if surface is periodic in v parameter</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433156"></A><CODE>
u_degree</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433158"></A>short</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433160"></A>u degree of the surface</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433162"></A><CODE>
v_degree</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433164"></A>short</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433166"></A>v degree of the surface</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433168"></A><CODE>
n_u_vertices</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433170"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433172"></A>number of control vertices (‘poles’) in u direction</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433174"></A><CODE>
n_v_vertices</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433176"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433178"></A>number of control vertices (‘poles’) in v direction</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433180"></A><CODE>
u_knot_type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433182"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433184"></A>form of u knot vector - see “B-curve”</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433186"></A><CODE>
v_knot_type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433188"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433190"></A>form of v knot vector</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433192"></A><CODE>
n_u_knots</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433194"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433196"></A>number of distinct u knots</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433198"></A><CODE>
n_v_knots</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433200"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433202"></A>number of distinct v knots</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433204"></A><CODE>
rational</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433206"></A>logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433208"></A>true if surface is rational</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433210"></A><CODE>
u_closed</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433212"></A>logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433214"></A>true if surface is closed in u</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433216"></A><CODE>
v_closed</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433218"></A>logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433220"></A>true if surface is closed in v</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433222"></A><CODE>
surface_form</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433224"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433226"></A>shape of surface, if special</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433228"></A><CODE>
vertex_dim</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433230"></A>short</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433232"></A>dimension of control vertices</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433234"></A><CODE>
bspline_vertices</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433236"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433238"></A>control vertices (poles) node</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433240"></A><CODE>
u_knot_mult</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433242"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433244"></A>multiplicities of u knot vector</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433246"></A><CODE>
v_knot_mult</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433248"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433250"></A>multiplicities of v knot vector</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433252"></A><CODE>
u_knots</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433254"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433256"></A>u knot vector</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433258"></A><CODE>
v_knots</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433260"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-433262"></A>v knot vector</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-433264"></A>The surface form enum is defined below.</P>
<P>
<A NAME="50487361_pgfId-288598"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288583"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-482106"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-482114"></A>    SCH_unset              = 1,          //Unknown</PRE>
<PRE><A NAME="50487361_pgfId-482122"></A>    SCH_arbitrary          = 2,          //No particular shape</PRE>
<PRE><A NAME="50487361_pgfId-482130"></A>    SCH_planar             = 3,</PRE>
<PRE><A NAME="50487361_pgfId-482138"></A>    SCH_cylindrical        = 4,</PRE>
<PRE><A NAME="50487361_pgfId-482146"></A>    SCH_conical            = 5,</PRE>
<PRE><A NAME="50487361_pgfId-482154"></A>    SCH_spherical          = 6,</PRE>
<PRE><A NAME="50487361_pgfId-482162"></A>    SCH_toroidal           = 7,</PRE>
<PRE><A NAME="50487361_pgfId-482170"></A>    SCH_surf_of_revolution = 8,</PRE>
<PRE><A NAME="50487361_pgfId-482178"></A>    SCH_ruled              = 9,</PRE>
<PRE><A NAME="50487361_pgfId-482186"></A>    SCH_quadric            = 10,</PRE>
<PRE><A NAME="50487361_pgfId-482194"></A>    SCH_swept              = 11</PRE>
<PRE><A NAME="50487361_pgfId-482202"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-482210"></A>    SCH_surface_form_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288625"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-433333"></A>struct NURBS_SURF_s               //NURBS surface</PRE>
<PRE><A NAME="50487361_pgfId-482218"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-482226"></A>    logical                       u_periodic;           // $l</PRE>
<PRE><A NAME="50487361_pgfId-482234"></A>    logical                       v_periodic;           // $l</PRE>
<PRE><A NAME="50487361_pgfId-482242"></A>    short                         u_degree;             // $n</PRE>
<PRE><A NAME="50487361_pgfId-482250"></A>    short                         v_degree;             // $n</PRE>
<PRE><A NAME="50487361_pgfId-482258"></A>    int                           n_u_vertices;         // $d</PRE>
<PRE><A NAME="50487361_pgfId-482266"></A>    int                           n_v_vertices;         // $d</PRE>
<PRE><A NAME="50487361_pgfId-482274"></A>    SCH_knot_type_t               u_knot_type;          // $u</PRE>
<PRE><A NAME="50487361_pgfId-482282"></A>    SCH_knot_type_t               v_knot_type;          // $u</PRE>
<PRE><A NAME="50487361_pgfId-482290"></A>    int                           n_u_knots;            // $d</PRE>
<PRE><A NAME="50487361_pgfId-482298"></A>    int                           n_v_knots;            // $d</PRE>
<PRE><A NAME="50487361_pgfId-482306"></A>    logical                       rational;             // $l</PRE>
<PRE><A NAME="50487361_pgfId-482314"></A>    logical                       u_closed;             // $l</PRE>
<PRE><A NAME="50487361_pgfId-482322"></A>    logical                       v_closed;             // $l</PRE>
<PRE><A NAME="50487361_pgfId-482330"></A>    SCH_surface_form_t            surface_form;         // $u</PRE>
<PRE><A NAME="50487361_pgfId-482338"></A>    short                         vertex_dim;           // $n</PRE>
<PRE><A NAME="50487361_pgfId-482346"></A>    struct BSPLINE_VERTICES_s    *bspline_vertices;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-482354"></A>    struct KNOT_MULT_s           *u_knot_mult;          // $p</PRE>
<PRE><A NAME="50487361_pgfId-482362"></A>    struct KNOT_MULT_s           *v_knot_mult;          // $p</PRE>
<PRE><A NAME="50487361_pgfId-482370"></A>    struct KNOT_SET_s            *u_knots;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-482378"></A>    struct KNOT_SET_s            *v_knots;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-482386"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-482394"></A>typedef struct NURBS_SURF_s *NURBS_SURF;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288626"></A>The <CODE>
bspline_vertices</CODE>
, <CODE>
knot_set</CODE>
 and <CODE>
knot_mult</CODE>
 nodes and the <CODE>
knot_type</CODE>
 enum are described in the documentation for BCURVE.</P>
<P>
<A NAME="50487361_pgfId-288627"></A>The ‘surface data’ field in a B-surface node is a structure designed to hold auxiliary or ‘derived’ data about the surface: it is not a necessary part of the definition of the B-surface. It may be null, or the majority of its individual fields may be null. It is recommended that it only be set by Parasolid.</P>
<P>
<A NAME="50487361_pgfId-288655"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288630"></A>struct SURFACE_DATA_s         //auxiliary surface data</PRE>
<PRE><A NAME="50487361_pgfId-482402"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-482410"></A>    interval                  original_uint;            // $i</PRE>
<PRE><A NAME="50487361_pgfId-482418"></A>    interval                  original_vint;            // $i</PRE>
<PRE><A NAME="50487361_pgfId-482426"></A>    interval                  extended_uint;            // $i</PRE>
<PRE><A NAME="50487361_pgfId-482434"></A>    interval                  extended_vint;            // $i</PRE>
<PRE><A NAME="50487361_pgfId-482442"></A>    SCH_self_int_t            self_int;                 // $u</PRE>
<PRE><A NAME="50487361_pgfId-482450"></A>    char                      original_u_start;         // $c</PRE>
<PRE><A NAME="50487361_pgfId-482458"></A>    char                      original_u_end;           // $c</PRE>
<PRE><A NAME="50487361_pgfId-482466"></A>    char                      original_v_start;         // $c</PRE>
<PRE><A NAME="50487361_pgfId-482474"></A>    char                      original_v_end;           // $c</PRE>
<PRE><A NAME="50487361_pgfId-482482"></A>    char                      extended_u_start;         // $c</PRE>
<PRE><A NAME="50487361_pgfId-482490"></A>    char                      extended_u_end;           // $c</PRE>
<PRE><A NAME="50487361_pgfId-482498"></A>    char                      extended_v_start;         // $c</PRE>
<PRE><A NAME="50487361_pgfId-482506"></A>    char                      extended_v_end;           // $c</PRE>
<PRE><A NAME="50487361_pgfId-482514"></A>    char                      analytic_form_type;       // $c</PRE>
<PRE><A NAME="50487361_pgfId-482522"></A>    char                      swept_form_type;          // $c</PRE>
<PRE><A NAME="50487361_pgfId-482530"></A>    char                      spun_form_type;           // $c</PRE>
<PRE><A NAME="50487361_pgfId-482538"></A>    char                      blend_form_type;          // $c</PRE>
<PRE><A NAME="50487361_pgfId-482546"></A>    void                     *analytic_form;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-482554"></A>    void                     *swept_form;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-482562"></A>    void                     *spun_form;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-482570"></A>    void                     *blend_form;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-482578"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-482586"></A>typedef struct SURFACE_DATA_s *SURFACE_DATA;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288656"></A>The ‘original_’ and ‘extended_’ parameter intervals and corresponding character fields <CODE>
original_u_start</CODE>
 etc. are all connected with XT’s ability to extend B-surfaces when necessary - functionality which is commonly exploited in “local operation” algorithms for example. This is done automatically without the need for user intervention.</P>
<P>
<A NAME="50487361_pgfId-433641"></A>In cases where the required extension can be performed by adding rows or columns of control points, then the nurbs data will be modified accordingly - this is referred to as an ‘explicit’ extension. In some rational B-surface cases, explicit extension is not possible - in these cases, the surface will be ‘implicitly’ extended. When a B-surface is implicitly extended, the nurbs data is not changed, but it will be treated as being larger by allowing out-of-range evaluations on the surface. Whenever an explicit or implicit extension takes place, it is reflected in the following fields:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-433642"></A><CODE>
original_u_int</CODE>
 and <CODE>
original_v_int</CODE>
 are the original valid parameter ranges for a B-surface before it was extended</LI>
<LI>
<A NAME="50487361_pgfId-288659"></A><CODE>
extended_u_int</CODE>
 and <CODE>
extended_v_int</CODE>
 are the valid parameter ranges for a B-surface once it has been extended.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-288660"></A>The character fields <CODE>
original_u_start</CODE>
 etc. all refer to the status of the corresponding parameter boundary of the surface before or after an extension has taken place. For B-surfaces, the character can have one of the following values:</P>
<P>
<A NAME="50487361_pgfId-288667"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288663"></A>const char SCH_degenerate = &acute;D&acute;;    //Degenerate edge</PRE>
<PRE><A NAME="50487361_pgfId-288664"></A>const char SCH_periodic   = &acute;P&acute;;    //Periodic parameterization</PRE>
<PRE><A NAME="50487361_pgfId-288665"></A>const char SCH_bounded    = &acute;B&acute;;    //Parameterization bounded</PRE>
<PRE><A NAME="50487361_pgfId-288666"></A>const char SCH_closed     = &acute;C&acute;;    //Closed, but not periodic</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288668"></A>The separate fields <CODE>
original_u_start</CODE>
 and <CODE>
extended_u_start</CODE>
 etc. are necessary because an extension may cause the corresponding parameter boundary to become degenerate.</P>
<P>
<A NAME="50487361_pgfId-288669"></A>If the <CODE>
surface_data</CODE>
 node is present, then the <CODE>
original_u_int</CODE>
, <CODE>
original_v_int</CODE>
, <CODE>
original_u_start</CODE>
, <CODE>
original_u_end</CODE>
, <CODE>
original_v_start</CODE>
 and <CODE>
original_v_end</CODE>
 fields should be set to their appropriate values. If the surface has not been extended, the <CODE>
extended_u_int</CODE>
 and <CODE>
extended_v_int</CODE>
 fields should contain null, and the <CODE>
extended_u_start</CODE>
 etc. Fields should contain:</P>
<P>
<A NAME="50487361_pgfId-288670"></A><CODE>
const char SCH_unset_char = '?'; //generic uninvestigated value</CODE>
</P>
<P>
<A NAME="50487361_pgfId-288671"></A>As soon as any parameter boundary of the surface is extended, all the fields should be set, regardless of whether the corresponding boundary has been affected by the extension.</P>
<P>
<A NAME="50487361_pgfId-288672"></A>The <CODE>
SCH_self_int_t</CODE>
 enum is documented in the corresponding <CODE>
curve_data</CODE>
 structure under B-curve.</P>
<P>
<A NAME="50487361_pgfId-288673"></A>The <CODE>
swept_form_type</CODE>
, <CODE>
spun_form_type</CODE>
 and <CODE>
blend_form_type</CODE>
 characters and the corresponding pointers <CODE>
swept_form</CODE>
, <CODE>
spun_form</CODE>
 and <CODE>
blend_form</CODE>
, are for future use and are not implemented in Parasolid . The character fields should be set to <CODE>
SCH_unset_char (‘?’)</CODE>
 and the pointers should be set to null pointer.</P>
<P>
<A NAME="50487361_pgfId-288674"></A>If the <CODE>
analytic_form</CODE>
 field is not null, it will point to a <CODE>
HELIX_SU_FORM</CODE>
 node, which indicates that the surface has a helical shape. In this case the <CODE>
analytic_form_type</CODE>
 field will be set to ‘H’.</P>
<P>
<A NAME="50487361_pgfId-288688"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288677"></A>struct HELIX_SU_FORM_s</PRE>
<PRE><A NAME="50487361_pgfId-482594"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-482602"></A>    vector                  axis_pt;                     // $v</PRE>
<PRE><A NAME="50487361_pgfId-482610"></A>    vector                  axis_dir;                    // $v</PRE>
<PRE><A NAME="50487361_pgfId-482618"></A>    char                    hand;                        // $c</PRE>
<PRE><A NAME="50487361_pgfId-482626"></A>    interval                turns;                       // $i</PRE>
<PRE><A NAME="50487361_pgfId-482634"></A>    double                  pitch;                       // $f</PRE>
<PRE><A NAME="50487361_pgfId-482642"></A>    double                  gap;                         // $f</PRE>
<PRE><A NAME="50487361_pgfId-482650"></A>    double                  tol;                         // $f</PRE>
<PRE><A NAME="50487361_pgfId-482658"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-482666"></A>typedef struct HELIX_SU_FORM_s *HELIX_SU_FORM;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288689"></A>The <CODE>
axis_pt</CODE>
 and <CODE>
axis_dir</CODE>
 fields define the axis of the helix. The hand field is ‘+’ for a right-handed and ‘-’ for a left-handed helix. The turns field gives the extent of the helix relative to the profile curve which was used to generate the surface. For instance, an interval [0 10] indicates a start position at the profile curve and an end 10 turns along the axis. Pitch is the distance travelled along the axis in one turn. Tol is the accuracy to which the owning <CODE>
bsurface</CODE>
 fits this specification. Gap is for future expansion and will currently be zero. The <CODE>
v</CODE>
 parameter increases in the direction of the axis.</P>


<H4>
<A NAME="50487361_pgfId-288690"></A>5.2.2.10 Swept_surf</H4>
<P>
<A NAME="50487361_pgfId-288691"></A>A swept surface has a parametric representation of the form:</P>
<P>
<A NAME="50487361_pgfId-288692"></A><CODE>
R(u, v) = C(u) + vD</CODE>
</P>
<P>
<A NAME="50487361_pgfId-288693"></A>Where:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-433709"></A><CODE>
C(u)</CODE>
 is the section curve.</LI>
<LI>
<A NAME="50487361_pgfId-433710"></A><CODE>
D</CODE>
 is the sweep direction (unit vector).</LI>
<LI>
<A NAME="50487361_pgfId-433738"></A><CODE>
C</CODE>
 shall not be an intersection curve, a trimmed curve, an SP-curve or a PE-curve/foreign curve. It must be analytic or a B-curve.</LI>
<LI>
<A NAME="50487361_pgfId-22230198"></A>The swept surface inherits its <CODE>
u</CODE>
 parameterisation from the section curve.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-433724"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-21.gif">

<P>
<A NAME="50487361_pgfId-288756"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288733"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288735"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288737"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288739"></A><CODE>
section</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288741"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288743"></A>section curve</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288745"></A><CODE>
sweep</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288747"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288749"></A>swept direction (a unit vector)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288751"></A><CODE>
scale</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288753"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288755"></A>for internal use only - may be set to null</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288773"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288759"></A>struct SWEPT_SURF_s == ANY_SURF_s  //Swept surface</PRE>
<PRE><A NAME="50487361_pgfId-1875827"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1875828"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1875829"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875830"></A>    union  SURFACE_OWNER_u        owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875831"></A>    union  SURFACE_u              next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875832"></A>    union  SURFACE_u              previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875833"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875834"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-482749"></A>    union  CURVE_u                section;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-482758"></A>    vector                        sweep;               // $v</PRE>
<PRE><A NAME="50487361_pgfId-433802"></A>    double                        scale;               // $f</PRE>
<PRE><A NAME="50487361_pgfId-482767"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-433810"></A>typedef struct SWEPT_SURF_s *SWEPT_SURF;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-288774"></A>5.2.2.11 Spun_surf</H4>
<P>
<A NAME="50487361_pgfId-288775"></A>A spun surface has a parametric representation of the form:</P>
<P>
<A NAME="50487361_pgfId-288776"></A><CODE>
R(u, v) = Z(u) + (C(u) - Z(u))cos(v) + A X (C(u) - Z(u)) sin(v)</CODE>
</P>
<P>
<A NAME="50487361_pgfId-288777"></A>Where:</P>
<P>
<A NAME="50487361_pgfId-288811"></A>&nbsp;</P>

<IMG SRC="../graphics/xt_chap-22.gif">

<UL>
<LI>
<A NAME="50487361_pgfId-288812"></A><CODE>
C(u)</CODE>
 is the profile curve.</LI>
<LI>
<A NAME="50487361_pgfId-288813"></A><CODE>
Z(u)</CODE>
 is the projection of <CODE>
C(u)</CODE>
 onto the spin axis.</LI>
<LI>
<A NAME="50487361_pgfId-288814"></A><CODE>
A</CODE>
 is the spin axis direction (unit vector).</LI>
<LI>
<A NAME="50487361_pgfId-3774963"></A><CODE>
C</CODE>
 shall not be an intersection curve,a trimmed curve, an SP-curve or a PE-curve/foreign curve. It must be analytic or a B-curve.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-21344332"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<ADDRESS>
<A NAME="50487361_pgfId-21344331"></A>Note: <CODE>
Z(u) = P + ((C(u) - P). A)A</CODE>
 where P is a reference point on the axis.</ADDRESS><BR>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288881"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288822"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288824"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288826"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288828"></A><CODE>
profile</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288830"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288832"></A>profile curve</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288834"></A><CODE>
base</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288836"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288838"></A>point on spin axis</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288840"></A><CODE>
axis</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288842"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288844"></A>spin axis direction (a unit vector)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288846"></A><CODE>
start</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288848"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288850"></A>position of degeneracy at low u (may be null)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288852"></A><CODE>
end</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288854"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288856"></A>position of degeneracy at low v (may be null)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288858"></A><CODE>
start_param</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288860"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288862"></A>curve parameter at low u degeneracy (may be null)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288864"></A><CODE>
end_param</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288866"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288868"></A>curve parameter at high u degeneracy (may be null)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288870"></A><CODE>
x_axis</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288872"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288874"></A>unit vector in profile plane if common with spin axis</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288876"></A><CODE>
scale</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288878"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-288880"></A>for internal use only - may be set to null</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288904"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-288884"></A>struct SPUN_SURF_s == ANY_SURF_s  //Spun surface</PRE>
<PRE><A NAME="50487361_pgfId-1875849"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-1875850"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-1875851"></A>    union  ATTRIB_FEAT_u          attributes_features; // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875852"></A>    union  SURFACE_OWNER_u        owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875853"></A>    union  SURFACE_u              next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875854"></A>    union  SURFACE_u              previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875855"></A>    struct GEOMETRIC_OWNER_s     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-1875856"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-482839"></A>    union  CURVE_u                profile;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-482847"></A>    vector                        base;                // $v</PRE>
<PRE><A NAME="50487361_pgfId-482855"></A>    vector                        axis;                // $v</PRE>
<PRE><A NAME="50487361_pgfId-482863"></A>    vector                        start;               // $v</PRE>
<PRE><A NAME="50487361_pgfId-482871"></A>    vector                        end;                 // $v</PRE>
<PRE><A NAME="50487361_pgfId-482879"></A>    double                        start_param;         // $f</PRE>
<PRE><A NAME="50487361_pgfId-434421"></A>    double                        end_param;           // $f</PRE>
<PRE><A NAME="50487361_pgfId-482887"></A>    vector                        x_axis;              // $v</PRE>
<PRE><A NAME="50487361_pgfId-482895"></A>    double                        scale;               // $f</PRE>
<PRE><A NAME="50487361_pgfId-482903"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-434595"></A>typedef struct SPUN_SURF_s *SPUN_SURF;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-288905"></A>The ‘start’ and ‘end’ vectors correspond to physical degeneracies on the spun surface caused by the profile curve crossing the spin axis at that point. The values <CODE>
start_param</CODE>
 and <CODE>
end_param</CODE>
 are the corresponding parameters on the curve. These parameter values define the valid range for the u parameter of the surface. If either value is null, then the valid range for u is infinite in that direction. For example, for a straight line profile curve intersecting the spin axis at the parameter <CODE>
t=1</CODE>
, values of null for <CODE>
start_param</CODE>
 and 1 for <CODE>
end_param</CODE>
 would define a cone with <CODE>
u</CODE>
 parameterisation(-infinity, 1].</P>
<P>
<A NAME="50487361_pgfId-288906"></A>If the profile curve lies in a plane containing the spin axis, then <CODE>
x_axis</CODE>
 shall be set to a vector perpendicular to the spin axis and in the plane of the profile, pointing from the spin axis to a point on the profile curve in the valid range. If the profile curve is not planar, or its plane does not contain the spin axis, then <CODE>
x_axis</CODE>
 should be set to null.</P>


<H4>
<A NAME="50487361_pgfId-22300255"></A>5.2.2.12 PE_surf (Foreign geometry surface)</H4>
<P>
<A NAME="50487361_pgfId-22300256"></A>Foreign (or ‘PE’) geometry in XT is a type used for representing customers’ in-house proprietary data. It can also be used internally for representing geometry connected with this data (for example, offset foreign surfaces). These two types of foreign geometry usage are referred to as ‘external’ and ‘internal’ respectively. The only internal PE-surface is the offset PE-surface.</P>
<P>
<A NAME="50487361_pgfId-22300257"></A>Applications not using foreign geometry will never encounter either external or internal PE data structures at Parasolid V9 or beyond.</P>
<P>
<A NAME="50487361_pgfId-22300292"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300263"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300265"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300267"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300269"></A><CODE>
type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300271"></A>char</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300273"></A>whether internal or external</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300275"></A><CODE>
data</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300277"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300279"></A>internal or external data</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300281"></A><CODE>
tf</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300283"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300285"></A>transform applied to geometry</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300287"></A><CODE>
internal geom</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300289"></A>pointer array</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300291"></A>reference to other related geometry</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22300310"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22300295"></A>struct PE_SURF_s == ANY_SURF_s  //PE_surface</PRE>
<PRE><A NAME="50487361_pgfId-22300296"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22300297"></A>int  node_id;  //$d</PRE>
<PRE><A NAME="50487361_pgfId-22300298"></A>union ATTRIB_FEAT_u               attributes_features;   //$p</PRE>
<PRE><A NAME="50487361_pgfId-22300299"></A>union SURFACE_OWNER_u             owner;                 //$p</PRE>
<PRE><A NAME="50487361_pgfId-22300300"></A>union SURFACE_u                   next;                  //$p</PRE>
<PRE><A NAME="50487361_pgfId-22300301"></A>union SURFACE_u                   previous;              //$p</PRE>
<PRE><A NAME="50487361_pgfId-22300302"></A>struct GEOMETRIC_OWNER_s         *geometric_owner;       //$p</PRE>
<PRE><A NAME="50487361_pgfId-22300303"></A>char                              sense;                 //$c</PRE>
<PRE><A NAME="50487361_pgfId-22300304"></A>char                              type;                  //$c</PRE>
<PRE><A NAME="50487361_pgfId-22300305"></A>union PE_DATA_u                   data;                  //$p</PRE>
<PRE><A NAME="50487361_pgfId-22300306"></A>struct TRANSFORM_s                tf;                    //$p</PRE>
<PRE><A NAME="50487361_pgfId-22300307"></A>union PE_INT_GEOM_u               internal_geom[ 1 ];    //$p[]</PRE>
<PRE><A NAME="50487361_pgfId-22300308"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-22300309"></A>typedef struct PE_SURF_s *PE_SURF;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22230338"></A>The <CODE>
PE_DATA</CODE>
 and <CODE>
PE_INT_GEOM</CODE>
 unions are defined under ‘PE-curve’.</P>



<H3>
<A NAME="50487361_pgfId-22230340"></A>	5.2.3 	<A NAME="50487361_92242"></A>Mesh Surfaces</H3>
<P>
<A NAME="50487361_pgfId-22230341"></A>Each MESH surface node references a PSM_MESH node containing facet data. Meshes cannot be shared by more than one face of a body.</P>
<P>
<A NAME="50487361_pgfId-22230385"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230344"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230346"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230348"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230350"></A><CODE>
mesh box</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230352"></A>box</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230354"></A>may contain an axis-aligned box bounding the mesh</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230356"></A><CODE>
transform</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230358"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230360"></A>transform applied</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230362"></A><CODE>
rcv_key</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230364"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230366"></A>key of XMM file containing PSM mesh data. This field is not used.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230368"></A><CODE>
rcv_index</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230370"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230372"></A>unique integer value corresponding to the index of the PSM_MESH in the POINTER_LIS_BLOCK used as the root node in the corresponding XT mesh data file, if used</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230374"></A><CODE>
psm_imesh</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230376"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230378"></A>a pointer to the PSM_MESH node when mesh data is embedded in the XT part or partition file</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230380"></A><CODE>
pff_imesh</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230382"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22301813"></A>a pointer to mesh data in the internal debug format. This is for internal use only.</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22230405"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22230388"></A>struct MESH_s == ANY_SURF_s  //Mesh</PRE>
<PRE><A NAME="50487361_pgfId-22230389"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22230390"></A>int                         node_id;              //$d</PRE>
<PRE><A NAME="50487361_pgfId-22230391"></A>union  ATTRIB_FEAT_u        attributes_features;  //$p</PRE>
<PRE><A NAME="50487361_pgfId-22230392"></A>union  SURFACE_OWNER_u      owner;                //$p</PRE>
<PRE><A NAME="50487361_pgfId-22230393"></A>union  SURFACE_u            next;                 //$p</PRE>
<PRE><A NAME="50487361_pgfId-22230394"></A>union  SURFACE_u            previous;             //$p</PRE>
<PRE><A NAME="50487361_pgfId-22230395"></A>struct GEOMETRIC_OWNER_s   *geometric_owner;      //$p</PRE>
<PRE><A NAME="50487361_pgfId-22230396"></A>char                        sense;                //$c</PRE>
<PRE><A NAME="50487361_pgfId-22230397"></A>box                         mesh_box;             //$b</PRE>
<PRE><A NAME="50487361_pgfId-22230398"></A>struct TRANSFORM_s         *transform;            //$p</PRE>
<PRE><A NAME="50487361_pgfId-22230399"></A>union  MESH_KEY_u           rcv_key;              //$p</PRE>
<PRE><A NAME="50487361_pgfId-22230400"></A>int                         rcv_index;            //$d</PRE>
<PRE><A NAME="50487361_pgfId-22230401"></A>struct PSM_MESH_s          *psm_imesh;            //$p</PRE>
<PRE><A NAME="50487361_pgfId-22230402"></A>struct PFF_MESH_s          *pff_imesh;            //$p</PRE>
<PRE><A NAME="50487361_pgfId-22230403"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-22230404"></A>typedef struct MESH_s *MESH;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22230406"></A>The <CODE>
rcv_key</CODE>
 field is not used and must always be set to null pointer.</P>
<P>
<A NAME="50487361_pgfId-22230407"></A>The PSM mesh data may be embedded in the XT part or partition file, or stored in an associated XT mesh data file. The definition of the PSM mesh data is identical in both cases. When PSM mesh data is stored in an associated XT mesh data file the <CODE>
psm_imesh</CODE>
 field must be set to null pointer.</P>

<H4>
<A NAME="50487361_pgfId-22230409"></A>5.2.3.1 <A NAME="50487361_82142"></A>PSM mesh</H4>
<P>
<A NAME="50487361_pgfId-22230410"></A>Mesh data is stored in a PSM_MESH node, which is referenced by the MESH node.</P>
<P>
<A NAME="50487361_pgfId-22230411"></A>The mesh data is described using the following fields:</P>
<P>
<A NAME="50487361_pgfId-22230473"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230414"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230416"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230418"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230420"></A><CODE>
precision</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230422"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230424"></A>number format used to store the mesh data</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230426"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230428"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230430"></A>mesh data owner</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230432"></A><CODE>
position_pool</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230434"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230439"></A>array of positions. See <A HREF="xt_chap.06.html#50487361_34336">Section 5.2.3.2</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230441"></A><CODE>
normal_pool</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230443"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230445"></A>array of directions stored in polar coordinates. See <A HREF="xt_chap.06.html#50487361_24145">Section 5.2.3.4</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230450"></A><CODE>
position_indices</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230452"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230454"></A>array of 3N indices into the position pool, where N is the number of facets. See <A HREF="xt_chap.06.html#50487361_90390">Section 5.2.3.3</A></P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230459"></A><CODE>
normal_type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230461"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230463"></A>form of mesh normals</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230465"></A><CODE>
normal_indices</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230467"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230469"></A>array of 3N indices into the normal pool, where N is the number of facets. See <A HREF="xt_chap.06.html#50487361_14989">Section 5.2.3.5</A></P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22230501"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22230476"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-22230477"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22230478"></A>SCH_mesh_normal_none       = 1,</PRE>
<PRE><A NAME="50487361_pgfId-22230479"></A>SCH_mesh_normal_per_vertex = 2,</PRE>
<PRE><A NAME="50487361_pgfId-22230480"></A>SCH_mesh_normal_per_facet  = 3</PRE>
<PRE><A NAME="50487361_pgfId-22230481"></A>}</PRE>
<PRE><A NAME="50487361_pgfId-22230482"></A>SCH_mesh_normal_type_t;</PRE>
<PRE><A NAME="50487361_pgfId-22230483"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-22230484"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-22230485"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22230486"></A>SCH_mesh_precision_double  = 1,</PRE>
<PRE><A NAME="50487361_pgfId-22230487"></A>SCH_mesh_precision_single  = 2</PRE>
<PRE><A NAME="50487361_pgfId-22230488"></A>}</PRE>
<PRE><A NAME="50487361_pgfId-22230489"></A>SCH_mesh_precision_t;</PRE>
<PRE><A NAME="50487361_pgfId-22230490"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-22230491"></A>struct PSM_MESH_s  //PSM Mesh</PRE>
<PRE><A NAME="50487361_pgfId-22230492"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22230493"></A>SCH_mesh_precision_t        precision;  //$u</PRE>
<PRE><A NAME="50487361_pgfId-22230494"></A>struct MESH_s              *owner;  //$p</PRE>
<PRE><A NAME="50487361_pgfId-22230495"></A>struct VECTOR_COMB_s       *position_pool;  //p</PRE>
<PRE><A NAME="50487361_pgfId-22230496"></A>struct VECTOR_COMB_s       *normal_pool;  //$p</PRE>
<PRE><A NAME="50487361_pgfId-22230497"></A>struct INTEGER_COMB_s      *position_indices;  //$p</PRE>
<PRE><A NAME="50487361_pgfId-22230498"></A>SCH_mesh_normal_type_t      normal_type;  //$u</PRE>
<PRE><A NAME="50487361_pgfId-22230499"></A>struct INTEGER_COMB_s      *normal_indices;  //$p</PRE>
<PRE><A NAME="50487361_pgfId-22230500"></A>};</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22230502"></A>The <CODE>
owner</CODE>
 field is reserved for future use and must be set to null pointer.</P>
<P>
<A NAME="50487361_pgfId-22230503"></A>The <CODE>
precision</CODE>
 field is reserved for future use and must be set to 1, i.e. double precision.</P>
<P>
<A NAME="50487361_pgfId-22230504"></A>The <CODE>
normal_type</CODE>
 defines whether normals are stored, and if so, whether storage is on a per-facet or per-vertex basis. See <A HREF="xt_chap.06.html#50487361_14989">Section 5.2.3.5, “Normal indices”</A>, for more information.</P>


<H4>
<A NAME="50487361_pgfId-22230509"></A>5.2.3.2 <A NAME="50487361_34336"></A>Position pool</H4>
<P>
<A NAME="50487361_pgfId-22230510"></A>The position pool is an indexed point cloud. The vector array is stored using “comb” nodes, each of which consists of a “spine” array containing pointers to “tooth” arrays. Each tooth array contains the vector information. All the teeth have the same length, which is a power of 2. See <A HREF="xt_chap.06.html#50487361_57928">Section 5.2.7, “Comb nodes”</A> for more information on the VECTOR_COMB node. </P>


<H4>
<A NAME="50487361_pgfId-22230515"></A>5.2.3.3 <A NAME="50487361_90390"></A>Position indices</H4>
<P>
<A NAME="50487361_pgfId-22230516"></A>The mesh is defined by each facet specifying 3 positions from the position pool. The indices for these positions are stored in an integer comb, similar to the vector comb. See <A HREF="xt_chap.06.html#50487361_57928">Section 5.2.7, “Comb nodes”</A> for more information on INTEGER_COMB nodes.</P>


<H4>
<A NAME="50487361_pgfId-22230521"></A>5.2.3.4 <A NAME="50487361_24145"></A>Normal pool</H4>
<P>
<A NAME="50487361_pgfId-22230522"></A>The normal pool is an indexed cloud of normals, i.e. unit vectors. These are stored in double-precision spherical polar coordinates.</P>
<P>
<A NAME="50487361_pgfId-22230523"></A>The normal pool is optional, so need not exist at all.</P>


<H4>
<A NAME="50487361_pgfId-22230525"></A>5.2.3.5 <A NAME="50487361_14989"></A>Normal indices</H4>
<P>
<A NAME="50487361_pgfId-22230526"></A>If normals are stored with the mesh they must be stored for each vertex of each facet. The type of normal storage used by the mesh data is specified by the <CODE>
normal_type</CODE>
 field.</P>
<UL>
<LI>
<A NAME="50487361_pgfId-22230527"></A>If no normals are stored, normal indices are not needed and must be set to null pointer.</LI>
<LI>
<A NAME="50487361_pgfId-22230528"></A>If the normals are per-facet, then the number of normal indices is the same as the number of position indices, and the normal indices and position indices are parallel arrays.</LI>
<LI>
<A NAME="50487361_pgfId-19360117"></A>Normal storage per-vertex is not implemented.</LI>
</UL>



<H3>
<A NAME="50487361_pgfId-21092362"></A>	5.2.4 	Lattices</H3>
<P>
<A NAME="50487361_pgfId-21097548"></A>Each LATTICE node references a LATTICE_DATA node containing the lattice geometry data.</P>
<P>
<A NAME="50487361_pgfId-21092459"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092418"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092420"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092422"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092424"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092426"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092428"></A>integer unique within part</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092430"></A><CODE>
attribute_feature</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092432"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092434"></A>attributes and features associated with lattice</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092436"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092438"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092440"></A>owner</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092442"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092444"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092446"></A>next lattice in geometry chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092448"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092450"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092452"></A>previous lattice in geometry chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092454"></A><CODE>
geometric_owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092456"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21092458"></A>geometric owner node</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21093059"></A><CODE>
sense</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21093061"></A>char</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21093063"></A>sense of lattice: ‘+’ or ‘-’ (see <A HREF="xt_chap.06.html#50487361_41883">Section 5.2.8, “Curve, surface and lattice senses”</A>)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21093097"></A><CODE>
data</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21093099"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21093101"></A>lattice geometry data</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21097610"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-21093466"></A>struct LATTICE_s                    //Lattice</PRE>
<PRE><A NAME="50487361_pgfId-21093467"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-21093468"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-21093469"></A>    union  ATTRIB_FEAT_u          attributes_feature;  // $p</PRE>
<PRE><A NAME="50487361_pgfId-21093470"></A>    union  LATTICE_OWNER_u        owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-21093471"></A>    struct LATTICE_s             *next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-21093472"></A>    struct LATTICE_s             *previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-21093473"></A>    struct GEOMETRIC_OWNER_S     *geometric_owner;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-21093963"></A>    char                          sense;               // $c</PRE>
<PRE><A NAME="50487361_pgfId-21094080"></A>    union  LATTICE_DATA_u         data;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-21093474"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-21093475"></A>typedef struct LATTICE_s *LATTICE</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21362591"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-21093281"></A>union LATTICE_OWNER_u</PRE>
<PRE><A NAME="50487361_pgfId-21093282"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-21093284"></A>    struct BODY_s                *body; </PRE>
<PRE><A NAME="50487361_pgfId-21093285"></A>    struct ASSEMBLY_s            *assembly;</PRE>
<PRE><A NAME="50487361_pgfId-21093286"></A>    struct WORLD_s               *world; </PRE>
<PRE><A NAME="50487361_pgfId-21348557"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-21364134"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-21093288"></A>typedef union LATTICE_OWNER_u LATTICE_OWNER;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21361614"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-21362617"></A>union LATTICE_DATA_u</PRE>
<PRE><A NAME="50487361_pgfId-21362618"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-21362619"></A>    DS_block_p_t                     any;</PRE>
<PRE><A NAME="50487361_pgfId-21362620"></A>    struct LATTICE_DATA_IRREGULAR_s *irregular;</PRE>
<PRE><A NAME="50487361_pgfId-21362621"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-21362622"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-21362623"></A>typedef union LATTICE_DATA_u LATTICE_DATA;</PRE>
</TD>
</TR>
</TABLE>

<H4>
<A NAME="50487361_pgfId-21098701"></A>5.2.4.1 Irregular lattice node</H4>
<P>
<A NAME="50487361_pgfId-21093476"></A>Lattice data is stored in a LATTICE_DATA_IRREGULAR node, which is referenced by the LATTICE node. The lattice data is described using the following fields:</P>
<P>
<A NAME="50487361_pgfId-21097220"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097167"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097169"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097171"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097173"></A><CODE>
connectivity</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097175"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097177"></A>graph of lattice. See the GRAPH_COMPACT node below for more information.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097179"></A><CODE>
positions</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097181"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097183"></A>array of positions</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097185"></A><CODE>
ball_type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097187"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097189"></A>form of ball radii</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097191"></A><CODE>
ball_radius</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097193"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097195"></A>constant radius for balls</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097197"></A><CODE>
ball_radii</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097199"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097201"></A>array of variable radii for balls</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097203"></A><CODE>
ball_rod_radii</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097205"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097207"></A>array of variable radii for rods at balls</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22372425"></A><CODE>
ball_blend_type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22372427"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22372429"></A>type of blend for the balls</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22372431"></A><CODE>
ball_blend_size</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22372433"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22372435"></A>constant blend size for balls</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22372437"></A><CODE>
ball_blend_sizes</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22372439"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22372441"></A>array of variable blend sizes for balls if <CODE>
ball_blend_type</CODE>
 is anything other than <CODE>
SCH_ball_blend_none</CODE>
 and <CODE>
ball_blend_size</CODE>
 is zero.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097209"></A><CODE>
rod_term_type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097211"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097213"></A>form of rod terminal radii</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097215"></A><CODE>
rod_term_radius</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097217"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097219"></A>constant terminal radius for rods</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097921"></A>rod_start_radii</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097923"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097925"></A>array of variable radii for start of rod</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097959"></A>rod_end_radii</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097961"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097963"></A>array of variable radii for ends of rod</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097995"></A>rod_mid_type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097997"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21097999"></A>form of mid radius of rods</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21098030"></A>rod_mid_radius</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21098032"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21098034"></A>constant mid radius for rods</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21098061"></A>rod_mid_radii</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21098063"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21098065"></A>array of mid radii for rods</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21103176"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-21094189"></A>struct LATTICE_DATA_IRREGULAR_s            //General lattice data</PRE>
<PRE><A NAME="50487361_pgfId-21094190"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-21094191"></A>    struct GRAPH_COMPACT_s        *connectivity;       // $p</PRE>
<PRE><A NAME="50487361_pgfId-21094192"></A>    struct VECTOR_COMB_s_         *positions;          // $p</PRE>
<PRE><A NAME="50487361_pgfId-21094193"></A>    SCH_lattice_ball_type_t        ball_type;          // $u</PRE>
<PRE><A NAME="50487361_pgfId-21094488"></A>    double                         ball_radius;        // $f</PRE>
<PRE><A NAME="50487361_pgfId-21094194"></A>    struct REAL_COMB_s            *ball_radii;         // $p</PRE>
<PRE><A NAME="50487361_pgfId-21094671"></A>    struct REAL_COMB_s            *ball_rod_radii;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-22373272"></A>     SCH_lattice_ball_blend_type_t  ball_blend_type;    // $u</PRE>
<PRE><A NAME="50487361_pgfId-22373273"></A>    double                         ball_blend_size;    // $f</PRE>
<PRE><A NAME="50487361_pgfId-22373314"></A>    struct REAL_COMB_s            *ball_blend_sizes;   // $p</PRE>
<PRE><A NAME="50487361_pgfId-21094696"></A>    SCH_lattice_rod_term_type_t    rod_term_type;      // $u</PRE>
<PRE><A NAME="50487361_pgfId-21094814"></A>    double                         rod_term_radius;    // $f</PRE>
<PRE><A NAME="50487361_pgfId-21094815"></A>    struct REAL_COMB_s            *rod_start_radii;    // $p</PRE>
<PRE><A NAME="50487361_pgfId-21094816"></A>    struct REAL_COMB_s            *rod_end_radii;      // $p</PRE>
<PRE><A NAME="50487361_pgfId-21094712"></A>    SCH_lattice_rod_mid_type_t     rod_mid_type;       // $u</PRE>
<PRE><A NAME="50487361_pgfId-21095386"></A>    double                         rod_mid_radius;     // $f</PRE>
<PRE><A NAME="50487361_pgfId-21095387"></A>    struct REAL_COMB_s            *rod_mid_radii;      // $p</PRE>
<PRE><A NAME="50487361_pgfId-21094199"></A>  };</PRE>
<PRE><A NAME="50487361_pgfId-21094200"></A>typedef struct LATTICE_DATA_IRREGULAR_s *LATTICE_DATA_IRREGULAR;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21100467"></A>The GRAPH_COMPACT node stores graph data for a lattice and is defined as follows:</P>
<P>
<A NAME="50487361_pgfId-21100492"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-21100478"></A>typedef struct GRAPH_COMPACT_s  //Graph data</PRE>
<PRE><A NAME="50487361_pgfId-21100479"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-21100480"></A>    struct INTEGER_COMB_s       *adjacency_indices;        // $p</PRE>
<PRE><A NAME="50487361_pgfId-21100481"></A>    struct INTEGER_COMB_s_      *adjacencies;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-21100482"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-21100483"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-21100484"></A>typedef struct GRAPH_COMPACT_s *GRAPH_COMPACT; </PRE>
<PRE><A NAME="50487361_pgfId-21100485"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-21100486"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-21100487"></A>SCH_define_init_fn_m( GRAPH_COMPACT_S, SELF,</PRE>
<PRE><A NAME="50487361_pgfId-21100488"></A>                      self -&gt; adjacency_indices = null;</PRE>
<PRE><A NAME="50487361_pgfId-21100489"></A>                      self -&gt; adjacencies       = null;</PRE>
<PRE><A NAME="50487361_pgfId-21100490"></A>                     ) </PRE>
<PRE><A NAME="50487361_pgfId-21100491"></A>&nbsp;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21098329"></A>The <CODE>
ball_type</CODE>
 enum defines the type of ball radii</P>
<P>
<A NAME="50487361_pgfId-22373175"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-21099900"></A>typedef short short enum</PRE>
<PRE><A NAME="50487361_pgfId-21099901"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-21099902"></A>    SCH_ball_unset    = 0,</PRE>
<PRE><A NAME="50487361_pgfId-21099903"></A>    SCH_ball_const    = 1,</PRE>
<PRE><A NAME="50487361_pgfId-21099904"></A>    SCH_ball_variable = 2</PRE>
<PRE><A NAME="50487361_pgfId-21099905"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-21099906"></A>    SCH_lattice_ball_type_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21100081"></A>The <CODE>
ball_blend_type</CODE>
 enum defines the type of ball blend </P>
<P>
<A NAME="50487361_pgfId-22372912"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22372903"></A>typedef short short enum</PRE>
<PRE><A NAME="50487361_pgfId-22372904"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-22372905"></A>    SCH_ball_blend_none = 0,</PRE>
<PRE><A NAME="50487361_pgfId-22372906"></A>    SCH_ball_blend_absolute = 1,</PRE>
<PRE><A NAME="50487361_pgfId-22372907"></A>    SCH_ball_blend_relative = 2,</PRE>
<PRE><A NAME="50487361_pgfId-22372909"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-22372910"></A>    SCH_lattice_ball_blend_type_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21098982"></A>The<CODE>
 rod_term_type</CODE>
 enum defines the type of rod terminal radii</P>
<P>
<A NAME="50487361_pgfId-21100028"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-21100050"></A>typedef short short enum</PRE>
<PRE><A NAME="50487361_pgfId-21100051"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-21100052"></A>    SCH_rod_term_unset      = 0,</PRE>
<PRE><A NAME="50487361_pgfId-21100053"></A>    SCH_rod_term_const      = 1,</PRE>
<PRE><A NAME="50487361_pgfId-21100054"></A>    SCH_rod_term_derived    = 2,</PRE>
<PRE><A NAME="50487361_pgfId-21100055"></A>    SCH_rod_term_variable_1 = 3,</PRE>
<PRE><A NAME="50487361_pgfId-21100056"></A>    SCH_rod_term_variable_2 = 4</PRE>
<PRE><A NAME="50487361_pgfId-21100057"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-21100058"></A>    SCH_lattice_rod_term_type_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21099015"></A>The <CODE>
rod_mid_type</CODE>
 enum defines the type of the rod mid radii</P>
<P>
<A NAME="50487361_pgfId-22372803"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-21100114"></A>typedef short short enum</PRE>
<PRE><A NAME="50487361_pgfId-21100115"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-21100116"></A>    SCH_rod_mid_unset      = 0,</PRE>
<PRE><A NAME="50487361_pgfId-21100117"></A>    SCH_rod_mid_none       = 1,</PRE>
<PRE><A NAME="50487361_pgfId-21100118"></A>    SCH_rod_mid_const      = 2,</PRE>
<PRE><A NAME="50487361_pgfId-21100119"></A>    SCH_rod_mid_variable   = 3</PRE>
<PRE><A NAME="50487361_pgfId-21100120"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-21100121"></A>    SCH_lattice_rod_mid_type_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21099049"></A>The arrays in the LATTICE_DATA_IRREGULAR node are stored using “comb” nodes, each of which consists of a “spine” array containing pointers to “tooth” arrays. Each tooth array contains the vector or real information. See <A HREF="xt_chap.06.html#50487361_57928">Section 5.2.7, “Comb nodes”</A> for more information.</P>



<H3>
<A NAME="50487361_pgfId-495065"></A>	5.2.5 	Point</H3>
<P>
<A NAME="50487361_pgfId-435095"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435054"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435056"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435058"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435060"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435062"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435064"></A>integer unique within part</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435066"></A><CODE>
attributes_features</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435068"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435070"></A>attributes and features associated with point</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435072"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435074"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435076"></A>owner</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435078"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435080"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435082"></A>next point in chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435084"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435086"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435088"></A>previous point in chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435090"></A><CODE>
pvec</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435092"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-435094"></A>position of point</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-435106"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-435098"></A>union POINT_OWNER_u</PRE>
<PRE><A NAME="50487361_pgfId-483007"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-483015"></A>    struct VERTEX_s              *vertex; </PRE>
<PRE><A NAME="50487361_pgfId-483023"></A>    struct BODY_s                *body; </PRE>
<PRE><A NAME="50487361_pgfId-483031"></A>    struct ASSEMBLY_s            *assembly;</PRE>
<PRE><A NAME="50487361_pgfId-483039"></A>    struct WORLD_s               *world; </PRE>
<PRE><A NAME="50487361_pgfId-21355132"></A>    };</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-435119"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-435563"></A>struct POINT_s                    //Point</PRE>
<PRE><A NAME="50487361_pgfId-483063"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-4100297"></A>    int                           node_id;             // $d</PRE>
<PRE><A NAME="50487361_pgfId-4100298"></A>    union  ATTRIB_FEAT_u        </PRE>
<PRE><A NAME="50487361_pgfId-21364178"></A>    attributes_features;                               // $p</PRE>
<PRE><A NAME="50487361_pgfId-483087"></A>    union  POINT_OWNER_u          owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-483095"></A>    struct POINT_s               *next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-483103"></A>    struct POINT_s               *previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-483111"></A>    vector                        pvec;                // $v</PRE>
<PRE><A NAME="50487361_pgfId-435480"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-483119"></A>typedef struct POINT_s *POINT;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-289029"></A>	5.2.6 	Transform</H3>
<P>
<A NAME="50487361_pgfId-21952092"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289032"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289034"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289036"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289038"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289040"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289042"></A>integer unique within part</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289044"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289046"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289048"></A>owning instance or world</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289050"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289052"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289054"></A>next transform in chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289056"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289058"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289060"></A>previous pointer in chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289062"></A><CODE>
rotation_matrix</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289064"></A>double[3][3]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289066"></A>rotation component</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289068"></A><CODE>
translation_vector</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289070"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289072"></A>translation component</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289074"></A><CODE>
scale</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289076"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289078"></A>scaling factor</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289080"></A><CODE>
flag</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289082"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289084"></A>binary flags indicating non-trivial components</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289086"></A><CODE>
perspective_vector</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289088"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289090"></A>perspective vector (always null vector)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21951087"></A>precision</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21951089"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21951091"></A>additional precision data for the transform</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289092"></A>The transform acts as:</P>
<P>
<A NAME="50487361_pgfId-17674338"></A><CODE>
x’ = (rotation_matrix . x + translation_vector) * scale</CODE>
</P>
<P>
<A NAME="50487361_pgfId-289094"></A>The ‘flag’ field contains various bit flags which identify the components of the transformation:</P>
<P>
<A NAME="50487361_pgfId-289132"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289097"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289099"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289101"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289103"></A><CODE>
translation</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289105"></A>00001</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289107"></A>set if translation vector non-zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289109"></A><CODE>
rotation</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289111"></A>00010</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289113"></A>set if rotation matrix is not the identity</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289115"></A><CODE>
scaling</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289117"></A>00100</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289119"></A>set if scaling component is not 1.0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289121"></A><CODE>
reflection</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289123"></A>01000</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289125"></A>set if determinant of rotation matrix is negative</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289127"></A><CODE>
general affine</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289129"></A>10000</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289131"></A>set if the rotation_matrix is not a rigid rotation</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289140"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-435777"></A>union TRANSFORM_OWNER_u{</PRE>
<PRE><A NAME="50487361_pgfId-483127"></A>    struct INSTANCE_s          *instance; </PRE>
<PRE><A NAME="50487361_pgfId-483135"></A>    struct WORLD_s             *world;</PRE>
<PRE><A NAME="50487361_pgfId-483143"></A>    };</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21951908"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-289143"></A>struct TRANSFORM_s               //Transformation</PRE>
<PRE><A NAME="50487361_pgfId-4193636"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-4193637"></A>    int                           node_id;                 // $d</PRE>
<PRE><A NAME="50487361_pgfId-483167"></A>    union TRANSFORM_OWNER_u       owner;                   // $p</PRE>
<PRE><A NAME="50487361_pgfId-483175"></A>    struct TRANSFORM_s           *next;                    // $p</PRE>
<PRE><A NAME="50487361_pgfId-483183"></A>    struct TRANSFORM_s           *previous;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-483191"></A>    double                        rotation_matrix[3][3];   // $f[9]</PRE>
<PRE><A NAME="50487361_pgfId-483199"></A>    vector                        translation_vector;      // $v</PRE>
<PRE><A NAME="50487361_pgfId-483207"></A>    double                        scale;                   // $f</PRE>
<PRE><A NAME="50487361_pgfId-483215"></A>    unsigned                      flag;                    // $d</PRE>
<PRE><A NAME="50487361_pgfId-483223"></A>    vector                        perspective_vector;      // $v</PRE>
<PRE><A NAME="50487361_pgfId-21951196"></A>struct TRANSFORM_PRECISION_s     *precision;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-483231"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-483239"></A>typedef struct TRANSFORM_s *TRANSFORM;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21951846"></A>The TRANSFORM_PRECISION node is an optional structure for storing additional precision information of the transform and is defined as follows:</P>
<P>
<A NAME="50487361_pgfId-21951660"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-21951679"></A>struct TRANSFORM_PRECISION_s     //Transformation precision</PRE>
<PRE><A NAME="50487361_pgfId-21951680"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-21951681"></A>double  rotation_matrix[3][3];    //$f[3*3]</PRE>
<PRE><A NAME="50487361_pgfId-21951682"></A>vector  translation_vector;       //$v</PRE>
<PRE><A NAME="50487361_pgfId-21951683"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-21951685"></A>typedef struct TRANSFORM_PRECISION_s *TRANSFORM_PRECISION;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21469177"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<ADDRESS>
<A NAME="50487361_pgfId-21954637"></A>Note:  When consuming Parasolid-native XT, the values in the TRANSFORM_PRECISION structure (when not NULL) should be added to those in the <CODE>
rotation_matrix</CODE>
 and <CODE>
translation_vector</CODE>
 values in the parent TRANSFORM structure.</ADDRESS><BR>
<ADDRESS>
<A NAME="50487361_pgfId-21954902"></A>When using the format reference to write XT data, the TRANSFORM_PRECISION structure should not typically be used.</ADDRESS><BR>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-21103130"></A>	5.2.7 	<A NAME="50487361_57928"></A>Comb nodes</H3>

<H4>
<A NAME="50487361_pgfId-21098748"></A>5.2.7.1 <A NAME="50487361_94753"></A>VECTOR_COMB nodes</H4>
<P>
<A NAME="50487361_pgfId-21101303"></A>The VECTOR_COMB node stores an array of double precision vectors.</P>
<P>
<A NAME="50487361_pgfId-22300326"></A>The vector array is stored using “comb” nodes, each of which consists of a “spine” array containing pointers to “tooth” arrays. Each tooth array contains the vector information. All the teeth have the same length, which is a power of 2.</P>
<P>
<A NAME="50487361_pgfId-22300364"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300329"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300331"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300333"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300335"></A><CODE>
encoding</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300337"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300339"></A>Form of the vector coordinates</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300341"></A><CODE>
n_vectors</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300343"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300345"></A>Number of vectors stored in the comb</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300347"></A><CODE>
n_max_vectors</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300349"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300351"></A>Maximum number of vectors for which space has been allocated in the comb</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300353"></A><CODE>
shift</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300355"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300357"></A>Capacity of the tooth, defined as 2<CODE>
shift</CODE>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300359"></A><CODE>
teeth</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300361"></A>pointer array</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300363"></A>Array of pointers to vector teeth</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22300387"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22300367"></A>struct VECTOR_TOOTH_s                         //Vector Tooth</PRE>
<PRE><A NAME="50487361_pgfId-22300368"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22300369"></A>double                      values[1];        //$f[]</PRE>
<PRE><A NAME="50487361_pgfId-22300370"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-22300371"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-22300372"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-22300373"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22300374"></A>SCH_vector_simple    = 1,</PRE>
<PRE><A NAME="50487361_pgfId-22300375"></A>SCH_vector_spherical = 2</PRE>
<PRE><A NAME="50487361_pgfId-22300376"></A>}</PRE>
<PRE><A NAME="50487361_pgfId-22300377"></A>SCH_vector_encoding_t;</PRE>
<PRE><A NAME="50487361_pgfId-22300378"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-22300379"></A>struct VECTOR_COMB_s  //Vector Comb</PRE>
<PRE><A NAME="50487361_pgfId-22300380"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22300381"></A>SCH_vector_encoding_t       encoding;        //$u</PRE>
<PRE><A NAME="50487361_pgfId-22300382"></A>int                         n_vectors;       //$d</PRE>
<PRE><A NAME="50487361_pgfId-22300383"></A>int                         n_max_vectors;   //$d</PRE>
<PRE><A NAME="50487361_pgfId-22300384"></A>int                         shift;           //$d</PRE>
<PRE><A NAME="50487361_pgfId-22300385"></A>struct VECTOR_TOOTH_s      *teeth[1]     ;  //$p[]</PRE>
<PRE><A NAME="50487361_pgfId-22300386"></A>};</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22300388"></A>The <CODE>
encoding</CODE>
 enum determines the number of values used to store the vectors:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-22300389"></A><CODE>
simple</CODE>
 vectors are stored as triplets of doubles corresponding to Cartesian coordinates;</LI>
<LI>
<A NAME="50487361_pgfId-21101369"></A><CODE>
spherical</CODE>
 vectors are stored as pairs of doubles corresponding to (theta, phi) spherical coordinates. This encoding is only used for unit vectors.</LI>
</UL>


<H4>
<A NAME="50487361_pgfId-21101596"></A>5.2.7.2 INTEGER_COMB nodes</H4>
<P>
<A NAME="50487361_pgfId-21344831"></A>Similar to vector comb nodes and is defined as follows:</P>
<P>
<A NAME="50487361_pgfId-22300417"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22300397"></A>struct INTEGER_TOOTH_s                            //Integer Tooth</PRE>
<PRE><A NAME="50487361_pgfId-22300398"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22300399"></A>int                         values[1];            //$d[]</PRE>
<PRE><A NAME="50487361_pgfId-22300400"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-22300401"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-22300402"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-22300403"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22300404"></A>SCH_no_encoding       = 1</PRE>
<PRE><A NAME="50487361_pgfId-22300405"></A>}</PRE>
<PRE><A NAME="50487361_pgfId-22300406"></A>SCH_comb_encoding_t;</PRE>
<PRE><A NAME="50487361_pgfId-22300407"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-22300408"></A>struct INTEGER_COMB_s                            //Integer Comb</PRE>
<PRE><A NAME="50487361_pgfId-22300409"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22300410"></A>SCH_comb_encoding_t         encoding;            //$u</PRE>
<PRE><A NAME="50487361_pgfId-22300411"></A>int                         n_integers;          //$d</PRE>
<PRE><A NAME="50487361_pgfId-22300412"></A>int                         n_max_integers;      //$d</PRE>
<PRE><A NAME="50487361_pgfId-22300413"></A>int                         n_bits_per_integer;  //$d</PRE>
<PRE><A NAME="50487361_pgfId-22300414"></A>int                         shift;               //$d</PRE>
<PRE><A NAME="50487361_pgfId-22300415"></A>struct INTEGER_TOOTH_s     *teeth[1];            //$p[]</PRE>
<PRE><A NAME="50487361_pgfId-22300416"></A>};</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21101711"></A>The <CODE>
encoding</CODE>
 enum is reserved for future use. The n_bits_per_integer integer is not used and must be set to 32.</P>


<H4>
<A NAME="50487361_pgfId-21101224"></A>5.2.7.3 REAL_COMB nodes</H4>
<P>
<A NAME="50487361_pgfId-21102159"></A>These are similar to vector nodes and are described as follows:</P>
<P>
<A NAME="50487361_pgfId-22300460"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300425"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300427"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300429"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300431"></A><CODE>
encoding</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300433"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300435"></A>Reserved for future use</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300437"></A><CODE>
length</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300439"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300441"></A>Number of reals stored in the comb</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300443"></A><CODE>
max_length</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300445"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300447"></A>Maximum length</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300449"></A><CODE>
shift</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300451"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300453"></A>Capacity of the tooth, defined as 2<CODE>
shift</CODE>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300455"></A><CODE>
teeth</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300457"></A>pointer array</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22300459"></A>Array of pointers to real teeth</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21103590"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-21362879"></A>struct REAL_TOOTH_s                            //Real Tooth</PRE>
<PRE><A NAME="50487361_pgfId-21362880"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-21362881"></A>int                      values[1];            //$d[]</PRE>
<PRE><A NAME="50487361_pgfId-21362882"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-21362883"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-21362884"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-21362885"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-21362886"></A>SCH_no_encoding       = 1</PRE>
<PRE><A NAME="50487361_pgfId-21362887"></A>}</PRE>
<PRE><A NAME="50487361_pgfId-21362888"></A>SCH_comb_encoding_t;</PRE>
<PRE><A NAME="50487361_pgfId-21362709"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-21102263"></A>struct REAL_COMB_s                              //Real Comb</PRE>
<PRE><A NAME="50487361_pgfId-21102264"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-21102265"></A>    SCH_comb_encoding_t         encoding;       //$u</PRE>
<PRE><A NAME="50487361_pgfId-21102266"></A>    int                         length;         //$d</PRE>
<PRE><A NAME="50487361_pgfId-21102267"></A>    int                         max_length;     //$d</PRE>
<PRE><A NAME="50487361_pgfId-21102268"></A>    int                         shift;          //$d</PRE>
<PRE><A NAME="50487361_pgfId-21102269"></A>    struct REAL_TOOTH_s        *teeth[1];       //$p[]</PRE>
<PRE><A NAME="50487361_pgfId-21102270"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-21102271"></A>typedef struct REAL_COMB_s *REAL_COMB;</PRE>
</TD>
</TR>
</TABLE>



<H3>
<A NAME="50487361_pgfId-289157"></A>	5.2.8 	<A NAME="50487361_41883"></A>Curve, surface and lattice senses</H3>
<P>
<A NAME="50487361_pgfId-289158"></A>The ‘natural’ tangent to a curve is that in the increasing parameter direction, and the ‘natural’ normal to a surface is in the direction of the cross-product of dP/du and dP/dv. For some purposes these are modified by the curve and surfaces senses, respectively - for example in the definition of blend surfaces, offset surfaces and intersection curves.</P>
<P>
<A NAME="50487361_pgfId-289159"></A>At the XT interface, the edge/curve and face/surface sense orientations are regarded as properties of the topology/geometry combination. In the XT format, this orientation information resides in the curves, surfaces and faces as follows:</P>
<P>
<A NAME="50487361_pgfId-289160"></A>The edge/curve orientation is stored in the <CODE>
curve-&gt;sense</CODE>
 field. The face/surface orientation is a combination of sense flags stored in the <CODE>
face-&gt;sense</CODE>
 and <CODE>
surface-&gt;sense</CODE>
 fields, so the face/surface orientation is true (i.e. the face normal is parallel to the natural surface normal) if neither, or both, of the face and surface senses are positive.</P>
<P>
<A NAME="50487361_pgfId-21364221"></A>In the XT Format, the orientation information of lattices is stored in the <CODE>
sense</CODE>
 field. If the sense is positive, the interior of the lattice is considered solid, and void if the sense is negative. </P>


<H3>
<A NAME="50487361_pgfId-289161"></A>	5.2.9 	Geometric_owner</H3>
<P>
<A NAME="50487361_pgfId-289162"></A>Where geometry has dependants, the dependants point back to the referencing geometry by means of Geometric Owner nodes. Each geometric node points to a doubly-linked ring of Geometric Owner nodes which identify its referencing geometry. Referenced geometry is as follows:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-21344732"></A>Intersection: 2 surfaces.</LI>
<LI>
<A NAME="50487361_pgfId-21344733"></A>SP-curve: Surface.</LI>
<LI>
<A NAME="50487361_pgfId-21344734"></A>Trimmed curve: basis curve.</LI>
<LI>
<A NAME="50487361_pgfId-21344735"></A>Blended edge: 2 supporting surfaces, 2 <CODE>
blend_bound</CODE>
 surfaces, 1 spine curve.</LI>
<LI>
<A NAME="50487361_pgfId-21344736"></A>Blend bound: blend surface.</LI>
<LI>
<A NAME="50487361_pgfId-21344737"></A>Offset surface: underlying surface.</LI>
<LI>
<A NAME="50487361_pgfId-21344738"></A>Swept surface: section curve.</LI>
<LI>
<A NAME="50487361_pgfId-21344739"></A>Spun surface: profile curve.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-21344752"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<ADDRESS>
<A NAME="50487361_pgfId-21344751"></A>Note: The 2D B-curve referenced by an SP-curve is not a dependent in this sense, and does not need a geometric owner node.</ADDRESS><BR>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289203"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289174"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289176"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289178"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289180"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289182"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289184"></A>referencing geometry</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289186"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289188"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289190"></A>next in ring of geometric owners referring to the same geometry</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289192"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289194"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289196"></A>previous in above ring</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289198"></A><CODE>
shared_geometry</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289200"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289202"></A>referenced (dependent) geometry</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-21103899"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-289206"></A>struct GEOMETRIC_OWNER_s      //geometric owner of geometry</PRE>
<PRE><A NAME="50487361_pgfId-483247"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-483255"></A>    union  GEOMETRY_u              owner;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-483263"></A>    struct GEOMETRIC_OWNER_s      *next;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-483271"></A>    struct GEOMETRIC_OWNER_s      *previous;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-483279"></A>    union  GEOMETRY_u              shared_geometry;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-483287"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-483295"></A>typedef struct GEOMETRIC_OWNER_s *GEOMETRIC_OWNER;</PRE>
</TD>
</TR>
</TABLE>




<P ALIGN=RIGHT>
<A HREF="#topofdoc"><I>[back to top]</I></A>
</P>

<HR>

<H1>
<A NAME="50487361_pgfId-289215"></A>5.3	Topology


</H1>
<P>
<A NAME="50487361_pgfId-463485"></A>In the following tables, ‘ignore’ means this may be set to null (zero) if the XT data is created outside of the Parasolid Kernel. For XT data created by the Parasolid Kernel, this may take any value, but should be ignored.</P>
<P>
<A NAME="50487361_pgfId-289217"></A>Unless otherwise stated, all chains of nodes are doubly-linked and null-terminated.</P>

<H3>
<A NAME="50487361_pgfId-289218"></A>	5.3.1 	World</H3>
<P>
<A NAME="50487361_pgfId-289310"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463387"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463389"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463391"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463393"></A><CODE>
assembly</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463395"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463397"></A>Head of chain of assemblies</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463399"></A><CODE>
attribute</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463401"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463403"></A>Ignore</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463405"></A><CODE>
body</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463407"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463409"></A>Head of chain of bodies. This chain contains standard and compound bodies but does not contain any child bodies.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463411"></A><CODE>
transform</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463413"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463415"></A>Head of chain of transforms</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21362300"></A><CODE>
lattice</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21362302"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21362304"></A>Head of chain of lattices </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463417"></A><CODE>
surface</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463419"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463421"></A>Head of chain of surfaces</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463423"></A><CODE>
curve</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463425"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463427"></A>Head of chain of curves</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463429"></A><CODE>
point</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463431"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463433"></A>Head of chain of points</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18725920"></A><CODE>
mesh</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18725922"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18725924"></A>Head of chain of meshes</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18725926"></A><CODE>
polyline</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18725928"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18725930"></A>Head of chain of polylines</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463435"></A><CODE>
alive</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463437"></A>logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463439"></A>True unless partition is at initial pmark</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463441"></A><CODE>
attrib_def</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463443"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463445"></A>Head of chain of attribute definitions</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18725974"></A><CODE>
attdef_list</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18725976"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18725978"></A>Shallbe set to null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463447"></A><CODE>
highest_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463449"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463451"></A>Highest pmark id in partition</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463453"></A><CODE>
current_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463455"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463457"></A>Id of current pmark</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463459"></A><CODE>
index_map_offset</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463461"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463463"></A>Shallbe set to 0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463465"></A><CODE>
index_map</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463467"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463469"></A>Shall be set to null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463471"></A><CODE>
schema_embedding_map</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463473"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-463475"></A>Shallbe set to null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-19885524"></A><CODE>
mesh_offset_data</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-19885526"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-19885528"></A>Data for embedded meshes. If the XT file does not contain embedded meshes, this field must be set to null.</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289311"></A>The World node is only used when a partition is transmitted. Because some of the attribute definitions may be referenced by nodes which have been deleted, but which may reappear on rollback, the attribute definitions are chained off the World node rather than simply being referenced by attributes.</P>
<P>
<A NAME="50487361_pgfId-18726019"></A>The <CODE>
attdef_list</CODE>
 field is not used and shall be set to null pointer.</P>
<P>
<A NAME="50487361_pgfId-289312"></A>The fields <CODE>
index_map_offset</CODE>
, <CODE>
index_map</CODE>
, and <CODE>
schema_embedding_map</CODE>
 are used for Indexed Transmit; applications writing XT data shall set them to 0 and null.</P>
<P>
<A NAME="50487361_pgfId-20088387"></A>The <CODE>
mesh_offset_data</CODE>
 field is used for embedded mesh data.</P>
<P>
<A NAME="50487361_pgfId-289330"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-436316"></A>struct WORLD_s                    //World</PRE>
<PRE><A NAME="50487361_pgfId-483303"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-483311"></A>    struct ASSEMBLY_s            *assembly;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-483319"></A>    struct ATTRIBUTE_s           *attribute;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-436260"></A>    struct BODY_s                *body;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-483327"></A>    struct TRANSFORM_s           *transform;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-21362995"></A>    struct LATTICE_s             *lattice;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-483335"></A>    union  SURFACE_u              surface;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-483343"></A>    union  CURVE_u                curve;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-483351"></A>    struct POINT_s               *point;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-22231744"></A>    union SURFACE_u               mesh;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-22231745"></A>    union CURVE_u                 polyline;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-483359"></A>    logical                       alive;                 // $l</PRE>
<PRE><A NAME="50487361_pgfId-483367"></A>    struct  ATTRIB_DEF_s         *attrib_def;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-18738531"></A>    struct  POINTER_LIS_BLOCK_s  *attdef_list;           // $p</PRE>
<PRE><A NAME="50487361_pgfId-483375"></A>    int                           highest_id;            // $d</PRE>
<PRE><A NAME="50487361_pgfId-483383"></A>    int                           current_id;            // $d</PRE>
<PRE><A NAME="50487361_pgfId-22231750"></A>    int                           index_map_offset:      // $d</PRE>
<PRE><A NAME="50487361_pgfId-22231751"></A>    struct INT_VALUES_s           *index_map;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-22231752"></A>    struct INT_VALUES_s           *schema_embedding_map; // $p</PRE>
<PRE><A NAME="50487361_pgfId-22231753"></A>    struct MESH_OFFSET_DATA_s     *mesh_offset_data;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-483415"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-483423"></A>typedef struct WORLD_s *WORLD;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-289331"></A>	5.3.2 	Assembly</H3>
<P>
<A NAME="50487361_pgfId-289441"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289334"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289336"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289338"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289340"></A><CODE>
highest_node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289342"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289344"></A>Highest identifier in assembly</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289346"></A><CODE>
attributes_features</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289348"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289350"></A>Head of chain of attributes of/and features in assembly</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289352"></A><CODE>
attribute_chains</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289354"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289356"></A>List of attributes, one for each attribute definition used in the assembly</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289358"></A><CODE>
list</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289360"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289362"></A>Null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21363405"></A><CODE>
lattice</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21363407"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21363409"></A>Head of construction lattice chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289364"></A><CODE>
surface</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289366"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289368"></A>Head of construction surface chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289370"></A><CODE>
curve</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289372"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289374"></A>Head of construction curve chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289376"></A><CODE>
point</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289378"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289380"></A>Head of construction point chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18532186"></A><CODE>
mesh</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18532188"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18532190"></A>Head of construction mesh chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18532180"></A><CODE>
polyline</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18532182"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18532184"></A>Head of construction polyline chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289382"></A><CODE>
key</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289384"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289386"></A>Ignore</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289388"></A><CODE>
res_size</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289390"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289392"></A>Value of ‘size box’ when transmitted (normally 1000)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289394"></A><CODE>
res_linear</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289396"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231758"></A>Value of linear resolution when transmitted (normally 1.0e-8).</P>
<P>
<A NAME="50487361_pgfId-470634"></A>For more information on linear resolution, see <A HREF="xt_chap.05.html#50487394_56059">Section 4.2, “General points”</A>.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289400"></A><CODE>
ref_instance</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289402"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289404"></A>Head of chain of instances referencing this assembly</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289406"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289408"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289410"></A>Ignore</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289412"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289414"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289416"></A>Ignore</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289418"></A><CODE>
state</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289420"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289422"></A>Set to 1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289424"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289426"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289428"></A>Ignore</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289430"></A><CODE>
type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289432"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289434"></A>Always 1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289436"></A><CODE>
sub_instance</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289438"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289440"></A>Head of chain of instances in assembly</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-19885603"></A><CODE>
mesh_offset_data</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-19885605"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-19885607"></A>Data for embedded meshes. If the XT file does not contain embedded meshes, this field must be set to null.</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289442"></A>The value of the ‘state’ field should be ignored, as should any nodes of type ‘KEY’ referenced by the assembly. If XT data is constructed without the use of the Parasolid Kernel, the state field should be set to 1, and the key to null.</P>
<P>
<A NAME="50487361_pgfId-327775"></A>The <CODE>
highest_node_id</CODE>
 gives the highest identifier of any node in the assembly. Certain nodes within the assembly (namely instances, transforms, geometry, attributes and groups) have unique identifiers which are non-zero integers.</P>
<P>
<A NAME="50487361_pgfId-20142138"></A>The <CODE>
mesh_offset_data</CODE>
 field is used for embedded mesh data.</P>
<P>
<A NAME="50487361_pgfId-327785"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-327778"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-483431"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-483439"></A>    SCH_collective_assembly  = 1,</PRE>
<PRE><A NAME="50487361_pgfId-483447"></A>    SCH_conjunctive_assembly = 2,</PRE>
<PRE><A NAME="50487361_pgfId-483455"></A>    SCH_disjunctive_assembly = 3</PRE>
<PRE><A NAME="50487361_pgfId-483463"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-483471"></A>    SCH_assembly_type;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289465"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-289456"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-483479"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-483487"></A>    SCH_new_part       = 1,</PRE>
<PRE><A NAME="50487361_pgfId-483495"></A>    SCH_stored_part    = 2,</PRE>
<PRE><A NAME="50487361_pgfId-483503"></A>    SCH_modified_part  = 3,</PRE>
<PRE><A NAME="50487361_pgfId-483511"></A>    SCH_anonymous_part = 4,</PRE>
<PRE><A NAME="50487361_pgfId-483519"></A>    SCH_unloaded_part  = 5</PRE>
<PRE><A NAME="50487361_pgfId-483527"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-483535"></A>    SCH_part_state;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289489"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-289468"></A>struct ASSEMBLY_s                 //Assembly</PRE>
<PRE><A NAME="50487361_pgfId-483543"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-483551"></A>    int                           highest_node_id;      // $d</PRE>
<PRE><A NAME="50487361_pgfId-4702728"></A>    union ATTRIB_FEAT_u           attributes_features;  // $p</PRE>
<PRE><A NAME="50487361_pgfId-483567"></A>    struct LIST_s                *attribute_chains;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-483575"></A>    struct LIST_s                *list;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-21363577"></A>    union LATTICE_u               lattice;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-483583"></A>    union SURFACE_u               surface;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-483591"></A>    union CURVE_u                 curve;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-483599"></A>    struct POINT_s               *point;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-22231343"></A>    union SURFACE_u               mesh;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-22231344"></A>    union CURVE_u                 polyline;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-483607"></A>    struct KEY_s                 *key;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-483615"></A>    double                        res_size;             // $f</PRE>
<PRE><A NAME="50487361_pgfId-483623"></A>    double                        res_linear;           // $f</PRE>
<PRE><A NAME="50487361_pgfId-483631"></A>    struct INSTANCE_s            *ref_instance;         // $p</PRE>
<PRE><A NAME="50487361_pgfId-483639"></A>    struct ASSEMBLY_s            *next;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-483647"></A>    struct ASSEMBLY_s            *previous;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-483655"></A>    SCH_part_state                state;                // $u</PRE>
<PRE><A NAME="50487361_pgfId-483663"></A>    struct WORLD_s               *owner;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-483671"></A>    SCH_assembly_type             type;                 // $u</PRE>
<PRE><A NAME="50487361_pgfId-483679"></A>    struct INSTANCE_s            *sub_instance;         // $p</PRE>
<PRE><A NAME="50487361_pgfId-19944867"></A>struct MESH_OFFSET_DATA_s  *mesh_offset_data;  //$p</PRE>
<PRE><A NAME="50487361_pgfId-483687"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-483695"></A>typedef struct ASSEMBLY_s *ASSEMBLY;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289497"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-437351"></A>struct KEY_s                      //Key</PRE>
<PRE><A NAME="50487361_pgfId-483703"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-483711"></A>    string[1];                    char                  // $c[]</PRE>
<PRE><A NAME="50487361_pgfId-483719"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-483727"></A>typedef struct KEY_s  *KEY;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-289498"></A>	5.3.3 	Instance</H3>
<P>
<A NAME="50487361_pgfId-289566"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289501"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289503"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289505"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289507"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289509"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289511"></A>Identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289513"></A><CODE>
attributes_features</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289515"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289517"></A>Head of chain of attributes of instance and <CODE>
member_of_feature </CODE>
instance</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289519"></A><CODE>
type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289521"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289523"></A>Always 1</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289525"></A><CODE>
part</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289527"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289529"></A>Part referenced by instance</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289531"></A><CODE>
transform</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289533"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289535"></A>Transform of instance</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289537"></A><CODE>
assembly</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289539"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289541"></A>Assembly in which instance lies</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289543"></A><CODE>
next_in_part</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289545"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289547"></A>Next instance in assembly</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289549"></A><CODE>
prev_in_part</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289551"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289553"></A>Previous instance in assembly</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289555"></A><CODE>
next_of_part</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289557"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289559"></A>Next instance of instance-&gt;part</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289561"></A><CODE>
prev_of_part</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289563"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289565"></A>Previous instance of instance-&gt;part</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22300494"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<ADDRESS>
<A NAME="50487361_pgfId-22300493"></A>Note: Only standard bodies can be instanced. Compound or child bodies cannot be instanced.</ADDRESS><BR>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289579"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-289573"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-483735"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-483743"></A>    SCH_positive_instance = 1,</PRE>
<PRE><A NAME="50487361_pgfId-483751"></A>    SCH_negative_instance = 2</PRE>
<PRE><A NAME="50487361_pgfId-483759"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-483767"></A>    SCH_instance_type;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289588"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-289582"></A>union  PART_u</PRE>
<PRE><A NAME="50487361_pgfId-483775"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-483783"></A>    struct BODY_s          *body;</PRE>
<PRE><A NAME="50487361_pgfId-483791"></A>    struct ASSEMBLY_s      *assembly;</PRE>
<PRE><A NAME="50487361_pgfId-483799"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-483807"></A>typedef union PART_u PART;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289605"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-289591"></A>struct INSTANCE_s                 //Instance</PRE>
<PRE><A NAME="50487361_pgfId-4856411"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-4856412"></A>    int                           node_id;               // $d</PRE>
<PRE><A NAME="50487361_pgfId-4856413"></A>    union  ATTRIB_FEAT_u          attributes_features;   // $p</PRE>
<PRE><A NAME="50487361_pgfId-483839"></A>    SCH_instance_type             type;                  // $u</PRE>
<PRE><A NAME="50487361_pgfId-483847"></A>    union  PART_u                 part;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-483855"></A>    struct TRANSFORM_s           *transform;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-483863"></A>    struct ASSEMBLY_s            *assembly;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-483871"></A>    struct INSTANCE_s            *next_in_part;          // $p</PRE>
<PRE><A NAME="50487361_pgfId-483879"></A>    struct INSTANCE_s            *prev_in_part;          // $p</PRE>
<PRE><A NAME="50487361_pgfId-483887"></A>    struct INSTANCE_s            *next_of_part;          // $p</PRE>
<PRE><A NAME="50487361_pgfId-483895"></A>    struct INSTANCE_s            *prev_of_part;          // $p</PRE>
<PRE><A NAME="50487361_pgfId-483903"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-483911"></A>typedef struct INSTANCE_s *INSTANCE;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-289606"></A>	5.3.4 	Body</H3>
<P>
<A NAME="50487361_pgfId-289794"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289609"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289611"></A>Data type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289613"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289615"></A><CODE>
highest_node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289617"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231802"></A>Highest identifier in a standard body.</P>
<P>
<A NAME="50487361_pgfId-22231803"></A>For compound bodies, this is the highest identifier, including entities in child bodies.</P>
<P>
<A NAME="50487361_pgfId-289621"></A>For child bodies, this is the identifier of the child body itself. It is also the highest unique identifier of the entities which were in the child body when it was added to its parent compound body.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289623"></A><CODE>
attributes_features</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289625"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231819"></A>Head of chain of attributes of and features in body.</P>
<P>
<A NAME="50487361_pgfId-289628"></A>All features in a compound body and its children are chained off this regardless of their contents.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289630"></A><CODE>
attribute_chains</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289632"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231825"></A>List of attributes, one for each attribute definition used in the body.</P>
<P>
<A NAME="50487361_pgfId-289635"></A>For compound bodies, all attributes within the compound body and its children appear in the <CODE>
attribute_chains</CODE>
 list for the compound body, except those attributes that are directly attached to the child bodies. These attributes appear in the <CODE>
attribute_chains</CODE>
 list of their relevant child body.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21667013"></A>lattice</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21667015"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-21667017"></A>Head of construction lattice chain.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289637"></A><CODE>
surface</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289639"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289641"></A>Head of construction surface chain. For a child body, these fields are always null.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289643"></A><CODE>
curve</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289645"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289647"></A>Head of construction curve chain. For a child body, these fields are always null.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289649"></A><CODE>
point</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289651"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289653"></A>Head of construction point chain. For a child body, these fields are always null.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18603984"></A><CODE>
mesh</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18603986"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18603988"></A>Head of construction mesh chain. For a child body, these fields are always null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18604058"></A><CODE>
polyline</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18604060"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18604062"></A>Head of construction polyline chain. For a child body, these fields are always null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289655"></A><CODE>
key</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289657"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289659"></A>Ignore</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289661"></A><CODE>
res_size</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289663"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289665"></A>Value of ‘size box’ when transmitted (normally 1000)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289667"></A><CODE>
res_linear</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289669"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22301357"></A>Value of linear resolution when transmitted (normally 1.0e-8).</P>
<P>
<A NAME="50487361_pgfId-470722"></A>For more information on linear resolution, see <A HREF="xt_chap.05.html#50487394_56059">Section 4.2, “General points”</A>.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289673"></A><CODE>
ref_instance</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289675"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289677"></A>Head of chain of instances referencing this assembly</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289679"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289681"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289683"></A>For a child body, this field chains children of the same parent together.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289685"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289687"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289689"></A>For a child body, this field chains children of the same parent together.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289691"></A><CODE>
state</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289693"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289695"></A>Set to 1 (see below)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289697"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289699"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289701"></A>For a child, this field references its parent compound body.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289703"></A><CODE>
body_type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289705"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289707"></A>Body type. If children of a compound body have the same <CODE>
body_type</CODE>
, then this will also be the <CODE>
body_type</CODE>
 of the compound body. Otherwise, the <CODE>
body_type</CODE>
 of the compound will be general.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289709"></A><CODE>
nom_geom_state</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289711"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289713"></A>Set to 1 (for future use)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289715"></A><CODE>
shell</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289717"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22206497"></A>For general bodies: null. </P>
<P>
<A NAME="50487361_pgfId-22206502"></A>For solid bodies: the first shell in one of the solid regions. </P>
<P>
<A NAME="50487361_pgfId-4956813"></A>For other bodies: the first shell in one of the regions.This field is <STRONG>
obsolete</STRONG>, and should be ignored by applications reading XT data. When writing XT data, it shall be set as above.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289721"></A><CODE>
boundary_surface</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289723"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289725"></A>Head of chain of surfaces attached directly or indirectly to faces or edges or fins. For a child body, these fields are always null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289727"></A><CODE>
boundary_curve</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289729"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289731"></A>Head of chain of curves attached directly or indirectly to edges or faces or fins. For a child body, these fields are always null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289733"></A><CODE>
boundary_point</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289735"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289737"></A>Head of chain of points attached to vertices. For a child body, these fields are always null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18604096"></A><CODE>
boundary_mesh</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18604098"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18604100"></A>Head of chain of meshes attached directly or indirectly to faces or edges or fins. For a child body, these fields are always null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18604112"></A><CODE>
boundary_polyline</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18604114"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-18604116"></A>Head of chain of polylines attached directly or indirectly to edges or faces or fins. For a child body, these fields are always null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289739"></A><CODE>
region</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289741"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231910"></A>Head of chain of regions in body; this is the infinite region.</P>
<P>
<A NAME="50487361_pgfId-22231911"></A>For a compound body, this is the head of chain of regions comprising of all the regions of all the child bodies. The regions of each child body are contiguous in this chain and the order of the regions corresponds to the order of the children. </P>
<P>
<A NAME="50487361_pgfId-289745"></A>For a child body, this field points to the first region of the child. For an empty compound body (i.e. one without any children), this field is null.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289747"></A><CODE>
edge</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289749"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289751"></A>Head of chain of all non-wireframe edges in body. For a compound body, this is the head of a chain of all non-wireframe edges in all the children.For a child body, this field is null.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289753"></A><CODE>
vertex</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289755"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289757"></A>Head of chain of all vertices in body. For a compound body, this is the head of a chain of all vertices in all the children.For a child body, this field is null.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289759"></A><CODE>
index_map_offset</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289761"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289763"></A>Shallbe set to 0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289765"></A><CODE>
index_map</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289767"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289769"></A>Shall be set to null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289771"></A><CODE>
node_id_index_map</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289773"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289775"></A>Shallbe set to null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289777"></A><CODE>
schema_embedding_map</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289779"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289781"></A>Shallbe set to null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289783"></A><CODE>
child</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289785"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289787"></A>For a compound body, this is the first child body. the children are chained using the <CODE>
next</CODE>
 and <CODE>
previous</CODE>
 pointers. For a standard or child body, this is null.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289789"></A><CODE>
lowest_node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289791"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289793"></A>For a standard or compound body, this field is zero. For a child body, this is the lowest node id of the entities in the child body.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-19885692"></A><CODE>
mesh_offset_data</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-19885694"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-19885696"></A>Data for embedded meshes. If the XT file does not contain embedded meshes, this field must be set to null.</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289795"></A>The value of the ‘state’ field should be ignored, as should any nodes of type ‘KEY’ referenced by the body. If XT data is constructed without using the Parasolid Kernel, the state field should be set to 1, and the key to null.</P>
<P>
<A NAME="50487361_pgfId-289796"></A>The <CODE>
highest_node_id</CODE>
 gives the highest identifier of any node in this body. Most nodes in a body which are visible at the PK interface have identifier, which are non-zero integers unique to that node within the body. Applications writing XT data shall ensure that identifiers are present and distinct. The details of which nodes have node ids are given in an appendix.</P>
<P>
<A NAME="50487361_pgfId-289797"></A>The fields <CODE>
index_map_offset</CODE>
, <CODE>
index_map, node_id_index_map</CODE>
, and <CODE>
schema_embedding_map</CODE>
 are used for Indexed Transmit; applications writing XT data shall ensure that these fields are set to 0 and null.</P>
<P>
<A NAME="50487361_pgfId-20088479"></A>The <CODE>
mesh_offset_data</CODE>
 field is used for embedded mesh data.</P>
<P>
<A NAME="50487361_pgfId-289809"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-289801"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-483919"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-483927"></A>    SCH_solid_body     = 1,</PRE>
<PRE><A NAME="50487361_pgfId-483935"></A>    SCH_wire_body      = 2,</PRE>
<PRE><A NAME="50487361_pgfId-483943"></A>    SCH_sheet_body     = 3,</PRE>
<PRE><A NAME="50487361_pgfId-483951"></A>    SCH_general_body   = 6</PRE>
<PRE><A NAME="50487361_pgfId-483959"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-483967"></A>    SCH_body_type;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289818"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-289812"></A>typedef short short enum</PRE>
<PRE><A NAME="50487361_pgfId-483975"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-483983"></A>    SCH_nom_geom_off = 1,              --- Entirely off</PRE>
<PRE><A NAME="50487361_pgfId-483991"></A>    SCH_nom_geom_on  = 2,              --- Entirely on</PRE>
<PRE><A NAME="50487361_pgfId-483999"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-484007"></A>    SCH_nom_geom_state_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289854"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-289821"></A>struct BODY_s                     //Body</PRE>
<PRE><A NAME="50487361_pgfId-5311025"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-5311026"></A>    int                           highest_node_id;       // $d</PRE>
<PRE><A NAME="50487361_pgfId-5311027"></A>    union  ATTRIB_FEAT_u          attributes_features;   // $p</PRE>
<PRE><A NAME="50487361_pgfId-484031"></A>    struct LIST_s                *attribute_chains;      // $p</PRE>
<PRE><A NAME="50487361_pgfId-21667269"></A>    union  LATTICE_u             *lattice;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-484039"></A>    union  SURFACE_u              surface;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-484047"></A>    union  CURVE_u                curve;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-484055"></A>    struct POINT_s               *point;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-22231962"></A>    union SURFACE_u               mesh;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-22231963"></A>    union CURVE_u                 polyline;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-484063"></A>    struct KEY_s                 *key;                   // $p</PRE>
<PRE><A NAME="50487361_pgfId-484071"></A>    double                        res_size;              // $f</PRE>
<PRE><A NAME="50487361_pgfId-484079"></A>    double                        res_linear;            // $f</PRE>
<PRE><A NAME="50487361_pgfId-484087"></A>    struct INSTANCE_s            *ref_instance;          // $p</PRE>
<PRE><A NAME="50487361_pgfId-484095"></A>    struct BODY_s                *next;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484103"></A>    struct BODY_s                *previous;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-484111"></A>    SCH_part_state                state;                 // $u</PRE>
<PRE><A NAME="50487361_pgfId-22301451"></A>    union BODY_OWNER_u            owner;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-484127"></A>    SCH_body_type                 body_type;             // $u</PRE>
<PRE><A NAME="50487361_pgfId-484135"></A>    SCH_nom_geom_state_t          nom_geom_state;        // $u</PRE>
<PRE><A NAME="50487361_pgfId-484143"></A>    struct SHELL_s               *shell;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-484151"></A>    union  SURFACE_u              boundary_surface;      // $p</PRE>
<PRE><A NAME="50487361_pgfId-484159"></A>    union  CURVE_u                boundary_curve;        // $p</PRE>
<PRE><A NAME="50487361_pgfId-484167"></A>    struct POINT_s               *boundary_point;        // $p</PRE>
<PRE><A NAME="50487361_pgfId-22231973"></A>    union SURFACE_u               boundary_mesh;         // $p</PRE>
<PRE><A NAME="50487361_pgfId-22231974"></A>    union CURVE_u                 boundary_polyline;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-484175"></A>    struct REGION_s              *region;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-484183"></A>    struct EDGE_s                *edge;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484191"></A>    struct VERTEX_s              *vertex;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-484199"></A>    int                           index_map_offset;      // $d</PRE>
<PRE><A NAME="50487361_pgfId-484207"></A>    struct INT_VALUES_s          *index_map;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-484215"></A>    struct INT_VALUES_s          *node_id_index_map;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-484223"></A>    struct INT_VALUES_s          *schema_embedding_map;  // $p</PRE>
<PRE><A NAME="50487361_pgfId-22301456"></A>struct BODY_s   *child;  //$p</PRE>
<PRE><A NAME="50487361_pgfId-19361361"></A>int   lowest_node_id;  //$d</PRE>
<PRE><A NAME="50487361_pgfId-22301462"></A>struct MESH_OFFSET_data_s  *mesh_offset_data;  //$p</PRE>
<PRE><A NAME="50487361_pgfId-484247"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-484255"></A>typedef struct BODY_s *BODY;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22300531"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-22300526"></A>union BODY_OWNER_u </PRE>
<PRE><A NAME="50487361_pgfId-22300527"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-22300528"></A>struct WORLD_s  *world; </PRE>
<PRE><A NAME="50487361_pgfId-22300529"></A>struct BODY_s  *body; </PRE>
<PRE><A NAME="50487361_pgfId-22300530"></A>};</PRE>
</TD>
</TR>
</TABLE>

<H4>
<A NAME="50487361_pgfId-21344984"></A>5.3.4.1 Attaching geometry to topology</H4>
<P>
<A NAME="50487361_pgfId-289865"></A>The faces which reference a surface are chained together, surface-&gt;owner is the head of this chain. Similarly the edges which reference the same curve are chained together. Fins do not share curves.</P>
<P>
<A NAME="50487361_pgfId-289866"></A>Geometry in parts may be chained into one of the three boundary geometry chains, or one of the three construction geometry chains. A geometric node will fall into one of the following cases:</P>
<P>
<A NAME="50487361_pgfId-289916"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289869"></A>Geometry</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289871"></A>Owner</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289873"></A>Whether chained</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289875"></A>Attached to face</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289877"></A>face</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289879"></A>In boundary_surface chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289881"></A>Attached to edge or fin</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289883"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289885"></A>In boundary_curve chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289887"></A>Attached to vertex</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289889"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289891"></A>In boundary_point chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289893"></A>Indirectly attached to face or edge or fin</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289895"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289897"></A>In boundary_surface chain or boundary_curve chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289899"></A>Construction geometry</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289901"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289903"></A>In lattice, surface, curve or point chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289905"></A>2D B-curve in SP-curve</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289907"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289909"></A>Not chained</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289911"></A>type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289913"></A>char</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289915"></A>Region type - solid (‘S’) or void (‘V’)</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289917"></A>Here ‘indirectly attached’ means geometry which is a dependent of a dependent of (... etc) of geometry attached to an edge, face or fin.</P>
<P>
<A NAME="50487361_pgfId-289918"></A>Geometry in a construction chain may reference geometry in a boundary chain, but not vice-versa.</P>



<H3>
<A NAME="50487361_pgfId-289919"></A>	5.3.5 	Region</H3>
<P>
<A NAME="50487361_pgfId-289975"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289922"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289924"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289926"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289928"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289930"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289932"></A>Identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289934"></A><CODE>
attributes_features</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289936"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289938"></A>Head of chain of attributes of region and member of features of region</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289940"></A><CODE>
body</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289942"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289944"></A>Body of region. For a region in a child body, this field references the parent compound body.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289946"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289948"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289950"></A>Next region in body</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289952"></A><CODE>
prev</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289954"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289956"></A>Previous region in body</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289958"></A><CODE>
shell</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289960"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289962"></A>Head of singly-linked chain of shells in region</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289964"></A><CODE>
type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289966"></A>char</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289968"></A>Region type - solid (‘S’) or void (‘V’)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289970"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289972"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289974"></A>For a region in a child body, this field references the child body. Otherwise, the field is null.</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-289990"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-289978"></A>struct REGION_s                   //Region</PRE>
<PRE><A NAME="50487361_pgfId-5669684"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-5669685"></A>    int                           node_id;               // $d</PRE>
<PRE><A NAME="50487361_pgfId-5669686"></A>    union  ATTRIB_FEAT_u          attributes_features;   // $p</PRE>
<PRE><A NAME="50487361_pgfId-484319"></A>    struct BODY_s                *body;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484327"></A>    struct REGION_s              *next;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484335"></A>    struct REGION_s              *previous;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-484343"></A>    struct SHELL_s               *shell;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-484351"></A>    char                          type;                  // $c</PRE>
<PRE><A NAME="50487361_pgfId-22301527"></A>struct BODY_s  *owner:  //$p</PRE>
<PRE><A NAME="50487361_pgfId-484367"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-484375"></A>typedef struct REGION_s *REGION;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-289991"></A>	5.3.6 	Shell</H3>
<P>
<A NAME="50487361_pgfId-290031"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289994"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289996"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-289998"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290000"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290002"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-5724358"></A>Identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290006"></A><CODE>
attributes_features</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290008"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290010"></A>Head of chain of attributes of shell</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290012"></A><CODE>
body</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290014"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290016"></A>For standard bodies: For shells in wire and sheet bodies, and for shells bounding a solid region of a solid body, this is set to the body of the shell. For shells in general bodies, or void shells in solid bodies, it is null.</P>
<P>
<A NAME="50487361_pgfId-22301547"></A>For shells in child bodies, this field is set to the parent compound body if the child has type wire or sheet, or if it has type solid and the shell belongs to a solid region. Otherwise, this field is null.</P>
<P>
<A NAME="50487361_pgfId-290018"></A>This field is <STRONG>
obsolete</STRONG>, and should be ignored by applications reading XT data. When writing XT data, it shall be set as above.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290020"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290022"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290024"></A>Next shell in region</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290026"></A><CODE>
face</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290028"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290030"></A>Head of chain of back-faces of shell (i.e. faces with face normal pointing out of region of shell).</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-438724"></A><CODE>
edge</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-438726"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-438728"></A>Head of chain of wire-frame edges of shell.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-438824"></A><CODE>
vertex</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-438826"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-438828"></A>If shell consists of a single vertex, this is it; else null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-438961"></A><CODE>
region</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-438963"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-438965"></A>Region of shell</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-439012"></A><CODE>
front_face</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-439014"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-439016"></A>Head of chain of front-faces of shell (i.e. faces with face normal pointing into region of shell).</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290047"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290034"></A>struct SHELL_s                    //Shell</PRE>
<PRE><A NAME="50487361_pgfId-5778598"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-5778599"></A>    int                           node_id;               // $d</PRE>
<PRE><A NAME="50487361_pgfId-5778600"></A>    union  ATTRIB_FEAT_u          attributes_features;   // $p</PRE>
<PRE><A NAME="50487361_pgfId-484407"></A>    struct BODY_s                *body;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484415"></A>    struct SHELL_s               *next;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484423"></A>    struct FACE_s                *face;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484431"></A>    struct EDGE_s                *edge;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484439"></A>    struct VERTEX_s              *vertex;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-484447"></A>    struct REGION_s              *region;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-484455"></A>    struct FACE_s                *front_face;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-484463"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-484471"></A>typedef struct SHELL_s *SHELL;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-290048"></A>	5.3.7 	Face</H3>
<P>
<A NAME="50487361_pgfId-290140"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290051"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290053"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290055"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290057"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290059"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290061"></A>Identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290063"></A><CODE>
attributes_features</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290065"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290067"></A>Head of chain of attributes of face and <CODE>
member_of_</CODE>
feature of face.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290069"></A><CODE>
tolerance</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290071"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290073"></A>Not used (null double)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290075"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290077"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290079"></A>Next back-face in shell</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290081"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290083"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290085"></A>Previous back-face in shell</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290087"></A><CODE>
loop</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290089"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290091"></A>Head of singly-linked chain of loops</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290093"></A><CODE>
shell</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290095"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290097"></A>Shell of which this is a back-face</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290099"></A><CODE>
surface</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290101"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290103"></A>Surface of face</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290105"></A><CODE>
sense</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290107"></A>char</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290109"></A>Face sense - positive (‘+’) or negative (‘-’)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290111"></A><CODE>
next_on_surface</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290113"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290115"></A>Next in chain of faces sharing the surface of this face</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290117"></A><CODE>
previous_on_surface</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290119"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290121"></A>Previous in chain of faces sharing the surface of this face</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290123"></A><CODE>
next_front</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290125"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290127"></A>Next front-face in shell</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290129"></A><CODE>
previous_front</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290131"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290133"></A>Previous front-face in shell</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290135"></A><CODE>
front_shell</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290137"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290139"></A>Shell of which this is a front-face</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290161"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290143"></A>struct FACE_s                     //Face</PRE>
<PRE><A NAME="50487361_pgfId-5937434"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-5937435"></A>    int                           node_id;               // $d</PRE>
<PRE><A NAME="50487361_pgfId-5937436"></A>    union ATTRIB_FEAT_u          attributes_features;   // $</PRE>
<PRE><A NAME="50487361_pgfId-484503"></A>    double                        tolerance;             // $f</PRE>
<PRE><A NAME="50487361_pgfId-484511"></A>    struct FACE_s                *next;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484519"></A>    struct FACE_s                *previous;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-484527"></A>    struct LOOP_s                *loop;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484535"></A>    struct SHELL_s               *shell;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-484543"></A>    union  SURFACE_u              surface;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-484551"></A>    char                          sense;                 // $c</PRE>
<PRE><A NAME="50487361_pgfId-484559"></A>    struct FACE_s                *next_on_surface;       // $p</PRE>
<PRE><A NAME="50487361_pgfId-484567"></A>    struct FACE_s                *previous_on_surface;   // $p</PRE>
<PRE><A NAME="50487361_pgfId-484575"></A>    struct FACE_s                *next_front;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-484583"></A>    struct FACE_s                *previous_front;        // $p</PRE>
<PRE><A NAME="50487361_pgfId-484591"></A>    struct SHELL_s               *front_shell;           // $p</PRE>
<PRE><A NAME="50487361_pgfId-484599"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-484607"></A>typedef struct FACE_s *FACE;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-290162"></A>	5.3.8 	Loop</H3>
<P>
<A NAME="50487361_pgfId-290200"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290165"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290167"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290169"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290171"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290173"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290175"></A>Identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-6067502"></A>attributes_features</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290179"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290181"></A>Head of chain of attributes of loop</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290183"></A><CODE>
halfedge</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290185"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290187"></A>One of ring of fins of loop</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290189"></A><CODE>
face</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290191"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290193"></A>Face of loop</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290195"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290197"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290199"></A>Next loop in face</P>
</TD>
</TR>
</TABLE>

<H4>
<A NAME="50487361_pgfId-21344990"></A>5.3.8.1 Isolated loops</H4>
<P>
<A NAME="50487361_pgfId-390972"></A>An isolated loop (one consisting of a single vertex) does not refer directly to a vertex, but points to a fin which refers to that vertex. This isolated fin has <CODE>
halfedge-&gt;forward = halfedge-&gt;backward = halfedge</CODE>
, and <CODE>
halfedge-&gt;other = halfedge-&gt;curve = halfedge-&gt;edge = null</CODE>
. Its sense is not significant. The fin is chained into the chain of fins referencing the isolated vertex.</P>
<P>
<A NAME="50487361_pgfId-290214"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290205"></A>struct LOOP_s                     //Loop</PRE>
<PRE><A NAME="50487361_pgfId-6467786"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-6124444"></A>    int                           node_id;               // $d</PRE>
<PRE><A NAME="50487361_pgfId-6124445"></A>    union  ATTRIB_FEAT_u          attributes_features;   // $p</PRE>
<PRE><A NAME="50487361_pgfId-6681177"></A>    struct HALFEDGE_s            *<CODE>halfedge</CODE>
;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-484647"></A>    struct FACE_s                *face;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484655"></A>    struct LOOP_s                *next;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484663"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-484671"></A>typedef struct LOOP_s *LOOP;</PRE>
</TD>
</TR>
</TABLE>



<H3>
<A NAME="50487361_pgfId-290215"></A>	5.3.9 	Fin</H3>
<P>
<A NAME="50487361_pgfId-22300569"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<ADDRESS>
<A NAME="50487361_pgfId-22300568"></A>Note: Fins are referred to as halfedges in the PK Interface.</ADDRESS><BR>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290283"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290218"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290220"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290222"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290224"></A><CODE>
attributes_features</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290226"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290228"></A>Head of chain of attributes of fin</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290230"></A><CODE>
loop</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290232"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290234"></A>Loop of fin</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290236"></A><CODE>
forward</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290238"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290240"></A>Next fin around loop</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290242"></A><CODE>
backward</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290244"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290246"></A>Previous fin around loop</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290248"></A><CODE>
vertex</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290250"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290252"></A>Forward vertex of fin</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290254"></A><CODE>
other</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290256"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290258"></A>Next fin around edge, clockwise looking along edge</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290260"></A><CODE>
edge</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290262"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290264"></A>Edge of fin</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290266"></A><CODE>
curve</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290268"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290270"></A>For a non-dummy fin of a tolerant edge, this will be a trimmed SP-curve, otherwise null.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290272"></A><CODE>
next_at_vx</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290274"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290276"></A>Next fin referencing the vertex of this fin</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290278"></A><CODE>
sense</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290280"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290282"></A>Positive (‘+’) if the fin direction is parallel to that of its edge, else negative (‘-’)</P>
</TD>
</TR>
</TABLE>

<H4>
<A NAME="50487361_pgfId-21345034"></A>5.3.9.1 Dummy fins</H4>
<P>
<A NAME="50487361_pgfId-409460"></A>An application will see edges as having any number of fins, including zero. However internally, they have at least two. This is so that the forward and backward vertices of an edge can always be found as <CODE>
edge-&gt;halfedge-&gt;vertex</CODE>
 and <CODE>
edge-&gt;halfedge-&gt;other-&gt;vertex</CODE>
 respectively - the first one being a positive fin, the second a negative fin. If an edge does not have both a positive and a negative externally-visible fin, dummy fins will exist for this purpose. Dummy fins have <CODE>
halfedge-&gt;loop = halfedge-&gt;forward = halfedge-&gt;backward = halfedge-&gt;curve = halfedge-&gt;next_at_vx = null</CODE>
. For example the boundaries of a sheet always have one dummy fin. See <A HREF="xt_chap.06.html#50487361_65263">Section 5.3.9.2, “Fin chain at a vertex”</A> for more information on fin chains at a vertex.</P>
<P>
<A NAME="50487361_pgfId-408351"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-6661141"></A>struct HALFEDGE_s  //<CODE>Halfedge</CODE>
</PRE>
<PRE><A NAME="50487361_pgfId-6525516"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-6525518"></A>    union  ATTRIB_FEAT_u         attributes_features;   // $p</PRE>
<PRE><A NAME="50487361_pgfId-444289"></A>    struct HALFEDGE_s           *forward;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-484703"></A>    struct HALFEDGE_s           *backward;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-484711"></A>    struct VERTEX_s             *vertex;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-484719"></A>    struct HALFEDGE_s           *other;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-484727"></A>    struct EDGE_s               *edge;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484735"></A>    union  CURVE_u               curve;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-484743"></A>    struct HALFEDGE_s           *next_at_vx;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-484751"></A>    char                         sense;                 // $c</PRE>
<PRE><A NAME="50487361_pgfId-484759"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-484767"></A>typedef struct HALFEDGE_s *HALFEDGE;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-22230836"></A>5.3.9.2 <A NAME="50487361_65263"></A>Fin chain at a vertex</H4>
<P>
<A NAME="50487361_pgfId-22230837"></A>The fin chain at a vertex only includes fins which are primary or secondary fins i.e <CODE>
edge-&gt;halfedge </CODE>
or <CODE>
edge-&gt;halfedge-&gt;other</CODE>
 for some edge. All fins going into a vertex have that vertex as their <CODE>
halfedge-&gt;vertex</CODE>
 but only those fins which are primary or secondary fins appear in the fin chains at the vertex. For any edge with a vertex or vertices, regardless of how many fins it has, the primary fin will be in the fin chain of the vertex towards which the edge points. The secondary fin will be in the fin chain of the vertex away from which the edge points. Any other fin will not appear in either fin chain at a vertex.</P>



<H3>
<A NAME="50487361_pgfId-408352"></A>	5.3.10 	Vertex</H3>
<P>
<A NAME="50487361_pgfId-290367"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290306"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290308"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290310"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290312"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290314"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290316"></A>Identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290318"></A><CODE>
attributes_features</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290320"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290322"></A>Head of chain of attributes of vertex and <CODE>
member_of_</CODE>
feature of vertex</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290324"></A><CODE>
halfedge</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290326"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290328"></A>Head of singly-linked chain of fins referencing this vertex</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290330"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290332"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290334"></A>Previous vertex in body</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290336"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290338"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290340"></A>Next vertex in body</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290342"></A><CODE>
point</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290344"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290346"></A>Point of vertex</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290348"></A><CODE>
tolerance</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290350"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290352"></A>Tolerance of vertex (null-double for accurate vertex)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290354"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290356"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290358"></A>Owning body (for non-acorn vertices) or shell (for acorn vertices). If the vertex is in a child body and it’s not an acorn vertex then the field references the parent compound body.</P>
</TD>
</TR>
</TABLE>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290361"></A>union SHELL_OR_BODY_u</PRE>
<PRE><A NAME="50487361_pgfId-484775"></A>    (</PRE>
<PRE><A NAME="50487361_pgfId-484783"></A>    struct BODY_s              *body;</PRE>
<PRE><A NAME="50487361_pgfId-484791"></A>    struct SHELL_s             *shell;</PRE>
<PRE><A NAME="50487361_pgfId-484799"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-484807"></A>typedef union SHELL_OR_BODY_u SHELL_OR_BODY;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290382"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290370"></A>struct VERTEX_s                   //Vertex</PRE>
<PRE><A NAME="50487361_pgfId-6732001"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-6732002"></A>    int                           node_id;               // $d</PRE>
<PRE><A NAME="50487361_pgfId-6732003"></A>    union  ATTRIB_FEAT_u          attributes_features;   // $p</PRE>
<PRE><A NAME="50487361_pgfId-6960479"></A>    struct HALFEDGE_s            *<CODE>halfedge</CODE>
;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-484847"></A>    struct VERTEX_s              *previous;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-484855"></A>    struct VERTEX_s              *next;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484863"></A>    struct POINT_s               *point;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-484871"></A>    double                        tolerance;             // $f</PRE>
<PRE><A NAME="50487361_pgfId-484879"></A>    union SHELL_OR_BODY_u         owner;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-484887"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-484895"></A>typedef struct VERTEX_s *VERTEX;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-290383"></A>	5.3.11 	Edge</H3>
<P>
<A NAME="50487361_pgfId-290451"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290386"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290388"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290390"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290392"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290394"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290396"></A>Identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290398"></A><CODE>
attributes_features</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290400"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290402"></A>Head of chain of attributes of edge and <CODE>
member_of_feature</CODE>
 of edge</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290404"></A><CODE>
tolerance</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290406"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290408"></A>Tolerance of edge (null-double for accurate edges)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290410"></A><CODE>
halfedge</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290412"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290414"></A>Head of singly-linked chain of fins around edge</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290416"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290418"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290420"></A>Previous edge in body or shell</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290422"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290424"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290426"></A>Next edge in body or shell</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290428"></A><CODE>
curve</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290430"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290432"></A>Curve of edge, zero for tolerant edge. If edge is accurate, but any of its vertices are tolerant, this will be a trimmed curve.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290434"></A><CODE>
next_on_curve</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290436"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290438"></A>Next in chain of edges sharing the curve of this edge</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290440"></A><CODE>
previous_on_curve</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290442"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290444"></A>Previous in chain of edges sharing the curve of this edge</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290446"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290448"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290450"></A>Owning body (for non-wireframe edges) or shell (for wireframe edges). If the edge is in a child body and it is not a wireframe edge, then the field references the parent compound body.</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290468"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290454"></A>struct EDGE_s                     //Edge</PRE>
<PRE><A NAME="50487361_pgfId-7260458"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-7260459"></A>    int                           node_id;               // $d</PRE>
<PRE><A NAME="50487361_pgfId-7260460"></A>    union  ATTRIB_FEAT_u          attributes_features;   // $p</PRE>
<PRE><A NAME="50487361_pgfId-7260472"></A>    double                        tolerance;             // $f</PRE>
<PRE><A NAME="50487361_pgfId-7260484"></A>    struct HALFEDGE_s            *<CODE>halfedge</CODE>
;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-484943"></A>    struct EDGE_s                *previous;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-484951"></A>    struct EDGE_s                *next;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-484959"></A>    union  CURVE_u                curve;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-484967"></A>    struct EDGE_s;               *next_on_curve          // $p</PRE>
<PRE><A NAME="50487361_pgfId-484975"></A>    struct EDGE_s                *previous_on_curve;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-484983"></A>    union  SHELL_OR_BODY_u        owner;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-484991"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-484999"></A>typedef struct EDGE_s *EDGE;</PRE>
</TD>
</TR>
</TABLE>




<P ALIGN=RIGHT>
<A HREF="#topofdoc"><I>[back to top]</I></A>
</P>

<HR>

<H1>
<A NAME="50487361_pgfId-395484"></A>5.4	Associated Data


</H1>

<H3>
<A NAME="50487361_pgfId-395485"></A>	5.4.1 	List</H3>
<P>
<A NAME="50487361_pgfId-395565"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395488"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395490"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395492"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395494"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395496"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395498"></A>Zero</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395500"></A><CODE>
list_type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395502"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395504"></A>Always</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395506"></A><CODE>
notransmit</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395508"></A>logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395510"></A>Ignore</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395512"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395514"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395516"></A>Owning part</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395518"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395520"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395522"></A>Ignore</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395524"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395526"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395528"></A>Ignore</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395530"></A><CODE>
list_length</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395532"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395534"></A>Length of list (&gt;=0)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395536"></A><CODE>
block_length</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395538"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395540"></A>Length of each block of list. Always 20</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395542"></A><CODE>
size_of_entry</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395544"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395546"></A>Ignore</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395548"></A><CODE>
finger_index</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395550"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395552"></A>Any integer between 1 and list-&gt;list_length (set to 1 if length is zero). Ignore</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395554"></A><CODE>
finger_block</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395556"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395558"></A>Any block e.g. the first one. Ignore</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395560"></A><CODE>
list_block</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395562"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-395564"></A>Head of singly-linked chain of pointer list blocks</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290551"></A>Lists only occur in part data as the list of attributes referenced by a part.</P>
<P>
<A NAME="50487361_pgfId-290559"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-444914"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-485007"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-485015"></A>    LIS_pointer = 4</PRE>
<PRE><A NAME="50487361_pgfId-485023"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-485031"></A>    LIS_type_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290567"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290562"></A>union LIS_BLOCK_u</PRE>
<PRE><A NAME="50487361_pgfId-485039"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-485047"></A>    struct POINTER_LIS_BLOCK_s    *pointer_block;</PRE>
<PRE><A NAME="50487361_pgfId-485055"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-485063"></A>typedef union LIS_BLOCK_u     LIS_BLOCK;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-444958"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-444964"></A>union LIS_OWNER_u</PRE>
<PRE><A NAME="50487361_pgfId-485071"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-485079"></A>    struct BODY_s                 *body;</PRE>
<PRE><A NAME="50487361_pgfId-485087"></A>    struct ASSEMBLY_s             *assembly;</PRE>
<PRE><A NAME="50487361_pgfId-485095"></A>    struct WORLD_s                *world;</PRE>
<PRE><A NAME="50487361_pgfId-485103"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-485111"></A>typedef union LIST_OWNER_u    LIST_OWNER;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290586"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290570"></A>struct LIST_s                     //List Header</PRE>
<PRE><A NAME="50487361_pgfId-7508358"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-7508359"></A>    int                           node_id;               // $d</PRE>
<PRE><A NAME="50487361_pgfId-485135"></A>    LIS_type_t                    list_type;             // $u</PRE>
<PRE><A NAME="50487361_pgfId-485143"></A>    logical                       notransmit;            // $l</PRE>
<PRE><A NAME="50487361_pgfId-485151"></A>    union  LIST_OWNER_u           owner;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-485159"></A>    struct LIST_s                *next;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-485167"></A>    struct LIST_s                *previous;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-485175"></A>    int                           list_length;           // $d</PRE>
<PRE><A NAME="50487361_pgfId-485183"></A>    int                           block_length;          // $d</PRE>
<PRE><A NAME="50487361_pgfId-485191"></A>    int                           size_of_entry;         // $d</PRE>
<PRE><A NAME="50487361_pgfId-485199"></A>    int                           finger_index;          // $d</PRE>
<PRE><A NAME="50487361_pgfId-485207"></A>    union  LIS_BLOCK_u            finger_block;          // $p</PRE>
<PRE><A NAME="50487361_pgfId-485215"></A>    union  LIS_BLOCK_u            list_block;            // $p</PRE>
<PRE><A NAME="50487361_pgfId-485223"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-485231"></A>typedef struct LIST_s *LIST;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-290587"></A>	5.4.2 	Pointer_lis_block</H3>
<P>
<A NAME="50487361_pgfId-290631"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290590"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290592"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290594"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290596"></A><CODE>
n_entries</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290598"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290600"></A>Number of entries in this block (0 &lt;= n_entries &lt;= 20). Only the first block may have n_entries = 0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290602"></A><CODE>
index_map_offset</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290604"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290606"></A>Shallbe set to 0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290608"></A><CODE>
next_block</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290610"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290612"></A>Next pointer list block in chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290614"></A><CODE>
entries[20]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290616"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290618"></A>Pointers in block, those beyond n_entries shall be zero</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290632"></A>When the <CODE>
pointer_lis_block</CODE>
 is used as the root node in XT data containing more than one part, the restriction <CODE>
n_entries &lt;= 20</CODE>
 does not apply.</P>
<P>
<A NAME="50487361_pgfId-290633"></A>The <CODE>
index_map_offset</CODE>
 field is used for Indexed Transmit; applications writing XT data shall ensure this field is set to 0.</P>
<P>
<A NAME="50487361_pgfId-290644"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290636"></A>struct POINTER_LIS_BLOCK_s        //Pointer List</PRE>
<PRE><A NAME="50487361_pgfId-485239"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-485247"></A>    int                           n_entries;            // $d</PRE>
<PRE><A NAME="50487361_pgfId-485255"></A>    int                           index_map_offset      // $d</PRE>
<PRE><A NAME="50487361_pgfId-485263"></A>    struct POINTER_LIS_BLOCK_s   *next_block;           // $p</PRE>
<PRE><A NAME="50487361_pgfId-485271"></A>    void                         *entries[ 1 ];         // $p[]</PRE>
<PRE><A NAME="50487361_pgfId-485279"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-485287"></A>typedef struct POINTER_LIS_BLOCK_s *POINTER_LIS_BLOCK;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-290645"></A>	5.4.3 	Att_def_id</H3>
<P>
<A NAME="50487361_pgfId-290659"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290648"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290650"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290652"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290654"></A><CODE>
string[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290656"></A>char</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290658"></A>String name e.g. &quot;SDL/TYSA_COLOUR&quot;</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290667"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290662"></A>struct ATT_DEF_ID_s  //name field type for attrib def.</PRE>
<PRE><A NAME="50487361_pgfId-486954"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-486962"></A>    char                          string[1];            // $c[]</PRE>
<PRE><A NAME="50487361_pgfId-486970"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-486978"></A>typedef struct ATT_DEF_ID_s *ATT_DEF_ID;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-290668"></A>	5.4.4 	Field_names</H3>
<P>
<A NAME="50487361_pgfId-290682"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290671"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290673"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290675"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290677"></A><CODE>
names[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290679"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-290681"></A>Array of field names - unicode or char</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290691"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290685"></A>typedef union FIELD_NAME_u</PRE>
<PRE><A NAME="50487361_pgfId-486986"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-486994"></A>    struct CHAR_VALUES_s         *name</PRE>
<PRE><A NAME="50487361_pgfId-487002"></A>    struct UNICODE_VALUES_s      *uname</PRE>
<PRE><A NAME="50487361_pgfId-487010"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-487018"></A>    FIELD_NAME_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290699"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290694"></A>struct FIELD_NAME_s               //attribute field name</PRE>
<PRE><A NAME="50487361_pgfId-487026"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-487034"></A>    union  FIELD_NAME_u           names[1];       // $p[]</PRE>
<PRE><A NAME="50487361_pgfId-487042"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-487050"></A>typedef struct FIELD_NAME_s *FIELD_NAME;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-471459"></A>	5.4.5 	Attrib_def</H3>
<P>
<A NAME="50487361_pgfId-22300617"></A>The XT Format provides a set of pre-defined attribute definitions known as system attribute definitions. See <A HREF="xt_chap.08.html#50487410_61421">Appendix A, “System Attribute Definitions”</A>, for more information on these. </P>
<P>
<A NAME="50487361_pgfId-22230846"></A>Attribute definitions have the following form in the XT format:</P>
<P>
<A NAME="50487361_pgfId-471807"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471760"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471762"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471764"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471766"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471768"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471770"></A>Next attribute definition. This can be ignored, except in partition data.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471772"></A><CODE>
identifier</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471774"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471776"></A>Pointer to a string name</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471778"></A><CODE>
type_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471780"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471782"></A>Numeric id, e.g. 8001 for color. 9000 for user-defined attribute definitions</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471784"></A><CODE>
actions[8]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471786"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471788"></A>Required actions on various events</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471790"></A><CODE>
field_names</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471792"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471794"></A>Names of fields (unicode or char)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471796"></A><CODE>
legal_owners[14]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471798"></A>logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471800"></A>Allowed owner types</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471802"></A><CODE>
fields[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471804"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-471806"></A>Array of field types. Note that the number of fields is given by the length of the variable length part of this node, i.e. the integer following the node type in the XT data.</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290751"></A>The <CODE>
legal_owners</CODE>
 array is an array of logicals determining which node types may own this type of attribute.</P>
<P>
<A NAME="50487361_pgfId-290752"></A>e.g. if faces are allowed <CODE>
attrib_def -&gt; legal_owners [SCH_fa_owner] = true</CODE>
.</P>
<P>
<A NAME="50487361_pgfId-290753"></A>Note that if the XT data contains user fields, the ‘fields’ field of an attribute definition may contain extra values, set to zero. These are to be ignored.</P>
<P>
<A NAME="50487361_pgfId-290754"></A>The ‘actions’ field in an attribute definition defines the behaviour of the attribute when an event (rotate, scale, translate, reflect, split, merge, transfer, change) occurs. The actions are in table F.49:</P>
<P>
<A NAME="50487361_pgfId-472059"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472028"></A>Action</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472030"></A>Explanation</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472032"></A><CODE>
do_nothing</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472034"></A>Leave attribute as it is</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472036"></A><CODE>
delete</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472038"></A>Delete the attribute</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472040"></A><CODE>
transform</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472042"></A>Transform the transformable fields (point, vector, direction, axis) by appropriate part of transformation</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472044"></A><CODE>
propagate</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472046"></A>Copy attribute onto split-off node</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472048"></A><CODE>
keep_sub_dominant</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472050"></A>Move attribute(s) from deleted node onto surviving node in a merge, but any such attributes already on the surviving node are deleted</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472052"></A><CODE>
keep_if_equal</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472054"></A>Keep attribute if present on both nodes being merged, with the same field values</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472056"></A><CODE>
combine</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-472058"></A>Move attribute(s) from deleted node onto surviving node, in a merge</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-22221495"></A>The XT attribute classes 1-7 correspond as follows:</P>
<P>
<A NAME="50487361_pgfId-22221641"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221498"></A>&nbsp;</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221500"></A>split</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221502"></A>merge</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221504"></A>transfer</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221506"></A>change</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221508"></A>rotate</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221510"></A>scale</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221512"></A>translate</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221514"></A>reflect</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221516"></A>class 1</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221518"></A>propagate</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221520"></A>keep_equal</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221522"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221524"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221526"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221528"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221530"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221532"></A>do_nothing</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221534"></A>class 2</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221536"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221538"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221540"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221542"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221544"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221546"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221548"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221550"></A>do_nothing</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221552"></A>class 3</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221554"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221556"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221558"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221560"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221562"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221564"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221566"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221568"></A>delete</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221570"></A>class 4</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221572"></A>propagate</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221574"></A>keep_equal</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221576"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221578"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221580"></A>transform</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221582"></A>transform</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221584"></A>transform</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221586"></A>transform</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221588"></A>class 5</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221590"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221592"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221594"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221596"></A>delete</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221598"></A>transform</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221600"></A>transform</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221602"></A>transform</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221604"></A>transform</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221606"></A>class 6</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221608"></A>propagate</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221610"></A>combine</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221612"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221614"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221616"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221618"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221620"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221622"></A>do_nothing</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221624"></A>class 7</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221626"></A>propagate</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221628"></A>combine</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221630"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221632"></A>do_nothing</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221634"></A>transform</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221636"></A>transform</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221638"></A>transform</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22221640"></A>transform</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-7867186"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-471736"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-487058"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-487066"></A>    SCH_rotate      = 0,</PRE>
<PRE><A NAME="50487361_pgfId-487074"></A>    SCH_scale       = 1,</PRE>
<PRE><A NAME="50487361_pgfId-487082"></A>    SCH_translate   = 2,</PRE>
<PRE><A NAME="50487361_pgfId-487090"></A>    SCH_reflect     = 3,</PRE>
<PRE><A NAME="50487361_pgfId-487098"></A>    SCH_split       = 4,</PRE>
<PRE><A NAME="50487361_pgfId-487106"></A>    SCH_merge       = 5,</PRE>
<PRE><A NAME="50487361_pgfId-487114"></A>    SCH_transfer    = 6,</PRE>
<PRE><A NAME="50487361_pgfId-487122"></A>    SCH_change      = 7,</PRE>
<PRE><A NAME="50487361_pgfId-487130"></A>    SCH_max_logged_event   //last entry; value in $d[] code for actions</PRE>
<PRE><A NAME="50487361_pgfId-487138"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-487146"></A>    SCH_logged_event_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290966"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290955"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-487154"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-487162"></A>    SCH_do_nothing        = 0,</PRE>
<PRE><A NAME="50487361_pgfId-487170"></A>    SCH_delete            = 1,</PRE>
<PRE><A NAME="50487361_pgfId-487178"></A>    SCH_transform         = 2,</PRE>
<PRE><A NAME="50487361_pgfId-487186"></A>    SCH_propagate         = 3,</PRE>
<PRE><A NAME="50487361_pgfId-487194"></A>    SCH_keep_sub_dominant = 4,</PRE>
<PRE><A NAME="50487361_pgfId-487202"></A>    SCH_keep_if_equal     = 5,</PRE>
<PRE><A NAME="50487361_pgfId-487210"></A>    SCH_combine           = 6</PRE>
<PRE><A NAME="50487361_pgfId-487218"></A>    }</PRE>
<PRE><A NAME="50487361_pgfId-487226"></A>    SCH_action_on_fields_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-290988"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290969"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-487234"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-487242"></A>    SCH_as_owner = 0,</PRE>
<PRE><A NAME="50487361_pgfId-487250"></A>    SCH_in_owner = 1,</PRE>
<PRE><A NAME="50487361_pgfId-487258"></A>    SCH_by_owner = 2,</PRE>
<PRE><A NAME="50487361_pgfId-487266"></A>    SCH_sh_owner = 3,</PRE>
<PRE><A NAME="50487361_pgfId-487274"></A>    SCH_fa_owner = 4,</PRE>
<PRE><A NAME="50487361_pgfId-487282"></A>    SCH_lo_owner = 5,</PRE>
<PRE><A NAME="50487361_pgfId-487290"></A>    SCH_ed_owner = 6,</PRE>
<PRE><A NAME="50487361_pgfId-487298"></A>    SCH_vx_owner = 7,</PRE>
<PRE><A NAME="50487361_pgfId-487306"></A>    SCH_fe_owner = 8,</PRE>
<PRE><A NAME="50487361_pgfId-487314"></A>    SCH_sf_owner = 9,</PRE>
<PRE><A NAME="50487361_pgfId-487322"></A>    SCH_cu_owner = 10,</PRE>
<PRE><A NAME="50487361_pgfId-487330"></A>    SCH_pt_owner = 11,</PRE>
<PRE><A NAME="50487361_pgfId-487338"></A>    SCH_rg_owner = 12,</PRE>
<PRE><A NAME="50487361_pgfId-487346"></A>    SCH_fn_owner = 13,</PRE>
<PRE><A NAME="50487361_pgfId-487354"></A>    SCH_max_owner  //last entry; value in $l[] for                    .legal_owners</PRE>
<PRE><A NAME="50487361_pgfId-487362"></A>    } </PRE>
<PRE><A NAME="50487361_pgfId-487370"></A>    SCH_attrib_owners_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291005"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-290991"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-487378"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-487386"></A>    SCH_int_field       = 1,</PRE>
<PRE><A NAME="50487361_pgfId-487394"></A>    SCH_real_field      = 2,</PRE>
<PRE><A NAME="50487361_pgfId-487402"></A>    SCH_char_field      = 3,</PRE>
<PRE><A NAME="50487361_pgfId-487410"></A>    SCH_point_field     = 4,</PRE>
<PRE><A NAME="50487361_pgfId-487418"></A>    SCH_vector_field    = 5,</PRE>
<PRE><A NAME="50487361_pgfId-487426"></A>    SCH_direction_field = 6,</PRE>
<PRE><A NAME="50487361_pgfId-487434"></A>    SCH_axis_field      = 7,</PRE>
<PRE><A NAME="50487361_pgfId-487442"></A>    SCH_tag_field       = 8,</PRE>
<PRE><A NAME="50487361_pgfId-487450"></A>    SCH_pointer_field   = 9,</PRE>
<PRE><A NAME="50487361_pgfId-487458"></A>    SCH_unicode_field   = 10</PRE>
<PRE><A NAME="50487361_pgfId-487466"></A>    } </PRE>
<PRE><A NAME="50487361_pgfId-487474"></A>    SCH_field_type_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291019"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-447483"></A>struct ATTRIB_DEF_s               //attribute definition</PRE>
<PRE><A NAME="50487361_pgfId-487482"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-487490"></A>    struct ATTRIB_DEF_s          *next;               // $p</PRE>
<PRE><A NAME="50487361_pgfId-487498"></A>    struct ATT_DEF_ID_s          *identifier;         // $p</PRE>
<PRE><A NAME="50487361_pgfId-487506"></A>    int                           type_id;            // $d</PRE>
<PRE><A NAME="50487361_pgfId-22198106"></A>    SCH_action_on_fields_t        actions             // $u[8]</PRE>
<PRE><A NAME="50487361_pgfId-22198112"></A>    [(int)SCH_max_logged_event];                      // $u[8]</PRE>
<PRE><A NAME="50487361_pgfId-487522"></A>    struct FIELD_NAMES_s         *field_names         // $p</PRE>
<PRE><A NAME="50487361_pgfId-22198148"></A>    logical                       legal_owners        // $l[14]</PRE>
<PRE><A NAME="50487361_pgfId-22198154"></A>     [(int)SCH_max_owner];                            //$l[14]</PRE>
<PRE><A NAME="50487361_pgfId-487538"></A>    SCH_field_type_t              fields[1];          // $u[]</PRE>
<PRE><A NAME="50487361_pgfId-487546"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-487554"></A>typedef struct ATTRIB_DEF_s *ATTRIB_DEF;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-291020"></A>	5.4.6 	Attribute</H3>
<P>
<A NAME="50487361_pgfId-291070"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291023"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291025"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291027"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291029"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291031"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291033"></A>Identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-8442702"></A>definition</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-8442704"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-8442706"></A>Attribute definition</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291035"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291037"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291039"></A>Attribute owner</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291041"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291043"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291045"></A>Next attribute, feature, or <CODE>
member_of_feature</CODE>
</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291047"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291049"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291051"></A>Previous ditto</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291053"></A><CODE>
next_of_type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291055"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291057"></A>Next attribute of this type in this part</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291059"></A><CODE>
previous_of_type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291061"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291063"></A>Previous attribute of this type in this part</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291065"></A><CODE>
fields[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291067"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291069"></A>Fields, of type int_values etc. The number of fields is given by the length of the variable part of the node. There may be no fields.</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-388703"></A>The attributes of a node are chained using the next and previous pointers in the attribute. The <CODE>
attributes_</CODE>
features pointer in the node points to the head of this chain. This chain also contains the <CODE>
member_of_</CODE>
feature of the node.</P>
<P>
<A NAME="50487361_pgfId-326694"></A>Attributes within the same part, with the same attribute definition, are chained together by the <CODE>
next_of_type</CODE>
 and <CODE>
previous_of_type</CODE>
 pointers. The part points to the head of this chain as follows. The <CODE>
attribute_chains</CODE>
 pointer in the part points to a list which contains the heads of these attribute chains, one for each attribute definition which has attributes in the part. The list may be null.</P>
<P>
<A NAME="50487361_pgfId-326695"></A>Note that the <CODE>
attributes_</CODE>
featur<CODE>
es</CODE>
 chains in parts, features and nodes contain the following types of node:</P>
<UL>
<LI>
<A NAME="50487361_pgfId-21345300"></A>Part: attributes and features.</LI>
<LI>
<A NAME="50487361_pgfId-21345301"></A>Feature: attributes.</LI>
<LI>
<A NAME="50487361_pgfId-21345302"></A>Node: attributes and <CODE>
member_of_feature</CODE>
.</LI>
</UL>
<P>
<A NAME="50487361_pgfId-22300653"></A>Fields of type ‘pointer’ can be used in Parasolid V12.0, but they are always transmitted as empty.</P>
<P>
<A NAME="50487361_pgfId-291098"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-291080"></A>union ATTRIBUTE_OWNER_u</PRE>
<PRE><A NAME="50487361_pgfId-487562"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-487570"></A>    struct ASSEMBLY_s            *assembly;</PRE>
<PRE><A NAME="50487361_pgfId-487578"></A>    struct INSTANCE_s            *instance;</PRE>
<PRE><A NAME="50487361_pgfId-487586"></A>    struct BODY_s                *body;</PRE>
<PRE><A NAME="50487361_pgfId-487594"></A>    struct SHELL_s               *shell;</PRE>
<PRE><A NAME="50487361_pgfId-487602"></A>    struct REGION_s              *region;</PRE>
<PRE><A NAME="50487361_pgfId-487610"></A>    struct FACE_s                *face;</PRE>
<PRE><A NAME="50487361_pgfId-487618"></A>    struct LOOP_s                *loop;</PRE>
<PRE><A NAME="50487361_pgfId-487626"></A>    struct EDGE_s                *edge;</PRE>
<PRE><A NAME="50487361_pgfId-487634"></A>    struct HALFEDGE_s            *<CODE>halfedge</CODE>
;</PRE>
<PRE><A NAME="50487361_pgfId-487642"></A>    struct VERTEX_s              *vertex;</PRE>
<PRE><A NAME="50487361_pgfId-487650"></A>    union  SURFACE_u              Surface;</PRE>
<PRE><A NAME="50487361_pgfId-487658"></A>    union  CURVE_u                Curve;</PRE>
<PRE><A NAME="50487361_pgfId-487666"></A>    struct POINT_s               *point;</PRE>
<PRE><A NAME="50487361_pgfId-487674"></A>    struct <CODE>FEATURE_s</CODE>
             *feature;</PRE>
<PRE><A NAME="50487361_pgfId-487682"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-487690"></A>typedef union ATTRIBUTE_OWNER_u ATTRIBUTE_OWNER;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291114"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-291101"></A>union FIELD_VALUES_u</PRE>
<PRE><A NAME="50487361_pgfId-487698"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-487706"></A>    struct INT_VALUES_s          *int_values;</PRE>
<PRE><A NAME="50487361_pgfId-487714"></A>    struct REAL_VALUES_s         *real_values;</PRE>
<PRE><A NAME="50487361_pgfId-487722"></A>    struct CHAR_VALUES_s         *char_values;</PRE>
<PRE><A NAME="50487361_pgfId-487730"></A>    struct POINT_VALUES_s        *point_values;</PRE>
<PRE><A NAME="50487361_pgfId-487738"></A>    struct VECTOR_VALUES_s       *vector_values;</PRE>
<PRE><A NAME="50487361_pgfId-487746"></A>    struct DIRECTION_VALUES_s    *direction_values;</PRE>
<PRE><A NAME="50487361_pgfId-487754"></A>    struct AXIS_VALUES_s         *axis_values;</PRE>
<PRE><A NAME="50487361_pgfId-487762"></A>    struct TAG_VALUES_s          *tag_values;</PRE>
<PRE><A NAME="50487361_pgfId-487770"></A>    struct UNICODE_VALUES_s      *unicode_values;</PRE>
<PRE><A NAME="50487361_pgfId-487778"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-487786"></A>typedef union FIELD_VALUES_u FIELD_VALUES;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291129"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-291117"></A>struct ATTRIBUTE_s                //Attribute</PRE>
<PRE><A NAME="50487361_pgfId-487794"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-487802"></A>    int                          node_id;              // $d</PRE>
<PRE><A NAME="50487361_pgfId-487810"></A>    struct ATTRIB_DEF_s         *definition;           // $p</PRE>
<PRE><A NAME="50487361_pgfId-487818"></A>    union  ATTRIBUTE_OWNER_u     owner;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-487826"></A>    union  ATTRIB_FEAT_u         next;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-487834"></A>    union  ATTRIB_FEAT_u         previous;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-487842"></A>    struct ATTRIBUTE_s          *next_of_type;         // $p</PRE>
<PRE><A NAME="50487361_pgfId-487850"></A>    struct ATTRIBUTE_s          *previous_of_type;     // $p</PRE>
<PRE><A NAME="50487361_pgfId-487858"></A>    union  FIELD_VALUES_u        fields[1];            // $p[]</PRE>
<PRE><A NAME="50487361_pgfId-487866"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-487874"></A>typedef struct ATTRIBUTE_s *ATTRIBUTE;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-291130"></A>	5.4.7 	Int_values</H3>
<P>
<A NAME="50487361_pgfId-291144"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291133"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291135"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291137"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291139"></A><CODE>
values[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291141"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291143"></A>Integer values</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291152"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-291147"></A>struct INT_VALUES_s                //Int values</PRE>
<PRE><A NAME="50487361_pgfId-487882"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-487890"></A>    int                            values[1];           // $d[]</PRE>
<PRE><A NAME="50487361_pgfId-487898"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-487906"></A>typedef struct INT_VALUES_s *INT_VALUES;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-291153"></A>	5.4.8 	Real_values</H3>
<P>
<A NAME="50487361_pgfId-291167"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291156"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291158"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291160"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291162"></A><CODE>
values[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291164"></A>double</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291166"></A>Real values</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291175"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-291170"></A>struct REAL_VALUES_s               //Real values</PRE>
<PRE><A NAME="50487361_pgfId-487914"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-487922"></A>    double                         values[1];           // $f[]</PRE>
<PRE><A NAME="50487361_pgfId-487930"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-487938"></A>typedef struct REAL_VALUES_s *REAL_VALUES;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-291176"></A>	5.4.9 	Char_values</H3>
<P>
<A NAME="50487361_pgfId-291190"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291179"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291181"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291183"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291185"></A><CODE>
values[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291187"></A>char</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291189"></A>Character values</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291198"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-291193"></A>struct CHAR_VALUES_s               //Character values</PRE>
<PRE><A NAME="50487361_pgfId-487946"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-487954"></A>    char                           values[1];           // $c[]</PRE>
<PRE><A NAME="50487361_pgfId-487962"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-487970"></A>typedef struct CHAR_VALUES_s *CHAR_VALUES;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-291199"></A>	5.4.10 	Unicode_values</H3>
<P>
<A NAME="50487361_pgfId-291213"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291202"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291204"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291206"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291208"></A><CODE>
values[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291210"></A>short</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291212"></A>Unicode character values</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291221"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-291216"></A>struct UNICODE_VALUES_s            //Unicode character values</PRE>
<PRE><A NAME="50487361_pgfId-487978"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-487986"></A>    short                          values[1];           // $w[]</PRE>
<PRE><A NAME="50487361_pgfId-487994"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-488002"></A>typedef struct UNICODE_VALUES_s *UNICODE_VALUES;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-291222"></A>	5.4.11 	Point_values</H3>
<P>
<A NAME="50487361_pgfId-291236"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291225"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291227"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291229"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291231"></A><CODE>
values[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291233"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291235"></A>Point values</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291244"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-291239"></A>struct POINT_VALUES_s              //Point values</PRE>
<PRE><A NAME="50487361_pgfId-488010"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-488018"></A>    vector                         values[1];           // $v[]</PRE>
<PRE><A NAME="50487361_pgfId-488026"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-488034"></A>typedef struct POINT_VALUES_s *POINT_VALUES;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-291245"></A>	5.4.12 	Vector_values</H3>
<P>
<A NAME="50487361_pgfId-291259"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291248"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291250"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291252"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291254"></A><CODE>
values[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291256"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291258"></A>Vector values</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291267"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-449596"></A>struct VECTOR_VALUES_s             //Vector values</PRE>
<PRE><A NAME="50487361_pgfId-488042"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-488050"></A>    vector                         values[1];           // $v[]</PRE>
<PRE><A NAME="50487361_pgfId-488058"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-488066"></A>typedef struct VECTOR_VALUES_s *VECTOR_VALUES;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-291268"></A>	5.4.13 	Direction_values</H3>
<P>
<A NAME="50487361_pgfId-291282"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291271"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291273"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291275"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291277"></A><CODE>
values[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291279"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291281"></A>Direction values</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291290"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-291285"></A>struct DIRECTION_VALUES_s          //Direction values</PRE>
<PRE><A NAME="50487361_pgfId-488074"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-488082"></A>    vector                         values[1];           // $v[]</PRE>
<PRE><A NAME="50487361_pgfId-488090"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-488098"></A>typedef struct DIRECTION_VALUES_s *DIRECTION_VALUES;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-291291"></A>	5.4.14 	Axis_values</H3>
<P>
<A NAME="50487361_pgfId-291305"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291294"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291296"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291298"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291300"></A><CODE>
values[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291302"></A>vector</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291304"></A>Axis values</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291313"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-291308"></A>struct AXIS_VALUES_s              //Axis values</PRE>
<PRE><A NAME="50487361_pgfId-488106"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-488114"></A>    vector                         values[1];           // $v[]</PRE>
<PRE><A NAME="50487361_pgfId-488122"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-488130"></A>typedef struct AXIS_VALUES_s *AXIS_VALUES;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-291314"></A>	5.4.15 	Tag_values</H3>
<P>
<A NAME="50487361_pgfId-291328"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291317"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291319"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291321"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291323"></A><CODE>
values[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291325"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-291327"></A>Integer tag values</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291336"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-291331"></A>struct TAG_VALUES_s                //Tag values</PRE>
<PRE><A NAME="50487361_pgfId-488138"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-488146"></A>    int                            values[1];           // $t[]</PRE>
<PRE><A NAME="50487361_pgfId-488154"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-488162"></A>typedef struct TAG_VALUES_s *TAG_VALUES;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-382296"></A>The tag field type and the <CODE>
tag_values</CODE>
 node are not available for use in user-defined attributes, they occur only in certain system attributes.</P>


<H3>
<A NAME="50487361_pgfId-382297"></A>	5.4.16 	Feature</H3>
<P>
<A NAME="50487361_pgfId-22300666"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<ADDRESS>
<A NAME="50487361_pgfId-22300665"></A>Note: Features are referred to as ‘groups’ in the PK Interface.</ADDRESS><BR>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-359811"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359764"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359766"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359768"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359770"></A><CODE>
node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359772"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359774"></A>Identifier</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359776"></A><CODE>
attributes_features</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359778"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359780"></A>Head of chain of attributes of this feature</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359782"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359784"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359786"></A>Owning part</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359788"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359790"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359792"></A>Next feature or attribute</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359794"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359796"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359798"></A>Previous feature or attribute</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359800"></A><CODE>
type</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359802"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359804"></A>Type of node allowed in feature</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359806"></A><CODE>
first_member</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359808"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-359810"></A>Head of chain of <CODE>
member_of_</CODE>
feature nodes in feature</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-326607"></A>The groups in a part are chained by the next and previous pointers in a group. The <CODE>
attributes_</CODE>
features pointer in the part points to the head of the chain. This chain also contains the attributes attached directly to the part - groups and attributes are intermingled in this chain, the order is not significant.</P>
<P>
<A NAME="50487361_pgfId-326483"></A>Each group has a chain of <CODE>
member_of_</CODE>
feature. These are chained together using the <CODE>
next_member</CODE>
 and <CODE>
previous_member</CODE>
 pointers. The <CODE>
first_member</CODE>
 pointer in the feature points to the head of the chain. Each <CODE>
member_of_</CODE>
feature<CODE>
 </CODE>
has an <CODE>
owning_</CODE>
feature pointer which points back to the feature.</P>
<P>
<A NAME="50487361_pgfId-326466"></A>Each <CODE>
member_of_</CODE>
feature<CODE>
 </CODE>
has an owner pointer which points to a node. Thus the feature references its member nodes via the <CODE>
member_of_feature</CODE>
.</P>
<P>
<A NAME="50487361_pgfId-326451"></A>The <CODE>
member_of_</CODE>
feature which refer to a particular node are chained using the next and previous pointers in the <CODE>
member_of_</CODE>
feature. The <CODE>
attributes_</CODE>
features pointer in the node points to the head of this chain. This chain also contains the attributes attached to the node.</P>
<P>
<A NAME="50487361_pgfId-291414"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-291401"></A>typedef enum</PRE>
<PRE><A NAME="50487361_pgfId-488170"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-488178"></A>    SCH_instance_fe   = 1,</PRE>
<PRE><A NAME="50487361_pgfId-488186"></A>    SCH_face_fe       = 2,</PRE>
<PRE><A NAME="50487361_pgfId-488194"></A>    SCH_loop_fe       = 3,</PRE>
<PRE><A NAME="50487361_pgfId-488202"></A>    SCH_edge_fe       = 4,</PRE>
<PRE><A NAME="50487361_pgfId-488210"></A>    SCH_vertex_fe     = 5,</PRE>
<PRE><A NAME="50487361_pgfId-488218"></A>    SCH_surface_fe    = 6,</PRE>
<PRE><A NAME="50487361_pgfId-488226"></A>    SCH_curve_fe      = 7,</PRE>
<PRE><A NAME="50487361_pgfId-488234"></A>    SCH_point_fe      = 8,</PRE>
<PRE><A NAME="50487361_pgfId-488242"></A>    SCH_mixed_fe      = 9,</PRE>
<PRE><A NAME="50487361_pgfId-488250"></A>    SCH_region_fe     = 10,</PRE>
<PRE><A NAME="50487361_pgfId-22301782"></A>    SCH_pf_pline_fe   = 11,</PRE>
<PRE><A NAME="50487361_pgfId-22301783"></A>    SCH_feature_fe    = 12</PRE>
<PRE><A NAME="50487361_pgfId-488274"></A>    } SCH_feature_type_t;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-326308"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-326420"></A>struct FEATURE_s  //Feature</PRE>
<PRE><A NAME="50487361_pgfId-9536225"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-9536226"></A>    int                          node_id;               // $d</PRE>
<PRE><A NAME="50487361_pgfId-488298"></A>    union  ATTRIB_FEAT_u         attributes_features;   // $p</PRE>
<PRE><A NAME="50487361_pgfId-488306"></A>    union  PART_u                owner;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-488314"></A>    union  ATTRIB_FEAT_u         next;                  // $p</PRE>
<PRE><A NAME="50487361_pgfId-488322"></A>    union  ATTRIB_FEAT_u         previous;              // $p</PRE>
<PRE><A NAME="50487361_pgfId-488330"></A>    SCH_feature_type_t           type;                  // $u</PRE>
<PRE><A NAME="50487361_pgfId-488338"></A>    struct MEMBER_OF_FEATURE_s  *first_member;          // $p</PRE>
<PRE><A NAME="50487361_pgfId-488346"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-488354"></A>typedef struct FEATURE_s *FEATURE;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-326309"></A>	5.4.17 	Member_of_feature</H3>
<P>
<A NAME="50487361_pgfId-326359"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326312"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326314"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326316"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326318"></A><CODE>
dummy_node_id</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326320"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326322"></A>Entity label</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326324"></A><CODE>
owning_feature</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326326"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326328"></A>Owning feature</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326330"></A><CODE>
owner</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326332"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326334"></A>Referenced member of feature</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326336"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326338"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326340"></A>Next attribute, feature or <CODE>
member_of_</CODE>
feature</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326342"></A><CODE>
previous</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326344"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326346"></A>Previous ditto</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326348"></A><CODE>
next_member</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326350"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326352"></A>Next <CODE>
member_of_</CODE>
feature in this feature</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326354"></A><CODE>
previous_member</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326356"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-326358"></A>Previous ditto</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-291495"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-326255"></A>union FEATURE_MEMBER_u</PRE>
<PRE><A NAME="50487361_pgfId-488362"></A>    {</PRE>
<PRE><A NAME="50487361_pgfId-488378"></A>    struct INSTANCE_s            *instance;</PRE>
<PRE><A NAME="50487361_pgfId-9835073"></A>    struct FACE_s                *face;</PRE>
<PRE><A NAME="50487361_pgfId-488386"></A>    struct REGION_s              *region;</PRE>
<PRE><A NAME="50487361_pgfId-488394"></A>    struct LOOP_s                *loop;</PRE>
<PRE><A NAME="50487361_pgfId-488402"></A>    struct EDGE_s                *edge;</PRE>
<PRE><A NAME="50487361_pgfId-488410"></A>    struct VERTEX_s              *vertex;</PRE>
<PRE><A NAME="50487361_pgfId-488418"></A>    union  SURFACE_u              surface;</PRE>
<PRE><A NAME="50487361_pgfId-488426"></A>    union  CURVE_u                curve;</PRE>
<PRE><A NAME="50487361_pgfId-488434"></A>    struct POINT_s               *point;</PRE>
<PRE><A NAME="50487361_pgfId-22301798"></A>struct FEATURE_s  *feature;</PRE>
<PRE><A NAME="50487361_pgfId-488450"></A>    };</PRE>
<PRE><A NAME="50487361_pgfId-488458"></A>typedef union FEATURE_MEMBER_u FEATURE_MEMBER;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-20021530"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-326240"></A>struct MEMBER_OF_FEATURE_s //Member of feature</PRE>
<PRE><A NAME="50487361_pgfId-488466"></A>   {</PRE>
<PRE><A NAME="50487361_pgfId-488474"></A>   int                             dummy_node_id;        // $d</PRE>
<PRE><A NAME="50487361_pgfId-488482"></A>   struct FEATURE_s               *owning_feature;       // $</PRE>
<PRE><A NAME="50487361_pgfId-20022812"></A>   union  FEATURE_MEMBER_u         owner;                // $p</PRE>
<PRE><A NAME="50487361_pgfId-20022817"></A>   union  ATTRIB_FEAT_u            next;                 // $p</PRE>
<PRE><A NAME="50487361_pgfId-20022823"></A>   union  ATTRIB_FEAT_u            previous;             // $p</PRE>
<PRE><A NAME="50487361_pgfId-20022829"></A>   struct MEMBER_OF_FEATURE_s     *next_member;          // $p</PRE>
<PRE><A NAME="50487361_pgfId-20022834"></A>   struct MEMBER_OF_FEATURE_s     *previous_member;      // $p</PRE>
<PRE><A NAME="50487361_pgfId-488530"></A>   };</PRE>
<PRE><A NAME="50487361_pgfId-488538"></A>typedef struct MEMBER_OF_FEATURE_s *MEMBER_OF_FEATURE;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-20068404"></A>	5.4.18 	Part_XMT_block</H3>
<P>
<A NAME="50487361_pgfId-20068830"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068444"></A>Field name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068446"></A>Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068448"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068450"></A><CODE>
n_entries</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068452"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068454"></A>Number of entries in this block. (<CODE>
n_entries</CODE>
 &gt;1)</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068456"></A><CODE>
index_map_offset</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068458"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068460"></A>Must be set to 0</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068462"></A><CODE>
index_map</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068464"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068466"></A>Must be set to null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068468"></A><CODE>
schema_embedding_map</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068470"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068472"></A>Must be set to null</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068633"></A><CODE>
mesh_offset_data</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068635"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068637"></A>Data for embedded meshes. If the XT file does not contain embedded meshes, this field must be set to null.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068660"></A><CODE>
entries[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068662"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-20068664"></A>Pointers in block</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-20068435"></A>The PART_XMT_BLOCK must be the root node in XT data containing more than one part, </P>
<P>
<A NAME="50487361_pgfId-20088228"></A>The fields <CODE>
index_map_offset</CODE>
, <CODE>
index_map</CODE>
, and <CODE>
schema_embedding_map</CODE>
 are used for Indexed Transmit.</P>
<P>
<A NAME="50487361_pgfId-20069019"></A>The <CODE>
mesh_offset_data</CODE>
 field is used for embedded mesh data.</P>
<P>
<A NAME="50487361_pgfId-20147279"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-20069112"></A>struct PART_XMT_BLOCK_s //Part list</PRE>
<PRE><A NAME="50487361_pgfId-20069113"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-20069114"></A>int                              n_entries;              //$d</PRE>
<PRE><A NAME="50487361_pgfId-20069115"></A>unsigned                         index_map_offset;       //$d</PRE>
<PRE><A NAME="50487361_pgfId-20069116"></A>struct INT_VALUES_s             *index_map;              //$p</PRE>
<PRE><A NAME="50487361_pgfId-20069117"></A>struct INT_VALUES_s             *schema_embedding_map;   //$p</PRE>
<PRE><A NAME="50487361_pgfId-20087877"></A>struct MESH_OFFSET_DATA_s       *mesh_offset_data;       //$p</PRE>
<PRE><A NAME="50487361_pgfId-20069119"></A>union PART_u                     entries[1];             //$p[]</PRE>
<PRE><A NAME="50487361_pgfId-20069120"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-20069121"></A>&nbsp;</PRE>
<PRE><A NAME="50487361_pgfId-20069100"></A>typedef struct PART_XMT_BLOCK_s *PART_XMT_BLOCK;</PRE>
</TD>
</TR>
</TABLE>


<H3>
<A NAME="50487361_pgfId-20140805"></A>	5.4.19 	Mesh_offset_data</H3>
<P>
<A NAME="50487361_pgfId-20140806"></A>The MESH_OFFSET_DATA node is used for embedded mesh data. It is the second node in an XT file with embedded meshes. At most, there can only be one MESH_OFFSET_DATA node.</P>
<P>
<A NAME="50487361_pgfId-20141250"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230954"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230956"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230958"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230960"></A><CODE>
mesh_index_map</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230962"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230964"></A>Must be set to an <CODE>
offset_values</CODE>
 node</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230966"></A><CODE>
schema_data</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230968"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230973"></A>See <A HREF="xt_chap.06.html#50487361_71015">Section 5.4.19.2, “Schema_data”</A> for information</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230975"></A><CODE>
schema_data_offset_high</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230977"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230979"></A>Must be present</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230981"></A><CODE>
schema_data_offset_low</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230983"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230985"></A>Must be present</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-20140853"></A>The <CODE>
schema_data</CODE>
 field must be present if the XT data contains embedded schema information, otherwise it must be set to null.</P>
<P>
<A NAME="50487361_pgfId-20140841"></A>The <CODE>
schema_data_offset_high</CODE>
 and <CODE>
schema_data_offset_low</CODE>
 fields must be present and indicate either the offset of the <CODE>
schema_data</CODE>
 node (if present), or the offset of the terminator.</P>
<P>
<A NAME="50487361_pgfId-20140852"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-20140844"></A>struct MESH_OFFSET_DATA_s //Mesh offset data</PRE>
<PRE><A NAME="50487361_pgfId-20140845"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-20140846"></A>struct OFFSET_VALUE_s    *mesh_index_map;           //$p</PRE>
<PRE><A NAME="50487361_pgfId-20140847"></A>struct SCHEMA_DATA_s     *schema_data;              //$p</PRE>
<PRE><A NAME="50487361_pgfId-20140848"></A>unsigned                 *schema_data_offset_high;  //$d</PRE>
<PRE><A NAME="50487361_pgfId-20140849"></A>unsigned                 *schema_data_offset_low ;  //$d</PRE>
<PRE><A NAME="50487361_pgfId-20140850"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-20140851"></A>typedef struct MESH_OFFSET_DATA_s *MESH_OFFSET_DATA;</PRE>
</TD>
</TR>
</TABLE>

<H4>
<A NAME="50487361_pgfId-20140855"></A>5.4.19.1 Offset_values</H4>
<P>
<A NAME="50487361_pgfId-20140856"></A>The OFFSET_VALUES node contains the offset values of each PSM_MESH node. These offset values must be in the same order as the PSM_MESH nodes in the XT data. If this node is present, it must be the third node in the XT data.</P>
<P>
<A NAME="50487361_pgfId-20140870"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230993"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230995"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230997"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22230999"></A><CODE>
values[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231001"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231003"></A>Offset values in high and low pairs</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-20140878"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-20140873"></A>struct OFFSET_VALUES_s     //Offset values</PRE>
<PRE><A NAME="50487361_pgfId-20140874"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-20140875"></A>unsigned    values[1];     //$d[]</PRE>
<PRE><A NAME="50487361_pgfId-20140876"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-20140877"></A>typedef struct OFFSET_VALUES_s *OFFSET_VALUES;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-20140880"></A>5.4.19.2 <A NAME="50487361_71015"></A>Schema_data</H4>
<P>
<A NAME="50487361_pgfId-20140881"></A>The SCHEMA_DATA node must be present if the XT data contains embedded schema information. The SCHEMA_DATA node chains one NODE_MAP node per node type used in the mesh data section of the XT data (i.e between the first PSM_MESH node and the last node before the SCHEMA_DATA node).</P>
<P>
<A NAME="50487361_pgfId-20144702"></A>There is a NEW_NODE_MAP node defining the following node types: </P>
<UL>
<LI>
<A NAME="50487361_pgfId-20143146"></A>PSM_MESH </LI>
<LI>
<A NAME="50487361_pgfId-20143156"></A>INTEGER_TOOTH </LI>
<LI>
<A NAME="50487361_pgfId-20143165"></A>INTEGER_COMB </LI>
<LI>
<A NAME="50487361_pgfId-20143174"></A>VECTOR_TOOTH</LI>
<LI>
<A NAME="50487361_pgfId-20143183"></A>VECTOR_COMB </LI>
</UL>
<P>
<A NAME="50487361_pgfId-20144270"></A>These node types are relative to the defined base schema, currently SCH_13006. See <A HREF="xt_chap.03.html#50487314_44241">Section 2.1.2, “Embedded schemas”</A> for more information.</P>
<P>
<A NAME="50487361_pgfId-20144755"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-20140884"></A>struct SCHEMA_DATA_s //Schema data</PRE>
<PRE><A NAME="50487361_pgfId-20140885"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-20140886"></A>union NODE_MAP_u   node_map;   //$p</PRE>
<PRE><A NAME="50487361_pgfId-20140887"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-20140888"></A>typedef struct SCHEMA_DATA_s *SCHEMA_DATA;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-20140890"></A>The SCHEMA_DATA node is followed by the NODE_MAP, FIELD_MAP, and SCHEMA_CHAR_VALUES nodes. These nodes will always be at the end of the embedded mesh file and indicate whether an embedded mesh file was saved using an embedded schema.</P>


<H4>
<A NAME="50487361_pgfId-20146749"></A>5.4.19.3 Node_map union</H4>
<P>
<A NAME="50487361_pgfId-20148605"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-20145905"></A>union NODE_MAP_u</PRE>
<PRE><A NAME="50487361_pgfId-20145906"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-20145907"></A>struct ANY_NODE_MAP_s *any;</PRE>
<PRE><A NAME="50487361_pgfId-20145908"></A>struct NEW_NODE_MAP_s *new;</PRE>
<PRE><A NAME="50487361_pgfId-20145909"></A>struct MOD_NODE_MAP_s *mod;</PRE>
<PRE><A NAME="50487361_pgfId-20145910"></A>struct OLD_NODE_MAP_s *old;</PRE>
<PRE><A NAME="50487361_pgfId-20145911"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-20145893"></A>typedef union NODE_MAP_u NODE_MAP;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-20145779"></A>5.4.19.4 Node map nodes </H4>
<P>
<A NAME="50487361_pgfId-20151407"></A>All node map nodes share the following common fields:</P>
<P>
<A NAME="50487361_pgfId-20152964"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231011"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231013"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231015"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231017"></A><CODE>
next</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231019"></A>pointer0</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231021"></A>Next node map in chain</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231023"></A>exemplar_offset_high</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231025"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231027"></A>Offset values of the first node of <CODE>
node_type</CODE>
 in the XT data</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231029"></A>exemplar_offset_low</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231031"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231033"></A>Offset values of the first node of <CODE>
node_type</CODE>
 in the XT data</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231035"></A>node_type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231037"></A>short</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231039"></A>Node type</P>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-20150406"></A>5.4.19.5 Any_node_map</H4>
<P>
<A NAME="50487361_pgfId-20149430"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-20145959"></A>struct ANY_NODE_MAP_s //Any node map</PRE>
<PRE><A NAME="50487361_pgfId-20145960"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-20145961"></A>union NODE_MAP_u             next;                  //$p</PRE>
<PRE><A NAME="50487361_pgfId-20145962"></A>unsigned                     exemplar_offset_high;  //$d</PRE>
<PRE><A NAME="50487361_pgfId-20145963"></A>unsigned                     exemplar_offset_low;   //$d</PRE>
<PRE><A NAME="50487361_pgfId-20145964"></A>short                        node_type;             //$n</PRE>
<PRE><A NAME="50487361_pgfId-20145965"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-20145855"></A>typedef struct ANY_NODE_MAP_s  *ANY_NODE_MAP;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-20140916"></A>5.4.19.6 Old_node_map</H4>
<P>
<A NAME="50487361_pgfId-20146203"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-20146225"></A>struct OLD_NODE_MAP_s == ANY_NODE_MAP_s //Unchanged node map</PRE>
<PRE><A NAME="50487361_pgfId-20146226"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-20146227"></A>union NODE_MAP_u             next;                  //$p</PRE>
<PRE><A NAME="50487361_pgfId-20146228"></A>unsigned                     exemplar_offset_high;  //$d</PRE>
<PRE><A NAME="50487361_pgfId-20146229"></A>unsigned                     exemplar_offset_low;   //$d</PRE>
<PRE><A NAME="50487361_pgfId-20146230"></A>short                        node_type;             //$n</PRE>
<PRE><A NAME="50487361_pgfId-20146231"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-20146213"></A>typedef struct OLD_NODE_MAP_s *OLD_NODE_MAP;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-20146107"></A>5.4.19.7 New_node_map</H4>
<P>
<A NAME="50487361_pgfId-20150534"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231047"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231049"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231051"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231053"></A>vla_field_xmt_code</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231055"></A>logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231057"></A>Whether the variable length array field (if present) should be saved to XT. If this field is not present, the value is set to false.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231059"></A>name</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231061"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231063"></A>Points to the schema character values node that contain the node name.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231065"></A>description</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231067"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231069"></A>Points to the schema character values node that contain the description.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231071"></A>field_maps[1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231073"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231075"></A>Array of new field maps</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-20146158"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-20140893"></A>struct NEW_NODE_MAP_s == ANY_NODE_MAP_s //New node map</PRE>
<PRE><A NAME="50487361_pgfId-20140894"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-20145597"></A>union NODE_MAP_u             next; $p</PRE>
<PRE><A NAME="50487361_pgfId-20140896"></A>unsigned                     exemplar_offset_high;  //$d</PRE>
<PRE><A NAME="50487361_pgfId-20140897"></A>unsigned                     exemplar_offset_low;   //$d</PRE>
<PRE><A NAME="50487361_pgfId-20140898"></A>short                        node_type;             //$n</PRE>
<PRE><A NAME="50487361_pgfId-20140899"></A>logical                      vla_field_xmt_code;    //$l</PRE>
<PRE><A NAME="50487361_pgfId-20140900"></A>struct SCHEMA_CHAR_VALUES_s *name;                  //$p</PRE>
<PRE><A NAME="50487361_pgfId-20140901"></A>struct SCHEMA_CHAR_VALUES_s *description;           //$p</PRE>
<PRE><A NAME="50487361_pgfId-20140902"></A>struct NEW_FIELD_MAP_s      *field_maps[1];         //$p[]</PRE>
<PRE><A NAME="50487361_pgfId-20140903"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-20147021"></A>typedef struct NEW_NODE_MAP_s *NEW_NODE_MAP;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-20140904"></A>5.4.19.8 Modified_node_map</H4>
<P>
<A NAME="50487361_pgfId-20150757"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231083"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231085"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231087"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231089"></A>vla_field_xmt_code</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231091"></A>logical</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231093"></A>Whether the variable length array field (if present) is transmitted. If this field is not present, the value is set to false.</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231095"></A>field_maps[1]</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231097"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231099"></A>Array of field maps</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-20146186"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-20140907"></A>struct MOD_NODE_MAP_s == ANY_NODE_MAP_s          //Modified node map</PRE>
<PRE><A NAME="50487361_pgfId-20140908"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-20140909"></A>union NODE_MAP_u             next;                  //$p</PRE>
<PRE><A NAME="50487361_pgfId-20140910"></A>unsigned                     exemplar_offset_high;  //$d</PRE>
<PRE><A NAME="50487361_pgfId-20140911"></A>unsigned                     exemplar_offset_low;   //$d</PRE>
<PRE><A NAME="50487361_pgfId-20140912"></A>short                        node_type;             //$n</PRE>
<PRE><A NAME="50487361_pgfId-20140913"></A>logical                      vla_field_xmt_code;    //$l</PRE>
<PRE><A NAME="50487361_pgfId-20140914"></A>union FIELD_MAP_u            field_maps[1];         //$p[]</PRE>
<PRE><A NAME="50487361_pgfId-20140915"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-20146965"></A>typedef struct MOD_NODE_MAP_s *MODE_NODE_MAP;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-20145807"></A>5.4.19.9 Field_map union</H4>
<P>
<A NAME="50487361_pgfId-20146352"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-20146386"></A>union FIELD_MAP_u</PRE>
<PRE><A NAME="50487361_pgfId-20146387"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-20146389"></A>struct NEW_FIELD_MAP_s *new;</PRE>
<PRE><A NAME="50487361_pgfId-20146390"></A>struct OLD_FIELD_MAP_s *old;</PRE>
<PRE><A NAME="50487361_pgfId-20146391"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-20146117"></A>typedef union FIELD_MAP_u FIELD_MAP;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-20146130"></A>5.4.19.10 Old_field_map</H4>
<P>
<A NAME="50487361_pgfId-20147773"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231107"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231109"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231111"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231113"></A><CODE>
base_index</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231115"></A>byte</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231117"></A>The field number this field used to be in the baseline schema</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-20146425"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-20146447"></A>struct OLD_FIELD_MAP_s // Old field map</PRE>
<PRE><A NAME="50487361_pgfId-20146448"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-20146449"></A>SCH_byte_t               base_index;    //$u</PRE>
<PRE><A NAME="50487361_pgfId-20146450"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-20146435"></A>typedef struct OLD_FIELD_MAP_s *OLD_FIELD_MAP;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-20146369"></A>5.4.19.11 New_field_map</H4>
<P>
<A NAME="50487361_pgfId-20147745"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231125"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231127"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231129"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231131"></A><CODE>
name</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231133"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231135"></A>Points to the schema character values node that contains the field name. </P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231137"></A>ptr_class</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231139"></A>short</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231141"></A>Node type or class of the field if it is a pointer field</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231143"></A>n_elts</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231145"></A>int</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231147"></A>Number of elements for that field</P>
</TD>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231149"></A>type</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231151"></A>pointer</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231153"></A>Points to a schema character values node that contains the field type.</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-20146521"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-20146543"></A>struct NEW_FIELD_MAP_s // New field map</PRE>
<PRE><A NAME="50487361_pgfId-20146544"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-20146545"></A>struct SCHEMA_CHAR_VALUES_s *name;      //$p</PRE>
<PRE><A NAME="50487361_pgfId-20146546"></A>short                        ptr_class; //$n</PRE>
<PRE><A NAME="50487361_pgfId-20146547"></A>int                          n_elts;    //$d</PRE>
<PRE><A NAME="50487361_pgfId-20146548"></A>struct SCHEMA_CHAR_VALUES_s *type;      //$p</PRE>
<PRE><A NAME="50487361_pgfId-20146531"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-20147068"></A>typedef struct NEW_FIELD_MAP_s *NEW_FIELD_MAP;</PRE>
</TD>
</TR>
</TABLE>


<H4>
<A NAME="50487361_pgfId-20140918"></A>5.4.19.12 Schema_char_values</H4>
<P>
<A NAME="50487361_pgfId-20140932"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231161"></A>Field Name</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231163"></A>Data Type</P>
</TH>
<TH ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231165"></A>Description</P>
</TH>
</TR>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231167"></A><CODE>
values[]</CODE>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231169"></A>char</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P>
<A NAME="50487361_pgfId-22231171"></A>Character values</P>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-20140940"></A>&nbsp;</P>
<TABLE BORDER="1">
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<PRE><A NAME="50487361_pgfId-20140935"></A>struct SCHEMA_CHAR_VALUES_s     //Schema character values</PRE>
<PRE><A NAME="50487361_pgfId-20140936"></A>{</PRE>
<PRE><A NAME="50487361_pgfId-20140937"></A>char values[1];     //$c[]</PRE>
<PRE><A NAME="50487361_pgfId-20140938"></A>};</PRE>
<PRE><A NAME="50487361_pgfId-20140939"></A>typedef struct SCHEMA_CHAR_VALUES_s *SCHEMA_CHAR_VALUES;</PRE>
</TD>
</TR>
</TABLE>
<P>
<A NAME="50487361_pgfId-20140941"></A>&nbsp;</P>
<P>
<A NAME="50487361_pgfId-458305"></A>&nbsp;</P>



<A NAME="endofdoc"></A>

<P ALIGN=RIGHT>
<A HREF="#topofdoc"><I>[back to top]</I></A>
</P>

<P></P><TABLE BORDER ALIGN=CENTER><TR>
  <TD>&lt;&lt;&lt; <A HREF="xt_chap.05.html">Model Structure</A></TD>
  <TD><A HREF="../xt_index.html">Chapters</A></TD>
  <TD><A HREF="xt_chap.07.html">Nodes and Classes</A> &gt;&gt;&gt;</TD>
</TR></TABLE>

</BODY>
</HTML>
