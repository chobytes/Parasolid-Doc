<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">

<html>
<head>
	<title>Parasolid PK Reference</title>
	<LINK rel="stylesheet" href="ps_doc.css">
	<script language="JavaScript">
	<!-- Hide script from older browsers -->
	
	function updateMenu() {
		if ((parent.theMenu) && (parent.theMenu.amBusy == false)) {	//Check that Joust is present
        //First, find the ID of the entry that points to this page.  This is where
        //we are going to add the new entries.
        var level2ID = parent.theMenu.findEntry('PK Reference', 'text');

        if (level2ID != -1) {		
            if (parent.theMenu.entry[level2ID].FirstChild < 0) { //Check they haven't been added already.
				
                var level3ID = parent.theMenu.addChild(level2ID, "Document", "PK Token Codes (Numeric)", "chapters/p2_chap.02.html", "PK Token Codes (Numeric)");
                level3ID = parent.theMenu.addEntry(level3ID, "Document", "PK token Codes with descriptions (Numeric)", "chapters/p2_chap.03.html", "PK token Codes with descriptions (Numeric)");
                level3ID = parent.theMenu.addEntry(level3ID, "Document", "PK token Codes (Alphabetic)", "chapters/p2_chap.04.html", "PK token Codes (Alphabetic)");
                level3ID = parent.theMenu.addEntry(level3ID, "Document", "PK token Codes with descriptions (Alphabetic)", "chapters/p2_chap.05.html", "PK token Codes with descriptions (Alphabetic)");
                level3ID = parent.theMenu.addEntry(level3ID, "Document", "PK Error Codes (Numeric)", "chapters/p2_chap.06.html", "PK Error Codes (Numeric)");
                level3ID = parent.theMenu.addEntry(level3ID, "Document", "PK Error Codes with descriptions (Numeric)", "chapters/p2_chap.07.html", "PK Error Codes with descriptions (Numeric)");
                level3ID = parent.theMenu.addEntry(level3ID, "Document", "PK Error Codes (Alphabetic)", "chapters/p2_chap.08.html", "PK Error Codes (Alphabetic)");
                level3ID = parent.theMenu.addEntry(level3ID, "Document", "PK Error Codes with descriptions (Alphabetic)", "chapters/p2_chap.09.html", "PK Error Codes with descriptions (Alphabetic)");
                level3ID = parent.theMenu.addEntry(level3ID, "Document", "PK Error Codes (Functional)", "chapters/p2_chap.10.html", "PK Error Codes (Functional)");
                level3ID = parent.theMenu.addEntry(level3ID, "Folder", "PK Classes", "", "PK Classes");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_APPITEM", "pk_index.html#pk_appitem", "PK_APPITEM");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_ASSEMBLY", "pk_index.html#pk_assembly", "PK_ASSEMBLY");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_ATTDEF", "pk_index.html#pk_attdef", "PK_ATTDEF");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_ATTRIB", "pk_index.html#pk_attrib", "PK_ATTRIB");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_BB", "pk_index.html#pk_bb", "PK_BB");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_BCURVE", "pk_index.html#pk_bcurve", "PK_BCURVE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_BLENDSF", "pk_index.html#pk_blendsf", "PK_BLENDSF");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_BODY", "pk_index.html#pk_body", "PK_BODY");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_BSURF", "pk_index.html#pk_bsurf", "PK_BSURF");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_CIRCLE", "pk_index.html#pk_circle", "PK_CIRCLE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_CLASS", "pk_index.html#pk_class", "PK_CLASS");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_CONE", "pk_index.html#pk_cone", "PK_CONE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_CURVE", "pk_index.html#pk_curve", "PK_CURVE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_CYL", "pk_index.html#pk_cyl", "PK_CYL");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_DEBUG", "pk_index.html#pk_debug", "PK_DEBUG");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_DELTA", "pk_index.html#pk_delta", "PK_DELTA");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_EDGE", "pk_index.html#pk_edge", "PK_EDGE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_ELLIPSE", "pk_index.html#pk_ellipse", "PK_ELLIPSE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_ENTITY", "pk_index.html#pk_entity", "PK_ENTITY");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_ERROR", "pk_index.html#pk_error", "PK_ERROR");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_FACE", "pk_index.html#pk_face", "PK_FACE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_FCURVE", "pk_index.html#pk_fcurve", "PK_FCURVE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_FIN", "pk_index.html#pk_fin", "PK_FIN");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_FRAME", "pk_index.html#pk_frame", "PK_FRAME");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_FSURF", "pk_index.html#pk_fsurf", "PK_FSURF");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_FUNCTION", "pk_index.html#pk_function", "PK_FUNCTION");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_GEOM", "pk_index.html#pk_geom", "PK_GEOM");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_GROUP", "pk_index.html#pk_group", "PK_GROUP");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_INSTANCE", "pk_index.html#pk_instance", "PK_INSTANCE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_LATTICE", "pk_index.html#pk_lattice", "PK_LATTICE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_LBALL", "pk_index.html#pk_lball", "PK_LBALL");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_LINE", "pk_index.html#pk_line", "PK_LINE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_LOOP", "pk_index.html#pk_loop", "PK_LOOP");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_LROD", "pk_index.html#pk_lrod", "PK_LROD");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_LTOPOL", "pk_index.html#pk_ltopol", "PK_LTOPOL");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_MARK", "pk_index.html#pk_mark", "PK_MARK");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_MEMORY", "pk_index.html#pk_memory", "PK_MEMORY");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_MESH", "pk_index.html#pk_mesh", "PK_MESH");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_MFACET", "pk_index.html#pk_mfacet", "PK_MFACET");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_MFIN", "pk_index.html#pk_mfin", "PK_MFIN");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_MTOPOL", "pk_index.html#pk_mtopol", "PK_MTOPOL");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_MVERTEX", "pk_index.html#pk_mvertex", "PK_MVERTEX");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_OFFSET", "pk_index.html#pk_offset", "PK_OFFSET");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_PART", "pk_index.html#pk_part", "PK_PART");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_PARTITION", "pk_index.html#pk_partition", "PK_PARTITION");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_PLANE", "pk_index.html#pk_plane", "PK_PLANE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_PLINE", "pk_index.html#pk_pline", "PK_PLINE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_PMARK", "pk_index.html#pk_pmark", "PK_PMARK");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_POINT", "pk_index.html#pk_point", "PK_POINT");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_REGION", "pk_index.html#pk_region", "PK_REGION");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_REPORT", "pk_index.html#pk_report", "PK_REPORT");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_SESSION", "pk_index.html#pk_session", "PK_SESSION");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_SHELL", "pk_index.html#pk_shell", "PK_SHELL");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_SPCURVE", "pk_index.html#pk_spcurve", "PK_SPCURVE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_SPHERE", "pk_index.html#pk_sphere", "PK_SPHERE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_SPUN", "pk_index.html#pk_spun", "PK_SPUN");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_SURF", "pk_index.html#pk_surf", "PK_SURF");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_SWEPT", "pk_index.html#pk_swept", "PK_SWEPT");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_THREAD", "pk_index.html#pk_thread", "PK_THREAD");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_TOPOL", "pk_index.html#pk_topol", "PK_TOPOL");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_TORUS", "pk_index.html#pk_torus", "PK_TORUS");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_TRANSF", "pk_index.html#pk_transf", "PK_TRANSF");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_TRCURVE", "pk_index.html#pk_trcurve", "PK_TRCURVE");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_VECTOR", "pk_index.html#pk_vector", "PK_VECTOR");
               var level4ID = parent.theMenu.addChild(level3ID, "Document", "PK_VERTEX", "pk_index.html#pk_vertex", "PK_VERTEX");
                parent.theMenu.reload();  //Now, reload (and redraw) the menu!
            }
        }
    } else {
        setTimeout("updateMenu();", 100);
    }
}

// Now call updateMenu
updateMenu();

// end hide script from older browsers -->
</script>
</head>

<BODY bgcolor="#ffffff" link="#0F3A68" vlink="#878787" alink="#FF7600" leftmargin="0" topmargin="0" marginwidth="0" marginheight="0" background="images/background.gif">

<A NAME="topofdoc"></A>

<TABLE cellpadding=0 cellspacing=0 border=0 width=100%>
  <TR>
    <TD>&nbsp;<A href="http://www.parasolid.com/"><IMG src="graphics/psbar_l.gif" border=0></A></TD>
    <TD align=RIGHT valign=CENTER>
        <FONT face="helvetica,arial" SIZE=5 class=NS28pt>
        <B>PK Reference</B></FONT></TD>
    <TD>&nbsp;&nbsp;</TD>
  </TR>
</TABLE>

<P><TABLE WIDTH=99%>
<TR>
<TH>Part 1</TH>
<TH>Part 2</TH>
</TR>

<TR>
<TD VALIGN=TOP>

<OL>
</OL>

<OL>
<LI VALUE=1><B>PK Interface Functions</B> - <I>see list below.</I>
</OL>

<OL>
<LI VALUE=2><A HREF="pk_exclusivity.html">Function Exclusivity</A></LI>
</OL>

<OL>
<LI VALUE=3><A HREF="pk_compound_allowed.html">PK Function Compound Body Support</A></LI>
</OL>

<OL>
<LI VALUE=4><A HREF="facet_support.html">Facet Geometry Support</A></LI>
</OL>

<OL>
<LI VALUE=5><A HREF="pk_Deprecated_Functions.txt">List of Deprecated Functions</A></LI>
</OL>

<OL>
<LI VALUE=6><A HREF="PS_config.pdf">Function Availability In Sales Packages</A></LI>
</OL>

</TD>

<TD VALIGN=TOP>

<OL>
<LI><B>PK Interface Structures</B> - see the list of
<I>functions</I> below.<BR>Structures are linked from their
related functions, and typedefs are linked wherever they are
used.
</OL>

<OL TYPE=A>
<LI> <A HREF=chapters/p2_chap.02.html>PK Token Codes (Numeric)</A>
<LI> <A HREF=chapters/p2_chap.03.html>PK token Codes with descriptions (Numeric)</A>
<LI> <A HREF=chapters/p2_chap.04.html>PK token Codes (Alphabetic)</A>
<LI> <A HREF=chapters/p2_chap.05.html>PK token Codes with descriptions (Alphabetic)</A>
<LI> <A HREF=chapters/p2_chap.06.html>PK Error Codes (Numeric)</A>
<LI> <A HREF=chapters/p2_chap.07.html>PK Error Codes with descriptions (Numeric)</A>
<LI> <A HREF=chapters/p2_chap.08.html>PK Error Codes (Alphabetic)</A>
<LI> <A HREF=chapters/p2_chap.09.html>PK Error Codes with descriptions (Alphabetic)</A>
<LI> <A HREF=chapters/p2_chap.10.html>PK Error Codes (Functional)</A>
</OL>

</TD>
</TR>
</TABLE>
<HR>

<table width="100%" border="0" cellpadding="0" cellspacing="3">
	<tr>
<td><div ALIGN=CENTER><h2><A HREF="pk_index.html">Hide descriptions of functions</A></h2></div></td><td><div ALIGN=CENTER><h2><A HREF="pk_index_deprecated_long.html">Show deprecated functions </A></h2></div></td>
	</tr>
</table>

<OL>
<LI VALUE=2><B>PK Interface Functions (sorted by Class)</B>
</OL>

<UL>

<A NAME=classes_section></A>
<LI>
<A HREF="#pk_appitem">PK_APPITEM</A>
<A HREF="#pk_assembly">PK_ASSEMBLY</A>
<A HREF="#pk_attdef">PK_ATTDEF</A>
<A HREF="#pk_attrib">PK_ATTRIB</A>
<LI>
<A HREF="#pk_bb">PK_BB</A>
<A HREF="#pk_bcurve">PK_BCURVE</A>
<A HREF="#pk_blendsf">PK_BLENDSF</A>
<A HREF="#pk_body">PK_BODY</A>
<A HREF="#pk_bsurf">PK_BSURF</A>
<LI>
<A HREF="#pk_circle">PK_CIRCLE</A>
<A HREF="#pk_class">PK_CLASS</A>
<A HREF="#pk_cone">PK_CONE</A>
<A HREF="#pk_curve">PK_CURVE</A>
<A HREF="#pk_cyl">PK_CYL</A>
<LI>
<A HREF="#pk_debug">PK_DEBUG</A>
<A HREF="#pk_delta">PK_DELTA</A>
<LI>
<A HREF="#pk_edge">PK_EDGE</A>
<A HREF="#pk_ellipse">PK_ELLIPSE</A>
<A HREF="#pk_entity">PK_ENTITY</A>
<A HREF="#pk_error">PK_ERROR</A>
<LI>
<A HREF="#pk_face">PK_FACE</A>
<A HREF="#pk_fcurve">PK_FCURVE</A>
<A HREF="#pk_fin">PK_FIN</A>
<A HREF="#pk_frame">PK_FRAME</A>
<A HREF="#pk_fsurf">PK_FSURF</A>
<A HREF="#pk_function">PK_FUNCTION</A>
<LI>
<A HREF="#pk_geom">PK_GEOM</A>
<A HREF="#pk_group">PK_GROUP</A>
<LI>
<A HREF="#pk_instance">PK_INSTANCE</A>
<LI>
<A HREF="#pk_lattice">PK_LATTICE</A>
<A HREF="#pk_lball">PK_LBALL</A>
<A HREF="#pk_line">PK_LINE</A>
<A HREF="#pk_loop">PK_LOOP</A>
<A HREF="#pk_lrod">PK_LROD</A>
<A HREF="#pk_ltopol">PK_LTOPOL</A>
<LI>
<A HREF="#pk_mark">PK_MARK</A>
<A HREF="#pk_memory">PK_MEMORY</A>
<A HREF="#pk_mesh">PK_MESH</A>
<A HREF="#pk_mfacet">PK_MFACET</A>
<A HREF="#pk_mfin">PK_MFIN</A>
<A HREF="#pk_mtopol">PK_MTOPOL</A>
<A HREF="#pk_mvertex">PK_MVERTEX</A>
<LI>
<A HREF="#pk_offset">PK_OFFSET</A>
<LI>
<A HREF="#pk_part">PK_PART</A>
<A HREF="#pk_partition">PK_PARTITION</A>
<A HREF="#pk_plane">PK_PLANE</A>
<A HREF="#pk_pline">PK_PLINE</A>
<A HREF="#pk_pmark">PK_PMARK</A>
<A HREF="#pk_point">PK_POINT</A>
<LI>
<A HREF="#pk_region">PK_REGION</A>
<A HREF="#pk_report">PK_REPORT</A>
<LI>
<A HREF="#pk_session">PK_SESSION</A>
<A HREF="#pk_shell">PK_SHELL</A>
<A HREF="#pk_spcurve">PK_SPCURVE</A>
<A HREF="#pk_sphere">PK_SPHERE</A>
<A HREF="#pk_spun">PK_SPUN</A>
<A HREF="#pk_surf">PK_SURF</A>
<A HREF="#pk_swept">PK_SWEPT</A>
<LI>
<A HREF="#pk_thread">PK_THREAD</A>
<A HREF="#pk_topol">PK_TOPOL</A>
<A HREF="#pk_torus">PK_TORUS</A>
<A HREF="#pk_transf">PK_TRANSF</A>
<A HREF="#pk_trcurve">PK_TRCURVE</A>
<LI>
<A HREF="#pk_vector">PK_VECTOR</A>
<A HREF="#pk_vertex">PK_VERTEX</A>
</UL>

<HR>
<A NAME=functions_section></A>

<P><A NAME=pk_appitem></A>
<B>PK_APPITEM</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_appitem_ask.html">PK_APPITEM_ask</A></TD><TD>returns the <B>'pointers'</B> referred to by the given <B>'appitems'</B></TD></TR>
<TR><TD><A HREF="headers/pk_appitem_create.html">PK_APPITEM_create</A></TD><TD>creates <B>'appitems'</B> to refer to the given <B>'pointers'</B></TD></TR>
<TR><TD><A HREF="headers/pk_appitem_delete.html">PK_APPITEM_delete</A></TD><TD>deletes the given <B>'appitems'</B></TD></TR>
<TR><TD><A HREF="headers/pk_appitem_is.html">PK_APPITEM_is</A></TD><TD>returns PK_LOGICAL_true if its argument is an appitem</TD></TR>
<TR><TD><A HREF="headers/pk_appitem_reset_pointers.html">PK_APPITEM_reset_pointers</A></TD><TD>overwrites the pointers referred to by the given <B>'appitems'</B> with the given <B>'pointers'</B></TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_assembly></A>
<B>PK_ASSEMBLY</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_assembly_ask_instances.html">PK_ASSEMBLY_ask_instances</A></TD><TD>returns the instances in an assembly</TD></TR>
<TR><TD><A HREF="headers/pk_assembly_ask_parts.html">PK_ASSEMBLY_ask_parts</A></TD><TD>returns the parts in an assembly</TD></TR>
<TR><TD><A HREF="headers/pk_assembly_ask_parts_transfs.html">PK_ASSEMBLY_ask_parts_transfs</A></TD><TD>returns the parts in an assembly, together with their associated transforms</TD></TR>
<TR><TD><A HREF="headers/pk_assembly_check.html">PK_ASSEMBLY_check</A></TD><TD>checks the given assembly</TD></TR>
<TR><TD><A HREF="headers/pk_assembly_create_empty.html">PK_ASSEMBLY_create_empty</A></TD><TD>creates an empty assembly</TD></TR>
<TR><TD><A HREF="headers/pk_assembly_make_level_assembly.html">PK_ASSEMBLY_make_level_assembly</A></TD><TD>creates a new assembly which contains, for each path from the given assembly to a body contained in it, an instance of that body with a transform equal to the product of the transforms attached to instances along the path</TD></TR>
<TR><TD><A HREF="headers/pk_assembly_transform.html">PK_ASSEMBLY_transform</A></TD><TD>transforms an assembly by transforming its top-level instances</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_attdef></A>
<B>PK_ATTDEF</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_attdef_ask.html">PK_ATTDEF_ask</A></TD><TD>writes the standard form of an attribute definition at the given address</TD></TR>
<TR><TD><A HREF="headers/pk_attdef_ask_2.html">PK_ATTDEF_ask_2</A></TD><TD>writes the standard form of an attribute definition at the given address</TD></TR>
<TR><TD><A HREF="headers/pk_attdef_ask_callback_flags.html">PK_ATTDEF_ask_callback_flags</A></TD><TD>returns the attribute callback flags associated with <B>'attdef'</B></TD></TR>
<TR><TD><A HREF="headers/pk_attdef_ask_callbacks.html">PK_ATTDEF_ask_callbacks</A></TD><TD>returns the attribute callback functions associated with <B>'attdef'</B></TD></TR>
<TR><TD><A HREF="headers/pk_attdef_create.html">PK_ATTDEF_create</A></TD><TD>creates an attribute definition from the given standard form</TD></TR>
<TR><TD><A HREF="headers/pk_attdef_create_2.html">PK_ATTDEF_create_2</A></TD><TD>creates an attribute definition from the given standard form</TD></TR>
<TR><TD><A HREF="headers/pk_attdef_find.html">PK_ATTDEF_find</A></TD><TD>returns the attribute definition that has the given name</TD></TR>
<TR><TD><A HREF="headers/pk_attdef_is_group_closing.html">PK_ATTDEF_is_group_closing</A></TD><TD>asks whether the given <B>'attdef'</B> is a group closing attribute definition</TD></TR>
<TR><TD><A HREF="headers/pk_attdef_register_cb.html">PK_ATTDEF_register_cb</A></TD><TD>registers a set of callback functions to be called when entities with attributes with definition <B>'attdef'</B> undergo certain events</TD></TR>
<TR><TD><A HREF="headers/pk_attdef_set_callback_flags.html">PK_ATTDEF_set_callback_flags</A></TD><TD>functions set the callback function on/off flags associated with <B>'attdef'</B></TD></TR>
<TR><TD><A HREF="headers/pk_attdef_set_group_closing.html">PK_ATTDEF_set_group_closing</A></TD><TD>sets the given <B>'attdef'</B> to be a group closing attribute definition</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_attrib></A>
<B>PK_ATTRIB</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_attrib_ask_attdef.html">PK_ATTRIB_ask_attdef</A></TD><TD>returns the attribute definition of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_axes.html">PK_ATTRIB_ask_axes</A></TD><TD>returns the array of axes from field <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_doubles.html">PK_ATTRIB_ask_doubles</A></TD><TD>returns the array of doubles from field <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_ints.html">PK_ATTRIB_ask_ints</A></TD><TD>returns the array of integers from field <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_named_axes.html">PK_ATTRIB_ask_named_axes</A></TD><TD>returns the array of axes from field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_named_doubles.html">PK_ATTRIB_ask_named_doubles</A></TD><TD>returns the array of doubles from field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_named_ints.html">PK_ATTRIB_ask_named_ints</A></TD><TD>returns the array of integers from field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_named_pointers.html">PK_ATTRIB_ask_named_pointers</A></TD><TD>returns the array of pointers from field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_named_string.html">PK_ATTRIB_ask_named_string</A></TD><TD>returns the character string stored in field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_named_ustring.html">PK_ATTRIB_ask_named_ustring</A></TD><TD>returns the Unicode string stored in field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_named_vectors.html">PK_ATTRIB_ask_named_vectors</A></TD><TD>returns the array of vectors from field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_no_roll.html">PK_ATTRIB_ask_no_roll</A></TD><TD>asks whether the input attributes have the no-roll property</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_nth_axis.html">PK_ATTRIB_ask_nth_axis</A></TD><TD>returns a single element of the axis array from field <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_nth_double.html">PK_ATTRIB_ask_nth_double</A></TD><TD>returns a single element of the double array from field <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_nth_int.html">PK_ATTRIB_ask_nth_int</A></TD><TD>returns a single element of the integer array from field <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_nth_pointer.html">PK_ATTRIB_ask_nth_pointer</A></TD><TD>returns a single element of the pointer array from field <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_nth_vector.html">PK_ATTRIB_ask_nth_vector</A></TD><TD>returns a single element of the vector array from field <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_owner.html">PK_ATTRIB_ask_owner</A></TD><TD>returns the owner of an attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_pointers.html">PK_ATTRIB_ask_pointers</A></TD><TD>returns the array of pointers from field <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_string.html">PK_ATTRIB_ask_string</A></TD><TD>returns the character string stored in field number <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_ustring.html">PK_ATTRIB_ask_ustring</A></TD><TD>returns the Unicode string stored in field number <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_ask_vectors.html">PK_ATTRIB_ask_vectors</A></TD><TD>returns the array of vectors from field <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_create_empty.html">PK_ATTRIB_create_empty</A></TD><TD>creates an attribute with the given definition with no data (all fields of length zero), and attaches it to the given entity</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_axes.html">PK_ATTRIB_set_axes</A></TD><TD>copies <B>'axes'</B> into field number <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_doubles.html">PK_ATTRIB_set_doubles</A></TD><TD>copies <B>'doubles'</B> into field number <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_ints.html">PK_ATTRIB_set_ints</A></TD><TD>copies <B>'ints'</B> into field number <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_named_axes.html">PK_ATTRIB_set_named_axes</A></TD><TD>copies <B>'axes'</B> into field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_named_doubles.html">PK_ATTRIB_set_named_doubles</A></TD><TD>copies <B>'doubles'</B> into field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_named_ints.html">PK_ATTRIB_set_named_ints</A></TD><TD>copies <B>'ints'</B> into field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_named_pointers.html">PK_ATTRIB_set_named_pointers</A></TD><TD>copies <B>'pointers'</B> into field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_named_string.html">PK_ATTRIB_set_named_string</A></TD><TD>copies <B>'string'</B> into field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_named_ustring.html">PK_ATTRIB_set_named_ustring</A></TD><TD>copies Unicode <B>'string'</B> into field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_named_vectors.html">PK_ATTRIB_set_named_vectors</A></TD><TD>copies <B>'vectors'</B> into field <B>'field_name'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_no_roll.html">PK_ATTRIB_set_no_roll</A></TD><TD>sets the given attributes to be no-roll attributes</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_pointers.html">PK_ATTRIB_set_pointers</A></TD><TD>copies <B>'pointers'</B> into field number <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_string.html">PK_ATTRIB_set_string</A></TD><TD>copies <B>'string'</B> into field number <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_ustring.html">PK_ATTRIB_set_ustring</A></TD><TD>copies Unicode <B>'string'</B> into field number <B>'field_no'</B> of the given attribute</TD></TR>
<TR><TD><A HREF="headers/pk_attrib_set_vectors.html">PK_ATTRIB_set_vectors</A></TD><TD>copies <B>'vectors'</B> into field number <B>'field_no'</B> of the given attribute</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_bb></A>
<B>PK_BB</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_bb_ask.html">PK_BB_ask</A></TD><TD>returns the standard form of the bulletin board</TD></TR>
<TR><TD><A HREF="headers/pk_bb_ask_status.html">PK_BB_ask_status</A></TD><TD>returns the status of the bulletin board</TD></TR>
<TR><TD><A HREF="headers/pk_bb_create.html">PK_BB_create</A></TD><TD>creates the bulletin board from its standard form</TD></TR>
<TR><TD><A HREF="headers/pk_bb_is.html">PK_BB_is</A></TD><TD>returns whether the received argument is a bulletin board</TD></TR>
<TR><TD><A HREF="headers/pk_bb_is_empty.html">PK_BB_is_empty</A></TD><TD>returns PK_LOGICAL_true if the Bulletin Board is off, or on and empty (i</TD></TR>
<TR><TD><A HREF="headers/pk_bb_output_events.html">PK_BB_output_events</A></TD><TD>outputs the events stored in the bulletin board</TD></TR>
<TR><TD><A HREF="headers/pk_bb_set_status.html">PK_BB_set_status</A></TD><TD>sets the status of a bulletin board</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_bcurve></A>
<B>PK_BCURVE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_bcurve_add_knot.html">PK_BCURVE_add_knot</A></TD><TD>modifies the given <B>'bcurve'</B> by inserting a knot at the given split parameter</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_ask.html">PK_BCURVE_ask</A></TD><TD>returns the standard form for a b-curve</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_ask_knots.html">PK_BCURVE_ask_knots</A></TD><TD>returns the uniques knots and the multiplicities of a given B-curve</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_ask_piecewise.html">PK_BCURVE_ask_piecewise</A></TD><TD>returns the piecewise standard form for a b-curve</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_ask_splinewise.html">PK_BCURVE_ask_splinewise</A></TD><TD>returns the splinewise standard form of a b-curve</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_clamp_knots.html">PK_BCURVE_clamp_knots</A></TD><TD>modifies the given <B>'bcurve'</B> by clamping its knotset to have bezier end conditions</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_create.html">PK_BCURVE_create</A></TD><TD>creates a b-curve from the standard form</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_create_by_fitting.html">PK_BCURVE_create_by_fitting</A></TD><TD>creates a set of bcurves by curve-fitting to within a tolerance</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_create_fitted.html">PK_BCURVE_create_fitted</A></TD><TD>creates a B-curve by fitting a curve to within a tolerance</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_create_piecewise.html">PK_BCURVE_create_piecewise</A></TD><TD>creates a b-curve from its piecewise standard form</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_create_spline_2.html">PK_BCURVE_create_spline_2</A></TD><TD>creates one or more B-curves by splining through a set of positions, with optional parameters and derivatives</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_create_splinewise.html">PK_BCURVE_create_splinewise</A></TD><TD>creates a b-curve from its splinewise standard form</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_extend.html">PK_BCURVE_extend</A></TD><TD>extends a bcurve</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_find_g1_discontinuity.html">PK_BCURVE_find_g1_discontinuity</A></TD><TD>finds G1 discontinuities on a B-curve</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_join.html">PK_BCURVE_join</A></TD><TD>creates a new <B>'bcurve'</B> by joining together a sequence of <B>'bcurves'</B></TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_lower_degree.html">PK_BCURVE_lower_degree</A></TD><TD>modifies the given <B>'bcurve'</B> by reducing its degree by the specified <B>'decrement'</B></TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_make_bsurf_lofted.html">PK_BCURVE_make_bsurf_lofted</A></TD><TD>creates a bsurf by lofting through a set of bcurves</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_make_matched.html">PK_BCURVE_make_matched</A></TD><TD>takes <B>'bcurves'</B> and creates a new set of curves <B>'matched'</B> which are identical in shape to the original curves, but whose knot sets are all the same as each other</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_raise_degree.html">PK_BCURVE_raise_degree</A></TD><TD>modifies the given <B>'bcurve'</B> by raising its degree by <B>'increment'</B></TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_remove_knots.html">PK_BCURVE_remove_knots</A></TD><TD>modifies the given <B>'bcurve'</B> by removing knots</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_reparameterise.html">PK_BCURVE_reparameterise</A></TD><TD>performs a rescaling and translation of the knot vector of the B-curve</TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_spin.html">PK_BCURVE_spin</A></TD><TD>spins a <B>'bcurve'</B> into a <B>'bsurf'</B></TD></TR>
<TR><TD><A HREF="headers/pk_bcurve_sweep.html">PK_BCURVE_sweep</A></TD><TD>sweeps a <B>'bcurve'</B> into a <B>'bsurf'</B></TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_blendsf></A>
<B>PK_BLENDSF</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_blendsf_ask.html">PK_BLENDSF_ask</A></TD><TD>returns the standard form of a rolling ball blend surface</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_body></A>
<B>PK_BODY</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_body_add_to_compound.html">PK_BODY_add_to_compound</A></TD><TD>adds <B>'bodies'</B> to an existing <B>'compound'</B> body, so they become child bodies with the compound body as their parent</TD></TR>
<TR><TD><A HREF="headers/pk_body_apply_knit_pattern.html">PK_BODY_apply_knit_pattern</A></TD><TD>assembles a composite sheet or solid body by merging paired edge in the knit pattern  does not support facet geometry [NF]</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_children.html">PK_BODY_ask_children</A></TD><TD>if <B>'body'</B> is a compound body, this function returns its child bodies</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_components.html">PK_BODY_ask_components</A></TD><TD>returns the components of the given body</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_config.html">PK_BODY_ask_config</A></TD><TD>the function returns the body configuration, which is described in the documentation of PK_BODY_config_t</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_curve_nmnl_state.html">PK_BODY_ask_curve_nmnl_state</A></TD><TD>returns whether nominal curves are enabled for the <B>'body'</B></TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_edges.html">PK_BODY_ask_edges</A></TD><TD>returns the set of edges in the given body</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_faces.html">PK_BODY_ask_faces</A></TD><TD>returns the set of faces in the given <B>'body'</B></TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_fins.html">PK_BODY_ask_fins</A></TD><TD>returns the set of fins in the given body</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_first_edge.html">PK_BODY_ask_first_edge</A></TD><TD>returns an edge in the given body, if one exists, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_first_face.html">PK_BODY_ask_first_face</A></TD><TD>returns a face in the given body, if one exists, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_frames.html">PK_BODY_ask_frames</A></TD><TD>returns the set of <B>'frames'</B> in the given <B>'body'</B></TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_loops.html">PK_BODY_ask_loops</A></TD><TD>return the set of loops in the given body</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_memory_usage.html">PK_BODY_ask_memory_usage</A></TD><TD>returns the amount of memory currently occupied by the body's data structures</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_parent.html">PK_BODY_ask_parent</A></TD><TD>returns the compound body containing <B>'body'</B>, if any</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_regions.html">PK_BODY_ask_regions</A></TD><TD>returns the regions of the given body</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_shells.html">PK_BODY_ask_shells</A></TD><TD>returns the set of shells in the given body</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_topology.html">PK_BODY_ask_topology</A></TD><TD>returns a definition of the topology of a body</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_type.html">PK_BODY_ask_type</A></TD><TD>classifies the given body</TD></TR>
<TR><TD><A HREF="headers/pk_body_ask_vertices.html">PK_BODY_ask_vertices</A></TD><TD>returns the set of vertices in the given body</TD></TR>
<TR><TD><A HREF="headers/pk_body_boolean_2.html">PK_BODY_boolean_2</A></TD><TD>performs a boolean operation between the target body and the list of tool bodies</TD></TR>
<TR><TD><A HREF="headers/pk_body_change_partition.html">PK_BODY_change_partition</A></TD><TD>moves the given <B>'body'</B> and the entities within it into the given <B>'partition'</B>, without changing their tags</TD></TR>
<TR><TD><A HREF="headers/pk_body_check.html">PK_BODY_check</A></TD><TD>checks the given body</TD></TR>
<TR><TD><A HREF="headers/pk_body_contains_vector.html">PK_BODY_contains_vector</A></TD><TD>determines whether the point represented by the given position vector lies inside, outside, or on the boundary of the given body</TD></TR>
<TR><TD><A HREF="headers/pk_body_copy_topology.html">PK_BODY_copy_topology</A></TD><TD>produces a new body which is a copy of the given body, with no geometry being copied</TD></TR>
<TR><TD><A HREF="headers/pk_body_create_sheet_circle.html">PK_BODY_create_sheet_circle</A></TD><TD>creates a circular sheet</TD></TR>
<TR><TD><A HREF="headers/pk_body_create_sheet_planar.html">PK_BODY_create_sheet_planar</A></TD><TD>creates a planar sheet whose boundary is an irregular polygon</TD></TR>
<TR><TD><A HREF="headers/pk_body_create_sheet_polygon.html">PK_BODY_create_sheet_polygon</A></TD><TD>creates a polygonal sheet</TD></TR>
<TR><TD><A HREF="headers/pk_body_create_sheet_rectangle.html">PK_BODY_create_sheet_rectangle</A></TD><TD>creates a sheet rectangle</TD></TR>
<TR><TD><A HREF="headers/pk_body_create_solid_block.html">PK_BODY_create_solid_block</A></TD><TD>creates a solid block</TD></TR>
<TR><TD><A HREF="headers/pk_body_create_solid_cone.html">PK_BODY_create_solid_cone</A></TD><TD>creates a solid cone</TD></TR>
<TR><TD><A HREF="headers/pk_body_create_solid_cyl.html">PK_BODY_create_solid_cyl</A></TD><TD>creates a solid cylinder</TD></TR>
<TR><TD><A HREF="headers/pk_body_create_solid_prism.html">PK_BODY_create_solid_prism</A></TD><TD>creates a solid prism</TD></TR>
<TR><TD><A HREF="headers/pk_body_create_solid_sphere.html">PK_BODY_create_solid_sphere</A></TD><TD>creates a solid sphere</TD></TR>
<TR><TD><A HREF="headers/pk_body_create_solid_torus.html">PK_BODY_create_solid_torus</A></TD><TD>creates a solid torus</TD></TR>
<TR><TD><A HREF="headers/pk_body_create_topology_2.html">PK_BODY_create_topology_2</A></TD><TD>creates the topology of a general body</TD></TR>
<TR><TD><A HREF="headers/pk_body_disjoin.html">PK_BODY_disjoin</A></TD><TD>divides the target body into one or more disjoint bodies, each of which represents a connected point-set</TD></TR>
<TR><TD><A HREF="headers/pk_body_embed_in_surf.html">PK_BODY_embed_in_surf</A></TD><TD>constructs the representation of a sheet body in the parameter space of its existing surface and embeds that in the parameter space of a new surface</TD></TR>
<TR><TD><A HREF="headers/pk_body_emboss.html">PK_BODY_emboss</A></TD><TD>creates emboss features on the target body</TD></TR>
<TR><TD><A HREF="headers/pk_body_enlarge.html">PK_BODY_enlarge</A></TD><TD>creates a new body by enlarging the body by the given factor</TD></TR>
<TR><TD><A HREF="headers/pk_body_extend.html">PK_BODY_extend</A></TD><TD>will extend a body across a set of laminar boundary edges</TD></TR>
<TR><TD><A HREF="headers/pk_body_extrude.html">PK_BODY_extrude</A></TD><TD>creates a new body by performing a linear extrusion of a given profile</TD></TR>
<TR><TD><A HREF="headers/pk_body_fill_hole.html">PK_BODY_fill_hole</A></TD><TD>will fill a hole in a body or collection of bodies with a set of faces</TD></TR>
<TR><TD><A HREF="headers/pk_body_find_extreme.html">PK_BODY_find_extreme</A></TD><TD>finds the extreme point on the given <B>'body'</B> in <B>'direction_1'</B></TD></TR>
<TR><TD><A HREF="headers/pk_body_find_facesets.html">PK_BODY_find_facesets</A></TD><TD> finds all the facesets on the body and splits those that are divided by the input edges into smaller facesets</TD></TR>
<TR><TD><A HREF="headers/pk_body_find_knit_pattern.html">PK_BODY_find_knit_pattern</A></TD><TD>constructs a knitting pattern by matching and splitting coincident edges, then pairing them off into corresponding entries in two edge arrays</TD></TR>
<TR><TD><A HREF="headers/pk_body_find_laminar_edges.html">PK_BODY_find_laminar_edges</A></TD><TD>returns the laminar edges in the given body</TD></TR>
<TR><TD><A HREF="headers/pk_body_fix_blends.html">PK_BODY_fix_blends</A></TD><TD>changes any edges of the given body which have had blends set on them by the PK_EDGE_set_blend_ functions, into faces with the appropriate surface geometry</TD></TR>
<TR><TD><A HREF="headers/pk_body_hollow_2.html">PK_BODY_hollow_2</A></TD><TD>hollows a solid body by offsetting all faces of the body by the given offset distance  NOTE : This function supersedes PK_BODY_hollow</TD></TR>
<TR><TD><A HREF="headers/pk_body_identify_details.html">PK_BODY_identify_details</A></TD><TD>identifies classic or rubber details in the given <B>'body'</B> of the types specified in <B>'details'</B></TD></TR>
<TR><TD><A HREF="headers/pk_body_identify_facesets.html">PK_BODY_identify_facesets</A></TD><TD> identifies surviving facesets, given matching edges on the target and tool bodies</TD></TR>
<TR><TD><A HREF="headers/pk_body_identify_general.html">PK_BODY_identify_general</A></TD><TD>identifies characteristics of a general body which require it to be of type PK_BODY_type_general_c</TD></TR>
<TR><TD><A HREF="headers/pk_body_imprint_body.html">PK_BODY_imprint_body</A></TD><TD>imprints edges on the given target and tool bodies</TD></TR>
<TR><TD><A HREF="headers/pk_body_imprint_curve.html">PK_BODY_imprint_curve</A></TD><TD>imprints a curve onto a body, thereby creating a new edge or edges</TD></TR>
<TR><TD><A HREF="headers/pk_body_imprint_cus_shadow.html">PK_BODY_imprint_cus_shadow</A></TD><TD>takes the given bodies and splits their faces into portions which are completely visible in the given view direction by imprinting the <B>'shadow'</B> curves cast by overlapping faces in front</TD></TR>
<TR><TD><A HREF="headers/pk_body_imprint_faces_2.html">PK_BODY_imprint_faces_2</A></TD><TD>imprints edges on the given target body and tool faces</TD></TR>
<TR><TD><A HREF="headers/pk_body_imprint_plane_2.html">PK_BODY_imprint_plane_2</A></TD><TD>intersects the supplied plane with the faces of the body and imprints edges and vertices at the intersections</TD></TR>
<TR><TD><A HREF="headers/pk_body_intersect_bodies.html">PK_BODY_intersect_bodies</A></TD><TD>performs a boolean intersect operation between the target body and the list of tool bodies</TD></TR>
<TR><TD><A HREF="headers/pk_body_is_cellular.html">PK_BODY_is_cellular</A></TD><TD>returns whether the given body is cellular</TD></TR>
<TR><TD><A HREF="headers/pk_body_knit.html">PK_BODY_knit</A></TD><TD>assembles a body by merging paired topols from the <B>'topols'</B> and <B>'matches'</B> array</TD></TR>
<TR><TD><A HREF="headers/pk_body_make_compound.html">PK_BODY_make_compound</A></TD><TD>creates a compound body containing <B>'bodies'</B></TD></TR>
<TR><TD><A HREF="headers/pk_body_make_curves_outline.html">PK_BODY_make_curves_outline</A></TD><TD>outputs one or more outlines of a body or bodies for a given view direction as a set of ordered curves together with their intervals</TD></TR>
<TR><TD><A HREF="headers/pk_body_make_facet_body.html">PK_BODY_make_facet_body</A></TD><TD>produces a new body which is a copy of the given body with its geometry replaced with facet geometry generated using the supplied options</TD></TR>
<TR><TD><A HREF="headers/pk_body_make_lofted_body.html">PK_BODY_make_lofted_body</A></TD><TD>creates a sheet or solid body based on surfaces created by lofting through a set of sheet, wire or minimum body profiles</TD></TR>
<TR><TD><A HREF="headers/pk_body_make_manifold_bodies.html">PK_BODY_make_manifold_bodies</A></TD><TD>breaks a body into manifold pieces</TD></TR>
<TR><TD><A HREF="headers/pk_body_make_patterned.html">PK_BODY_make_patterned</A></TD><TD>creates a body made of patterned repetitions of the given body</TD></TR>
<TR><TD><A HREF="headers/pk_body_make_persp_outline.html">PK_BODY_make_persp_outline</A></TD><TD>produces outlines for viewing bodies of type PK_BODY_type_solid_c or PK_BODY_type_sheet_c from the <B>'eye_position'</B>, to give a perspective view</TD></TR>
<TR><TD><A HREF="headers/pk_body_make_section.html">PK_BODY_make_section</A></TD><TD>generates sections of target bodies using set of tool bodies</TD></TR>
<TR><TD><A HREF="headers/pk_body_make_section_with_surfs.html">PK_BODY_make_section_with_surfs</A></TD><TD>generates sections of target bodies using set of tool surfaces</TD></TR>
<TR><TD><A HREF="headers/pk_body_make_spun_outline.html">PK_BODY_make_spun_outline</A></TD><TD>outputs one or more outlines of a body or bodies for a given spin axis as a set of ordered curves together with their intervals</TD></TR>
<TR><TD><A HREF="headers/pk_body_make_swept_body_2.html">PK_BODY_make_swept_body_2</A></TD><TD>creates a sheet or solid body by sweeping a set of wire or sheet profiles along a wire path</TD></TR>
<TR><TD><A HREF="headers/pk_body_make_swept_tool.html">PK_BODY_make_swept_tool</A></TD><TD>creates a solid body by sweeping a solid tool body along a wire path</TD></TR>
<TR><TD><A HREF="headers/pk_body_offset_2.html">PK_BODY_offset_2</A></TD><TD>offsets faces of a solid or sheet body</TD></TR>
<TR><TD><A HREF="headers/pk_body_offset_planar_wire.html">PK_BODY_offset_planar_wire</A></TD><TD>offsets a planar wire body in the plane by a specified distance</TD></TR>
<TR><TD><A HREF="headers/pk_body_pick_topols.html">PK_BODY_pick_topols</A></TD><TD>pick entities from an array of body instances by their proximity to a line</TD></TR>
<TR><TD><A HREF="headers/pk_body_remove_from_parents.html">PK_BODY_remove_from_parents</A></TD><TD>removes the given child bodies from their parents</TD></TR>
<TR><TD><A HREF="headers/pk_body_repair_shells.html">PK_BODY_repair_shells</A></TD><TD>attempts to repair the shell and region structure of the given <B>'body'</B></TD></TR>
<TR><TD><A HREF="headers/pk_body_reverse_orientation.html">PK_BODY_reverse_orientation</A></TD><TD>reverses the orientation of a body</TD></TR>
<TR><TD><A HREF="headers/pk_body_section_with_sheet_2.html">PK_BODY_section_with_sheet_2</A></TD><TD>sections the target body with the tool sheet body</TD></TR>
<TR><TD><A HREF="headers/pk_body_section_with_surf.html">PK_BODY_section_with_surf</A></TD><TD>sections the target body with the tool surface</TD></TR>
<TR><TD><A HREF="headers/pk_body_set_curve_nmnl_state.html">PK_BODY_set_curve_nmnl_state</A></TD><TD>sets whether nominal curves are enabled for the <B>'body'</B></TD></TR>
<TR><TD><A HREF="headers/pk_body_set_type.html">PK_BODY_set_type</A></TD><TD>tries to change the type of the body (e</TD></TR>
<TR><TD><A HREF="headers/pk_body_sew_bodies.html">PK_BODY_sew_bodies</A></TD><TD>attempts to sew the received bodies together where they have edges common to within a given tolerance upper bound</TD></TR>
<TR><TD><A HREF="headers/pk_body_share_geom.html">PK_BODY_share_geom</A></TD><TD>attempts to reduce the size of a part by sharing geometry</TD></TR>
<TR><TD><A HREF="headers/pk_body_simplify_geom.html">PK_BODY_simplify_geom</A></TD><TD>simplifies the classic geometry of a body where possible</TD></TR>
<TR><TD><A HREF="headers/pk_body_spin.html">PK_BODY_spin</A></TD><TD>spins a minimum body into a wire body, a wire body into a sheet body, a sheet body into a solid body or a general body into a general body</TD></TR>
<TR><TD><A HREF="headers/pk_body_subtract_bodies.html">PK_BODY_subtract_bodies</A></TD><TD>performs a boolean subtract operation between the target body and the list of tool bodies</TD></TR>
<TR><TD><A HREF="headers/pk_body_sweep.html">PK_BODY_sweep</A></TD><TD>sweeps a minimum body into a wire body, a wire body into a sheet body, a sheet body into a solid body or a general body into a general body</TD></TR>
<TR><TD><A HREF="headers/pk_body_taper.html">PK_BODY_taper</A></TD><TD>applies two-sided tapering to the <B>'body'</B> parted by the <B>'parting_body'</B></TD></TR>
<TR><TD><A HREF="headers/pk_body_thicken_3.html">PK_BODY_thicken_3</A></TD><TD>thickens a sheet body into a solid body</TD></TR>
<TR><TD><A HREF="headers/pk_body_transform_2.html">PK_BODY_transform_2</A></TD><TD>transforms the given body by the given transformation</TD></TR>
<TR><TD><A HREF="headers/pk_body_trim.html">PK_BODY_trim</A></TD><TD>trims the <B>'body'</B> which must be a sheet</TD></TR>
<TR><TD><A HREF="headers/pk_body_trim_gap_analysis.html">PK_BODY_trim_gap_analysis</A></TD><TD>finds gaps in the edges supplied to a failed trim operation</TD></TR>
<TR><TD><A HREF="headers/pk_body_trim_neutral_sheets_2.html">PK_BODY_trim_neutral_sheets_2</A></TD><TD>trims the neutral sheets in accordance with their pairs of face sets</TD></TR>
<TR><TD><A HREF="headers/pk_body_unite_bodies.html">PK_BODY_unite_bodies</A></TD><TD>performs a boolean unite operation between the target body and the list of tool bodies</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_bsurf></A>
<B>PK_BSURF</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_bsurf_add_u_knot.html">PK_BSURF_add_u_knot</A></TD><TD>modifies the given <B>'bsurf'</B> by inserting a knot at the given <B>'u'</B> split parameter</TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_add_v_knot.html">PK_BSURF_add_v_knot</A></TD><TD>modifies the given <B>'bsurf'</B> by inserting a knot at the given <B>'v'</B> split parameter</TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_ask.html">PK_BSURF_ask</A></TD><TD>returns the standard form for a b_surface</TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_ask_knots.html">PK_BSURF_ask_knots</A></TD><TD>returns the unique knots and the multiplicities of a given B-surface</TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_ask_piecewise.html">PK_BSURF_ask_piecewise</A></TD><TD>returns the piecewise standard form for a b-surface</TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_ask_splinewise.html">PK_BSURF_ask_splinewise</A></TD><TD>returns the splinewise standard form of a b-surface</TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_clamp_knots.html">PK_BSURF_clamp_knots</A></TD><TD>modifies the given <B>'bsurf'</B> by clamping its knotset to have bezier end conditions</TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_create.html">PK_BSURF_create</A></TD><TD>creates a b-surface from the standard form</TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_create_constrained.html">PK_BSURF_create_constrained</A></TD><TD>creates a constrained B-surface</TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_create_fitted.html">PK_BSURF_create_fitted</A></TD><TD>creates a B-surface by fitting an input surface to within a tolerance</TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_create_piecewise.html">PK_BSURF_create_piecewise</A></TD><TD>creates a b-surface from a piecewise standard form</TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_create_splinewise.html">PK_BSURF_create_splinewise</A></TD><TD>creates a b-surface from its splinewise standard form</TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_find_g1_discontinuity.html">PK_BSURF_find_g1_discontinuity</A></TD><TD>finds G1 discontinuities on a B-surface</TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_lower_degree.html">PK_BSURF_lower_degree</A></TD><TD>modifies the given <B>'bsurf'</B> by reducing its <B>'u_or_v'</B> degree by <B>'decrement'</B></TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_raise_degree.html">PK_BSURF_raise_degree</A></TD><TD>modifies the given <B>'bsurf'</B> by raising its <B>'u_or_v'</B> degree by <B>'increment'</B></TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_remove_knots.html">PK_BSURF_remove_knots</A></TD><TD>modifies the given <B>'bsurf'</B> by removing knots in the parameter direction given by <B>'u_or_v'</B></TD></TR>
<TR><TD><A HREF="headers/pk_bsurf_reparameterise.html">PK_BSURF_reparameterise</A></TD><TD>performs a general U,V reparameterisation of the received <B>'bsurf'</B>, including options to transpose, reverse or rescale the U,V directions</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_circle></A>
<B>PK_CIRCLE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_circle_ask.html">PK_CIRCLE_ask</A></TD><TD>writes the standard form of a circle at the given address</TD></TR>
<TR><TD><A HREF="headers/pk_circle_create.html">PK_CIRCLE_create</A></TD><TD>creates a circle from the given standard form</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_class></A>
<B>PK_CLASS</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_class_ask_superclass.html">PK_CLASS_ask_superclass</A></TD><TD>return the class token of the given class's immediate superclass</TD></TR>
<TR><TD><A HREF="headers/pk_class_is_subclass.html">PK_CLASS_is_subclass</A></TD><TD>returns whether <B>'may_be_subclass'</B> is a subclass of <B>'class'</B></TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_cone></A>
<B>PK_CONE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_cone_ask.html">PK_CONE_ask</A></TD><TD>returns the standard form of the given cone</TD></TR>
<TR><TD><A HREF="headers/pk_cone_create.html">PK_CONE_create</A></TD><TD>creates a cone from the given standard form</TD></TR>
<TR><TD><A HREF="headers/pk_cone_make_solid_body.html">PK_CONE_make_solid_body</A></TD><TD>creates a solid body from a conical surface</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_curve></A>
<B>PK_CURVE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_curve_ask_edges.html">PK_CURVE_ask_edges</A></TD><TD>returns the set of accurate edges to which the given curve is attached</TD></TR>
<TR><TD><A HREF="headers/pk_curve_ask_edges_nmnl.html">PK_CURVE_ask_edges_nmnl</A></TD><TD>returns the set of edges to which the given curve is attached, either as the curve of an accurate edge or as the nominal curve of a tolerant edge</TD></TR>
<TR><TD><A HREF="headers/pk_curve_ask_fin.html">PK_CURVE_ask_fin</A></TD><TD>returns the fin to which the given curve is attached, if there is one, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_curve_ask_interval.html">PK_CURVE_ask_interval</A></TD><TD>returns an interval indicating the parametric bounds of the given curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_ask_param.html">PK_CURVE_ask_param</A></TD><TD>returns information about the parameterisation of the given curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_ask_parm_different.html">PK_CURVE_ask_parm_different</A></TD><TD>returns true if the curve has a different parametrisation at the PK than at the KI</TD></TR>
<TR><TD><A HREF="headers/pk_curve_ask_part.html">PK_CURVE_ask_part</A></TD><TD>returns the part which owns the given curve, if there is one, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_curve_convert_parm_to_ki.html">PK_CURVE_convert_parm_to_ki</A></TD><TD>converts pk parameters on the given curve, to ki parameters</TD></TR>
<TR><TD><A HREF="headers/pk_curve_convert_parm_to_pk.html">PK_CURVE_convert_parm_to_pk</A></TD><TD>converts ki parameters on the given curve, to pk parameters</TD></TR>
<TR><TD><A HREF="headers/pk_curve_embed_in_surf_2.html">PK_CURVE_embed_in_surf_2</A></TD><TD>creates one or more spcurves by embedding a b-spline representation of a specified section of a curve in parameter space (or the Z=0 plane) into the parameter space of a given surface</TD></TR>
<TR><TD><A HREF="headers/pk_curve_eval.html">PK_CURVE_eval</A></TD><TD>evaluates a point and derivatives at a given parameter on the given curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_eval_curvature.html">PK_CURVE_eval_curvature</A></TD><TD>calculates the tangent, principal normal, binormal and curvature of a <B>'curve'</B> at the given parametric position</TD></TR>
<TR><TD><A HREF="headers/pk_curve_eval_curvature_handed.html">PK_CURVE_eval_curvature_handed</A></TD><TD>behaves like PK_CURVE_eval_curvature but takes an additional direction argument</TD></TR>
<TR><TD><A HREF="headers/pk_curve_eval_handed.html">PK_CURVE_eval_handed</A></TD><TD>the function behaves like PK_CURVE_eval but takes an additional argument to control the direction of the evaluation</TD></TR>
<TR><TD><A HREF="headers/pk_curve_eval_with_tan_handed.html">PK_CURVE_eval_with_tan_handed</A></TD><TD>behaves like PK_CURVE_eval_with_tangent but takes an additional direction argument</TD></TR>
<TR><TD><A HREF="headers/pk_curve_eval_with_tangent.html">PK_CURVE_eval_with_tangent</A></TD><TD>evaluates a point, derivatives and tangent at a given parameter on the given curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_find_box.html">PK_CURVE_find_box</A></TD><TD>returns a BOX which bounds the given curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_find_degens.html">PK_CURVE_find_degens</A></TD><TD>finds degeneracies on the given curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_find_discontinuity.html">PK_CURVE_find_discontinuity</A></TD><TD>interface function permits a user to query any standard curve type for either analytic or geometric discontinuities of levels 1 through 3</TD></TR>
<TR><TD><A HREF="headers/pk_curve_find_length.html">PK_CURVE_find_length</A></TD><TD>evaluates the arc length of that part of the given curve specified by the given parametric interval</TD></TR>
<TR><TD><A HREF="headers/pk_curve_find_min_radius.html">PK_CURVE_find_min_radius</A></TD><TD>finds the minimum radius of curvature of the given curve, its position and parameter</TD></TR>
<TR><TD><A HREF="headers/pk_curve_find_non_aligned_box.html">PK_CURVE_find_non_aligned_box</A></TD><TD>computes a non axis-aligned box bounding a portion of the given curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_find_self_int.html">PK_CURVE_find_self_int</A></TD><TD>finds self-intersections in the given curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_find_surfs_common.html">PK_CURVE_find_surfs_common</A></TD><TD>finds pairs of surfaces which have the given curve in common</TD></TR>
<TR><TD><A HREF="headers/pk_curve_find_vector_interval.html">PK_CURVE_find_vector_interval</A></TD><TD>returns the parameter interval of a curve bounded by two position vectors lying on the curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_find_vectors.html">PK_CURVE_find_vectors</A></TD><TD>returns position vectors on the supplied curve given measurements in 3-space</TD></TR>
<TR><TD><A HREF="headers/pk_curve_fix_degens.html">PK_CURVE_fix_degens</A></TD><TD>attempts to fix degeneracies on the given curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_fix_self_int.html">PK_CURVE_fix_self_int</A></TD><TD>attempts to fix self-intersections in the given curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_intersect_curve.html">PK_CURVE_intersect_curve</A></TD><TD>PK_CURVE_intersect_curve finds the intersections between specified regions of two curves</TD></TR>
<TR><TD><A HREF="headers/pk_curve_is_isoparam.html">PK_CURVE_is_isoparam</A></TD><TD>tests whether a bounded curve lying within a surface is a constant-parameter curve (i</TD></TR>
<TR><TD><A HREF="headers/pk_curve_make_approx.html">PK_CURVE_make_approx</A></TD><TD>creates a curve which is an arc length parametrised approximation to a supplied curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_make_bcurve_2.html">PK_CURVE_make_bcurve_2</A></TD><TD>creates a B-curve which is coincident with the given parametric <B>'range'</B> of the given <B>'curve'</B></TD></TR>
<TR><TD><A HREF="headers/pk_curve_make_bcurve_array.html">PK_CURVE_make_bcurve_array</A></TD><TD>given an array of curves and intervals this function creates B-curves that satisfy the <B>'options'</B> specified</TD></TR>
<TR><TD><A HREF="headers/pk_curve_make_curve_reversed.html">PK_CURVE_make_curve_reversed</A></TD><TD>makes a new curve which is coincident with the given <B>'curve'</B> but whose parameter increases in the opposite direction along the curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_make_helical_surf.html">PK_CURVE_make_helical_surf</A></TD><TD>creates a helix, tapered helix or spiral surface by sweeping a part of a curve about an axis</TD></TR>
<TR><TD><A HREF="headers/pk_curve_make_spcurves_2.html">PK_CURVE_make_spcurves_2</A></TD><TD>creates an SP-curve representation of a curve which lies, possibly approximately, in a surface</TD></TR>
<TR><TD><A HREF="headers/pk_curve_make_surf_isocline.html">PK_CURVE_make_surf_isocline</A></TD><TD>makes an isocline surface <B>'surf'</B> which passes through the given <B>'t_interval'</B> of the given <B>'curve'</B></TD></TR>
<TR><TD><A HREF="headers/pk_curve_make_wire_body_2.html">PK_CURVE_make_wire_body_2</A></TD><TD>creates a wire body from an array of curves and intervals</TD></TR>
<TR><TD><A HREF="headers/pk_curve_output_vectors.html">PK_CURVE_output_vectors</A></TD><TD>outputs position vectors along a curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_parameterise_vector.html">PK_CURVE_parameterise_vector</A></TD><TD>find parameter of point on curve</TD></TR>
<TR><TD><A HREF="headers/pk_curve_project.html">PK_CURVE_project</A></TD><TD>projects and/or imprints the supplied curves onto the given target entities</TD></TR>
<TR><TD><A HREF="headers/pk_curve_spin_2.html">PK_CURVE_spin_2</A></TD><TD>spins a curve to form a surface</TD></TR>
<TR><TD><A HREF="headers/pk_curve_sweep.html">PK_CURVE_sweep</A></TD><TD>sweeps a curve to form a surface</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_cyl></A>
<B>PK_CYL</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_cyl_ask.html">PK_CYL_ask</A></TD><TD>returns the standard form of the given cylinder</TD></TR>
<TR><TD><A HREF="headers/pk_cyl_create.html">PK_CYL_create</A></TD><TD>creates a cylinder from the given standard form</TD></TR>
<TR><TD><A HREF="headers/pk_cyl_make_solid_body.html">PK_CYL_make_solid_body</A></TD><TD>creates a solid body from a cylindrical surface</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_debug></A>
<B>PK_DEBUG</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_debug_behaviours_start.html">PK_DEBUG_behaviours_start</A></TD><TD>initialises and starts the debug of the behaviours mechanism</TD></TR>
<TR><TD><A HREF="headers/pk_debug_behaviours_stop.html">PK_DEBUG_behaviours_stop</A></TD><TD>stops the debug of the behaviours mechanism</TD></TR>
<TR><TD><A HREF="headers/pk_debug_body_compare.html">PK_DEBUG_body_compare</A></TD><TD></TD></TR>
<TR><TD><A HREF="headers/pk_debug_body_extract_data.html">PK_DEBUG_body_extract_data</A></TD><TD></TD></TR>
<TR><TD><A HREF="headers/pk_debug_receive.html">PK_DEBUG_receive</A></TD><TD>receives a transmit file and extracts any additional data, if no data is associated, the function will return PK_ERROR_no_data</TD></TR>
<TR><TD><A HREF="headers/pk_debug_report_comment.html">PK_DEBUG_report_comment</A></TD><TD>writes a comment to the debug report file</TD></TR>
<TR><TD><A HREF="headers/pk_debug_report_start.html">PK_DEBUG_report_start</A></TD><TD>initialises and starts the output of debug information</TD></TR>
<TR><TD><A HREF="headers/pk_debug_report_stop.html">PK_DEBUG_report_stop</A></TD><TD>stops the output of debug information for PK functions</TD></TR>
<TR><TD><A HREF="headers/pk_debug_session_check.html">PK_DEBUG_session_check</A></TD><TD></TD></TR>
<TR><TD><A HREF="headers/pk_debug_session_watch_classes.html">PK_DEBUG_session_watch_classes</A></TD><TD></TD></TR>
<TR><TD><A HREF="headers/pk_debug_session_watch_fns.html">PK_DEBUG_session_watch_fns</A></TD><TD></TD></TR>
<TR><TD><A HREF="headers/pk_debug_session_watch_items.html">PK_DEBUG_session_watch_items</A></TD><TD></TD></TR>
<TR><TD><A HREF="headers/pk_debug_shuffle_start.html">PK_DEBUG_shuffle_start</A></TD><TD>initialises and starts the shuffling of return array arguments for some PK functions</TD></TR>
<TR><TD><A HREF="headers/pk_debug_shuffle_stop.html">PK_DEBUG_shuffle_stop</A></TD><TD>stops the shuffling of return array arguments</TD></TR>
<TR><TD><A HREF="headers/pk_debug_transmit.html">PK_DEBUG_transmit</A></TD><TD>saves additional data to a transmit file</TD></TR>
<TR><TD><A HREF="headers/pk_debug_try_error_handler.html">PK_DEBUG_try_error_handler</A></TD><TD>calls the supplied function with the supplied context from within executing Parasolid</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_delta></A>
<B>PK_DELTA</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_delta_register_callbacks.html">PK_DELTA_register_callbacks</A></TD><TD>registers the partitioned rollback frustrum, and switches on partitioned rollback</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_edge></A>
<B>PK_EDGE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_edge_ask_blend.html">PK_EDGE_ask_blend</A></TD><TD>returns information about the blend on a given edge if any</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_body.html">PK_EDGE_ask_body</A></TD><TD>returns the body which contains the given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_convexity.html">PK_EDGE_ask_convexity</A></TD><TD>the function returns the convexity of the given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_curve.html">PK_EDGE_ask_curve</A></TD><TD>returns the curve of the given edge, if it has one, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_curve_nmnl.html">PK_EDGE_ask_curve_nmnl</A></TD><TD>returns the nominal curve of the given <B>'edge'</B>, if it has one, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_faces.html">PK_EDGE_ask_faces</A></TD><TD>returns the set of faces which contain the given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_fins.html">PK_EDGE_ask_fins</A></TD><TD>returns an ordered list of fins connected to the given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_first_fin.html">PK_EDGE_ask_first_fin</A></TD><TD>returns the first fin belonging to the given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_geometry.html">PK_EDGE_ask_geometry</A></TD><TD>returns the geometry of an edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_geometry_nmnl.html">PK_EDGE_ask_geometry_nmnl</A></TD><TD>returns the nominal geometry of an edge, if present</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_next_in_body.html">PK_EDGE_ask_next_in_body</A></TD><TD>returns the next edge in the body which contains the given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_oriented_curve.html">PK_EDGE_ask_oriented_curve</A></TD><TD>returns the curve and orientation of the given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_precision.html">PK_EDGE_ask_precision</A></TD><TD>returns the <B>'precision'</B> of the given <B>'edge'</B></TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_shells.html">PK_EDGE_ask_shells</A></TD><TD>returns the set of shells which contain the given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_type.html">PK_EDGE_ask_type</A></TD><TD>classifies the given edge according to whether it is     (a)     open, closed, or a ring</TD></TR>
<TR><TD><A HREF="headers/pk_edge_ask_vertices.html">PK_EDGE_ask_vertices</A></TD><TD>returns the vertices bounding the given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_attach_curve_nmnl.html">PK_EDGE_attach_curve_nmnl</A></TD><TD>attaches the <B>'curve'</B> provided to the <B>'edge'</B> as a nominal curve</TD></TR>
<TR><TD><A HREF="headers/pk_edge_attach_curves_2.html">PK_EDGE_attach_curves_2</A></TD><TD>attaches curves to edges</TD></TR>
<TR><TD><A HREF="headers/pk_edge_check.html">PK_EDGE_check</A></TD><TD>checks the given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_contains_vector.html">PK_EDGE_contains_vector</A></TD><TD>determines whether the given position vector coincides with the given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_delete.html">PK_EDGE_delete</A></TD><TD>deletes the given set of edges</TD></TR>
<TR><TD><A HREF="headers/pk_edge_delete_wireframe.html">PK_EDGE_delete_wireframe</A></TD><TD>deletes the given wireframe edges</TD></TR>
<TR><TD><A HREF="headers/pk_edge_detach_curve_nmnl.html">PK_EDGE_detach_curve_nmnl</A></TD><TD>detaches the nominal curve from a tolerant <B>'edge'</B> if it has one</TD></TR>
<TR><TD><A HREF="headers/pk_edge_euler_close_zip.html">PK_EDGE_euler_close_zip</A></TD><TD>'zips' two edges together by merging the vertices at either end</TD></TR>
<TR><TD><A HREF="headers/pk_edge_euler_delete_make_loop.html">PK_EDGE_euler_delete_make_loop</A></TD><TD>deletes an edge from a loop splitting it into two loops</TD></TR>
<TR><TD><A HREF="headers/pk_edge_euler_delete_ring_face.html">PK_EDGE_euler_delete_ring_face</A></TD><TD>deletes a ring edge and a face</TD></TR>
<TR><TD><A HREF="headers/pk_edge_euler_delete_ring_loop.html">PK_EDGE_euler_delete_ring_loop</A></TD><TD>deletes a bi-wire ring edge and its loops</TD></TR>
<TR><TD><A HREF="headers/pk_edge_euler_delete_with_face.html">PK_EDGE_euler_delete_with_face</A></TD><TD>deletes an edge and merges two faces and loops into one</TD></TR>
<TR><TD><A HREF="headers/pk_edge_euler_delete_with_loop.html">PK_EDGE_euler_delete_with_loop</A></TD><TD>deletes an edge and merges loops of the same face into one</TD></TR>
<TR><TD><A HREF="headers/pk_edge_euler_merge_vertices.html">PK_EDGE_euler_merge_vertices</A></TD><TD>deletes an edge by merging its vertices</TD></TR>
<TR><TD><A HREF="headers/pk_edge_euler_open_zip.html">PK_EDGE_euler_open_zip</A></TD><TD>splits an edge lengthwise, replacing it with two edges joined at one end</TD></TR>
<TR><TD><A HREF="headers/pk_edge_euler_slit.html">PK_EDGE_euler_slit</A></TD><TD>replaces an edge by a 2-edge face</TD></TR>
<TR><TD><A HREF="headers/pk_edge_euler_split.html">PK_EDGE_euler_split</A></TD><TD>splits an edge by adding a vertex</TD></TR>
<TR><TD><A HREF="headers/pk_edge_find_deviation_2.html">PK_EDGE_find_deviation_2</A></TD><TD>finds distance samples between the two edges</TD></TR>
<TR><TD><A HREF="headers/pk_edge_find_end_tangents.html">PK_EDGE_find_end_tangents</A></TD><TD>finds the end positions of an edge and the edge tangents at those positions</TD></TR>
<TR><TD><A HREF="headers/pk_edge_find_extreme.html">PK_EDGE_find_extreme</A></TD><TD>finds the extreme point on the given <B>'edge'</B> in <B>'direction_1'</B></TD></TR>
<TR><TD><A HREF="headers/pk_edge_find_g1_edges.html">PK_EDGE_find_g1_edges</A></TD><TD>returns the set of tangent edges for a given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_find_interval.html">PK_EDGE_find_interval</A></TD><TD>computes the parameter interval of the curve, to which the edge corresponds</TD></TR>
<TR><TD><A HREF="headers/pk_edge_imprint_point.html">PK_EDGE_imprint_point</A></TD><TD>imprints a point onto an edge, thereby creating a new vertex</TD></TR>
<TR><TD><A HREF="headers/pk_edge_is_planar.html">PK_EDGE_is_planar</A></TD><TD>detects whether an edge lies in a plane</TD></TR>
<TR><TD><A HREF="headers/pk_edge_is_smooth.html">PK_EDGE_is_smooth</A></TD><TD>checks whether the edge passed to it in <B>'edge'</B> is smooth according to the angular criterion passed in <B>'max_angle'</B></TD></TR>
<TR><TD><A HREF="headers/pk_edge_make_curve.html">PK_EDGE_make_curve</A></TD><TD>makes a single continuous curve from a set of edges to a given tolerance</TD></TR>
<TR><TD><A HREF="headers/pk_edge_make_faces_from_wire.html">PK_EDGE_make_faces_from_wire</A></TD><TD>attaches faces to closed loops of wireframe edges in a body</TD></TR>
<TR><TD><A HREF="headers/pk_edge_make_wire_body.html">PK_EDGE_make_wire_body</A></TD><TD>creates a wire body from a collection of existing edges</TD></TR>
<TR><TD><A HREF="headers/pk_edge_offset_on_body.html">PK_EDGE_offset_on_body</A></TD><TD>offsets a set of edges in the faces of their body</TD></TR>
<TR><TD><A HREF="headers/pk_edge_optimise.html">PK_EDGE_optimise</A></TD><TD>given a tolerant edge, this function attempts to set a tolerance on the edge that lies between the maximum deviation and the desired upper bound</TD></TR>
<TR><TD><A HREF="headers/pk_edge_propagate_orientation.html">PK_EDGE_propagate_orientation</A></TD><TD>orientates the edges of a wire body to be in the same direction as the given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_remove_blend.html">PK_EDGE_remove_blend</A></TD><TD>removes an unfixed blend from the given edge</TD></TR>
<TR><TD><A HREF="headers/pk_edge_remove_to_bodies.html">PK_EDGE_remove_to_bodies</A></TD><TD>separates a body into two or more bodies by selecting wire edges which are to be removed into new bodies</TD></TR>
<TR><TD><A HREF="headers/pk_edge_repair.html">PK_EDGE_repair</A></TD><TD>attempts to repair an array of edges</TD></TR>
<TR><TD><A HREF="headers/pk_edge_reset_precision_2.html">PK_EDGE_reset_precision_2</A></TD><TD>attempts to reset the precision of the given <B>'edge'</B> to the session precision: that is to make Parasolid regard the edge as exact</TD></TR>
<TR><TD><A HREF="headers/pk_edge_reverse_2.html">PK_EDGE_reverse_2</A></TD><TD>reverses the given edges and their associated geometry</TD></TR>
<TR><TD><A HREF="headers/pk_edge_set_blend_chain.html">PK_EDGE_set_blend_chain</A></TD><TD>sets a blend defined over an entire chain of edges</TD></TR>
<TR><TD><A HREF="headers/pk_edge_set_blend_chamfer.html">PK_EDGE_set_blend_chamfer</A></TD><TD>sets edges to have a chamfer blend</TD></TR>
<TR><TD><A HREF="headers/pk_edge_set_blend_constant.html">PK_EDGE_set_blend_constant</A></TD><TD>sets edges to have a constant <B>'radius'</B> blend</TD></TR>
<TR><TD><A HREF="headers/pk_edge_set_precision_2.html">PK_EDGE_set_precision_2</A></TD><TD>sets the <B>'precision'</B> of the given <B>'edge'</B></TD></TR>
<TR><TD><A HREF="headers/pk_edge_split_at_param.html">PK_EDGE_split_at_param</A></TD><TD>splits an edge at the given parameter</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_ellipse></A>
<B>PK_ELLIPSE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_ellipse_ask.html">PK_ELLIPSE_ask</A></TD><TD>writes the standard form of an ellipse at the given address</TD></TR>
<TR><TD><A HREF="headers/pk_ellipse_create.html">PK_ELLIPSE_create</A></TD><TD>creates an ellipse from the given standard form</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_entity></A>
<B>PK_ENTITY</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_entity_ask_attribs.html">PK_ENTITY_ask_attribs</A></TD><TD>returns all the attributes with the given attribute definition directly attached to the given entity</TD></TR>
<TR><TD><A HREF="headers/pk_entity_ask_class.html">PK_ENTITY_ask_class</A></TD><TD>returns the given entity's concrete class</TD></TR>
<TR><TD><A HREF="headers/pk_entity_ask_description.html">PK_ENTITY_ask_description</A></TD><TD>returns a textual description of Parasolid's internal representation of a PK entity</TD></TR>
<TR><TD><A HREF="headers/pk_entity_ask_first_attrib.html">PK_ENTITY_ask_first_attrib</A></TD><TD>returns an attribute with the given attribute definition attached to the given entity</TD></TR>
<TR><TD><A HREF="headers/pk_entity_ask_identifier.html">PK_ENTITY_ask_identifier</A></TD><TD>returns the identifier of an entity within a part</TD></TR>
<TR><TD><A HREF="headers/pk_entity_ask_owning_groups.html">PK_ENTITY_ask_owning_groups</A></TD><TD>returns the set of groups of which the given entity is a member</TD></TR>
<TR><TD><A HREF="headers/pk_entity_ask_owning_groups_2.html">PK_ENTITY_ask_owning_groups_2</A></TD><TD>returns the set of <B>'groups'</B> of which the given <B>'entity'</B> is a member and which satisfy the conditions defined in the options structure</TD></TR>
<TR><TD><A HREF="headers/pk_entity_ask_partition.html">PK_ENTITY_ask_partition</A></TD><TD>returns the partition containing the given entity</TD></TR>
<TR><TD><A HREF="headers/pk_entity_ask_user_field.html">PK_ENTITY_ask_user_field</A></TD><TD>returns the user field values for the given entity</TD></TR>
<TR><TD><A HREF="headers/pk_entity_check_attribs.html">PK_ENTITY_check_attribs</A></TD><TD>checks the system attributes attached to the given entity, and returns information concerning the faulty attributes found, if any</TD></TR>
<TR><TD><A HREF="headers/pk_entity_copy_2.html">PK_ENTITY_copy_2</A></TD><TD>produces a new entity which is a copy of the given entity</TD></TR>
<TR><TD><A HREF="headers/pk_entity_delete.html">PK_ENTITY_delete</A></TD><TD>deletes the given entities</TD></TR>
<TR><TD><A HREF="headers/pk_entity_delete_attribs.html">PK_ENTITY_delete_attribs</A></TD><TD>deletes any attributes with the given definition directly attached to the given entity</TD></TR>
<TR><TD><A HREF="headers/pk_entity_find_reparam.html">PK_ENTITY_find_reparam</A></TD><TD>identifies classic geometries, associated with the entities received in <B>'entities'</B>, for which the reliability of Parasolid operations could be improved by modifying their parameterisation</TD></TR>
<TR><TD><A HREF="headers/pk_entity_is.html">PK_ENTITY_is</A></TD><TD>returns whether the given argument is an entity</TD></TR>
<TR><TD><A HREF="headers/pk_entity_is_curve.html">PK_ENTITY_is_curve</A></TD><TD>returns whether the given entity is a curve</TD></TR>
<TR><TD><A HREF="headers/pk_entity_is_geom.html">PK_ENTITY_is_geom</A></TD><TD>returns whether the given entity is geometry</TD></TR>
<TR><TD><A HREF="headers/pk_entity_is_part.html">PK_ENTITY_is_part</A></TD><TD>returns whether the given entity is a part</TD></TR>
<TR><TD><A HREF="headers/pk_entity_is_surf.html">PK_ENTITY_is_surf</A></TD><TD>returns whether the given entity is a surface</TD></TR>
<TR><TD><A HREF="headers/pk_entity_is_topol.html">PK_ENTITY_is_topol</A></TD><TD>returns whether the given entity is topology</TD></TR>
<TR><TD><A HREF="headers/pk_entity_may_own_attdef.html">PK_ENTITY_may_own_attdef</A></TD><TD>returns PK_LOGICAL_true if an attribute constructed from the given attribute definition could be attached to the given entity, otherwise PK_LOGICAL_false</TD></TR>
<TR><TD><A HREF="headers/pk_entity_range.html">PK_ENTITY_range</A></TD><TD>finds the global minimum/maximum separation between two arrays of entities</TD></TR>
<TR><TD><A HREF="headers/pk_entity_range_vector.html">PK_ENTITY_range_vector</A></TD><TD>finds the global minimum separation between an array of entities and an array of positions</TD></TR>
<TR><TD><A HREF="headers/pk_entity_set_user_field.html">PK_ENTITY_set_user_field</A></TD><TD>sets the user field values for the given entity</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_error></A>
<B>PK_ERROR</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_error_ask_callbacks.html">PK_ERROR_ask_callbacks</A></TD><TD>returns the application error handler for the session, (if one is registered), or NULL</TD></TR>
<TR><TD><A HREF="headers/pk_error_ask_last.html">PK_ERROR_ask_last</A></TD><TD>returns the standard form of the most recent PK error</TD></TR>
<TR><TD><A HREF="headers/pk_error_clear_last.html">PK_ERROR_clear_last</A></TD><TD>clears the most recent PK error</TD></TR>
<TR><TD><A HREF="headers/pk_error_raise.html">PK_ERROR_raise</A></TD><TD>raises a PK-format error</TD></TR>
<TR><TD><A HREF="headers/pk_error_register_callbacks.html">PK_ERROR_register_callbacks</A></TD><TD>registers the given application error handler for the session</TD></TR>
<TR><TD><A HREF="headers/pk_error_reraise.html">PK_ERROR_reraise</A></TD><TD>repeats the most recent PK error</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_face></A>
<B>PK_FACE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_face_ask_body.html">PK_FACE_ask_body</A></TD><TD>returns the body which contains the given face</TD></TR>
<TR><TD><A HREF="headers/pk_face_ask_edges.html">PK_FACE_ask_edges</A></TD><TD>returns the set of edges in the given face</TD></TR>
<TR><TD><A HREF="headers/pk_face_ask_faces_adjacent.html">PK_FACE_ask_faces_adjacent</A></TD><TD>returns all faces which are immediately adjacent to the given array of faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_ask_first_loop.html">PK_FACE_ask_first_loop</A></TD><TD>returns the first loop in the given face</TD></TR>
<TR><TD><A HREF="headers/pk_face_ask_loops.html">PK_FACE_ask_loops</A></TD><TD>returns the set of loops bounding the given face</TD></TR>
<TR><TD><A HREF="headers/pk_face_ask_next_in_body.html">PK_FACE_ask_next_in_body</A></TD><TD>returns the next face in the body which contains the given face</TD></TR>
<TR><TD><A HREF="headers/pk_face_ask_oriented_surf.html">PK_FACE_ask_oriented_surf</A></TD><TD>returns the surface and orientation of the given face</TD></TR>
<TR><TD><A HREF="headers/pk_face_ask_shells.html">PK_FACE_ask_shells</A></TD><TD>returns the shells of the given face</TD></TR>
<TR><TD><A HREF="headers/pk_face_ask_surf.html">PK_FACE_ask_surf</A></TD><TD>returns the surface of the given face, if there is one, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_face_ask_type.html">PK_FACE_ask_type</A></TD><TD>classifies the given face</TD></TR>
<TR><TD><A HREF="headers/pk_face_ask_vertices.html">PK_FACE_ask_vertices</A></TD><TD>returns the set of vertices in the given face</TD></TR>
<TR><TD><A HREF="headers/pk_face_attach_surf_fitting.html">PK_FACE_attach_surf_fitting</A></TD><TD>creates a surface to fit and attach to face</TD></TR>
<TR><TD><A HREF="headers/pk_face_attach_surfs.html">PK_FACE_attach_surfs</A></TD><TD>attaches surfaces to faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_boolean_2.html">PK_FACE_boolean_2</A></TD><TD>performs a boolean operation between the list of faces of a target body and the list of faces of a tool body</TD></TR>
<TR><TD><A HREF="headers/pk_face_change.html">PK_FACE_change</A></TD><TD>changes the given faces by applying the related given operation to each of them</TD></TR>
<TR><TD><A HREF="headers/pk_face_check.html">PK_FACE_check</A></TD><TD>checks the given face</TD></TR>
<TR><TD><A HREF="headers/pk_face_check_pair.html">PK_FACE_check_pair</A></TD><TD>checks the given pair of faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_classify_details.html">PK_FACE_classify_details</A></TD><TD>classifies the given faceset as details of some type</TD></TR>
<TR><TD><A HREF="headers/pk_face_close_gaps.html">PK_FACE_close_gaps</A></TD><TD>closes gaps at tolerant vertices in the face loops by modifying the fin geometries of the loops</TD></TR>
<TR><TD><A HREF="headers/pk_face_contains_vectors.html">PK_FACE_contains_vectors</A></TD><TD>determines whether the points represented by the given vectors or parameters lie inside, outside or on the boundary of the given face</TD></TR>
<TR><TD><A HREF="headers/pk_face_cover.html">PK_FACE_cover</A></TD><TD>creates a single face covering a set of input faces, which can then be used to replace the original faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_delete_2.html">PK_FACE_delete_2</A></TD><TD>deletes the given faces from a solid or sheet body and repairs any resulting wounds</TD></TR>
<TR><TD><A HREF="headers/pk_face_delete_blends.html">PK_FACE_delete_blends</A></TD><TD>deletes the given faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_delete_facesets.html">PK_FACE_delete_facesets</A></TD><TD>deletes a collection of facesets from a body</TD></TR>
<TR><TD><A HREF="headers/pk_face_delete_from_gen_body.html">PK_FACE_delete_from_gen_body</A></TD><TD>deletes the given faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_delete_from_sheet.html">PK_FACE_delete_from_sheet</A></TD><TD>removes the specified <B>'faces'</B> from a sheet body</TD></TR>
<TR><TD><A HREF="headers/pk_face_emboss.html">PK_FACE_emboss</A></TD><TD>creates emboss features on the target body over areas covered by the specified <B>'faces'</B></TD></TR>
<TR><TD><A HREF="headers/pk_face_euler_make_loop.html">PK_FACE_euler_make_loop</A></TD><TD>adds an isolated vertex and loop to a face</TD></TR>
<TR><TD><A HREF="headers/pk_face_euler_make_ring_face.html">PK_FACE_euler_make_ring_face</A></TD><TD>adds a new ring loop to a face, creating a new face</TD></TR>
<TR><TD><A HREF="headers/pk_face_euler_make_ring_loop.html">PK_FACE_euler_make_ring_loop</A></TD><TD>adds a new loop to a face</TD></TR>
<TR><TD><A HREF="headers/pk_face_euler_unslit.html">PK_FACE_euler_unslit</A></TD><TD>replaces a 2-edge face with an edge</TD></TR>
<TR><TD><A HREF="headers/pk_face_find_blend_unders.html">PK_FACE_find_blend_unders</A></TD><TD>given a constant radius blended face this function will return all underlying faces associated with the blend face</TD></TR>
<TR><TD><A HREF="headers/pk_face_find_edges_common.html">PK_FACE_find_edges_common</A></TD><TD>finds edges which are common to two faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_find_extreme.html">PK_FACE_find_extreme</A></TD><TD>finds the extreme point on the given <B>'face'</B> in <B>'direction_1'</B></TD></TR>
<TR><TD><A HREF="headers/pk_face_find_interior_vec.html">PK_FACE_find_interior_vec</A></TD><TD>the function returns an arbitrary vector interior to the given face, and the surface u- and v-parameters of the vector</TD></TR>
<TR><TD><A HREF="headers/pk_face_find_outer_loop.html">PK_FACE_find_outer_loop</A></TD><TD>the function returns the outer loop of the given face</TD></TR>
<TR><TD><A HREF="headers/pk_face_find_uvbox.html">PK_FACE_find_uvbox</A></TD><TD>finds a uvbox which bounds the given face in the parameter space of the face's surface</TD></TR>
<TR><TD><A HREF="headers/pk_face_fix_mesh_defects.html">PK_FACE_fix_mesh_defects</A></TD><TD>attempts to repair meshes attached to the given faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_hollow_3.html">PK_FACE_hollow_3</A></TD><TD>hollows a solid body by offsetting the given <B>'faces'</B> by the given <B>'offsets'</B></TD></TR>
<TR><TD><A HREF="headers/pk_face_identify_blends.html">PK_FACE_identify_blends</A></TD><TD>given an array of <B>'faces'</B> (all from the same body) and the type of blends that should be identified this function will return all constant radius rolling ball blends of the required <B>'ident_type'</B> which satisfy the <B>'options'</B> specified</TD></TR>
<TR><TD><A HREF="headers/pk_face_imprint_curves_2.html">PK_FACE_imprint_curves_2</A></TD><TD>imprints an array of curves onto a face, thereby creating new edges and faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_imprint_cus_isoclin.html">PK_FACE_imprint_cus_isoclin</A></TD><TD>creates and imprints isocline curves on a given set of faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_imprint_faces_2.html">PK_FACE_imprint_faces_2</A></TD><TD>imprints edges on the given target and tool faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_imprint_point.html">PK_FACE_imprint_point</A></TD><TD>imprints a point onto a face, thereby creating a new vertex</TD></TR>
<TR><TD><A HREF="headers/pk_face_instance_bodies.html">PK_FACE_instance_bodies</A></TD><TD>instances (creates and then booleans transformed copies of</TD></TR>
<TR><TD><A HREF="headers/pk_face_instance_tools.html">PK_FACE_instance_tools</A></TD><TD>instances (creates and then booleans transformed copies of</TD></TR>
<TR><TD><A HREF="headers/pk_face_intersect_curve.html">PK_FACE_intersect_curve</A></TD><TD>PK_FACE_intersect_curve finds the intersections between a face and the specified region of a curve</TD></TR>
<TR><TD><A HREF="headers/pk_face_intersect_face.html">PK_FACE_intersect_face</A></TD><TD>PK_FACE_intersect_face finds the intersections between two faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_intersect_surf.html">PK_FACE_intersect_surf</A></TD><TD>PK_FACE_intersect_surf finds the intersections between a face and a surface</TD></TR>
<TR><TD><A HREF="headers/pk_face_is_coincident.html">PK_FACE_is_coincident</A></TD><TD>checks if two faces, possibly under transformation,  are coincident to tolerance</TD></TR>
<TR><TD><A HREF="headers/pk_face_is_periodic.html">PK_FACE_is_periodic</A></TD><TD>asks whether the face is periodic</TD></TR>
<TR><TD><A HREF="headers/pk_face_is_uvbox.html">PK_FACE_is_uvbox</A></TD><TD>detects whether a face is parametrically rectangular</TD></TR>
<TR><TD><A HREF="headers/pk_face_make_3_face_blend.html">PK_FACE_make_3_face_blend</A></TD><TD>makes a three-face blend from the given faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_make_blend.html">PK_FACE_make_blend</A></TD><TD>makes a blend of the given faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_make_neutral_sheet_2.html">PK_FACE_make_neutral_sheet_2</A></TD><TD>creates the neutral sheet defined by the surfaces on the faces and returns it as a sheet body</TD></TR>
<TR><TD><A HREF="headers/pk_face_make_sect_with_sfs.html">PK_FACE_make_sect_with_sfs</A></TD><TD>sections selected regions of the target body with tool surfaces</TD></TR>
<TR><TD><A HREF="headers/pk_face_make_sheet_bodies.html">PK_FACE_make_sheet_bodies</A></TD><TD>creates sheet bodies from a collection of faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_make_solid_bodies.html">PK_FACE_make_solid_bodies</A></TD><TD>creates solid bodies from a collection of faces  offers partial support for facet geometry [PF]</TD></TR>
<TR><TD><A HREF="headers/pk_face_offset_2.html">PK_FACE_offset_2</A></TD><TD>offsets faces of a solid or sheet body</TD></TR>
<TR><TD><A HREF="headers/pk_face_output_surf_trimmed.html">PK_FACE_output_surf_trimmed</A></TD><TD>returns a trimmed surface representation of the given face</TD></TR>
<TR><TD><A HREF="headers/pk_face_pattern_2.html">PK_FACE_pattern_2</A></TD><TD>creates a pattern of a feature on the target body</TD></TR>
<TR><TD><A HREF="headers/pk_face_remove_to_solid_bodies.html">PK_FACE_remove_to_solid_bodies</A></TD><TD>separates a body into two or more bodies by selecting which faces are to be removed into new bodies</TD></TR>
<TR><TD><A HREF="headers/pk_face_repair.html">PK_FACE_repair</A></TD><TD>attempts to repair a face</TD></TR>
<TR><TD><A HREF="headers/pk_face_reparameterise_surf.html">PK_FACE_reparameterise_surf</A></TD><TD>reparameterises the surfaces attached to the given <B>'faces'</B></TD></TR>
<TR><TD><A HREF="headers/pk_face_replace_surfs_3.html">PK_FACE_replace_surfs_3</A></TD><TD>replaces the geometry of the given faces with the supplied surfaces</TD></TR>
<TR><TD><A HREF="headers/pk_face_replace_with_sheet.html">PK_FACE_replace_with_sheet</A></TD><TD>replaces a set of faces on a target body with a set of faces from a sheet body</TD></TR>
<TR><TD><A HREF="headers/pk_face_reverse.html">PK_FACE_reverse</A></TD><TD>reverses the orientation of a given set of faces, but will not change any of their associated geometry</TD></TR>
<TR><TD><A HREF="headers/pk_face_section_with_sheet_2.html">PK_FACE_section_with_sheet_2</A></TD><TD>sections selected regions of the target body with selected regions of the tool sheet body</TD></TR>
<TR><TD><A HREF="headers/pk_face_set_approx.html">PK_FACE_set_approx</A></TD><TD>produces an approximate representation of the edges of the supplied faces</TD></TR>
<TR><TD><A HREF="headers/pk_face_simplify_geom.html">PK_FACE_simplify_geom</A></TD><TD>simplifies the classic geometries of the supplied faces, where possible</TD></TR>
<TR><TD><A HREF="headers/pk_face_spin.html">PK_FACE_spin</A></TD><TD>spins one or more faces of a solid or sheet body</TD></TR>
<TR><TD><A HREF="headers/pk_face_split_at_param.html">PK_FACE_split_at_param</A></TD><TD>splits a face along constant parameter line</TD></TR>
<TR><TD><A HREF="headers/pk_face_sweep.html">PK_FACE_sweep</A></TD><TD>sweeps one or more faces of a solid or sheet body</TD></TR>
<TR><TD><A HREF="headers/pk_face_taper.html">PK_FACE_taper</A></TD><TD>applies tapering to the given <B>'faces'</B> by replacing their geometry with taper surfaces</TD></TR>
<TR><TD><A HREF="headers/pk_face_transform_2.html">PK_FACE_transform_2</A></TD><TD>transforms the given faces by the given transformations</TD></TR>
<TR><TD><A HREF="headers/pk_face_unset_approx.html">PK_FACE_unset_approx</A></TD><TD>unsets the approximate representation of the edges of the supplied faces</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_fcurve></A>
<B>PK_FCURVE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_fcurve_ask.html">PK_FCURVE_ask</A></TD><TD>returns the standard form of a foreign curve</TD></TR>
<TR><TD><A HREF="headers/pk_fcurve_create.html">PK_FCURVE_create</A></TD><TD>creates a foreign curve from its standard form</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_fin></A>
<B>PK_FIN</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_fin_ask_body.html">PK_FIN_ask_body</A></TD><TD>returns the body of the given fin</TD></TR>
<TR><TD><A HREF="headers/pk_fin_ask_curve.html">PK_FIN_ask_curve</A></TD><TD>returns the curve attached to the given fin, if there is one, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_fin_ask_edge.html">PK_FIN_ask_edge</A></TD><TD>returns the edge of the given fin</TD></TR>
<TR><TD><A HREF="headers/pk_fin_ask_face.html">PK_FIN_ask_face</A></TD><TD>returns the face of the given fin</TD></TR>
<TR><TD><A HREF="headers/pk_fin_ask_geometry.html">PK_FIN_ask_geometry</A></TD><TD>returns the geometry of a fin</TD></TR>
<TR><TD><A HREF="headers/pk_fin_ask_loop.html">PK_FIN_ask_loop</A></TD><TD>returns the loop of the given fin</TD></TR>
<TR><TD><A HREF="headers/pk_fin_ask_next_in_loop.html">PK_FIN_ask_next_in_loop</A></TD><TD>returns the next fin in order around the given fin's loop</TD></TR>
<TR><TD><A HREF="headers/pk_fin_ask_next_of_edge.html">PK_FIN_ask_next_of_edge</A></TD><TD>returns the next fin in order around the given fin's edge</TD></TR>
<TR><TD><A HREF="headers/pk_fin_ask_oriented_curve.html">PK_FIN_ask_oriented_curve</A></TD><TD>returns the curve and orientation of the given fin, if any</TD></TR>
<TR><TD><A HREF="headers/pk_fin_ask_previous_in_loop.html">PK_FIN_ask_previous_in_loop</A></TD><TD>returns the previous fin in order around the given fin's loop</TD></TR>
<TR><TD><A HREF="headers/pk_fin_ask_previous_of_edge.html">PK_FIN_ask_previous_of_edge</A></TD><TD>returns the previous fin in order around the given fin's edge</TD></TR>
<TR><TD><A HREF="headers/pk_fin_ask_type.html">PK_FIN_ask_type</A></TD><TD>classifies the given fin according to the relationship between its edge and its face</TD></TR>
<TR><TD><A HREF="headers/pk_fin_attach_curves.html">PK_FIN_attach_curves</A></TD><TD>attaches curves to fins</TD></TR>
<TR><TD><A HREF="headers/pk_fin_euler_glue.html">PK_FIN_euler_glue</A></TD><TD>glues fins from two edges in the order indicated so that in the result the fins all belong to one edge</TD></TR>
<TR><TD><A HREF="headers/pk_fin_find_curve_parameter.html">PK_FIN_find_curve_parameter</A></TD><TD>computes the fin curve parameter corresponding to the given surface parameters</TD></TR>
<TR><TD><A HREF="headers/pk_fin_find_interval.html">PK_FIN_find_interval</A></TD><TD>computes the parameter interval of the curve, to which the fin corresponds</TD></TR>
<TR><TD><A HREF="headers/pk_fin_find_mtopols.html">PK_FIN_find_mtopols</A></TD><TD>finds the mvertices and/or mfins along a fin</TD></TR>
<TR><TD><A HREF="headers/pk_fin_find_surf_parameters.html">PK_FIN_find_surf_parameters</A></TD><TD>computes fin surface parameters corresponding to the given curve parameter</TD></TR>
<TR><TD><A HREF="headers/pk_fin_find_uvbox.html">PK_FIN_find_uvbox</A></TD><TD>finds a uvbox which bounds the given fin in the parameter space of the fin's owning face's surface</TD></TR>
<TR><TD><A HREF="headers/pk_fin_is_positive.html">PK_FIN_is_positive</A></TD><TD>returns whether the given fin goes in the same direction as its owning edge</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_frame></A>
<B>PK_FRAME</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_frame_ask_body.html">PK_FRAME_ask_body</A></TD><TD>returns the <B>'body'</B> which contains the given <B>'frame'</B></TD></TR>
<TR><TD><A HREF="headers/pk_frame_ask_geometry.html">PK_FRAME_ask_geometry</A></TD><TD>returns the geometry associated with the given <B>'frame'</B>, if there is one, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_frame_ask_owner.html">PK_FRAME_ask_owner</A></TD><TD>returns the owner of the given <B>'frame'</B>, if there is one, otherwise PK_ENTITY_NULL</TD></TR>
<TR><TD><A HREF="headers/pk_frame_ask_sense.html">PK_FRAME_ask_sense</A></TD><TD>returns the <B>'sense'</B> of the given <B>'frame'</B></TD></TR>
<TR><TD><A HREF="headers/pk_frame_reverse.html">PK_FRAME_reverse</A></TD><TD>flips the sense associated with the given <B>'frame'</B></TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_fsurf></A>
<B>PK_FSURF</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_fsurf_ask.html">PK_FSURF_ask</A></TD><TD>returns the standard form of a foreign surface</TD></TR>
<TR><TD><A HREF="headers/pk_fsurf_create.html">PK_FSURF_create</A></TD><TD>creates a foreign surface from its standard form</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_function></A>
<B>PK_FUNCTION</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_function_find.html">PK_FUNCTION_find</A></TD><TD>returns the functions that have the given names</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_geom></A>
<B>PK_GEOM</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_geom_ask_dependents.html">PK_GEOM_ask_dependents</A></TD><TD>returns the set of geometric dependents of the given geometric entity</TD></TR>
<TR><TD><A HREF="headers/pk_geom_ask_geom_category.html">PK_GEOM_ask_geom_category</A></TD><TD>returns the category of a geometric entity</TD></TR>
<TR><TD><A HREF="headers/pk_geom_ask_geom_owners.html">PK_GEOM_ask_geom_owners</A></TD><TD>returns the set of geometric owners of the given geometric entity</TD></TR>
<TR><TD><A HREF="headers/pk_geom_check.html">PK_GEOM_check</A></TD><TD>checks the given geometry</TD></TR>
<TR><TD><A HREF="headers/pk_geom_copy.html">PK_GEOM_copy</A></TD><TD>copies the given geometries while preserving the geometric dependencies amongst them</TD></TR>
<TR><TD><A HREF="headers/pk_geom_delete_single.html">PK_GEOM_delete_single</A></TD><TD>deletes a single geometric entity</TD></TR>
<TR><TD><A HREF="headers/pk_geom_enlarge.html">PK_GEOM_enlarge</A></TD><TD>enlarges the given geometric entities by the given factor</TD></TR>
<TR><TD><A HREF="headers/pk_geom_is_coincident.html">PK_GEOM_is_coincident</A></TD><TD>will compare two geometric entities to detect whether they occupy the same position(s) in space</TD></TR>
<TR><TD><A HREF="headers/pk_geom_range.html">PK_GEOM_range</A></TD><TD>finds the global minimum/maximum separation between two geometrical entities</TD></TR>
<TR><TD><A HREF="headers/pk_geom_range_array.html">PK_GEOM_range_array</A></TD><TD>finds the global minimum/maximum separation between two arrays of geometrical entities</TD></TR>
<TR><TD><A HREF="headers/pk_geom_range_array_vector.html">PK_GEOM_range_array_vector</A></TD><TD>finds the global minimum separation between an array of geometrical entities and a position</TD></TR>
<TR><TD><A HREF="headers/pk_geom_range_local.html">PK_GEOM_range_local</A></TD><TD>finds the local minimum separations between two geometrical entities</TD></TR>
<TR><TD><A HREF="headers/pk_geom_range_local_vector.html">PK_GEOM_range_local_vector</A></TD><TD>finds the local minimum separations between a geometrical entity and a position</TD></TR>
<TR><TD><A HREF="headers/pk_geom_range_vector.html">PK_GEOM_range_vector</A></TD><TD>finds the global minimum separation between a geometrical entity and a position</TD></TR>
<TR><TD><A HREF="headers/pk_geom_range_vector_many.html">PK_GEOM_range_vector_many</A></TD><TD>finds the global minimum separations for each pairing of the geometrical entity with one of the positions supplied</TD></TR>
<TR><TD><A HREF="headers/pk_geom_render.html">PK_GEOM_render</A></TD><TD>generates a view-independent representation of geometric entities and returns this through the GO interface</TD></TR>
<TR><TD><A HREF="headers/pk_geom_transform_2.html">PK_GEOM_transform_2</A></TD><TD>transforms the array of given geometric entities by the given transformation</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_group></A>
<B>PK_GROUP</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_group_add_entities.html">PK_GROUP_add_entities</A></TD><TD>adds the given set of entities to the given group</TD></TR>
<TR><TD><A HREF="headers/pk_group_ask_closure.html">PK_GROUP_ask_closure</A></TD><TD>detects whether or not the given <B>'group'</B> is closed</TD></TR>
<TR><TD><A HREF="headers/pk_group_ask_controls.html">PK_GROUP_ask_controls</A></TD><TD>returns the controls of the given group</TD></TR>
<TR><TD><A HREF="headers/pk_group_ask_entities.html">PK_GROUP_ask_entities</A></TD><TD>returns the set of entities contained in the given group</TD></TR>
<TR><TD><A HREF="headers/pk_group_ask_entity_class.html">PK_GROUP_ask_entity_class</A></TD><TD>returns the class of the entities allowed in the given group</TD></TR>
<TR><TD><A HREF="headers/pk_group_ask_entity_label.html">PK_GROUP_ask_entity_label</A></TD><TD>returns the label of the given entity in the given group</TD></TR>
<TR><TD><A HREF="headers/pk_group_ask_part.html">PK_GROUP_ask_part</A></TD><TD>returns the part which contains the given group</TD></TR>
<TR><TD><A HREF="headers/pk_group_contains_entity.html">PK_GROUP_contains_entity</A></TD><TD>returns whether the given entity is contained in the given group</TD></TR>
<TR><TD><A HREF="headers/pk_group_create_from_entities_2.html">PK_GROUP_create_from_entities_2</A></TD><TD>creates a group within the given part containing the given set of entities</TD></TR>
<TR><TD><A HREF="headers/pk_group_find_entities.html">PK_GROUP_find_entities</A></TD><TD>finds entities in the given group based on the given options</TD></TR>
<TR><TD><A HREF="headers/pk_group_merge_entities.html">PK_GROUP_merge_entities</A></TD><TD>merges the given array of entities into the given group</TD></TR>
<TR><TD><A HREF="headers/pk_group_remove_entities.html">PK_GROUP_remove_entities</A></TD><TD>removes from the given group, any entities which are also in the given array of entities</TD></TR>
<TR><TD><A HREF="headers/pk_group_set_entity_label.html">PK_GROUP_set_entity_label</A></TD><TD>sets the label of the given entity in the given group</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_instance></A>
<B>PK_INSTANCE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_instance_ask.html">PK_INSTANCE_ask</A></TD><TD>returns the standard form of the given instance</TD></TR>
<TR><TD><A HREF="headers/pk_instance_change_part.html">PK_INSTANCE_change_part</A></TD><TD>modifies the given instance so that it instances a different part</TD></TR>
<TR><TD><A HREF="headers/pk_instance_create.html">PK_INSTANCE_create</A></TD><TD>creates an instance from the given standard form</TD></TR>
<TR><TD><A HREF="headers/pk_instance_replace_transf.html">PK_INSTANCE_replace_transf</A></TD><TD>replaces the transform of an instance by the given one</TD></TR>
<TR><TD><A HREF="headers/pk_instance_transform.html">PK_INSTANCE_transform</A></TD><TD>transforms an instance by transforming its transform</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_lattice></A>
<B>PK_LATTICE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_lattice_ask_connectivity.html">PK_LATTICE_ask_connectivity</A></TD><TD>returns the connectivity type of the <B>'lattice'</B></TD></TR>
<TR><TD><A HREF="headers/pk_lattice_ask_n_lballs.html">PK_LATTICE_ask_n_lballs</A></TD><TD>returns the number of lballs in the given <B>'lattice'</B></TD></TR>
<TR><TD><A HREF="headers/pk_lattice_ask_n_lrods.html">PK_LATTICE_ask_n_lrods</A></TD><TD>returns the number of lrods in the given <B>'lattice'</B></TD></TR>
<TR><TD><A HREF="headers/pk_lattice_ask_part.html">PK_LATTICE_ask_part</A></TD><TD>returns the part which owns the given lattice, if there is one, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_lattice_ask_regions.html">PK_LATTICE_ask_regions</A></TD><TD>returns the set of regions in which <B>'lattice'</B> is embedded</TD></TR>
<TR><TD><A HREF="headers/pk_lattice_clip.html">PK_LATTICE_clip</A></TD><TD>creates new lattices by clipping the supplied <B>'lattice'</B></TD></TR>
<TR><TD><A HREF="headers/pk_lattice_combine.html">PK_LATTICE_combine</A></TD><TD>creates a new lattice by combining the supplied <B>'lattices'</B> into a single, possibly disjoint lattice</TD></TR>
<TR><TD><A HREF="headers/pk_lattice_create_by_graph.html">PK_LATTICE_create_by_graph</A></TD><TD>creates one or more lattices from data obtained by sequentially calling the input function <B>'graph_reader'</B> until it returns PK_LATTICE_cb_status_stop_c</TD></TR>
<TR><TD><A HREF="headers/pk_lattice_disjoin.html">PK_LATTICE_disjoin</A></TD><TD>creates a new lattice for each graph-connected component of a disjoint lattice</TD></TR>
<TR><TD><A HREF="headers/pk_lattice_do_for_all_lballs.html">PK_LATTICE_do_for_all_lballs</A></TD><TD>calls the given callback function for every lball in the given <B>'lattice'</B></TD></TR>
<TR><TD><A HREF="headers/pk_lattice_do_for_all_lrods.html">PK_LATTICE_do_for_all_lrods</A></TD><TD>calls the given callback function for every lrod in the given <B>'lattice'</B></TD></TR>
<TR><TD><A HREF="headers/pk_lattice_find_box.html">PK_LATTICE_find_box</A></TD><TD>returns the axis-aligned bounding box of a lattice</TD></TR>
<TR><TD><A HREF="headers/pk_lattice_find_nabox.html">PK_LATTICE_find_nabox</A></TD><TD>returns the non-axis-aligned bounding box of a lattice</TD></TR>
<TR><TD><A HREF="headers/pk_lattice_make_bodies.html">PK_LATTICE_make_bodies</A></TD><TD>makes a solid facet body from the given <B>'lattice'</B></TD></TR>
<TR><TD><A HREF="headers/pk_lattice_make_patterned.html">PK_LATTICE_make_patterned</A></TD><TD>creates a lattice made of patterned repetitions of the given lattice</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_lball></A>
<B>PK_LBALL</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_lball_ask_blend.html">PK_LBALL_ask_blend</A></TD><TD>returns information about the blend on the given <B>'lball'</B>, if any</TD></TR>
<TR><TD><A HREF="headers/pk_lball_ask_lballs_adj.html">PK_LBALL_ask_lballs_adj</A></TD><TD>returns the adjacent lballs of the given <B>'lball'</B></TD></TR>
<TR><TD><A HREF="headers/pk_lball_ask_lrods.html">PK_LBALL_ask_lrods</A></TD><TD>returns all lrods which have <B>'lball'</B> as one of their lballs</TD></TR>
<TR><TD><A HREF="headers/pk_lball_ask_position.html">PK_LBALL_ask_position</A></TD><TD>returns the position of the given <B>'lball'</B></TD></TR>
<TR><TD><A HREF="headers/pk_lball_ask_radius.html">PK_LBALL_ask_radius</A></TD><TD>returns the radius of the given <B>'lball'</B></TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_line></A>
<B>PK_LINE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_line_ask.html">PK_LINE_ask</A></TD><TD>writes the standard form of a line at the given address</TD></TR>
<TR><TD><A HREF="headers/pk_line_create.html">PK_LINE_create</A></TD><TD>creates a line from the given standard form</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_loop></A>
<B>PK_LOOP</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_loop_ask_body.html">PK_LOOP_ask_body</A></TD><TD>returns the body containing the given loop</TD></TR>
<TR><TD><A HREF="headers/pk_loop_ask_edges.html">PK_LOOP_ask_edges</A></TD><TD>returns a set of edges in the given loop</TD></TR>
<TR><TD><A HREF="headers/pk_loop_ask_face.html">PK_LOOP_ask_face</A></TD><TD>returns the face containing the given loop</TD></TR>
<TR><TD><A HREF="headers/pk_loop_ask_fins.html">PK_LOOP_ask_fins</A></TD><TD>returns an ordered list of fins around the given loop</TD></TR>
<TR><TD><A HREF="headers/pk_loop_ask_first_fin.html">PK_LOOP_ask_first_fin</A></TD><TD>returns the first fin in the given loop</TD></TR>
<TR><TD><A HREF="headers/pk_loop_ask_next_in_face.html">PK_LOOP_ask_next_in_face</A></TD><TD>returns the next loop in the face containing the given loop</TD></TR>
<TR><TD><A HREF="headers/pk_loop_ask_type.html">PK_LOOP_ask_type</A></TD><TD>classifies the given loop</TD></TR>
<TR><TD><A HREF="headers/pk_loop_ask_vertices.html">PK_LOOP_ask_vertices</A></TD><TD>returns an ordered list of vertices around the given loop</TD></TR>
<TR><TD><A HREF="headers/pk_loop_close_gaps.html">PK_LOOP_close_gaps</A></TD><TD>closes gaps at tolerant vertices in the loop by modifying the edge/fin geometry</TD></TR>
<TR><TD><A HREF="headers/pk_loop_delete_from_sheet_body.html">PK_LOOP_delete_from_sheet_body</A></TD><TD>deletes interior loops from a sheet body</TD></TR>
<TR><TD><A HREF="headers/pk_loop_euler_create_edge.html">PK_LOOP_euler_create_edge</A></TD><TD>is obsolete</TD></TR>
<TR><TD><A HREF="headers/pk_loop_euler_delete_isolated.html">PK_LOOP_euler_delete_isolated</A></TD><TD>deletes an isolated vertex and loop from a face</TD></TR>
<TR><TD><A HREF="headers/pk_loop_euler_delete_make_edge.html">PK_LOOP_euler_delete_make_edge</A></TD><TD>merges two loops in the same face into one by joining their vertices with an edge</TD></TR>
<TR><TD><A HREF="headers/pk_loop_euler_make_edge.html">PK_LOOP_euler_make_edge</A></TD><TD>adds a new edge to a loop</TD></TR>
<TR><TD><A HREF="headers/pk_loop_euler_make_edge_face.html">PK_LOOP_euler_make_edge_face</A></TD><TD>joins two vertices in the same loop, creating a new face</TD></TR>
<TR><TD><A HREF="headers/pk_loop_euler_make_edge_loop.html">PK_LOOP_euler_make_edge_loop</A></TD><TD>joins two vertices in the same loop of a face, creating a new loop</TD></TR>
<TR><TD><A HREF="headers/pk_loop_euler_transfer.html">PK_LOOP_euler_transfer</A></TD><TD>transfers a loop from one face to another</TD></TR>
<TR><TD><A HREF="headers/pk_loop_is_isolated.html">PK_LOOP_is_isolated</A></TD><TD>returns whether the given loop is isolated</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_lrod></A>
<B>PK_LROD</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_lrod_ask_geometry.html">PK_LROD_ask_geometry</A></TD><TD>returns the geometry of <B>'lrod'</B></TD></TR>
<TR><TD><A HREF="headers/pk_lrod_ask_lballs.html">PK_LROD_ask_lballs</A></TD><TD>returns the lballs of <B>'lrod'</B></TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_ltopol></A>
<B>PK_LTOPOL</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_ltopol_ask_box.html">PK_LTOPOL_ask_box</A></TD><TD>returns the bounding box of <B>'ltopols'</B></TD></TR>
<TR><TD><A HREF="headers/pk_ltopol_ask_class.html">PK_LTOPOL_ask_class</A></TD><TD>returns the class of an element of lattice topology</TD></TR>
<TR><TD><A HREF="headers/pk_ltopol_is.html">PK_LTOPOL_is</A></TD><TD>indicates whether <B>'may_be_ltopol'</B> is an ltopol</TD></TR>
<TR><TD><A HREF="headers/pk_ltopol_is_null_m.html">PK_LTOPOL_is_null_m</A></TD><TD>macro tests if an ltopol is null</TD></TR>
<TR><TD><A HREF="headers/pk_ltopol_null_m.html">PK_LTOPOL_null_m</A></TD><TD>macro populates an entity of type PK_LTOPOL_t with its null values</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_mark></A>
<B>PK_MARK</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_mark_ask_following.html">PK_MARK_ask_following</A></TD><TD>returns the mark following the given one</TD></TR>
<TR><TD><A HREF="headers/pk_mark_ask_forward.html">PK_MARK_ask_forward</A></TD><TD>returns PK_LOGICAL_true if roll-forward is enabled</TD></TR>
<TR><TD><A HREF="headers/pk_mark_ask_frustrum.html">PK_MARK_ask_frustrum</A></TD><TD>returns the registered frustrum of the non-partitioned PK rollback system</TD></TR>
<TR><TD><A HREF="headers/pk_mark_ask_pmarks.html">PK_MARK_ask_pmarks</A></TD><TD>returns the <B>'pmarks'</B> which are used by the given <B>'mark'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mark_ask_preceding.html">PK_MARK_ask_preceding</A></TD><TD>returns the mark preceding the given one</TD></TR>
<TR><TD><A HREF="headers/pk_mark_create.html">PK_MARK_create</A></TD><TD>sets a rollmark and returns a mark identifier</TD></TR>
<TR><TD><A HREF="headers/pk_mark_delete.html">PK_MARK_delete</A></TD><TD>deletes the given mark</TD></TR>
<TR><TD><A HREF="headers/pk_mark_goto.html">PK_MARK_goto</A></TD><TD>returns the modeller to the state when the given mark was created</TD></TR>
<TR><TD><A HREF="headers/pk_mark_goto_2.html">PK_MARK_goto_2</A></TD><TD>returns the modeller to the state when the given mark was created</TD></TR>
<TR><TD><A HREF="headers/pk_mark_is.html">PK_MARK_is</A></TD><TD>returns whether the given argument is a mark</TD></TR>
<TR><TD><A HREF="headers/pk_mark_is_on.html">PK_MARK_is_on</A></TD><TD>returns whether the non-partitioned PK rollback system is active</TD></TR>
<TR><TD><A HREF="headers/pk_mark_start.html">PK_MARK_start</A></TD><TD>starts non-partitioned PK rollback</TD></TR>
<TR><TD><A HREF="headers/pk_mark_stop.html">PK_MARK_stop</A></TD><TD>shuts down the non-partitioned PK rollback system</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_memory></A>
<B>PK_MEMORY</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_memory_alloc.html">PK_MEMORY_alloc</A></TD><TD>allocates the specified amount of memory required in bytes</TD></TR>
<TR><TD><A HREF="headers/pk_memory_ask_block_size.html">PK_MEMORY_ask_block_size</A></TD><TD>returns the current smallest size of a block of memory that Parasolid will request from FMALLO (PK_FMALLO_f_t) for storing modelling data</TD></TR>
<TR><TD><A HREF="headers/pk_memory_ask_callbacks.html">PK_MEMORY_ask_callbacks</A></TD><TD>returns the functions which are currently registered for Parasolid to use when allocating and freeing variable length information returned from the PK interface</TD></TR>
<TR><TD><A HREF="headers/pk_memory_free.html">PK_MEMORY_free</A></TD><TD>frees previously allocated memory</TD></TR>
<TR><TD><A HREF="headers/pk_memory_register_callbacks.html">PK_MEMORY_register_callbacks</A></TD><TD>registers memory allocation and free functions for Parasolid to use when returning variable length information</TD></TR>
<TR><TD><A HREF="headers/pk_memory_set_block_size.html">PK_MEMORY_set_block_size</A></TD><TD>sets the size of the smallest block of memory that Parasolid will request from FMALLO (PK_FMALLO_f_t) for modelling data</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_mesh></A>
<B>PK_MESH</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_mesh_ask_n_mfacets.html">PK_MESH_ask_n_mfacets</A></TD><TD>returns the number of mfacets in the given <B>'mesh'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mesh_ask_n_mvertices.html">PK_MESH_ask_n_mvertices</A></TD><TD>returns the number of mvertices in the given <B>'mesh'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mesh_ask_normal_type.html">PK_MESH_ask_normal_type</A></TD><TD>returns whether the given <B>'mesh'</B> currently has stored vertex normals or whether vertex normals will be generated dynamically</TD></TR>
<TR><TD><A HREF="headers/pk_mesh_create_from_facets.html">PK_MESH_create_from_facets</A></TD><TD></TD></TR>
<TR><TD><A HREF="headers/pk_mesh_discard_normals.html">PK_MESH_discard_normals</A></TD><TD>for meshes with stored normals this function will discard the normals</TD></TR>
<TR><TD><A HREF="headers/pk_mesh_do_for_all_mfacets.html">PK_MESH_do_for_all_mfacets</A></TD><TD>calls the given callback function for every mfacet in the given <B>'mesh'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mesh_do_for_all_mvertices.html">PK_MESH_do_for_all_mvertices</A></TD><TD>calls the given callback function for every mvertex in the given <B>'mesh'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mesh_eval_with_mtopol.html">PK_MESH_eval_with_mtopol</A></TD><TD>evaluates the <B>'mesh'</B> at the given <B>'uv'</B> position and returns the <B>'position'</B>, <B>'mfacet'</B> and <B>'mtopol'</B> at that position</TD></TR>
<TR><TD><A HREF="headers/pk_mesh_fill_holes.html">PK_MESH_fill_holes</A></TD><TD>returns a mesh which is a copy of the given <B>'mesh'</B> with those holes as specified by the options structure filled in</TD></TR>
<TR><TD><A HREF="headers/pk_mesh_find_defects.html">PK_MESH_find_defects</A></TD><TD>finds defects on a mesh</TD></TR>
<TR><TD><A HREF="headers/pk_mesh_find_laminar_mfins.html">PK_MESH_find_laminar_mfins</A></TD><TD>returns the laminar mfins in the given <B>'mesh'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mesh_find_sharp_mfins.html">PK_MESH_find_sharp_mfins</A></TD><TD>returns the sharp mfins in the given <B>'mesh'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mesh_find_sharp_mvxs.html">PK_MESH_find_sharp_mvxs</A></TD><TD>returns the sharp mvertices in the given <B>'mesh'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mesh_fix_defects.html">PK_MESH_fix_defects</A></TD><TD>fixes defects on a mesh</TD></TR>
<TR><TD><A HREF="headers/pk_mesh_has_unique_normals.html">PK_MESH_has_unique_normals</A></TD><TD>returns whether the given <B>'mesh'</B> has unique normals</TD></TR>
<TR><TD><A HREF="headers/pk_mesh_imprint_vectors.html">PK_MESH_imprint_vectors</A></TD><TD>imprints an array of vectors onto a mesh</TD></TR>
<TR><TD><A HREF="headers/pk_mesh_is_loaded.html">PK_MESH_is_loaded</A></TD><TD>returns whether the given <B>'mesh'</B> is loaded</TD></TR>
<TR><TD><A HREF="headers/pk_mesh_make_bodies.html">PK_MESH_make_bodies</A></TD><TD>makes one or more bodies from the given <B>'mesh'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mesh_make_surf_trimmed.html">PK_MESH_make_surf_trimmed</A></TD><TD>makes a trimmed surface from the given <B>'mesh'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mesh_store_normals.html">PK_MESH_store_normals</A></TD><TD>stores or modifies normals in the given <B>'mesh'</B></TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_mfacet></A>
<B>PK_MFACET</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_mfacet_ask_mfacet_adjacent.html">PK_MFACET_ask_mfacet_adjacent</A></TD><TD>returns the adjacent mfacet to the given <B>'mfacet'</B> which abuts this <B>'mfacet'</B> along the mfin with the given <B>'mfin_index'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mfacet_ask_mfin.html">PK_MFACET_ask_mfin</A></TD><TD>returns the <B>'mfin'</B> of <B>'mfacet'</B> with the given <B>'mfin_index'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mfacet_ask_mvertices.html">PK_MFACET_ask_mvertices</A></TD><TD>returns the <B>'mvertices'</B> of <B>'mfacet'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mfacet_ask_mvx_normals.html">PK_MFACET_ask_mvx_normals</A></TD><TD>returns the <B>'mvx_normals'</B> stored at the mvertices of <B>'mfacet'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mfacet_ask_normal.html">PK_MFACET_ask_normal</A></TD><TD>returns the normal vector of <B>'mfacet'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mfacet_ask_positions.html">PK_MFACET_ask_positions</A></TD><TD>returns the position vectors at the mvertices of <B>'mfacet'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mfacet_find_perimeters.html">PK_MFACET_find_perimeters</A></TD><TD>returns the perimeter mfins around a set of given mfacets</TD></TR>
<TR><TD><A HREF="headers/pk_mfacet_parameterise_vec.html">PK_MFACET_parameterise_vec</A></TD><TD>finds the mesh parameterisation of a position known to be on a particular mfacet</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_mfin></A>
<B>PK_MFIN</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_mfin_ask_mfacet.html">PK_MFIN_ask_mfacet</A></TD><TD>returns the <B>'mfacet'</B> which contains the <B>'mfin'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mfin_ask_mfin_adjacent.html">PK_MFIN_ask_mfin_adjacent</A></TD><TD>returns the mfin from the adjacent facet to this <B>'mfin'</B>s facet which is coincident with this <B>'mfin'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mfin_ask_mfin_index.html">PK_MFIN_ask_mfin_index</A></TD><TD>returns the index of <B>'mfin'</B> within its mfacet</TD></TR>
<TR><TD><A HREF="headers/pk_mfin_ask_mvertex.html">PK_MFIN_ask_mvertex</A></TD><TD>returns the <B>'mvertex'</B> towards which <B>'mfin'</B> points</TD></TR>
<TR><TD><A HREF="headers/pk_mfin_ask_mvx_curvature.html">PK_MFIN_ask_mvx_curvature</A></TD><TD>calculates the normal, principal directions and curvatures associated with the mvertex of the given <B>'mfin'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mfin_ask_mvx_normal.html">PK_MFIN_ask_mvx_normal</A></TD><TD>returns the <B>'mvx_normal'</B> at the mvertex of the given <B>'mfin'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mfin_ask_next_in_mfacet.html">PK_MFIN_ask_next_in_mfacet</A></TD><TD>returns the mfin following <B>'mfin'</B> in the same mfacet</TD></TR>
<TR><TD><A HREF="headers/pk_mfin_ask_next_of_mvertex.html">PK_MFIN_ask_next_of_mvertex</A></TD><TD>returns the next mfin around the mvertex pointed at by <B>'mfin'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mfin_ask_previous_in_mfacet.html">PK_MFIN_ask_previous_in_mfacet</A></TD><TD>returns the mfin preceding <B>'mfin'</B> in the same mfacet</TD></TR>
<TR><TD><A HREF="headers/pk_mfin_ask_previous_of_mvertex.html">PK_MFIN_ask_previous_of_mvertex</A></TD><TD>returns the previous mfin around the mvertex pointed at by <B>'mfin'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mfin_is_laminar.html">PK_MFIN_is_laminar</A></TD><TD>indicates whether or not <B>'mfin'</B> is a laminar mfin</TD></TR>
<TR><TD><A HREF="headers/pk_mfin_is_same_mfacet.html">PK_MFIN_is_same_mfacet</A></TD><TD>indicates whether or not <B>'mfin_1'</B> and <B>'mfin_2'</B> belong to the same mfacet</TD></TR>
<TR><TD><A HREF="headers/pk_mfin_is_sharp.html">PK_MFIN_is_sharp</A></TD><TD>indicates whether or not <B>'mfin'</B> is a sharp mfin</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_mtopol></A>
<B>PK_MTOPOL</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_mtopol_ask_box.html">PK_MTOPOL_ask_box</A></TD><TD>returns the bounding box of <B>'mtopol'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mtopol_ask_class.html">PK_MTOPOL_ask_class</A></TD><TD>returns the class of an element of mesh topology</TD></TR>
<TR><TD><A HREF="headers/pk_mtopol_is.html">PK_MTOPOL_is</A></TD><TD>indicates whether <B>'may_be_mtopol'</B> is a valid mtopol element</TD></TR>
<TR><TD><A HREF="headers/pk_mtopol_is_null_m.html">PK_MTOPOL_is_null_m</A></TD><TD>macro tests if an mtopol is null</TD></TR>
<TR><TD><A HREF="headers/pk_mtopol_make_meshes.html">PK_MTOPOL_make_meshes</A></TD><TD>creates meshes from a collection of mtopols</TD></TR>
<TR><TD><A HREF="headers/pk_mtopol_null_m.html">PK_MTOPOL_null_m</A></TD><TD>macro populates an entity of type PK_MTOPOL_t with its null values</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_mvertex></A>
<B>PK_MVERTEX</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_mvertex_ask_mfacets.html">PK_MVERTEX_ask_mfacets</A></TD><TD>returns all <B>'mfacets'</B> which have <B>'mvertex'</B> as one of their mvertices</TD></TR>
<TR><TD><A HREF="headers/pk_mvertex_ask_mfin.html">PK_MVERTEX_ask_mfin</A></TD><TD>returns an <B>'mfin'</B> which points towards <B>'mvertex'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mvertex_ask_mvertices_ring.html">PK_MVERTEX_ask_mvertices_ring</A></TD><TD>returns the ring of mvertices around the given <B>'mvertex'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mvertex_ask_normals.html">PK_MVERTEX_ask_normals</A></TD><TD>returns all the unique normals of the given <B>'mvertex'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mvertex_ask_position.html">PK_MVERTEX_ask_position</A></TD><TD>returns the <B>'position'</B> at the given <B>'mvertex'</B></TD></TR>
<TR><TD><A HREF="headers/pk_mvertex_is_laminar.html">PK_MVERTEX_is_laminar</A></TD><TD>returns PK_LOGICAL_true if the given <B>'mvertex'</B> lies on the laminar boundary of its mesh and PK_LOGICAL_false otherwise</TD></TR>
<TR><TD><A HREF="headers/pk_mvertex_set_positions.html">PK_MVERTEX_set_positions</A></TD><TD>sets the position of each given mvertex</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_offset></A>
<B>PK_OFFSET</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_offset_ask.html">PK_OFFSET_ask</A></TD><TD>writes the standard form of an offset surface at the given address</TD></TR>
<TR><TD><A HREF="headers/pk_offset_create.html">PK_OFFSET_create</A></TD><TD>the function creates an offset surface from the given standard form</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_part></A>
<B>PK_PART</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_part_add_geoms.html">PK_PART_add_geoms</A></TD><TD>adds the given geometry to the part's construction geometry</TD></TR>
<TR><TD><A HREF="headers/pk_part_ask_all_attdefs.html">PK_PART_ask_all_attdefs</A></TD><TD>returns the attribute definitions of all the attributes attached to entities within the given part</TD></TR>
<TR><TD><A HREF="headers/pk_part_ask_all_attribs.html">PK_PART_ask_all_attribs</A></TD><TD>returns all the attributes with the given attribute definition attached to any entity within the given part</TD></TR>
<TR><TD><A HREF="headers/pk_part_ask_attribs_cb.html">PK_PART_ask_attribs_cb</A></TD><TD>returns selected attributes and their owners from entities within the given <B>'part'</B>, using the <B>'callback'</B> function to select attributes from their definition and field values</TD></TR>
<TR><TD><A HREF="headers/pk_part_ask_con_lattices.html">PK_PART_ask_con_lattices</A></TD><TD>returns the set of construction lattices connected to the given part</TD></TR>
<TR><TD><A HREF="headers/pk_part_ask_construction_curves.html">PK_PART_ask_construction_curves</A></TD><TD>returns the set of construction curves connected to the given part</TD></TR>
<TR><TD><A HREF="headers/pk_part_ask_construction_points.html">PK_PART_ask_construction_points</A></TD><TD>returns the set of construction points connected to the given part</TD></TR>
<TR><TD><A HREF="headers/pk_part_ask_construction_surfs.html">PK_PART_ask_construction_surfs</A></TD><TD>returns the set of construction surfaces connected to the given part</TD></TR>
<TR><TD><A HREF="headers/pk_part_ask_geoms.html">PK_PART_ask_geoms</A></TD><TD>returns the set of geometric entities (points, curves, surfaces, and lattices) in the given part which are not attached to the part's topology</TD></TR>
<TR><TD><A HREF="headers/pk_part_ask_groups.html">PK_PART_ask_groups</A></TD><TD>returns the set of groups contained within the given part</TD></TR>
<TR><TD><A HREF="headers/pk_part_ask_groups_2.html">PK_PART_ask_groups_2</A></TD><TD>returns the set of <B>'groups'</B> contained within the given <B>'part'</B> satisfying conditions defined in the options structure</TD></TR>
<TR><TD><A HREF="headers/pk_part_ask_ref_instances.html">PK_PART_ask_ref_instances</A></TD><TD>returns the set of instances which instance the given part</TD></TR>
<TR><TD><A HREF="headers/pk_part_delete_attribs.html">PK_PART_delete_attribs</A></TD><TD>deletes attributes of given attribute definitions from entities within the given <B>'part'</B></TD></TR>
<TR><TD><A HREF="headers/pk_part_find_entity_by_ident.html">PK_PART_find_entity_by_ident</A></TD><TD>searches the given <B>'part'</B> for an <B>'entity'</B> of the given <B>'class'</B> with the given <B>'identifier'</B></TD></TR>
<TR><TD><A HREF="headers/pk_part_receive.html">PK_PART_receive</A></TD><TD>receives one or more parts using the given key string</TD></TR>
<TR><TD><A HREF="headers/pk_part_receive_b.html">PK_PART_receive_b</A></TD><TD>receives one or more parts directly from application memory</TD></TR>
<TR><TD><A HREF="headers/pk_part_receive_meshes.html">PK_PART_receive_meshes</A></TD><TD>receives or generates all mesh data which is not yet loaded for the array of parts specified</TD></TR>
<TR><TD><A HREF="headers/pk_part_receive_u.html">PK_PART_receive_u</A></TD><TD>receives one or more parts using the given Unicode key string</TD></TR>
<TR><TD><A HREF="headers/pk_part_receive_version.html">PK_PART_receive_version</A></TD><TD>returns information about the version of Parasolid used to create a part transmit file</TD></TR>
<TR><TD><A HREF="headers/pk_part_receive_version_b.html">PK_PART_receive_version_b</A></TD><TD>returns information about the version of Parasolid used to transmit a given part</TD></TR>
<TR><TD><A HREF="headers/pk_part_receive_version_u.html">PK_PART_receive_version_u</A></TD><TD>returns information about the version of Parasolid used to create a part transmit file</TD></TR>
<TR><TD><A HREF="headers/pk_part_rectify_identifiers.html">PK_PART_rectify_identifiers</A></TD><TD>ensures that a part has no duplicate or invalid identifiers</TD></TR>
<TR><TD><A HREF="headers/pk_part_remove_geoms.html">PK_PART_remove_geoms</A></TD><TD>removes from the part's construction geometry, any geometric entities which are also in the given array of geoms</TD></TR>
<TR><TD><A HREF="headers/pk_part_transmit.html">PK_PART_transmit</A></TD><TD>transmits the given parts using the given key string</TD></TR>
<TR><TD><A HREF="headers/pk_part_transmit_b.html">PK_PART_transmit_b</A></TD><TD>transmits the given parts into application memory</TD></TR>
<TR><TD><A HREF="headers/pk_part_transmit_u.html">PK_PART_transmit_u</A></TD><TD>transmits the given parts using the given Unicode key string</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_partition></A>
<B>PK_PARTITION</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_partition_advance_pmark.html">PK_PARTITION_advance_pmark</A></TD><TD>advances the current partition mark in the given <B>'partition'</B></TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask.html">PK_PARTITION_ask</A></TD><TD>allows properties of the <B>'partition'</B> to be queried</TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask_appitems.html">PK_PARTITION_ask_appitems</A></TD><TD>returns the set of appitems in the given partition</TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask_assemblies.html">PK_PARTITION_ask_assemblies</A></TD><TD>returns the set of assemblies in the given partition</TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask_bodies.html">PK_PARTITION_ask_bodies</A></TD><TD>returns the set of bodies in the given partition</TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask_cloning.html">PK_PARTITION_ask_cloning</A></TD><TD>reports the state of all clone spans in the given <B>'partition'</B>  Note: You are advised to consult with Parasolid Support before using cloning</TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask_facet_geom.html">PK_PARTITION_ask_facet_geom</A></TD><TD>categorises the parts and geometry of a partition and optionally returns any parts that contain facet geometry, as well as any facet orphan geometry</TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask_geoms.html">PK_PARTITION_ask_geoms</A></TD><TD>returns the set of geometric entities (points, curves, surfaces and lattices) in the given partition which are not contained within a part</TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask_initial_pmark.html">PK_PARTITION_ask_initial_pmark</A></TD><TD>returns the initial partition mark of the given partition</TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask_ki_lists.html">PK_PARTITION_ask_ki_lists</A></TD><TD>returns the set of ki lists in the given partition, which are not contained within a part</TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask_pmark.html">PK_PARTITION_ask_pmark</A></TD><TD>returns the current pmark of the given partition</TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask_pmark_size.html">PK_PARTITION_ask_pmark_size</A></TD><TD>returns the number of bytes of roll 'file' which would be passed to the Frustrum if a partition mark were to be set in the given partition</TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask_pmarks_2.html">PK_PARTITION_ask_pmarks_2</A></TD><TD>returns a set of pmarks in the partition</TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask_transfs.html">PK_PARTITION_ask_transfs</A></TD><TD>returns the set of transforms in the given partition, which are not contained within a part</TD></TR>
<TR><TD><A HREF="headers/pk_partition_ask_type.html">PK_PARTITION_ask_type</A></TD><TD>returns the type of the given <B>'partition'</B></TD></TR>
<TR><TD><A HREF="headers/pk_partition_clone_pmark.html">PK_PARTITION_clone_pmark</A></TD><TD>applies to the <B>'partition'</B> the changes between the original pmark corresponding to the current clone pmark of the partition and the given <B>'original_pmark'</B></TD></TR>
<TR><TD><A HREF="headers/pk_partition_copy.html">PK_PARTITION_copy</A></TD><TD>produces a new <B>'partition_copy'</B> which is a copy of the given <B>'partition'</B></TD></TR>
<TR><TD><A HREF="headers/pk_partition_create.html">PK_PARTITION_create</A></TD><TD>creates a partition</TD></TR>
<TR><TD><A HREF="headers/pk_partition_delete.html">PK_PARTITION_delete</A></TD><TD>deletes the given <B>'partition'</B> and all data within it</TD></TR>
<TR><TD><A HREF="headers/pk_partition_find_pmark_by_id.html">PK_PARTITION_find_pmark_by_id</A></TD><TD>searches the given <B>'partition'</B> for a <B>'pmark'</B> with the given <B>'identifier'</B></TD></TR>
<TR><TD><A HREF="headers/pk_partition_goto_guard.html">PK_PARTITION_goto_guard</A></TD><TD>restores the given <B>'partition'</B> to the state at a previously set guard</TD></TR>
<TR><TD><A HREF="headers/pk_partition_has_guard.html">PK_PARTITION_has_guard</A></TD><TD>returns whether the given <B>'partition'</B> has a guard</TD></TR>
<TR><TD><A HREF="headers/pk_partition_has_lattices.html">PK_PARTITION_has_lattices</A></TD><TD>returns whether the <B>'partition'</B> contains lattice geometry, and optionally returns any parts that contain lattice geometry, as well as any orphan lattices</TD></TR>
<TR><TD><A HREF="headers/pk_partition_is.html">PK_PARTITION_is</A></TD><TD>returns PK_LOGICAL_true if its argument is a partition</TD></TR>
<TR><TD><A HREF="headers/pk_partition_is_clone.html">PK_PARTITION_is_clone</A></TD><TD>detects whether entities in the <B>'partition'</B>, when at <B>'clone_pmark'</B>, are identical to their incarnations when at <B>'original_pmark'</B></TD></TR>
<TR><TD><A HREF="headers/pk_partition_make_pmark_2.html">PK_PARTITION_make_pmark_2</A></TD><TD>creates a partition mark in the given partition</TD></TR>
<TR><TD><A HREF="headers/pk_partition_merge.html">PK_PARTITION_merge</A></TD><TD>merges the given <B>'partitions'</B> by combining their model data and interleaving their pmark deltas into a single partition using the given <B>'pmarks'</B></TD></TR>
<TR><TD><A HREF="headers/pk_partition_receive.html">PK_PARTITION_receive</A></TD><TD>receives a partition from the given 'file' key</TD></TR>
<TR><TD><A HREF="headers/pk_partition_receive_b.html">PK_PARTITION_receive_b</A></TD><TD>receives a partition directly from application memory</TD></TR>
<TR><TD><A HREF="headers/pk_partition_receive_deltas_2.html">PK_PARTITION_receive_deltas_2</A></TD><TD>receives the deltas for the given <B>'partition'</B> from a file</TD></TR>
<TR><TD><A HREF="headers/pk_partition_receive_meshes.html">PK_PARTITION_receive_meshes</A></TD><TD>receives or generates all mesh data which is not yet loaded for the specified partition</TD></TR>
<TR><TD><A HREF="headers/pk_partition_receive_u.html">PK_PARTITION_receive_u</A></TD><TD>receives a partition from the given Unicode 'file' key</TD></TR>
<TR><TD><A HREF="headers/pk_partition_receive_version.html">PK_PARTITION_receive_version</A></TD><TD>returns information about the version of Parasolid used to create a partition transmit file</TD></TR>
<TR><TD><A HREF="headers/pk_partition_receive_version_b.html">PK_PARTITION_receive_version_b</A></TD><TD>returns information about the version of Parasolid used to create partition transmit data</TD></TR>
<TR><TD><A HREF="headers/pk_partition_receive_version_u.html">PK_PARTITION_receive_version_u</A></TD><TD>returns information about the version of Parasolid used to create a partition transmit file</TD></TR>
<TR><TD><A HREF="headers/pk_partition_reset_attribs.html">PK_PARTITION_reset_attribs</A></TD><TD>allows changes to the contents of selected attributes in the given partition</TD></TR>
<TR><TD><A HREF="headers/pk_partition_set_current.html">PK_PARTITION_set_current</A></TD><TD>makes the given partition the current partition</TD></TR>
<TR><TD><A HREF="headers/pk_partition_set_guard.html">PK_PARTITION_set_guard</A></TD><TD>sets the guard for the given <B>'partition'</B> to its current state</TD></TR>
<TR><TD><A HREF="headers/pk_partition_set_type.html">PK_PARTITION_set_type</A></TD><TD>sets the type of the given <B>'partition'</B></TD></TR>
<TR><TD><A HREF="headers/pk_partition_start_cloning.html">PK_PARTITION_start_cloning</A></TD><TD>starts cloning in the given <B>'partition'</B></TD></TR>
<TR><TD><A HREF="headers/pk_partition_stop_cloning.html">PK_PARTITION_stop_cloning</A></TD><TD>stops cloning in the given <B>'partition'</B></TD></TR>
<TR><TD><A HREF="headers/pk_partition_transmit.html">PK_PARTITION_transmit</A></TD><TD>transmits the given <B>'partition'</B> to the given 'file' <B>'key'</B></TD></TR>
<TR><TD><A HREF="headers/pk_partition_transmit_b.html">PK_PARTITION_transmit_b</A></TD><TD>transmits the given <B>'partition'</B> directly to application memory</TD></TR>
<TR><TD><A HREF="headers/pk_partition_transmit_delta.html">PK_PARTITION_transmit_delta</A></TD><TD>transmits the deltas of the given <B>'partition'</B></TD></TR>
<TR><TD><A HREF="headers/pk_partition_transmit_u.html">PK_PARTITION_transmit_u</A></TD><TD>transmits the given <B>'partition'</B> to the given Unicode 'file' <B>'key'</B></TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_plane></A>
<B>PK_PLANE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_plane_ask.html">PK_PLANE_ask</A></TD><TD>returns the standard form of the given plane</TD></TR>
<TR><TD><A HREF="headers/pk_plane_create.html">PK_PLANE_create</A></TD><TD>creates a plane from the given standard form</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_pline></A>
<B>PK_PLINE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_pline_ask.html">PK_PLINE_ask</A></TD><TD>returns the standard form for a polyline</TD></TR>
<TR><TD><A HREF="headers/pk_pline_create.html">PK_PLINE_create</A></TD><TD>creates a polyline from the standard form</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_pmark></A>
<B>PK_PMARK</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_pmark_ask_entities.html">PK_PMARK_ask_entities</A></TD><TD>returns the entities that would be created, modified and deleted if rolling to the destination <B>'pmark'</B></TD></TR>
<TR><TD><A HREF="headers/pk_pmark_ask_following.html">PK_PMARK_ask_following</A></TD><TD>returns the pmarks following the given one</TD></TR>
<TR><TD><A HREF="headers/pk_pmark_ask_identifier.html">PK_PMARK_ask_identifier</A></TD><TD>returns the identifier of a pmark, which is a positive integer unique within its partition</TD></TR>
<TR><TD><A HREF="headers/pk_pmark_ask_marks.html">PK_PMARK_ask_marks</A></TD><TD>functions returns the <B>'marks'</B> which 'use' the given <B>'pmark'</B></TD></TR>
<TR><TD><A HREF="headers/pk_pmark_ask_partition.html">PK_PMARK_ask_partition</A></TD><TD>returns the partition of the given partition mark</TD></TR>
<TR><TD><A HREF="headers/pk_pmark_ask_preceding.html">PK_PMARK_ask_preceding</A></TD><TD>returns the pmark preceding the given one, or PK_PMARK_null if there is none</TD></TR>
<TR><TD><A HREF="headers/pk_pmark_delete.html">PK_PMARK_delete</A></TD><TD>deletes the given partition marks</TD></TR>
<TR><TD><A HREF="headers/pk_pmark_goto_2.html">PK_PMARK_goto_2</A></TD><TD>returns the partition to the state when the given pmark was created</TD></TR>
<TR><TD><A HREF="headers/pk_pmark_is.html">PK_PMARK_is</A></TD><TD>returns PK_LOGICAL_true if its argument is a partition mark</TD></TR>
<TR><TD><A HREF="headers/pk_pmark_is_used_by_mark.html">PK_PMARK_is_used_by_mark</A></TD><TD>returns PK_LOGICAL_true if the given <B>'pmark'</B> is used in a session mark</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_point></A>
<B>PK_POINT</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_point_ask.html">PK_POINT_ask</A></TD><TD>returns the standard form of the given point</TD></TR>
<TR><TD><A HREF="headers/pk_point_ask_part.html">PK_POINT_ask_part</A></TD><TD>returns the part which owns the given point, if there is one, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_point_ask_vertex.html">PK_POINT_ask_vertex</A></TD><TD>returns the vertex connected to the given point, if there is one, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_point_create.html">PK_POINT_create</A></TD><TD>creates a point from the given standard form</TD></TR>
<TR><TD><A HREF="headers/pk_point_make_helical_curve.html">PK_POINT_make_helical_curve</A></TD><TD>creates a helix, tapered helix or spiral by sweeping a point about an axis</TD></TR>
<TR><TD><A HREF="headers/pk_point_make_minimum_body.html">PK_POINT_make_minimum_body</A></TD><TD>creates a minimum body whose single vertex is located at the given <B>'point'</B></TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_region></A>
<B>PK_REGION</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_region_ask_body.html">PK_REGION_ask_body</A></TD><TD>returns the body containing the given region</TD></TR>
<TR><TD><A HREF="headers/pk_region_ask_lattices.html">PK_REGION_ask_lattices</A></TD><TD>returns the set of lattices embedded in the given <B>'region'</B></TD></TR>
<TR><TD><A HREF="headers/pk_region_ask_regions_adjacent.html">PK_REGION_ask_regions_adjacent</A></TD><TD>returns all regions which are immediately adjacent to the given region</TD></TR>
<TR><TD><A HREF="headers/pk_region_ask_shells.html">PK_REGION_ask_shells</A></TD><TD>returns the set of shells bounding the given region</TD></TR>
<TR><TD><A HREF="headers/pk_region_ask_type.html">PK_REGION_ask_type</A></TD><TD>classifies the given region</TD></TR>
<TR><TD><A HREF="headers/pk_region_combine_bodies.html">PK_REGION_combine_bodies</A></TD><TD>combines two bodies into a single disconnected body</TD></TR>
<TR><TD><A HREF="headers/pk_region_embed_lattices.html">PK_REGION_embed_lattices</A></TD><TD>embeds the supplied <B>'lattices'</B> in the given <B>'region'</B></TD></TR>
<TR><TD><A HREF="headers/pk_region_imprint_curve.html">PK_REGION_imprint_curve</A></TD><TD>imprints a curve onto a region, thereby creating a new edge or edges</TD></TR>
<TR><TD><A HREF="headers/pk_region_imprint_point.html">PK_REGION_imprint_point</A></TD><TD>imprints a point onto a region, thereby creating a new acorn vertex</TD></TR>
<TR><TD><A HREF="headers/pk_region_is_solid.html">PK_REGION_is_solid</A></TD><TD>returns PK_LOGICAL_true if the given region is solid and PK_LOGICAL_false if it is void</TD></TR>
<TR><TD><A HREF="headers/pk_region_make_solid.html">PK_REGION_make_solid</A></TD><TD>sets the type of the given region to be solid</TD></TR>
<TR><TD><A HREF="headers/pk_region_make_void.html">PK_REGION_make_void</A></TD><TD>sets the type of the given <B>'region'</B> to be void</TD></TR>
<TR><TD><A HREF="headers/pk_region_remove_lattice.html">PK_REGION_remove_lattice</A></TD><TD>removes the given <B>'lattice'</B> from the given <B>'region'</B></TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_report></A>
<B>PK_REPORT</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_report_add_records.html">PK_REPORT_add_records</A></TD><TD>adds the given <B>'report_records'</B> to the <B>'report'</B></TD></TR>
<TR><TD><A HREF="headers/pk_report_ask.html">PK_REPORT_ask</A></TD><TD>returns the data of the requested <B>'report'</B></TD></TR>
<TR><TD><A HREF="headers/pk_report_clear.html">PK_REPORT_clear</A></TD><TD>clears the requested <B>'report'</B></TD></TR>
<TR><TD><A HREF="headers/pk_report_close.html">PK_REPORT_close</A></TD><TD>closes the given <B>'report'</B></TD></TR>
<TR><TD><A HREF="headers/pk_report_create.html">PK_REPORT_create</A></TD><TD>creates a <B>'report'</B> with the given <B>'name'</B></TD></TR>
<TR><TD><A HREF="headers/pk_report_delete.html">PK_REPORT_delete</A></TD><TD>deletes a <B>'report'</B></TD></TR>
<TR><TD><A HREF="headers/pk_report_find.html">PK_REPORT_find</A></TD><TD>returns the <B>'report'</B> which has the given <B>'name'</B></TD></TR>
<TR><TD><A HREF="headers/pk_report_is_open.html">PK_REPORT_is_open</A></TD><TD>returns PK_LOGICAL_true if the given report is open and PK_LOGICAL_false if it is closed</TD></TR>
<TR><TD><A HREF="headers/pk_report_set_function.html">PK_REPORT_set_function</A></TD><TD>sets the function name of a report</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_session></A>
<B>PK_SESSION</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_session_abort.html">PK_SESSION_abort</A></TD><TD>makes a request to Parasolid to abort the interrupted current operation</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_angle_precision.html">PK_SESSION_ask_angle_precision</A></TD><TD>returns the session angle precision</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_applio_2.html">PK_SESSION_ask_applio_2</A></TD><TD>returns the registered 'applio' functions for transmit file input and output</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_attdefs.html">PK_SESSION_ask_attdefs</A></TD><TD>returns user-defined attribute definitions in the session</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_behaviour.html">PK_SESSION_ask_behaviour</A></TD><TD>returns the currently set behaviour of the modeller</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_binding.html">PK_SESSION_ask_binding</A></TD><TD>allows the application to identify the programming language binding in use</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_cellular_guise.html">PK_SESSION_ask_cellular_guise</A></TD><TD>returns the session cellular guise</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_check_arguments.html">PK_SESSION_ask_check_arguments</A></TD><TD>returns whether argument checking is enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_check_continuity.html">PK_SESSION_ask_check_continuity</A></TD><TD>returns whether continuity checking is enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_check_self_int.html">PK_SESSION_ask_check_self_int</A></TD><TD>returns whether self intersection checking is enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_close_knots.html">PK_SESSION_ask_close_knots</A></TD><TD>returns whether bgeometry may have knots closer together than the session angular tolerance</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_curr_partition.html">PK_SESSION_ask_curr_partition</A></TD><TD>returns the current partition</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_err_reports.html">PK_SESSION_ask_err_reports</A></TD><TD></TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_facet_geometry.html">PK_SESSION_ask_facet_geometry</A></TD><TD>returns whether facet geometry is enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_fru_2.html">PK_SESSION_ask_fru_2</A></TD><TD>returns values of registered frustrum functions as specified in <B>'options'</B></TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_frustrum.html">PK_SESSION_ask_frustrum</A></TD><TD>return the installed frustrum</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_function.html">PK_SESSION_ask_function</A></TD><TD>returns the name of the PK function currently being called</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_general_topology.html">PK_SESSION_ask_general_topology</A></TD><TD>returns whether generalised topology is enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_indexio.html">PK_SESSION_ask_indexio</A></TD><TD>return the installed Indexed Frustrum</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_journalling.html">PK_SESSION_ask_journalling</A></TD><TD>returns whether journalling is enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_kernel_version.html">PK_SESSION_ask_kernel_version</A></TD><TD>returns modeller version and datestamp</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_latest_behaviour.html">PK_SESSION_ask_latest_behaviour</A></TD><TD>returns the latest allowed behaviour of the modeller regardless of the current behaviour setting</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_mark.html">PK_SESSION_ask_mark</A></TD><TD>returns the current session mark, and whether the session is at that mark or has been modified since it was created or rolled to</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_max_threads.html">PK_SESSION_ask_max_threads</A></TD><TD>returns the maximum number of threads which Parasolid can currently use internally (i</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_memory_usage.html">PK_SESSION_ask_memory_usage</A></TD><TD>returns the amount of memory currently occupied by the model data structure</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_mesh_angle.html">PK_SESSION_ask_mesh_angle</A></TD><TD>returns the session <B>'mesh_angle'</B></TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_partitions.html">PK_SESSION_ask_partitions</A></TD><TD>returns the partitions in the session</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_parts.html">PK_SESSION_ask_parts</A></TD><TD>returns all parts in the session</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_precision.html">PK_SESSION_ask_precision</A></TD><TD>returns the session precision</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_rebuild_history.html">PK_SESSION_ask_rebuild_history</A></TD><TD>returns the currently set rebuild history</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_schema_version.html">PK_SESSION_ask_schema_version</A></TD><TD>returns the Parasolid schema version number</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_smp.html">PK_SESSION_ask_smp</A></TD><TD>retrieves the current session Symmetric Multi-Processing (SMP) parameters</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_smp_stacksize.html">PK_SESSION_ask_smp_stacksize</A></TD><TD>returns the size of the stack allocated to Parasolid SMP threads</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_software_option.html">PK_SESSION_ask_software_option</A></TD><TD>return the current setting of a variant software option</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_swept_spun_surfs.html">PK_SESSION_ask_swept_spun_surfs</A></TD><TD>returns whether topological sweep and spin functions are allowed to produce swept and spun surfaces</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_tag_highest.html">PK_SESSION_ask_tag_highest</A></TD><TD>returns the value of the highest tag allocated</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_tag_limit.html">PK_SESSION_ask_tag_limit</A></TD><TD>returns whether tag limitation is enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_tags_remaining.html">PK_SESSION_ask_tags_remaining</A></TD><TD>returns the current number of tags which are available for subsequent use</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_unicode.html">PK_SESSION_ask_unicode</A></TD><TD>returns whether Unicode keys are enabled for Frustrum and application i/o</TD></TR>
<TR><TD><A HREF="headers/pk_session_ask_user_field_len.html">PK_SESSION_ask_user_field_len</A></TD><TD>returns the length of the user fields</TD></TR>
<TR><TD><A HREF="headers/pk_session_comment.html">PK_SESSION_comment</A></TD><TD>write a comment to the journal file</TD></TR>
<TR><TD><A HREF="headers/pk_session_is_in_kernel_2.html">PK_SESSION_is_in_kernel_2</A></TD><TD>returns whether it has been called from within the kernel or from outside the kernel</TD></TR>
<TR><TD><A HREF="headers/pk_session_is_roll_forward_on.html">PK_SESSION_is_roll_forward_on</A></TD><TD>returns PK_LOGICAL_true if the roll-forward interface parameter is set to true</TD></TR>
<TR><TD><A HREF="headers/pk_session_is_rollback_on.html">PK_SESSION_is_rollback_on</A></TD><TD>returns PK_LOGICAL_true if partitioned rollback has been enabled (see PK_DELTA_register_callbacks), otherwise PK_LOGICAL_false</TD></TR>
<TR><TD><A HREF="headers/pk_session_receive.html">PK_SESSION_receive</A></TD><TD>receives a session from the given 'file' <B>'key'</B></TD></TR>
<TR><TD><A HREF="headers/pk_session_receive_u.html">PK_SESSION_receive_u</A></TD><TD>receives a session from the given Unicode 'file' <B>'key'</B></TD></TR>
<TR><TD><A HREF="headers/pk_session_receive_version.html">PK_SESSION_receive_version</A></TD><TD>returns information about the version of Parasolid used to create a session transmit file</TD></TR>
<TR><TD><A HREF="headers/pk_session_receive_version_u.html">PK_SESSION_receive_version_u</A></TD><TD>returns information about the version of Parasolid used to create a session transmit file</TD></TR>
<TR><TD><A HREF="headers/pk_session_register.html">PK_SESSION_register</A></TD><TD>allows mutual registration between Parasolid and companion UGS toolkit products at run-time</TD></TR>
<TR><TD><A HREF="headers/pk_session_register_applio_2.html">PK_SESSION_register_applio_2</A></TD><TD>registers a new set of functions for use when the 'applio' format is selected for transmit files</TD></TR>
<TR><TD><A HREF="headers/pk_session_register_fru_2.html">PK_SESSION_register_fru_2</A></TD><TD>registers frustrum functions to values as specified in <B>'options'</B></TD></TR>
<TR><TD><A HREF="headers/pk_session_register_frustrum.html">PK_SESSION_register_frustrum</A></TD><TD>installs a new frustrum</TD></TR>
<TR><TD><A HREF="headers/pk_session_register_indexio.html">PK_SESSION_register_indexio</A></TD><TD>installs a new Indexed Frustrum</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_behaviour.html">PK_SESSION_set_behaviour</A></TD><TD>sets the behaviour of the modeller</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_cellular_guise.html">PK_SESSION_set_cellular_guise</A></TD><TD>sets how cellular bodies are treated by Parasolid</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_check_arguments.html">PK_SESSION_set_check_arguments</A></TD><TD>sets whether argument checking is to be enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_check_continuity.html">PK_SESSION_set_check_continuity</A></TD><TD>sets whether continuity checking is to be enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_check_self_int.html">PK_SESSION_set_check_self_int</A></TD><TD>sets whether self intersection checking is to be enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_close_knots.html">PK_SESSION_set_close_knots</A></TD><TD>sets whether bgeometry may have knots closer together than the session angular tolerance</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_err_reports.html">PK_SESSION_set_err_reports</A></TD><TD></TD></TR>
<TR><TD><A HREF="headers/pk_session_set_facet_geometry.html">PK_SESSION_set_facet_geometry</A></TD><TD>sets whether facet geometry and lattice support are to be enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_general_topology.html">PK_SESSION_set_general_topology</A></TD><TD>sets whether generalised topology is to be enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_journalling.html">PK_SESSION_set_journalling</A></TD><TD>sets whether journalling is to be enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_mesh_angle.html">PK_SESSION_set_mesh_angle</A></TD><TD>sets the session mesh angle</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_rebuild_history.html">PK_SESSION_set_rebuild_history</A></TD><TD>sets the rebuild history of the modeller</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_roll_forward.html">PK_SESSION_set_roll_forward</A></TD><TD>sets the roll_forward interface parameter</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_smp.html">PK_SESSION_set_smp</A></TD><TD>sets the Symmetric Multi-Processing (SMP) parameters for the session</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_smp_stacksize.html">PK_SESSION_set_smp_stacksize</A></TD><TD>set the size of the stack allocated to Parasolid SMP threads</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_software_option.html">PK_SESSION_set_software_option</A></TD><TD>replace the setting of a variant software option</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_swept_spun_surfs.html">PK_SESSION_set_swept_spun_surfs</A></TD><TD>sets whether topological sweep and spin functions are allowed to produce swept and spun surfaces</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_tag_limit.html">PK_SESSION_set_tag_limit</A></TD><TD>sets whether tag limitation is to be enabled</TD></TR>
<TR><TD><A HREF="headers/pk_session_set_unicode.html">PK_SESSION_set_unicode</A></TD><TD>enables/disables Unicode keys for Frustrum and application i/o</TD></TR>
<TR><TD><A HREF="headers/pk_session_start.html">PK_SESSION_start</A></TD><TD>starts the Parasolid modeller</TD></TR>
<TR><TD><A HREF="headers/pk_session_stop.html">PK_SESSION_stop</A></TD><TD>stops the modeller</TD></TR>
<TR><TD><A HREF="headers/pk_session_tidy.html">PK_SESSION_tidy</A></TD><TD>ensures that PK is in a valid state whenever a longjump is made</TD></TR>
<TR><TD><A HREF="headers/pk_session_transmit.html">PK_SESSION_transmit</A></TD><TD>transmits the session to the given 'file' <B>'key'</B></TD></TR>
<TR><TD><A HREF="headers/pk_session_transmit_u.html">PK_SESSION_transmit_u</A></TD><TD>transmits the session to the given Unicode 'file' <B>'key'</B></TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_shell></A>
<B>PK_SHELL</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_shell_ask_acorn_vertex.html">PK_SHELL_ask_acorn_vertex</A></TD><TD>returns the single acorn vertex of the given shell if the shell is of type PK_SHELL_type_acorn_c, otherwise PK_ENTITY_null is returned</TD></TR>
<TR><TD><A HREF="headers/pk_shell_ask_body.html">PK_SHELL_ask_body</A></TD><TD>returns the body of the given shell</TD></TR>
<TR><TD><A HREF="headers/pk_shell_ask_oriented_faces.html">PK_SHELL_ask_oriented_faces</A></TD><TD>returns the list of faces in the given shell, together with their orientations with respect to the shell</TD></TR>
<TR><TD><A HREF="headers/pk_shell_ask_region.html">PK_SHELL_ask_region</A></TD><TD>returns the region of the given shell</TD></TR>
<TR><TD><A HREF="headers/pk_shell_ask_type.html">PK_SHELL_ask_type</A></TD><TD>classifies the given shell according to the types of topological entities it contains</TD></TR>
<TR><TD><A HREF="headers/pk_shell_ask_wireframe_edges.html">PK_SHELL_ask_wireframe_edges</A></TD><TD>returns the set of wireframe edges in the given shell</TD></TR>
<TR><TD><A HREF="headers/pk_shell_find_sign.html">PK_SHELL_find_sign</A></TD><TD>classifies the given shell according to whether it closes off a volume and, if it does, whether the volume inside the shell is finite or infinite</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_spcurve></A>
<B>PK_SPCURVE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_spcurve_ask.html">PK_SPCURVE_ask</A></TD><TD>writes the standard form of an <B>'spcurve'</B> at the given address</TD></TR>
<TR><TD><A HREF="headers/pk_spcurve_create.html">PK_SPCURVE_create</A></TD><TD>creates an spcurve from the given standard form</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_sphere></A>
<B>PK_SPHERE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_sphere_ask.html">PK_SPHERE_ask</A></TD><TD>writes the standard form of a sphere at the given address</TD></TR>
<TR><TD><A HREF="headers/pk_sphere_create.html">PK_SPHERE_create</A></TD><TD>creates a sphere from the given standard form</TD></TR>
<TR><TD><A HREF="headers/pk_sphere_make_solid_body.html">PK_SPHERE_make_solid_body</A></TD><TD>creates a solid body from a sphere</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_spun></A>
<B>PK_SPUN</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_spun_ask.html">PK_SPUN_ask</A></TD><TD>writes the standard form of a spun surface at the given address</TD></TR>
<TR><TD><A HREF="headers/pk_spun_create.html">PK_SPUN_create</A></TD><TD>creates a spun surface from the given standard form</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_surf></A>
<B>PK_SURF</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_surf_ask_faces.html">PK_SURF_ask_faces</A></TD><TD>returns the set of faces to which the given surface is attached</TD></TR>
<TR><TD><A HREF="headers/pk_surf_ask_params.html">PK_SURF_ask_params</A></TD><TD>returns information about the parameterisation of the given surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_ask_part.html">PK_SURF_ask_part</A></TD><TD>returns the part which owns the given surface, if there is one, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_surf_ask_uvbox.html">PK_SURF_ask_uvbox</A></TD><TD>returns a uvbox indicating the parametric bounds of the given surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_create_blend.html">PK_SURF_create_blend</A></TD><TD>creates a surface, representing a constant radius rolling ball blend upon the supplied geometry  does not support facet geometry [NF]</TD></TR>
<TR><TD><A HREF="headers/pk_surf_eval.html">PK_SURF_eval</A></TD><TD>evaluates a point and derivatives at a parameter pair on the given surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_eval_curvature.html">PK_SURF_eval_curvature</A></TD><TD>calculates the normal, principal directions and principal curvatures of a surface at a given parametric position</TD></TR>
<TR><TD><A HREF="headers/pk_surf_eval_curvature_handed.html">PK_SURF_eval_curvature_handed</A></TD><TD>behaves like PK_SURF_eval_curvature but takes additional arguments ( <B>'u_hand_dir'</B> and <B>'v_hand_dir'</B> ) as the input</TD></TR>
<TR><TD><A HREF="headers/pk_surf_eval_grid.html">PK_SURF_eval_grid</A></TD><TD>evaluates points on a rectangular grid of parameters on the given surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_eval_handed.html">PK_SURF_eval_handed</A></TD><TD>behaves like PK_SURF_eval, but takes additional arguments ( <B>'u_hand_dir'</B> and <B>'v_hand_dir'</B> ) as input</TD></TR>
<TR><TD><A HREF="headers/pk_surf_eval_with_normal.html">PK_SURF_eval_with_normal</A></TD><TD>evaluates a point, derivatives and normal at a parameter pair on the given surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_eval_with_normal_handed.html">PK_SURF_eval_with_normal_handed</A></TD><TD>behaves like PK_SURF_eval_with_normal, but takes additional arguments ( <B>'u_hand_dir'</B> and <B>'v_hand_dir'</B> ) as input</TD></TR>
<TR><TD><A HREF="headers/pk_surf_extend.html">PK_SURF_extend</A></TD><TD>extends a surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_find_box.html">PK_SURF_find_box</A></TD><TD>returns a BOX which bounds the given surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_find_curves_common.html">PK_SURF_find_curves_common</A></TD><TD>finds curves which are common to two surfaces</TD></TR>
<TR><TD><A HREF="headers/pk_surf_find_degens.html">PK_SURF_find_degens</A></TD><TD>finds degeneracies in the given surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_find_discontinuity.html">PK_SURF_find_discontinuity</A></TD><TD>interface function permits a user to query any standard surface type for either analytic or geometric discontinuities of levels 1 through 3</TD></TR>
<TR><TD><A HREF="headers/pk_surf_find_min_radii.html">PK_SURF_find_min_radii</A></TD><TD>finds the minimum radius of curvature on each side of the given surface within the supplied <B>'uv_box'</B>, along with its position and u-v parameters</TD></TR>
<TR><TD><A HREF="headers/pk_surf_find_non_aligned_box.html">PK_SURF_find_non_aligned_box</A></TD><TD>computes a non axis-aligned box bounding a portion of the given surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_find_self_int.html">PK_SURF_find_self_int</A></TD><TD>finds self-intersections in the given surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_find_vectors.html">PK_SURF_find_vectors</A></TD><TD>the function will return position vectors on the supplied <B>'surface'</B> between the given <B>'uv_start'</B> and <B>'uv_end'</B>, in accordance with the supplied <B>'options'</B></TD></TR>
<TR><TD><A HREF="headers/pk_surf_fix_degens.html">PK_SURF_fix_degens</A></TD><TD>attempts to fix degeneracies in the given surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_fix_self_int.html">PK_SURF_fix_self_int</A></TD><TD>attempts to fix self-intersections in the given surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_intersect_curve.html">PK_SURF_intersect_curve</A></TD><TD>PK_SURF_intersect_curve finds the intersections between a surface and a curve</TD></TR>
<TR><TD><A HREF="headers/pk_surf_intersect_surf.html">PK_SURF_intersect_surf</A></TD><TD>PK_SURF_intersect_surf finds the intersections between two surfaces</TD></TR>
<TR><TD><A HREF="headers/pk_surf_make_bsurf_2.html">PK_SURF_make_bsurf_2</A></TD><TD>creates a <B>'bsurf'</B> which is coincident with the given parametric <B>'uvbox'</B> of the given <B>'surf'</B></TD></TR>
<TR><TD><A HREF="headers/pk_surf_make_bsurf_array.html">PK_SURF_make_bsurf_array</A></TD><TD>given an array of surfaces and uvboxes this function will return created B-surfaces that satisfy the <B>'options'</B> specified</TD></TR>
<TR><TD><A HREF="headers/pk_surf_make_curve_isoparam.html">PK_SURF_make_curve_isoparam</A></TD><TD>constructs a curve as the constant parameter line of <B>'surf'</B> specified by <B>'param'</B> and <B>'u_or_v'</B></TD></TR>
<TR><TD><A HREF="headers/pk_surf_make_cus_isocline.html">PK_SURF_make_cus_isocline</A></TD><TD>creates isocline curves on the given surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_make_sheet_body.html">PK_SURF_make_sheet_body</A></TD><TD>creates a sheet body from a surface</TD></TR>
<TR><TD><A HREF="headers/pk_surf_make_sheet_trimmed.html">PK_SURF_make_sheet_trimmed</A></TD><TD>creates a sheet body given surface and trimmed curve data</TD></TR>
<TR><TD><A HREF="headers/pk_surf_offset.html">PK_SURF_offset</A></TD><TD>creates a surface offset from the <B>'underlying_surf'</B> by <B>'offset_distance'</B></TD></TR>
<TR><TD><A HREF="headers/pk_surf_parameterise_vector.html">PK_SURF_parameterise_vector</A></TD><TD>find parameters of a point on a surface</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_swept></A>
<B>PK_SWEPT</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_swept_ask.html">PK_SWEPT_ask</A></TD><TD>writes the standard form of a swept surface at the given address</TD></TR>
<TR><TD><A HREF="headers/pk_swept_create.html">PK_SWEPT_create</A></TD><TD>creates a swept surface from the given standard form</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_thread></A>
<B>PK_THREAD</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_thread_ask_err_reports.html">PK_THREAD_ask_err_reports</A></TD><TD></TD></TR>
<TR><TD><A HREF="headers/pk_thread_ask_error_cbs.html">PK_THREAD_ask_error_cbs</A></TD><TD>returns the error handler for the calling thread (if one is registered), or NULL</TD></TR>
<TR><TD><A HREF="headers/pk_thread_ask_exclusion.html">PK_THREAD_ask_exclusion</A></TD><TD>returns whether the Parasolid interface is currently excluding other threads entering and whether the calling thread caused the exclusion</TD></TR>
<TR><TD><A HREF="headers/pk_thread_ask_function.html">PK_THREAD_ask_function</A></TD><TD>returns the name of the PK function being executed in the calling thread and the total recursion depth of its current call stack</TD></TR>
<TR><TD><A HREF="headers/pk_thread_ask_function_run.html">PK_THREAD_ask_function_run</A></TD><TD>asks whether the given PK functions will be run concurrently or exclusively in this thread</TD></TR>
<TR><TD><A HREF="headers/pk_thread_ask_id.html">PK_THREAD_ask_id</A></TD><TD>returns the thread ID of the calling thread as set by PK_THREAD_set_id</TD></TR>
<TR><TD><A HREF="headers/pk_thread_ask_last_error.html">PK_THREAD_ask_last_error</A></TD><TD>returns the standard form of the most recent PK error in the calling thread</TD></TR>
<TR><TD><A HREF="headers/pk_thread_ask_local_level.html">PK_THREAD_ask_local_level</A></TD><TD>returns the localisation level of the calling thread-chain</TD></TR>
<TR><TD><A HREF="headers/pk_thread_ask_memory_cbs.html">PK_THREAD_ask_memory_cbs</A></TD><TD>returns the functions which are currently registered for the calling thread to use when allocating and freeing variable length information returned from the PK interface</TD></TR>
<TR><TD><A HREF="headers/pk_thread_ask_partitions.html">PK_THREAD_ask_partitions</A></TD><TD>returns the <B>'partitions'</B> locked to the calling thread</TD></TR>
<TR><TD><A HREF="headers/pk_thread_chain_start.html">PK_THREAD_chain_start</A></TD><TD>starts chaining Parasolid functions in the calling thread</TD></TR>
<TR><TD><A HREF="headers/pk_thread_chain_stop.html">PK_THREAD_chain_stop</A></TD><TD>stops chaining Parasolid functions in the calling thread</TD></TR>
<TR><TD><A HREF="headers/pk_thread_clear_exclusion.html">PK_THREAD_clear_exclusion</A></TD><TD>tries to clear an exclusion that may be preventing other threads from entering Parasolid</TD></TR>
<TR><TD><A HREF="headers/pk_thread_clear_last_error.html">PK_THREAD_clear_last_error</A></TD><TD>clears the most recent PK error in the calling thread</TD></TR>
<TR><TD><A HREF="headers/pk_thread_is_in_chain.html">PK_THREAD_is_in_chain</A></TD><TD>returns the type of chain running in the calling thread, along with its link length and the maximum number of remaining functions in the current chain link</TD></TR>
<TR><TD><A HREF="headers/pk_thread_is_in_kernel.html">PK_THREAD_is_in_kernel</A></TD><TD>returns whether the calling thread is executing inside the kernel</TD></TR>
<TR><TD><A HREF="headers/pk_thread_lock_partitions.html">PK_THREAD_lock_partitions</A></TD><TD>attempts to lock partitions to the calling thread</TD></TR>
<TR><TD><A HREF="headers/pk_thread_register_error_cbs.html">PK_THREAD_register_error_cbs</A></TD><TD>registers the given error handler for the calling thread</TD></TR>
<TR><TD><A HREF="headers/pk_thread_register_memory_cbs.html">PK_THREAD_register_memory_cbs</A></TD><TD>registers memory allocation and free functions for the calling thread to use in Parasolid when returning variable length information</TD></TR>
<TR><TD><A HREF="headers/pk_thread_set_err_reports.html">PK_THREAD_set_err_reports</A></TD><TD></TD></TR>
<TR><TD><A HREF="headers/pk_thread_set_function_run.html">PK_THREAD_set_function_run</A></TD><TD>sets whether the given PK functions will be run concurrently or exclusively in this thread</TD></TR>
<TR><TD><A HREF="headers/pk_thread_set_id.html">PK_THREAD_set_id</A></TD><TD>stores the given thread ID in the calling thread</TD></TR>
<TR><TD><A HREF="headers/pk_thread_tidy.html">PK_THREAD_tidy</A></TD><TD>ensures that Parasolid is in a valid state for the calling thread whenever a longjump is made</TD></TR>
<TR><TD><A HREF="headers/pk_thread_unlock_partitions.html">PK_THREAD_unlock_partitions</A></TD><TD>unlocks and returns the <B>'partitions'</B> that were locked to the calling thread</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_topol></A>
<B>PK_TOPOL</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_topol_ask_entities_by_attdef.html">PK_TOPOL_ask_entities_by_attdef</A></TD><TD>returns the set of <B>'entities'</B> of the given <B>'class'</B> which belong to <B>'topol'</B> and either do or do not have an attribute of the given <B>'attdef'</B>, depending upon <B>'have_attrib'</B></TD></TR>
<TR><TD><A HREF="headers/pk_topol_categorise_geom.html">PK_TOPOL_categorise_geom</A></TD><TD>determines what category of geometry is attached to <B>'topology'</B></TD></TR>
<TR><TD><A HREF="headers/pk_topol_clash.html">PK_TOPOL_clash</A></TD><TD>clashes sets of topologies and returns the (list of) body, face or edge pairs which clash</TD></TR>
<TR><TD><A HREF="headers/pk_topol_delete_redundant_2.html">PK_TOPOL_delete_redundant_2</A></TD><TD>removes redundant topology or sub-topology from the given list of topologies</TD></TR>
<TR><TD><A HREF="headers/pk_topol_detach_geom.html">PK_TOPOL_detach_geom</A></TD><TD>detaches geometry from topology</TD></TR>
<TR><TD><A HREF="headers/pk_topol_eval_mass_props.html">PK_TOPOL_eval_mass_props</A></TD><TD>evaluates mass properties of a given set of topological entities</TD></TR>
<TR><TD><A HREF="headers/pk_topol_facet_2.html">PK_TOPOL_facet_2</A></TD><TD>generate a facetted representation of topological entities in tabular form  offers partial support for topology that has facet geometry (meshes & plines) [PF]</TD></TR>
<TR><TD><A HREF="headers/pk_topol_find_box_2.html">PK_TOPOL_find_box_2</A></TD><TD>returns an axis-aligned box which bounds the given topologies subject to supplied transformations</TD></TR>
<TR><TD><A HREF="headers/pk_topol_find_frames.html">PK_TOPOL_find_frames</A></TD><TD>returns the set of frames related to the supplied <B>'topol'</B></TD></TR>
<TR><TD><A HREF="headers/pk_topol_find_nabox.html">PK_TOPOL_find_nabox</A></TD><TD>returns a non-aligned box bounding the given topological entities</TD></TR>
<TR><TD><A HREF="headers/pk_topol_identify_redundant.html">PK_TOPOL_identify_redundant</A></TD><TD>identifies redundant topology or subtopology from the given list of topologies</TD></TR>
<TR><TD><A HREF="headers/pk_topol_imprint_frames.html">PK_TOPOL_imprint_frames</A></TD><TD>imprints frames on their owning regions</TD></TR>
<TR><TD><A HREF="headers/pk_topol_make_facet_topol.html">PK_TOPOL_make_facet_topol</A></TD><TD>generates facet geometry for an array of faces and edges from the same body</TD></TR>
<TR><TD><A HREF="headers/pk_topol_make_general_body.html">PK_TOPOL_make_general_body</A></TD><TD>creates a general body from a set of topologies</TD></TR>
<TR><TD><A HREF="headers/pk_topol_make_new.html">PK_TOPOL_make_new</A></TD><TD>removes groups and attributes attached to <B>'topol'</B> and replaces <B>'topol'</B> with <B>'new_topol'</B></TD></TR>
<TR><TD><A HREF="headers/pk_topol_range.html">PK_TOPOL_range</A></TD><TD>finds the global minimum/maximum distance between two topological entities</TD></TR>
<TR><TD><A HREF="headers/pk_topol_range_array.html">PK_TOPOL_range_array</A></TD><TD>finds the global minimum/maximum separation between two arrays of topological entities</TD></TR>
<TR><TD><A HREF="headers/pk_topol_range_array_vector.html">PK_TOPOL_range_array_vector</A></TD><TD>finds the global minimum separation between an array of topological entities and a position</TD></TR>
<TR><TD><A HREF="headers/pk_topol_range_geom.html">PK_TOPOL_range_geom</A></TD><TD>finds the global minimum/maximum distance between a topology and a geometry</TD></TR>
<TR><TD><A HREF="headers/pk_topol_range_geom_array.html">PK_TOPOL_range_geom_array</A></TD><TD>finds the global minimum / maximum separation between an array of topological and an array of geometrical entities</TD></TR>
<TR><TD><A HREF="headers/pk_topol_range_local.html">PK_TOPOL_range_local</A></TD><TD>finds the local minimum separations between two topological entities</TD></TR>
<TR><TD><A HREF="headers/pk_topol_range_local_vector.html">PK_TOPOL_range_local_vector</A></TD><TD>finds the local minimum/maximum separations between a topological entity and a position</TD></TR>
<TR><TD><A HREF="headers/pk_topol_range_vector.html">PK_TOPOL_range_vector</A></TD><TD>finds the global minimum separation between a topological entity and a position</TD></TR>
<TR><TD><A HREF="headers/pk_topol_remove_body_component.html">PK_TOPOL_remove_body_component</A></TD><TD>extracts a connected component of a body as a new body</TD></TR>
<TR><TD><A HREF="headers/pk_topol_render_facet.html">PK_TOPOL_render_facet</A></TD><TD>generate a facetted representation of topological entities through GO</TD></TR>
<TR><TD><A HREF="headers/pk_topol_render_line.html">PK_TOPOL_render_line</A></TD><TD>render an array of topological entities through GO as either a view-independent wire-frame drawing, a view-dependent wire-frame drawing or a hidden-line drawing according to values supplied in an options structure</TD></TR>
<TR><TD><A HREF="headers/pk_topol_render_volume.html">PK_TOPOL_render_volume</A></TD><TD>generates a view-independent representation of the volumetric geometry of an array of bodies or regions</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_torus></A>
<B>PK_TORUS</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_torus_ask.html">PK_TORUS_ask</A></TD><TD>writes the standard form of a torus at the given address</TD></TR>
<TR><TD><A HREF="headers/pk_torus_create.html">PK_TORUS_create</A></TD><TD>creates a torus from the given standard form</TD></TR>
<TR><TD><A HREF="headers/pk_torus_make_solid_body.html">PK_TORUS_make_solid_body</A></TD><TD>creates a solid body from a torus</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_transf></A>
<B>PK_TRANSF</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_transf_ask.html">PK_TRANSF_ask</A></TD><TD>returns the standard form of the given transf</TD></TR>
<TR><TD><A HREF="headers/pk_transf_check.html">PK_TRANSF_check</A></TD><TD>checks the given transformation</TD></TR>
<TR><TD><A HREF="headers/pk_transf_classify.html">PK_TRANSF_classify</A></TD><TD>classifies a supplied transform and optionally returns diagnostic information in the form of numerical data</TD></TR>
<TR><TD><A HREF="headers/pk_transf_create.html">PK_TRANSF_create</A></TD><TD>creates a transf from the given standard form</TD></TR>
<TR><TD><A HREF="headers/pk_transf_create_equal_scale.html">PK_TRANSF_create_equal_scale</A></TD><TD>creates an equal scaling transformation</TD></TR>
<TR><TD><A HREF="headers/pk_transf_create_reflection.html">PK_TRANSF_create_reflection</A></TD><TD>creates a reflection transformation</TD></TR>
<TR><TD><A HREF="headers/pk_transf_create_rotation.html">PK_TRANSF_create_rotation</A></TD><TD>creates a rotation transformation</TD></TR>
<TR><TD><A HREF="headers/pk_transf_create_translation.html">PK_TRANSF_create_translation</A></TD><TD>create a translation transformation</TD></TR>
<TR><TD><A HREF="headers/pk_transf_create_view.html">PK_TRANSF_create_view</A></TD><TD>returns a valid viewing transform given a unit vector that designates the desired <B>'view_direction'</B></TD></TR>
<TR><TD><A HREF="headers/pk_transf_enlarge.html">PK_TRANSF_enlarge</A></TD><TD>enlarges a transform by a given scale factor</TD></TR>
<TR><TD><A HREF="headers/pk_transf_is_equal.html">PK_TRANSF_is_equal</A></TD><TD>determines whether two transformations are equal</TD></TR>
<TR><TD><A HREF="headers/pk_transf_transform_2.html">PK_TRANSF_transform_2</A></TD><TD>applies a transform to another transform</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_trcurve></A>
<B>PK_TRCURVE</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_trcurve_ask.html">PK_TRCURVE_ask</A></TD><TD>writes the standard form of a trcurve at the given address</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_vector></A>
<B>PK_VECTOR</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_vector_is_equal.html">PK_VECTOR_is_equal</A></TD><TD>tests whether the two vectors are equal within the current session precision</TD></TR>
<TR><TD><A HREF="headers/pk_vector_is_parallel.html">PK_VECTOR_is_parallel</A></TD><TD>tests whether the two vectors are parallel within the current session angle precision</TD></TR>
<TR><TD><A HREF="headers/pk_vector_is_zero.html">PK_VECTOR_is_zero</A></TD><TD>tests whether the given vector <B>'vec'</B> is zero within the current session precision</TD></TR>
<TR><TD><A HREF="headers/pk_vector_make_lsq_plane.html">PK_VECTOR_make_lsq_plane</A></TD><TD>creates a plane by least-squares fitting to a set of position vectors</TD></TR>
<TR><TD><A HREF="headers/pk_vector_normalise.html">PK_VECTOR_normalise</A></TD><TD>the argument vector is normalised, unless the magnitude of the vector is strictly equal to 0</TD></TR>
<TR><TD><A HREF="headers/pk_vector_perpendicular.html">PK_VECTOR_perpendicular</A></TD><TD>accepts a PK_VECTOR1_t and a PK_VECTOR_t and returns a pointer to a PK_VECTOR1_t</TD></TR>
<TR><TD><A HREF="headers/pk_vector_transform.html">PK_VECTOR_transform</A></TD><TD>applies the given transform to the position vector and returns the result</TD></TR>
<TR><TD><A HREF="headers/pk_vector_transform_direction.html">PK_VECTOR_transform_direction</A></TD><TD>applies the given transformation to the direction vector and if necessary normalises the result</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


<P><A NAME=pk_vertex></A>
<B>PK_VERTEX</B></P>


<TABLE BORDER>

<TR><TD><P><A HREF="headers/pk_vertex_ask_body.html">PK_VERTEX_ask_body</A></TD><TD>returns the body of the given vertex</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_ask_faces.html">PK_VERTEX_ask_faces</A></TD><TD>returns the set of faces at the given vertex</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_ask_isolated_loops.html">PK_VERTEX_ask_isolated_loops</A></TD><TD>returns the set of isolated loops at the given vertex</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_ask_oriented_edges.html">PK_VERTEX_ask_oriented_edges</A></TD><TD>returns the list of edges at the given vertex, together with their orientations</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_ask_point.html">PK_VERTEX_ask_point</A></TD><TD>returns the point at the given vertex, if one exists, otherwise PK_ENTITY_null</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_ask_precision.html">PK_VERTEX_ask_precision</A></TD><TD>returns the <B>'precision'</B> of the given <B>'vertex'</B></TD></TR>
<TR><TD><A HREF="headers/pk_vertex_ask_shells.html">PK_VERTEX_ask_shells</A></TD><TD>returns the set of shells at the given vertex</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_ask_type.html">PK_VERTEX_ask_type</A></TD><TD>classifies the given vertex</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_attach_points.html">PK_VERTEX_attach_points</A></TD><TD>attaches points to vertices</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_delete_acorn.html">PK_VERTEX_delete_acorn</A></TD><TD>deletes the given acorn vertices</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_euler_delete.html">PK_VERTEX_euler_delete</A></TD><TD>deletes a vertex and its edge</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_euler_merge_edges.html">PK_VERTEX_euler_merge_edges</A></TD><TD>deletes a vertex from an edge</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_euler_split.html">PK_VERTEX_euler_split</A></TD><TD>splits a vertex, replacing it with an edge</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_make_blend.html">PK_VERTEX_make_blend</A></TD><TD>the given <B>'vertex'</B> of a sheet or wire body is replaced by a circular blend producing one new <B>'edge'</B> and two new <B>'vertices'</B></TD></TR>
<TR><TD><A HREF="headers/pk_vertex_optimise.html">PK_VERTEX_optimise</A></TD><TD>given a tolerant vertex, this function attempts to modify the position of the vertex and the end points of any trimmed curves, such that the maximum deviation falls within the given target value</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_remove_edge.html">PK_VERTEX_remove_edge</A></TD><TD>cuts a body at a given vertex</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_set_precision.html">PK_VERTEX_set_precision</A></TD><TD>sets the <B>'precision'</B> of the given <B>'vertex'</B></TD></TR>
<TR><TD><A HREF="headers/pk_vertex_spin.html">PK_VERTEX_spin</A></TD><TD>spins an end vertex of a wire body or the sole vertex of a minimum body into an edge</TD></TR>
<TR><TD><A HREF="headers/pk_vertex_sweep.html">PK_VERTEX_sweep</A></TD><TD>sweeps an end vertex of a wire body or the sole vertex of a minimum body into an edge</TD></TR>
</P>
</TABLE>
<P ALIGN=RIGHT><A HREF="#topofdoc"><I>[back to top]</I></A></P>


</BODY>
</HTML>
